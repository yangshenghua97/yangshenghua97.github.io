<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Spark大数据快速分析学习笔记（RDD编程）</title>
    <url>/2020/06/27/Spark%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BF%AB%E9%80%9F%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h3 id="RDD编程基础"><a href="#RDD编程基础" class="headerlink" title="RDD编程基础"></a>RDD编程基础</h3><p>1.何为RDD？RDD的全名叫做<strong>弹性分布式数据集</strong>，其实就是分布式的元素集合。</p>
<p>RDD支持两种类型的操作：转化操作(<strong><code>Transformation</code></strong>) 和 行为操作(<strong><code>action</code></strong>)。转化操作会由一个RDD生成一个新的RDD。行为操作会对RDD计算出一个结果，并把结果返回到驱动器程序中，或把结果存储到外部的存储系统。</p>
<h3 id="创建RDD"><a href="#创建RDD" class="headerlink" title="创建RDD"></a>创建RDD</h3><p>创建RDD有两种方式：读取外部数据集、驱动程序中对一个集合进行并行化</p>
<p>创建RDD最简单的方式是把程序中一个已有的集合传递给SparkContext的parallelize()方法，这种方式不怎么常用，常用的方式是读取外部数据集</p>
<p>下面的代码就是从外部数据（HDFS）中创建RDD</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> infile = sc.text<span class="constructor">File(<span class="string">"hdfs://master:9000/datafile"</span>)</span></span><br></pre></td></tr></table></figure>

<p><strong><code>sc.textFile()</code></strong>是一个将文本文件读入为一个存储字符串的RDD方法</p>
<h3 id="RDD操作"><a href="#RDD操作" class="headerlink" title="RDD操作"></a>RDD操作</h3><ul>
<li><h4 id="转化操作"><a href="#转化操作" class="headerlink" title="转化操作"></a>转化操作</h4></li>
<li><h4 id="行为操作"><a href="#行为操作" class="headerlink" title="行为操作"></a>行为操作</h4></li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<p>《Spark大数据快速分析》</p>
</blockquote>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>spark</tag>
      </tags>
  </entry>
  <entry>
    <title>Spark大数据快速分析学习笔记（一）</title>
    <url>/2020/06/26/Spark%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BF%AB%E9%80%9F%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="Spark中的Python和Scala的Shell"><a href="#Spark中的Python和Scala的Shell" class="headerlink" title="Spark中的Python和Scala的Shell"></a>Spark中的Python和Scala的Shell</h3><p>Spark自带交互式shell，能够即时数据分析。这里介绍两中语言的shell的使用；</p>
<ul>
<li><p>Python</p>
<p>要打开Python版本的Spark Shell可以在终端中输入命令：</p>
<figure class="highlight vala"><table><tr><td class="code"><pre><span class="line"><span class="meta"># pyspark</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Scala</p>
<p>打开Scala版本的shell</p>
<figure class="highlight vala"><table><tr><td class="code"><pre><span class="line"><span class="meta"># spark-shell</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>在打开spark shell时会输出很多的日志信息，可以调整日志的级别来控制输出的信息量。在spark的目录下的conf目录修改<strong>log4j.properties</strong>文件，在文件中修改如下内容：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">log4j.rootCategory</span>=WARN, console</span><br></pre></td></tr></table></figure>

<p>这样就可以减少大量的日志信息输出</p>
<h3 id="使用Spark"><a href="#使用Spark" class="headerlink" title="使用Spark"></a>使用Spark</h3><ul>
<li><p>初始化<strong>SparkContext</strong></p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="constructor">SparkConf()</span>.set<span class="constructor">AppName(<span class="string">"App"</span>)</span></span><br><span class="line"><span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="constructor">SparkContext(<span class="params">conf</span>=<span class="params">conf</span>)</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<p>《Spark快速大数据分析》</p>
</blockquote>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>spark</tag>
      </tags>
  </entry>
  <entry>
    <title>Python数据科学分析笔记</title>
    <url>/2020/06/11/bigdata/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E5%88%86%E6%9E%90%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<ul>
<li><a href=""></a></li>
<li><a href=""></a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>bigdata</category>
        <category>数据分析</category>
      </categories>
  </entry>
  <entry>
    <title>泛读Java集合源码分析</title>
    <url>/2020/06/11/java/java%E5%9F%BA%E7%A1%80/Java%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h3 id="剖析ArrayList"><a href="#剖析ArrayList" class="headerlink" title="剖析ArrayList"></a>剖析ArrayList</h3><h4 id="ArrayList实现的接口"><a href="#ArrayList实现的接口" class="headerlink" title="ArrayList实现的接口"></a>ArrayList实现的接口</h4><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ArrayList&lt;E&gt;</span> <span class="keyword">extends</span> <span class="title">AbstractList&lt;E&gt;</span></span></span><br><span class="line"><span class="class">        <span class="title">implements</span> <span class="title">List&lt;E&gt;</span>, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span>&#123;</span><br><span class="line">        ....</span><br></pre></td></tr></table></figure>

<ul>
<li><p>ArrayList实现了<strong><code>List</code></strong> List是一个数组队列，提供了相关的添加、删除、修改、遍历等功能</p>
</li>
<li><p>ArrayList实现了 <strong><code>RandomAccess</code></strong> 接口，为ArrayList提供了随机访问功能，可以通过元素的序号快速获取元素对象。</p>
</li>
<li><p>ArrayList还实现<strong><code>Cloneable</code></strong> 接口，覆盖函数<strong><code>clone()</code></strong>，能够被克隆。实现<strong><code>Serializable</code></strong>意味着ArrayList可以被序列化</p>
</li>
</ul>
<p>从java1.5后java加入了泛型的特性，在使用<strong><code>ArrayList</code></strong>时可以实现泛型化</p>
<p>例如下面的使用方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; strlist = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">ArrayList&lt;Integer&gt; intList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br></pre></td></tr></table></figure>

<h4 id="ArrayList基本原理"><a href="#ArrayList基本原理" class="headerlink" title="ArrayList基本原理"></a>ArrayList基本原理</h4><p>ArrayList的内部有一个elementData数组，一般会有一些预留的空间，有一个整数size记录实际的元素个数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">transient</span> Object[] elementData;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure>

<p>elementData会随着实际元素个数的增多而重新分配，而size则始终记录实际的元素个数</p>
<ul>
<li><p><strong>ArrayList常用方法的实现</strong></p>
<ul>
<li><p><strong><code>add()方法</code></strong></p>
<p>add方法的主要代码为：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        ensureCapacityInternal(<span class="built_in">size</span> + <span class="number">1</span>); <span class="comment">//插入元素，改变元素个数</span></span><br><span class="line">        elementData[<span class="built_in">size</span>++] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>add()方法首先调用 <strong><code>ensureCapacityInternal(size + 1)</code></strong> 以确保数组容量是够的。</p>
<p>这里以java1.8为例，首先ensureCapacityInternal确保数组容量足够，代码如下：</p>
<p><strong>ensureCapacityInternal</strong></p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> void ensure<span class="constructor">CapacityInternal(<span class="params">int</span> <span class="params">minCapacity</span>)</span> &#123;</span><br><span class="line">        ensure<span class="constructor">ExplicitCapacity(<span class="params">calculateCapacity</span>(<span class="params">elementData</span>,<span class="params">minCapacity</span>)</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>calculateCapacity</strong></p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateCapacity</span><span class="params">(Object[] elementData, <span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">            <span class="keyword">return</span> Math.<span class="built_in">max</span>(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minCapacity;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>calculateCapacity</strong> 判断elementData数组是否为空，如果是则将<strong><code>DEFAULT_CAPACITY</code></strong>的容量赋给<strong>minCapacity</strong> ，在这里<strong>DEFAULT_CAPACITY</strong> 大小为10；</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> static <span class="keyword">final</span> <span class="built_in">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>接下来调用<strong>ensureExplicitCapacity</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="built_in">void</span> ensureExplicitCapacity(<span class="built_in">int</span> minCapacity) &#123;</span><br><span class="line">        modCount++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">            grow(minCapacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>modCount</code></strong> 表示内部的增加修改次数，如果需要的长度大于当前的数组长度，则调用<strong><code>grow</code></strong> 方法,grow 的主要代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">        <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>remove()方法</code></strong> </p>
<p>remove方法源码</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> E remove(<span class="type">int</span> <span class="keyword">index</span>) &#123;</span><br><span class="line">        range<span class="keyword">Check</span>(<span class="keyword">index</span>);</span><br><span class="line">        modCount++;</span><br><span class="line">        E oldValue = elementData(<span class="keyword">index</span>);</span><br><span class="line">        <span class="type">int</span> numMoved = size - <span class="keyword">index</span> - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">System</span>.arraycopy(elementData, <span class="keyword">index</span>+<span class="number">1</span>, elementData, <span class="keyword">index</span>,</span><br><span class="line">                             numMoved);</span><br><span class="line">        elementData[<span class="comment">--size] = null; </span></span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>get()方法</code></strong></p>
<p>ArrayList能够支持随机访问，是因为内部的数据结构是数组，数组本身就是支持随机访问。get()方法首先判断输入的<strong><code>index</code></strong> 是否越界，然后将数组的index位置的<strong><code>元素</code></strong>返回即可。</p>
<p>源代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheck</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= size)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line">        <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h4 id="ArrayList的特点"><a href="#ArrayList的特点" class="headerlink" title="ArrayList的特点"></a>ArrayList的特点</h4><p>对于Arraylist，由于内部实现采用动态数组实现，所以具有以下几个特点</p>
<ul>
<li><strong>可以随机访问，按照索引位置进行访问效率很高</strong></li>
<li><strong>除非数组已经排序，否则按照内容查找元素效率比较低下</strong></li>
<li>添加元素的效率一般，重新分配和复制数组的开销平摊</li>
<li><strong>插入删除元素效率低下，因为需要移动元素</strong></li>
<li>ArrayList不是线程安全的，要实现线程安全的方式是使用<strong>Collections</strong>提供的方法修饰ArrayList</li>
</ul>
<h3 id="剖析LinkedList"><a href="#剖析LinkedList" class="headerlink" title="剖析LinkedList"></a>剖析LinkedList</h3><p>LinkedList实现了List接口、Deque、Queue接口。其内部实现是双向链表，每个元素在内存中是单独存放的，元素之间通过前驱链接和后继链接将节点连接起来。节点的代码如下：</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">private static class <span class="keyword">Node</span><span class="title">&lt;E</span>&gt; &#123;</span><br><span class="line">        E item;</span><br><span class="line">        <span class="keyword">Node</span><span class="title">&lt;E</span>&gt; next;</span><br><span class="line">        <span class="keyword">Node</span><span class="title">&lt;E</span>&gt; prev;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">Node</span><span class="title">(Node</span><span class="tag">&lt;E&gt;</span> prev, E element, <span class="keyword">Node</span><span class="title">&lt;E</span>&gt; next) &#123;</span><br><span class="line">            this.item = element;//元素</span><br><span class="line">            this.next = next;//前驱节点</span><br><span class="line">            this.prev = prev;//后继节点</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>LinkedList内部组成就是如下变量</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">transient int size = <span class="number">0</span>;//链表的长度</span><br><span class="line">   transient <span class="keyword">Node</span><span class="title">&lt;E</span>&gt; first;//指向头节点</span><br><span class="line">   transient <span class="keyword">Node</span><span class="title">&lt;E</span>&gt; last;//指向尾节点</span><br></pre></td></tr></table></figure>

<p>LinkedList常用的方法</p>
<ul>
<li><p><strong>add()方法</strong></p>
<p>该方法是在链表的end添加元素，其调用了自己的方法<strong><code>linkLast(E e)</code></strong>。俩来看看源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">	linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法首先将last的Node引用指向了一个新的Node(l)，然后根据l新建了一个<code>newNode</code>，其中的元素就为要添加的e；而后，我们让last指向newNode，接下来是自身进行维护该链表。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">        last = newNode;</span><br><span class="line">        <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">            first = newNode;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l.next = newNode;</span><br><span class="line">        size++;</span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>remove()方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">	checkElementIndex(index);</span><br><span class="line">	<span class="keyword">return</span> unlink(node(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 通过<strong><code>node</code></strong>方法找到节点，调用了unlike方法</p>
<figure class="highlight q"><table><tr><td class="code"><pre><span class="line">E unlink(Node&lt;E&gt; x) &#123;</span><br><span class="line">        <span class="comment">// assert x != null;</span></span><br><span class="line">        final E element = x.item;</span><br><span class="line">        final Node&lt;E&gt; <span class="built_in">next</span> = x.<span class="built_in">next</span>;</span><br><span class="line">        final Node&lt;E&gt; <span class="built_in">prev</span> = x.<span class="built_in">prev</span>;</span><br><span class="line"></span><br><span class="line">        if (<span class="built_in">prev</span> == <span class="built_in">null</span>) &#123;</span><br><span class="line">            <span class="built_in">first</span> = <span class="built_in">next</span>;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            <span class="built_in">prev</span>.<span class="built_in">next</span> = <span class="built_in">next</span>;</span><br><span class="line">            x.<span class="built_in">prev</span> = <span class="built_in">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (<span class="built_in">next</span> == <span class="built_in">null</span>) &#123;</span><br><span class="line">            last = <span class="built_in">prev</span>;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            <span class="built_in">next</span>.<span class="built_in">prev</span> = <span class="built_in">prev</span>;</span><br><span class="line">            x.<span class="built_in">next</span> = <span class="built_in">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        x.item = <span class="built_in">null</span>;</span><br><span class="line">        size--;</span><br><span class="line">        modCount++;</span><br><span class="line">        return element;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>删除x节点，就是让x的前驱和后继直接链接起来，next是x的后继，prev是x的前驱，分为下面两步：</p>
<ul>
<li>让x的前驱的后继指向x的后继。如果没有前驱，说明删除的是头节点，则修改头节点指向x的后继。</li>
<li>让x的后继的前驱指向x的前驱。如果x没有后继，说明删除的是尾节点，则修改尾节点指向x的前驱。</li>
</ul>
</li>
</ul>
<p>LinkedList特点</p>
<p>用法上，LinkedList是一个List，但也实现了Deque接口，可以作为队列、栈。双端队列使用。实现原理上，LinkedList内部是一个双向链表，并维护了长度，头节点、尾节点。</p>
<ul>
<li>按需分配空间，不需要预先分配很多的空间</li>
<li>不可以随机访问，按照索引位置访问效率太低，必须从头到尾顺着链接找</li>
<li>不管列表是否排序，只要是按照内容查找元素，效率都比较低</li>
<li>在两端添加、删除元素的效率很高</li>
<li>在中间插入、删除元素，要先定位，效率比较低，而修改本身的效率很高 </li>
</ul>
<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>HashMap实现了Map接口，HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。</p>
<p><strong>内部组成</strong>：HashMap内部组成主要有如下实例变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">transient</span> Entry&lt;K,V&gt;[]table = (Entry&lt;K,V&gt;[])EMPTY_TABLE;</span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java中级编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java集合框架</title>
    <url>/2020/06/09/java/java%E5%9F%BA%E7%A1%80/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<p>在编程时有些场景需要用到Java的集合框架，这篇博文将介绍在Java系统里的集合框架。</p>
<p><img src="C:%5CUsers%5C%E6%9D%A8%5CDesktop%5C%E8%AF%BB%E4%B9%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5C%E5%AF%BC%E5%87%BA%E5%9B%BE%E7%89%87%5CCollectionAndMap.png" alt=""></p>
<p>Java提供了大量持有对象的方式：</p>
<ul>
<li>数组</li>
<li><strong><code>Collection</code></strong>保存单一的元素，<strong><code>Map</code></strong>保存相关联的键值对。各种<strong>Collection</strong>和各种<strong>Map</strong>都可以在你向其中添加更多元素时自动调整其尺寸。</li>
<li>向数组一样，<strong>List</strong>也建立数字索引与对象的关联，因此数组和List都是拍好序的容器。List能自动扩充容量。</li>
<li>如果要进行大量的随机访问，就使用<strong><code>ArrayList</code></strong>;如果要经常从表中间插入或删除元素，则使用<strong><code>LinkedList</code></strong>.</li>
<li>各种<strong><code>Queue</code></strong>及栈的行为，优LinkedList提供</li>
<li><strong><code>Map</code></strong>是一种将对象与对象相关联的设计，<strong>HashMap</strong>设计用来快速访问；<strong>LinkedHashMap</strong>保持元素插入时的顺序，但是也通过散列提供快速访问能力。</li>
<li><strong><code>Set</code></strong>不接受重复元素。<strong>HashSet</strong>提供最快的查询速度，<strong>LinkedHashSet</strong>以插入顺序保存元素</li>
</ul>
<h3 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h3><h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><p>List有两种基本类型：ArrayList和LinkedList</p>
<h5 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a><strong>ArrayList</strong></h5><p><strong>ArrayList</strong>长于随机访问元素，但是在List的中间插入和移除元素时比较慢。下面来列举几个ArrayList的常用API</p>
<ul>
<li>contains()用于确定某个对象是否在列表中。</li>
<li>remove()方法移除一个对象，将这个对象的引用传递给remove()方法</li>
<li>indexOf()方法用来获取某个对象在List中的所处位置的索引编号</li>
<li>subList()方法将从较大的列表中创建出一个片段。</li>
<li>retailAll()方法时List的交集操作</li>
</ul>
<h4 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h4><p><strong>LinkedList</strong>实现基本的<strong>List</strong>接口。下面介绍LinkedList中的一些方法</p>
<ul>
<li>getFirst()方法返回列表的头，如果List为空，则抛出异常</li>
<li>removeFirst()移除并返回列表的头元素，在列表为空时抛出异常</li>
<li>addList()和addLast()相同，将某个元素插入到列表的头部或尾部</li>
<li>removeLast()移除并返回列表的最后一个元素</li>
</ul>
<h4 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h4><p>Queue是<strong>先进先出</strong>的容器，从容器的一端放入事物，从另一端取出，并且事物放入容器顺序与取出的顺序相同，队列常常被当作一种可靠的将对象从程序的某个区域传输到另一个区域的途径，下面介绍在Queue中的方法：</p>
<ul>
<li>offer()方法将一个元素插入到队尾，或者返回false</li>
<li>peek()和element()都将在不移除的情况下返回对头，peek()方法在队列为空时返回null，element()则会抛出异常信息。</li>
<li>poll()和remove()方法将移除并返回对头，当队列为空时poll()返回空，而remove()会抛出异常</li>
</ul>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<p>《Java编程思想》</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java中级编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Executor框架</title>
    <url>/2020/06/05/java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Executor%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h3 id="Executor框架两级调度"><a href="#Executor框架两级调度" class="headerlink" title="Executor框架两级调度"></a>Executor框架两级调度</h3><p><img src="https://raw.githubusercontent.com/yangshenghua97/Image/master/%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E4%B8%A4%E7%BA%A7%E8%B0%83%E5%BA%A6.png" alt=""></p>
<p>Java线程启动时会创建一个本地操作系统线程，当该Java线程终止时，这个操作系统线程也会被回收。操作系统会调度所有线程并将它们分配给可用CPU。</p>
<p>在上面的调度模型中：</p>
<p>在上层，Java多线程程序通常把应用分解为若干任务，然后使用用户级的调度器将这些任务映射为固定数量的线程；在底层，操作系统内核将这些线程映射到硬件处理器上。</p>
<h3 id="Executor框架结构"><a href="#Executor框架结构" class="headerlink" title="Executor框架结构"></a>Executor框架结构</h3><p>Executor框架由3大部分组成</p>
<ul>
<li><p><strong>任务</strong></p>
<p>包括被执行任务需要的实现接口(Runnable接口或Callable接口)<br>Runnable接口和Callable接口的实现类，可以被ThreadPoolExecutor或者ScheduleThreadPoolExecutor</p>
</li>
<li><p><strong>执行的任务</strong></p>
<p>包括任务执行机制的核心接口<strong><code>Executor</code></strong>以及继承自<strong><code>Executor</code></strong>的<strong><code>ExecutorService</code></strong>接口</p>
<p>Executor是一个接口，时Executor框架的基础，它将任务的提交与任务的执行分离</p>
<p>ThreadPoolExecutor是线程池的核心实现类，用来执行被提交的任务</p>
<p>ScheduleThreadPoolExecutor，可以在给定的延迟后运行命令，或者定期执行命令</p>
</li>
<li><p><strong>异步计算的框架</strong><br>包括接口<strong><code>Future</code></strong>和实现Future接口的<strong><code>FutureTask</code></strong>类，代表异步计算的结果</p>
<p><img src="https://raw.githubusercontent.com/yangshenghua97/Image/master/Executor%E6%A1%86%E6%9E%B6%E7%9A%84Class%E4%B8%8Einterface.png" alt=""></p>
</li>
</ul>
<h3 id="Executor框架成员"><a href="#Executor框架成员" class="headerlink" title="Executor框架成员"></a>Executor框架成员</h3><p>Executor框架主要成员：ThreadPoolExecutor、ScheduledThreadPoolExecutor、Future接口、Runnable接口、Callable接口、Executors。</p>
<ul>
<li><p><strong>ThreadPoolExecutor</strong></p>
<p>ThreadPoolExecutor通常使用工厂类<strong>Executors</strong>来创建，Executors可以创建3种类型的ThreadPoolExecutor；分别是SingleThreadExecutor、FixedThreadPool、CachedThreadPool。ThreadPoolExecutor是Executor框架最核心的类，是实现线程池的类。主要由下列组件构成</p>
<ul>
<li>corePool：核心线程池大小</li>
<li>maximumPool：最大线程池的大小</li>
<li>BlockingQueue：用来暂时保存任务的工作队列</li>
</ul>
</li>
</ul>
<p>下面分别介绍3种类型的ThreadPoolExecutor：</p>
<ul>
<li><p><strong>SingleThreadExecutor</strong>：</p>
<p>SingleThreadExecutor适用于需要保证顺序执行各个任务；并且在任意时间点，不会有多个线程是活动的应用场景。</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="keyword">new</span><span class="type">SingleThreadExecutor</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">FinalizableDelegatedExecutorService</span></span><br><span class="line"><span class="type"></span>            (<span class="keyword">new</span> <span class="type">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                    <span class="number">0</span>L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> <span class="type">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="keyword">new</span><span class="type">SingleThreadExecutor</span>(ThreadFactory threadFactory) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">FinalizableDelegatedExecutorService</span></span><br><span class="line"><span class="type"></span>            (<span class="keyword">new</span> <span class="type">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                    <span class="number">0</span>L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> <span class="type">LinkedBlockingQueue</span>&lt;Runnable&gt;(),</span><br><span class="line">                                    threadFactory));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，SingleThreadExecutor的corePoolSize和maximumPoolSize被设置为1，SingleThreadExecutor使用无界队列<strong>LinkedQueueBlockingQueue</strong>作为线程池的工作队列（队列的容量为Integer.MAX_VALUE）。SingleThreadExecutor的运行图如下</p>
<p><img src="https://raw.githubusercontent.com/yangshenghua97/Image/master/SingleThradPoolExecutor.png" alt=""></p>
<p>下面对上图中的过程进行说明：</p>
<p>1.如果当前运行的线程少于corePoolSize（线程池中没有运行的线程），则创建一个线程类执行任务</p>
<p>2.在线程池完成预热之后，将任务加入LinkedBlockingQueue</p>
<p>3.线程执行完1中的任务后，会在一个无限循环中反复从LinkedBlockingQueue获取任务来执行</p>
</li>
<li><p><strong>FixedThreadPool</strong>：</p>
<p>FixedThreadPool适用于为了满足资源管理的需求，而需要限制当前线程数量的应用场景。适用于负载均衡比较重的服务器</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="keyword">new</span><span class="type">FixedThreadPool</span>(int nThreads) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                      <span class="number">0</span>L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> <span class="type">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="keyword">new</span><span class="type">FixedThreadPool</span>(int nThreads, ThreadFactory threadFactory) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                      <span class="number">0</span>L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> <span class="type">LinkedBlockingQueue</span>&lt;Runnable&gt;(),</span><br><span class="line">                                      threadFactory);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>FixedThreadPool的corePoolSize和maximumPoolSize都被设置为创建FixedThreadPool时指定的参数nThread</p>
<p>当线程池中的线程数大于corePoolSize时，keepAliveTime为多余的空闲线程等待新任务的最长时间，超过这个时间后多余的线程将被终止。把keepAliveTime设置为0L，说明多余的空闲线程会被立即终止。</p>
<p><img src="https://raw.githubusercontent.com/yangshenghua97/Image/master/FixedThreadPool.png" alt=""></p>
<p>1.如果当前运行的线程数少于corePoolSize，则创建线程来执行任务</p>
<p>2.在线程池完成预热后将任务加入LinkedBlockingQueue</p>
<p>3.线程执行完成1中的任务后，会在循环中反复从LinkedBlockingQueue获取任务来执行</p>
<p>FixedThreadPool使用无界队列LinkedBlockingQueue作为线程池的工作队列（队列的容量为Integer.MAX_VALUE）</p>
</li>
<li><p><strong>CachedThreadPool</strong></p>
<p>CachedThreadPool是大小无界的线程池，适用于执行很多短期异步任务的小程序或负载较轻的服务器</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="keyword">new</span><span class="type">CachedThreadPool</span>(ThreadFactory threadFactory) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                      <span class="number">60</span>L, TimeUnit.SECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> <span class="type">SynchronousQueue</span>&lt;Runnable&gt;(),</span><br><span class="line">                                      threadFactory);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>CachedThreadPool的corePoolSize被设置为0，maximumPoolSize被设置为Integer.MAX_VALUE,即maximumPool是无界，把keepAliveTime设置为60L，CachedThreadPool中的空闲线程等待新任务的最长时间为60秒，空闲线程超过60秒后将会终止</p>
<p><img src="C:%5CUsers%5C%E6%9D%A8%5CDesktop%5C%E8%AF%BB%E4%B9%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5CCachedThreadPool.png" alt=""></p>
</li>
</ul>
<h3 id="ScheduleThreadPoolExecutor"><a href="#ScheduleThreadPoolExecutor" class="headerlink" title="ScheduleThreadPoolExecutor"></a>ScheduleThreadPoolExecutor</h3><p>待续</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>MapReduce&amp;HDFS</title>
    <url>/2020/06/05/bigdata/MapReduce-HDFS/</url>
    <content><![CDATA[<h3 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h3><p><strong>MapReduce编程模型</strong></p>
<p>整个MapReduce计算过程分为Map阶段和Reduce阶段，也称为映射和缩减阶段，这两个独立的阶段实际上是两个独立的过程，即Map过程和Reduce过程，在Map中进行数据的读取和数据的预处理，之后将预处理的结果发送给Reduce中进行合并。</p>
<p><strong>MapReduce执行流程</strong></p>
<ul>
<li>Hadoop计算流程</li>
</ul>
<h3 id="HDFS"><a href="#HDFS" class="headerlink" title="HDFS"></a>HDFS</h3>]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>队列同步器-AQS</title>
    <url>/2020/05/16/java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/AQS%E5%90%8C%E6%AD%A5%E5%99%A8/</url>
    <content><![CDATA[<h2 id="什么是队列同步器"><a href="#什么是队列同步器" class="headerlink" title="什么是队列同步器"></a>什么是队列同步器</h2><p>队列同步器是用来构建锁或者其他同步组件的基础框架，它使用一个int成员变量表示同步状态，通过内置的FIFO队列完成资源获得线程的排队工作。</p>
<p>同步器是实现锁的关键，在锁的实现中聚合同步器，利用同步器实现锁的语义。</p>
<p><strong>锁和同步器两者的关系：锁是面向使用者，定义了使用者与锁交互的接口，隐藏实现细节；而同步器面向的是锁的实现者，简化了锁的实现方式，屏蔽了同步状态管理、线程的排队、等待与唤醒等底层操作。</strong></p>
<p>AQS的主要使用方式是继承，子类通过继承同步器并实现它的抽象方法来管理同步状态，在抽象方法的实现过程中需要对同步状态进行更新，因此就需要使用同步器提供的3个方法来保证状态的改变是安全的。</p>
<h2 id="队列同步器的实现"><a href="#队列同步器的实现" class="headerlink" title="队列同步器的实现"></a>队列同步器的实现</h2><h3 id="同步队列"><a href="#同步队列" class="headerlink" title="同步队列"></a>同步队列</h3><p>同步队列依赖内部的同步队列完成同步状态的管理，当前线程获得同步状态失败时，同步器会将当前线程以及等待状态等信息构成一个节点将其加入到同步队列中，同时会阻塞当前线程，当同步状态释放时，会将首节点的线程唤醒，使其再次尝试获取同步状态。同步队列中的节点用来保存获取同步状态失败的线程引用、等待状态以及前驱后继节点。</p>
<table>
<thead>
<tr>
<th>属性类型与名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>int waitStatus</td>
<td>等待状态</td>
</tr>
<tr>
<td>Node prev</td>
<td>前驱节点</td>
</tr>
<tr>
<td>Node next</td>
<td>后继节点</td>
</tr>
<tr>
<td>Node nextWaiter</td>
<td>等待队列中的后继节点</td>
</tr>
<tr>
<td>Thread thread</td>
<td>获取同步状态的线程</td>
</tr>
</tbody></table>
<p>上面的<strong><code>waitStatus</code></strong>变量中有这么几个状态，</p>
<ul>
<li>CANCELED</li>
<li>SIGNAL</li>
<li>CONDITION</li>
<li>PROPAGATE</li>
<li>INITIAL</li>
</ul>
<p>同步队列的基本结构如下</p>
<p><img src="https://raw.githubusercontent.com/yangshenghua97/Image/master/AQSLinked.png" alt=""></p>
<p>同步器提供一个基于CAS的设置尾节点的方法（compareAndSetStatus），通过CAS设置尾节点；</p>
<p>如下图：</p>
<p><img src="https://raw.githubusercontent.com/yangshenghua97/Image/master/AQSLinkedCASAddtail.png" alt=""></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中的线程池</title>
    <url>/2020/05/04/java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<h3 id="合理使用线程池的好处"><a href="#合理使用线程池的好处" class="headerlink" title="合理使用线程池的好处"></a>合理使用线程池的好处</h3><ul>
<li><p>降低资源消耗</p>
<p>通过重复利用已创建的线程降低线程创建和的销毁造成的消耗</p>
</li>
<li><p>提高响应速度</p>
<p>当任务到达时，任务可以不需要等到线程创建就能立即执行</p>
</li>
<li><p>提高线程的可管理性</p>
<p>线程是稀缺资源，如果无限制创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优、监控</p>
</li>
</ul>
<h3 id="线程池的实现原理"><a href="#线程池的实现原理" class="headerlink" title="线程池的实现原理"></a>线程池的实现原理</h3><p><strong>线程池的处理流程</strong></p>
<ul>
<li>线程池判断核心线程池里的线程是否都在执行任务。如果不是，则创建一个新的工作线程来执行任务。如果核心线程池里的线程都在执行任务，则进入下一个流程</li>
<li>线程池铺垫工作队列是否已满。如果工作队列没有满，则将新提交的任务存储在这个工作队列中。如果工作队列慢了，则进入下一个流程</li>
<li>线程池判断线程池的线程是否都处于工作状态。如果没有，则创建一个新的工作线程來执行任务。如果已满，则交给饱和策略来处理这个任务</li>
</ul>
<p>流程图图如下：</p>
<p><img src="https://raw.githubusercontent.com/yangshenghua97/Image/master/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.png" alt=""></p>
<p><strong>ThreadPoolExector执行execute</strong></p>
<p>ThreadPoolExecutor执行execute方法分为4种情况：</p>
<ul>
<li>1 如果当前线程少于<strong><code>corePoolSize</code></strong>，则创建新线程来执行任务</li>
<li>2 如果运行的线程等于或多于corePoolSize，则将任务加入<strong><code>BlockingQueue</code></strong></li>
<li>3 如果无法将任务加入BlockingQueue，则创建新的线程来处理任务</li>
<li>4 如果创建新线程将使当前运行的线程超出maximumPoolSize，任务将被拒绝，并调用异常方法</li>
</ul>
<p><img src="https://raw.githubusercontent.com/yangshenghua97/Image/master/ThreadPoolExecutor.png" alt=""></p>
<p><strong>线程池中的线程执行任务分两种情况</strong></p>
<ul>
<li><p>在<strong><code>execute()</code></strong>方法中创建一个线程时，会让这个线程执行当前任务</p>
</li>
<li><p>这个线程执行完下图中1的任务后，会反复从BlockingQueue中获取任务来执行</p>
<p><img src="https://raw.githubusercontent.com/yangshenghua97/Image/master/ThreadPoolExecutor2.png" alt=""></p>
</li>
</ul>
<h3 id="线程池的使用"><a href="#线程池的使用" class="headerlink" title="线程池的使用"></a>线程池的使用</h3><p>  <strong>线程池的创建</strong><br>  通过<strong>ThreadPoolExecutor</strong>来创建一个线程池</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> ThreadPoolExecutor(<span class="keyword">int</span> corePoolSize,</span><br><span class="line">                   <span class="keyword">int</span> maximumPoolSize,</span><br><span class="line">                   <span class="keyword">long</span> keepAliveTime,</span><br><span class="line">                   TimeUnit unit,</span><br><span class="line">                   BlockingQueue&lt;Runnable&gt; workQueue)</span><br></pre></td></tr></table></figure>
<p>创建一个线程需要输入几个参数</p>
<ul>
<li>corePoolSize：线程池的基本大小</li>
<li>maximumPoolSize：线程池最大数量</li>
<li>keepAliveTime：线程活动保持时间</li>
<li>unit：线程活动保持时间单位</li>
<li>workQueue：任务队列</li>
</ul>
<p><strong>向线程池提交任务</strong></p>
<p>使用两个方法向线程池提交任务</p>
<ul>
<li><p><strong><code>execute()</code></strong>方法：</p>
<p>execute()方法用于提交不需要返回值得任务，所以无法判断任务是否被线程池执行成功</p>
</li>
<li><p><strong><code>submit()</code></strong>方法：</p>
<p>submit()方法用于提交需要返回值的任务。线程池会返回一个future类型的对象，通过这个<strong><code>future</code></strong>对象可以判断任务是否执行成功，并且可以通过future的get()方法来获取返回值，<strong><code>get()</code></strong>方法会阻塞当前线程直到任务完成，<strong>get(long timeout,TimeUnit unit)</strong>方法则会阻塞当前线程一段时间后立即返回，这种情况下有可能任务没有执行完成。</p>
</li>
</ul>
<p><strong>关闭线程池</strong></p>
<p>通过调用线程池的<strong><code>shutdown</code></strong>或<strong><code>shutdownNow</code></strong>方法关闭线程池。</p>
<p><strong>shutdownNow</strong>首先将线程池的状态设置成<strong><code>STOP</code></strong>,然后尝试停止所有正在执行或暂停任务的线程，并返回等待执行任务的列表。</p>
<p><strong>shutdown</strong>只是将线程池的状态设置成SHUTDOWN状态，然后中断所有没有正在执行的任务的线程。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发编程之Synchronized</title>
    <url>/2020/04/25/java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BSynchronized/</url>
    <content><![CDATA[<h2 id="synchronized的实现原理"><a href="#synchronized的实现原理" class="headerlink" title="synchronized的实现原理"></a>synchronized的实现原理</h2><h3 id="利用synchronized实现同步的基础："><a href="#利用synchronized实现同步的基础：" class="headerlink" title="利用synchronized实现同步的基础："></a>利用synchronized实现同步的基础：</h3><ul>
<li>对于普通同步方法，锁是当前的实例对象</li>
<li>对于静态同步方法，锁是当前类的Class对象</li>
<li>对于同步方法块，锁是Synchronized括号里的配置对象</li>
</ul>
<h3 id="Synchronized实现原理："><a href="#Synchronized实现原理：" class="headerlink" title="Synchronized实现原理："></a>Synchronized实现原理：</h3><p>JVM基于进入和退出<strong><code>Monitor</code></strong>对象来实现方法同步和代码块同步，代码块同步使用<strong><code>monitorenter</code></strong>和<strong><code>monitorexit</code></strong>指令实现，monitorenter指令是在编译后插入到同步代码块开始位置，而monitorexit是插入到方法结束和异常处，<strong><code>JVM</code></strong>要保证每个monitorenter必须有对应的monitorexit与之匹配。</p>
<p>关键字synchronized可以修饰方法或者以同步块的形式来进行使用，它主要确保多个线程在同一时刻，只能有一个线程处于方法或同步块中，他保证了线程对变量访问的可见性和排他性。对于同步块的实现使用monitorenter和monitorexit指令，而同步方法则是依靠方法修饰符上的<strong><code>ACC_SYNCHRONIZED</code></strong>来完成。其本质上是对一个对象的监视器(monitor)进行获取，而这个过程是排他的，也就是在同一时刻只能有一个线程获得synchronized所保护对象的监视器。任意一个对象都拥有自己的监视器，当这个对象有同步块或者这个对象的同步方法调用时，执行方法的线程必须先获取到该对象的监视器才能进入同步块或者同步方法，而没有获取到监视器的线程将会被阻塞在同步块和同步方法的入口处，进入<strong><code>BLOCKED</code></strong>状态。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP/IP协议</title>
    <url>/2020/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TTCP-IP%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h3 id="TCP-IP的标准制定"><a href="#TCP-IP的标准制定" class="headerlink" title="TCP/IP的标准制定"></a>TCP/IP的标准制定</h3><p>由于TCP/IP技术的公开性，他不属于任何一个厂商或者是专业协会所有。TCP/IP的标准大部分都由<strong>RFC</strong>技术报告的形式公开。RCF文件包含了所有TCP/IP的协定标准，以及其最新版本。RFC所涵盖的内容和细节非常广，也可以为新协定的标准和计划，但不能以学术研究论文的方式来编辑。</p>
<h3 id="TCP-IP的特性"><a href="#TCP-IP的特性" class="headerlink" title="TCP/IP的特性"></a>TCP/IP的特性</h3><ul>
<li>它是其它网络服务的基础，几乎所有数据包交换网络都提供了这种服务。TCP/IP是根据信息中所含的地址资料来进行资料的传送，他不能确保每个独立路由的数据包是可靠和依序的送达目的地。在每个连线过程中，线路都不是被”独占”的，而是直接映射到硬件地址上，因此特别有效。</li>
<li>因为数据包交换并不能确保每一个数据包的可靠性，因此我们就需要通讯软件来自动检测和修护传送过程中出现的错误和处理损坏数据包。这种服务就是用来确保电脑程序之间能够连接和传送大量的数据。关键的技术就是数据流进行分割，然后编号传送，然后通过接受的确认来确数据的完整性</li>
<li>在数据包交换技术中，TCP/IP是独立于硬件之上的。TCP/IP有自己的一套数据包规定和定义,能应用在不同的网络之上</li>
<li>只要用TCP/IP连接网络，就会获得一个独一无二的识别位址。数据包在交换过程中，是以位址数据为依据，不管数据包所经历的路由如何，数据都会被送到指定的地址。</li>
<li>TCP/IP 的确认模式是以“端到端”进行的。這样就无需理会数据包交换过程中所参与的其他设备。</li>
</ul>
<h3 id="TCP-IP协议分层框架"><a href="#TCP-IP协议分层框架" class="headerlink" title="TCP/IP协议分层框架"></a>TCP/IP协议分层框架</h3><ul>
<li><p>链路程：链路层以字节位单位0和1分别进行分组，定义数据帧，写入源和目标机器的物理地址，数据，校验位来传输数据。</p>
<p><img src="https://raw.githubusercontent.com/yangshenghua97/Image/master/linkway.png" alt=""></p>
<p>链路层报文结构</p>
</li>
<li><p>网络层：根据IP定义网络地址，区分网段。子网内根据地址解析协议(ARP)进行MAC寻址，子网外进行路由转发数据包，这个数据包即为IP数据包。</p>
</li>
<li><p>传输层：数据包通过网络层发送到目标计算机后，应用程序在传输层定义逻辑端口，确认身份后，将数据包交给应用程序，实现端口到端口间通讯。</p>
</li>
<li><p>应用层：传输层的数据到达应用程序时，以某种统一规定的协议格式解读数据。</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/yangshenghua97/Image/master/PTCIP.png" alt=""></p>
<h3 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h3><p>IP是面向无连接、无状态的，没有额外的机制保证发送的包是否有序到达。IP首先规定出IP地址格式，该地址相当于在逻辑意义上进行了网段的划分，给没台机器额外设置了一个唯一的详细地址。IP地址属于网络层，主要的功能字啊WLAN内进行路由寻址，选择最佳路由。</p>
<p><img src="https://raw.githubusercontent.com/yangshenghua97/Image/master/IP.png" alt=""></p>
<h3 id="TCP建立连接"><a href="#TCP建立连接" class="headerlink" title="TCP建立连接"></a>TCP建立连接</h3><p>传输控制协议(TCP)，是一种面向连接、确保数据在端到端间的可靠传输的协议。面向连接是指在发送数据前，需要先建立一条虚拟的链路，然后让数据在这条链路上“流动”传输。每个TCP数据包是封装在IP包中的，每一个IP头的后面紧接的是TCP头。</p>
<p><img src="https://raw.githubusercontent.com/yangshenghua97/Image/master/TCP.png" alt=""></p>
<p>协议第一行的两个端口号各个占据两个字节，分别代表源机器与目标机器的端口号。这两个端口号与IP报头格式中的源IP地址和目标IP地址所组成的四元组可唯一标识一条TCP连接。由于TCP是面向连接的，所以有服务器和客户端之分。需要服务端先在相应的端口上进行监听，准备好接收客户端发起的连接请求。在类UNIX系统系统上通过netstat命令列出机器上已建立的连接信息，其中包含唯一标识一条连接的四元组，以及各连接的状态等内容。</p>
<p>TCP的FLAG位有6个bit组成，分别代表SYN、ACK、FIN、URG、PSH、RST，需要重点关注的是SYN、ACK、FIN。SYN(Synchronize Sequence Numbers)用作建立连接时的同步信号；ACK(Acknowledgement)用于对收到的数据进行确认，所确认的数据由确认序列号表示；FIN(Finish)表示后面没有数据需要发送，通常意味着所建立的连接需要关闭。</p>
<h4 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h4><p>TCP三次握手是指在建立连接的三个步骤：</p>
<ul>
<li><p>A机器发出一个数据包并将SYN置1，表示希望建立连接。这个包中的序列号假设是x。</p>
</li>
<li><p>B机器收到A机器发过来的数据包后，通过SYN得知这是一个建立连接的请求，于是发送一个响应包并将SYN和ACK标记都置为1。假设这个包中的序列号是y，而确认序列号的必须是x+1，表示收到了A发过来的SYN。在TCP中，SYN被当作数据中的一个字节。</p>
</li>
<li><p>A接收到B的响应后需进行确认，确认包中将ACK置1，并将确认序列号设置为y+1，表示收到了来自B的SYN。</p>
<p><img src="https://raw.githubusercontent.com/yangshenghua97/Image/master/SANCIWUOSHOU.png" alt=""></p>
<p>双方只有确认4类信息，才能建立连接。在第二次握手后，从B机器视角看还有连个NO信息无法确认。在第三次握手后，B机器才能确认自己的发报能力是否正常的。</p>
<p><img src="https://raw.githubusercontent.com/yangshenghua97/Image/master/TCP3.png" alt=""></p>
</li>
</ul>
<p>连接三次握手也是防止出现请求超时导致脏连接。TTL网络报文的生存时间往往都会超过TCP请求时间，如果两次握手就可以创建连接的话，传输数据并释放连接后，第一个超时的连接请求才到达B机器的话，B机器会认为是A创建的连接的请求，然后确认同意创建连接。因为A机器的状态不是SYN_SENT,所以直接丢弃了B的确认数据，以致最后只是B机器单方面创建连接完毕。</p>
<p><img src="https://raw.githubusercontent.com/yangshenghua97/Image/master/%E8%84%8F%E8%BF%9E%E6%8E%A5.png" alt=""></p>
<h3 id="TCP断开连接"><a href="#TCP断开连接" class="headerlink" title="TCP断开连接"></a>TCP断开连接</h3><p>TCP是全双工通信，双方都能作为数据的发送方和接收方，但TCP连接也会有断开的时候。A、B机器连接只要三次握手，而断开则需要四次挥手，例如下图：</p>
<p>A机器想要断开连接，则待本方数据发送完毕后，传递FIN信号给B机器。B机器应答ACK，告诉A机器可以断开，但是需要等B机器处理完成数据，再主动给A机器发送FIN信号。这时A机器处于半关闭状态(FIN-WAIT-2)，无法再发送新的数据。B机器做好连接关闭前的准备工作后，发送FIN给A机器，此时B机器也进入半关闭状态(CLOSE_WAIT)。A机器发送针对B机器FIN的ACK后，进入TIME_WAIT状态，经过2MSL后，没有收到B机器传过来的报文，则确定B机器已经收到A机器最后发送的ACK指令，此时TCP连接正式释放。</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>CPU与内存</title>
    <url>/2020/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%9E%84%E6%88%90/CPU%E4%B8%8E%E5%86%85%E5%AD%98/</url>
    <content><![CDATA[<p><img src="https://raw.githubusercontent.com/yangshenghua97/Image/master/CPU.png" alt=""></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
</blockquote>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机基础</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机的0与1</title>
    <url>/2020/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%9E%84%E6%88%90/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%840%E4%B8%8E1/</url>
    <content><![CDATA[<p>在计算机中无论是什么设备，归根结底都是0和1的信号处理，设定基数为2，进位的规则是“逢二进一”，称之为二进制，设想有8条电路，每条电路有高电平和低电平两种状态。根据组合排列，有2^8 即256个种不同的信号。这8条电路，最左侧的一条表示正负，0表示正数，1表示负数，不参与数值表示。</p>
<h3 id="基本编码"><a href="#基本编码" class="headerlink" title="基本编码"></a>基本编码</h3><p>表示数的基本编码方式有原码、反码、补码；</p>
<p><strong>原码：符号为和数字实际值得结合，正数就是数值本身，符号为0；负数是数值本身，符号位为1，8位的二进制的表示范围是[-127,127]</strong></p>
<p><strong>反码：正数是本身，符号位为0；负数的数值部分是正数表示的基础上对各个位取反，符号位为1。8位二进制数的表示范围是[-127,127]</strong></p>
<p><strong>补码：正数是数组的本身，符号位为0，负数的数值部分是在正数表示基础上对各个位取反加1，符号位为1。8位二进制数的表示范围是[-127,127]</strong></p>
<table>
<thead>
<tr>
<th>正数/负数</th>
<th>原码</th>
<th>反码</th>
<th>补码</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>0000 0001</td>
<td>0000 0001</td>
<td>0000 0001</td>
</tr>
<tr>
<td>-1</td>
<td>1000 0001</td>
<td>1111 1110</td>
<td>1111 1111</td>
</tr>
<tr>
<td>2</td>
<td>0000 0010</td>
<td>0000 0010</td>
<td>0000 0010</td>
</tr>
<tr>
<td>-2</td>
<td>1000 0010</td>
<td>1111 1101</td>
<td>1111 1110</td>
</tr>
</tbody></table>
<p>为了加速计算机对加减乘除运算速度，所有产生了反码和补码。例如在进行减法计算时，1-2=-1在计算机运算中可以这样运算：1+（-2）=-1。如果使用原码计算则结果为：1+（-2）= [0000 0001]<del>原</del>+[1000 0010]<del>原</del> = [10000011]<del>原</del> = -3结果是错误的。为了解决这一问题，于是出现了反码，使用反码计算，结果为1-2 = 1+(-2) = [00000001]<del>反</del>+[1111 1101]<del>反</del>=[1111 1110]<del>反</del> = -1。</p>
<h3 id="计算机存储计量单位"><a href="#计算机存储计量单位" class="headerlink" title="计算机存储计量单位"></a>计算机存储计量单位</h3><p>在上述的一条线路在计算机中表示1位，<strong>即1个bit，8个bit组成一个单位，称为一个字节，即1个Byte，1024个Byte简写为KB，1024个KB简写为MB，1024个MB简写为GB</strong>。</p>
<h3 id="位移运算"><a href="#位移运算" class="headerlink" title="位移运算"></a>位移运算</h3><p>向右移动一位近似表示除以2，十进制转化为二进制数后，向右移时，最右边的1位将被直接抹去。在左移<strong><code>&lt;&lt;</code></strong>和右移<strong><code>&gt;&gt;</code></strong>这两种运算中符号位均参与移动，除了负数右移时高位补1外，其他情况均在空位处补0</p>
<p>左移运算由于符号位参与向左移动，在移动后的结果，最左位可能是1或是0，即正数向左移的结果可能负数也可能是正数，负数向左移的结果也是如此。</p>
<p>对于 <strong><code>&gt;&gt;&gt;</code></strong> 无符号向右移动(不存在&lt;&lt;&lt;位移运算)，当向右移动时，正负数高位均补0，正数不断向右移动的最小值是0，而负数不断向右移动的最小值为1，无需考虑符号位，高位直接补0</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<p>《码出高效 Java开发手册》</p>
</blockquote>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机基础</tag>
      </tags>
  </entry>
  <entry>
    <title>浅尝算法</title>
    <url>/2020/02/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><p>根据时间复杂度的不同，主流的排序算法分为3大类</p>
<p><strong>时间复杂度为O(n[^^]2)的排序算法</strong></p>
<ul>
<li>排序算法</li>
<li>选择排序</li>
<li>插入排序</li>
<li>希尔排序</li>
</ul>
<p><strong>时间复杂度为O(nlogn)的排序算法</strong></p>
<ul>
<li>快速排序</li>
<li>归并排序</li>
<li>堆排序</li>
</ul>
<p><strong>时间复杂度为线性的排序算法</strong></p>
<ul>
<li>计数排序</li>
<li>桶排序</li>
<li>基数排序</li>
</ul>
<h3 id="冒泡排序-bubble-sort"><a href="#冒泡排序-bubble-sort" class="headerlink" title="冒泡排序(bubble sort)"></a>冒泡排序(bubble sort)</h3><p>冒泡排序的思想就是把相邻的元素进行两两比较，当一个元素大于右侧相邻的元素时，交换它们的位置；当一个元素小于或等于右侧相邻元素时，位置不变。</p>
<p>冒泡排序是一种稳定的排序，值相等的元素并不会打乱原本的排序。由于该排序算法的每一轮都会遍历所有元素，总共遍历(元素数量-1)轮，所以平均时间复杂度为O(n[^^]2)。</p>
<p><code>代码实现</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">bubblesort</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;array.length-i-<span class="number">1</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(array[j]&gt;array[j+<span class="number">1</span>])&#123;</span><br><span class="line">                    tmp = array[j];</span><br><span class="line">                    array[j] = array[j+<span class="number">1</span>];</span><br><span class="line">                    array[j+<span class="number">1</span>] = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">5</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">7</span>&#125;;</span><br><span class="line">        sort(array);</span><br><span class="line">        System.out.println(Arrays.toString(array));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[3, 4, 5, 5, 6, 7, 8, 45, 46, 46, 84, 94]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>代码使用双循环进行排序，外部循环控制所有的回合，内部循环实现每一轮的冒泡处理，进行元素比较，再进行元素排序。</p>
<h3 id="冒泡排序的优化"><a href="#冒泡排序的优化" class="headerlink" title="冒泡排序的优化"></a>冒泡排序的优化</h3><p>在刚才描述的排序中，仍以【5,8,6,3,9,2,1,7】为例，当算法分别执行到第6、7轮时，数组状态如下：</p>
<p>【1，2，3，4，5，6，7，8，9】这是第6轮的。</p>
<p>第7轮：【1，2，3，4，5，6，7，8，9】。</p>
<p>在第6轮中整个数组就已经是有序的了，可算法还是执行了第7轮排序。</p>
<p>如果能够判断出数列已经有序，并做出标记，那么剩下的几轮排序就不必执行，可以提前结束。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> algs;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">bubblesort1</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lastExchangeIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sortBorder = array.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;array.length-<span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">boolean</span> isSorted = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;sortBorder; j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(array[j]&gt;array[j+<span class="number">1</span>])&#123;</span><br><span class="line">                    tmp = array[j];</span><br><span class="line">                    array[j] = array[j+<span class="number">1</span>];</span><br><span class="line">                    array[j+<span class="number">1</span>] = tmp;</span><br><span class="line">                    isSorted = <span class="keyword">false</span>;</span><br><span class="line">                    lastExchangeIndex = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            sortBorder = lastExchangeIndex;</span><br><span class="line">            <span class="keyword">if</span>(isSorted)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">7</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">46</span>,<span class="number">94</span>,<span class="number">84</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">46</span>,<span class="number">5</span>,<span class="number">45</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        sort(array);</span><br><span class="line">        System.out.println(Arrays.toString(array));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[3, 4, 5, 5, 6, 7, 8, 45, 46, 46, 84, 94]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>快速排序在每一轮中挑选一个基准元素，并让其它比它大的元素移动到数列的一边，比它小的元素移动到另一边，从而把数列拆解成两个部分。这叫分而治之。</p>
<p>每一轮的比较和交换，需要把数组全部元素都遍历一遍，时间复杂度为O(n)，这样下来平均需要logn轮，因此快速排序的总体的平均时间复杂度为O(nlogn)。</p>
<ul>
<li><p>基准元素的选择</p>
<p>基准元素（pivot），在分治过程中，以基准为中心，把其他基准元素移动到它左右两边。</p>
<p>那如何选择基准元素呢？</p>
<p>最简单的方式就是选择数列的第一个元素。但是这种方式在一些特殊情况下优点麻烦，所以这种方式还是不好。</p>
<p>为了尽量避开这种麻烦。在选择基准元素时，可随机选择一个元素作为基准元素，并且让基准元素和数列的首位元素交换位置。</p>
</li>
<li><p>元素的交换</p>
<p>元素的交换方式有两种：</p>
<p>1.双边循环法</p>
<p>如下图中数列：要求对其从小到大进行排序</p>
<p><img src="C:%5CUsers%5C%E6%9D%A8%5CDesktop%5Clist.png" alt=""></p>
<p><strong>首先，选定基准元素pivot，并且设置两个指针left和right，指向数列的最左和最右两个元素。</strong></p>
<p><strong>接下来进行第一次循环，从right指针开始，让指针所指向的元素和基准元素做比较。如果大于或等于pivot，则指针向左移动，如果小于pivot，则right指针停止移动，切换到left指针。</strong></p>
<p><strong>到了left指针移动，让指针所指向的元素和基准元素做比较，如果小于或等于pivot，则指针向右移动，让left和right指针所指向的元素进行交换。如果大于pivot，则left指针停止移动。</strong></p>
<p><img src="C:%5CUsers%5C%E6%9D%A8%5CDesktop%5C2.jpg" alt=""></p>
</li>
</ul>
<p>  2.单边循环法</p>
<p>  首先选定基准元素pivot。同时，设置一个mark指针指向数列的起始位置，这个mark指针代表小于基准元素的区域的边界。</p>
<p>  <img src="C:%5CUsers%5C%E6%9D%A8%5CDesktop%5Clist2.png" alt=""></p>
<p>  接下来，从基准元素的下一个位置开始遍历数组。</p>
<p>  如果遍历到的元素大于基准元素，就继续向后遍历。</p>
<p>  如果遍历到的元素小于基准元素，则需要做两件事：第一，把mark指针右移1位，因为小于pivot的区域边界增大了1，第二，让最新遍历到的元素和mark指针所在的位置的元素交换位置，因为最新遍历的元素归属于小于pivot的区域。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> algs;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">quicksort2</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> startIndex,<span class="keyword">int</span> endIndex)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(startIndex &gt;= endIndex)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> partition = partition(arr,startIndex,endIndex);</span><br><span class="line">        quickSort(arr,startIndex,partition-<span class="number">1</span>);</span><br><span class="line">        quickSort(arr,partition+<span class="number">1</span>,endIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[]arr,<span class="keyword">int</span> startIndex,<span class="keyword">int</span> endIndex)</span></span>&#123;        </span><br><span class="line">        <span class="keyword">int</span> pivot = arr[startIndex];</span><br><span class="line">        <span class="keyword">int</span> mark = startIndex;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = startIndex+<span class="number">1</span>;i&lt;=endIndex;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i]&lt;pivot)&#123;</span><br><span class="line">                mark++;</span><br><span class="line">                <span class="keyword">int</span> tmp = arr[mark];</span><br><span class="line">                arr[mark] = arr[i];</span><br><span class="line">                arr[i] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后把pivot元素交换到mark指针所在位置</span></span><br><span class="line">        arr[startIndex] = arr[mark];</span><br><span class="line">        arr[mark] = pivot;</span><br><span class="line">        <span class="keyword">return</span> mark;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> arr[] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">4</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        quickSort(arr,<span class="number">0</span>,arr.length-<span class="number">1</span>);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  <img src="C:%5CUsers%5C%E6%9D%A8%5CDesktop%5Cl.png" alt=""></p>
<p>  3.非递归实现</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> algs;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">quicksort3</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> startIndex,<span class="keyword">int</span> endIndex)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 用一个集合栈来代替递归函数栈</span></span><br><span class="line">        Stack&lt;Map&lt;String,Integer&gt;&gt; quickSortStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="comment">// 整个数列的起始下标，以哈希的形式入栈</span></span><br><span class="line">        Map&lt;String,Integer&gt; rootparam = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        rootparam.put(<span class="string">"startIndex"</span>,startIndex);</span><br><span class="line">        rootparam.put(<span class="string">"endIndex"</span>,endIndex);</span><br><span class="line">        quickSortStack.push(rootparam);</span><br><span class="line">        <span class="comment">// 循环结束条件：栈为空时</span></span><br><span class="line">        <span class="keyword">while</span>(!quickSortStack.isEmpty())&#123;</span><br><span class="line">            <span class="comment">// 栈顶元素出栈，得到起始下标</span></span><br><span class="line">            Map&lt;String,Integer&gt; param = quickSortStack.pop();</span><br><span class="line">            <span class="comment">// 得到基准元素位置</span></span><br><span class="line">            <span class="keyword">int</span> pivotIndex = partition(arr,param.get(<span class="string">"startIndex"</span>),param.get(<span class="string">"endIndex"</span>));        </span><br><span class="line">            <span class="comment">// 根据基准元素分成两部分，把每个部分的起始下标入栈</span></span><br><span class="line">            <span class="keyword">if</span>(param.get(<span class="string">"startIndex"</span>) &lt; pivotIndex-<span class="number">1</span>)&#123;</span><br><span class="line">                Map&lt;String,Integer&gt; leftparam = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">                leftparam.put(<span class="string">"startIndex"</span>,param.get(<span class="string">"startIndex"</span>));</span><br><span class="line">                leftparam.put(<span class="string">"endIndex"</span>,pivotIndex-<span class="number">1</span>);</span><br><span class="line">                quickSortStack.push(leftparam);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(pivotIndex+<span class="number">1</span> &lt; param.get(<span class="string">"endIndex"</span>))&#123;</span><br><span class="line">                Map&lt;String,Integer&gt; rightParam = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">                rightParam.put(<span class="string">"startIndex"</span>,pivotIndex+<span class="number">1</span>);</span><br><span class="line">                rightParam.put(<span class="string">"endIndex"</span>,param.get(<span class="string">"endIndex"</span>));</span><br><span class="line">                quickSortStack.push(rightParam);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[]arr,<span class="keyword">int</span> startIndex,<span class="keyword">int</span> endIndex)</span></span>&#123;        </span><br><span class="line">        <span class="keyword">int</span> pivot = arr[startIndex];</span><br><span class="line">        <span class="keyword">int</span> mark = startIndex;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = startIndex+<span class="number">1</span>;i&lt;=endIndex;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i]&lt;pivot)&#123;</span><br><span class="line">                mark++;</span><br><span class="line">                <span class="keyword">int</span> tmp = arr[mark];</span><br><span class="line">                arr[mark] = arr[i];</span><br><span class="line">                arr[i] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后把pivot元素交换到mark指针所在位置</span></span><br><span class="line">        arr[startIndex] = arr[mark];</span><br><span class="line">        arr[mark] = pivot;</span><br><span class="line">        <span class="keyword">return</span> mark;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> arr[] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">4</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">68</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">54</span>&#125;;</span><br><span class="line">        quickSort(arr,<span class="number">0</span>,arr.length-<span class="number">1</span>);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[1, 2, 3, 4, 4, 5, 6, 8, 9, 54, 68]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>浅尝算法</title>
    <url>/2020/02/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><p>根据时间复杂度的不同，主流的排序算法分为3大类</p>
<p><strong>时间复杂度为O(n[^^]2)的排序算法</strong></p>
<ul>
<li>排序算法</li>
<li>选择排序</li>
<li>插入排序</li>
<li>希尔排序</li>
</ul>
<p><strong>时间复杂度为O(nlogn)的排序算法</strong></p>
<ul>
<li>快速排序</li>
<li>归并排序</li>
<li>堆排序</li>
</ul>
<p><strong>时间复杂度为线性的排序算法</strong></p>
<ul>
<li>计数排序</li>
<li>桶排序</li>
<li>基数排序</li>
</ul>
<h3 id="冒泡排序-bubble-sort"><a href="#冒泡排序-bubble-sort" class="headerlink" title="冒泡排序(bubble sort)"></a>冒泡排序(bubble sort)</h3><p>冒泡排序的思想就是把相邻的元素进行两两比较，当一个元素大于右侧相邻的元素时，交换它们的位置；当一个元素小于或等于右侧相邻元素时，位置不变。</p>
<p>冒泡排序是一种稳定的排序，值相等的元素并不会打乱原本的排序。由于该排序算法的每一轮都会遍历所有元素，总共遍历(元素数量-1)轮，所以平均时间复杂度为O(n[^^]2)。</p>
<p><code>代码实现</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">bubblesort</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;array.length-i-<span class="number">1</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(array[j]&gt;array[j+<span class="number">1</span>])&#123;</span><br><span class="line">                    tmp = array[j];</span><br><span class="line">                    array[j] = array[j+<span class="number">1</span>];</span><br><span class="line">                    array[j+<span class="number">1</span>] = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">7</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">46</span>,<span class="number">94</span>,<span class="number">84</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">46</span>,<span class="number">5</span>,<span class="number">45</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        sort(array);</span><br><span class="line">        System.out.println(Arrays.toString(array));</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        输出:</span></span><br><span class="line"><span class="comment">        &gt;[3, 4, 5, 5, 6, 7, 8, 45, 46, 46, 84, 94]</span></span><br><span class="line"><span class="comment">        **/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码使用双循环进行排序，外部循环控制所有的回合，内部循环实现每一轮的冒泡处理，进行元素比较，在进行元素排</p>
<h4 id="算法优化"><a href="#算法优化" class="headerlink" title="算法优化"></a>算法优化</h4>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构基础</title>
    <url>/2020/02/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>  数据结构是算法的基石，是数据的组织、管理、存储形式，请使用的目的是为了访问和修改数据。数据结构的组成形式有：线性结构、树、图、其他数据结构（这个后面会缀述）</p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><ul>
<li><p>数组是有限个相同类型的变量所组成的有序集合，数组中的每个变量称为元素。</p>
<h4 id="数组的基本操作"><a href="#数组的基本操作" class="headerlink" title="数组的基本操作"></a>数组的基本操作</h4></li>
<li><p>读取元素：读取元素，只需要给出一个数组的下标，就可以读取相应的数组元素。这种根据下标读取的元素的方式称为随机读取。</p>
</li>
<li><p>更新元素：把一个元素的值替换成为一个新值，利用数组下标，把新值赋给该元素。</p>
</li>
<li><p>插入元素：插入数组元素的有三种：尾部插入、中间插入、超范围插入。</p>
<p>中间插入复杂些，因为数组的每个元素都有固定的下标，所以需要把插入位置及以后的元素向后移动，再把插入的元素放到对应的数组位置上。</p>
<p>超范围插入：超范围插入涉及到扩容，可以创建一个新数组，长度是旧数组的2倍，再把旧数组中的元素复制给新数组，就是实现了数组的扩容。</p>
</li>
<li><p>删除元素：数组的删除操作，如果删除的元素位于数组的中间，其后的元素都需要向前（也就是向左移动一位）</p>
<h4 id="数组的优点和缺点"><a href="#数组的优点和缺点" class="headerlink" title="数组的优点和缺点"></a>数组的优点和缺点</h4><p>数组的优点是拥有高效的随机访问能力。数组的缺点在插入和删除元素方面，由于数组元素连续紧密的存储在内存中，插入和删除元素会导致大量元素移动。数组适合读多写少的应用场景。</p>
</li>
</ul>
<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>  <strong>链表</strong>是一种在物理上非连续、非顺序的数据结构，由若干节点所组成。单向链表的每个节点包含两部分，一部分是存放数据的变量<strong>data</strong>，一部分是指向下一个节点的指针<strong>next</strong>。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> data;</span><br><span class="line">	Node next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  双向链表比单项链表多了指向前置节点的<strong>prev</strong>指针</p>
<p>  链表在内存中的存储方式是随机存储</p>
<h4 id="链表的基本操作"><a href="#链表的基本操作" class="headerlink" title="链表的基本操作"></a>链表的基本操作</h4><ul>
<li><p>查找节点：</p>
<p>链表查找节点时只能从头节点开始向后逐个查找。</p>
</li>
<li><p>更新节点：</p>
<p>链表的更新过程会像数组那样，直接把旧数据替换成新数据即可</p>
</li>
<li><p>插入节点：</p>
<p>尾部插入：把最后一个节点的next指针指向新插入的节点即可。</p>
<p>头部插入：把新节点的next节点的指针原先的头节点，把新节点变成链表的头节点</p>
<p>中间插入：把新节点的next指针指向插入位置的节点，插入位置前置节点的next指针指向新节点。</p>
</li>
<li><p>删除元素：</p>
<p>尾部删除：把倒数第二个节点的next指针指向空即可</p>
<p>头部删除：把链表的头节点设为原先头节点的next指针即可</p>
<p>中间删除：把要删除的节点的前置节点的next指针，指向要删除元素的下一个节点即可</p>
</li>
</ul>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLinkedList</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node head;</span><br><span class="line">    <span class="keyword">private</span> Node last;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> data,<span class="keyword">int</span> index)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt; size)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"Index outfound"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Node insertedNode = <span class="keyword">new</span> Node(data);</span><br><span class="line">        <span class="keyword">if</span>(size == <span class="number">0</span>)&#123;</span><br><span class="line">            head = insertedNode;</span><br><span class="line">            last = insertedNode;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(index == <span class="number">0</span>)&#123;</span><br><span class="line">            insertedNode.next = head;</span><br><span class="line">            head = insertedNode;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(size == index)&#123;</span><br><span class="line">            last.next = insertedNode;</span><br><span class="line">            last = insertedNode;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            Node prevNode = get(index-<span class="number">1</span>);</span><br><span class="line">            insertedNode.next = prevNode.next;</span><br><span class="line">            prevNode.next = insertedNode;</span><br><span class="line">        &#125;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt;= size)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"数组越界"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Node temp = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;index;i++)&#123;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">output</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Node temp = head;</span><br><span class="line">        <span class="keyword">while</span>(temp != <span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(temp.data);</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"size："</span>+size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span>|| index &gt;= size)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"下标越界"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Node removeNode = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(index == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 删除头结点</span></span><br><span class="line">            removeNode = head;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(index == size-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">// 删除尾节点</span></span><br><span class="line">            Node prevNode = get(index-<span class="number">1</span>);</span><br><span class="line">            removeNode = prevNode.next;</span><br><span class="line">            prevNode.next = <span class="keyword">null</span>;</span><br><span class="line">            last = prevNode;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 删除中间节点</span></span><br><span class="line">            Node prevNode = get(index-<span class="number">1</span>);</span><br><span class="line">            Node nextNode = prevNode.next.next;</span><br><span class="line">            removeNode = prevNode.next;</span><br><span class="line">            prevNode.next = nextNode;</span><br><span class="line">        &#125;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> removeNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> data;</span><br><span class="line">        Node next;</span><br><span class="line">        Node(<span class="keyword">int</span> data)&#123;</span><br><span class="line">            <span class="keyword">this</span>.data = data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        MyLinkedList myLinkedList = <span class="keyword">new</span> MyLinkedList();</span><br><span class="line">        myLinkedList.insert(<span class="number">3</span>,<span class="number">0</span>);</span><br><span class="line">        myLinkedList.insert(<span class="number">7</span>,<span class="number">1</span>);</span><br><span class="line">        myLinkedList.insert(<span class="number">9</span>,<span class="number">2</span>);</span><br><span class="line">        myLinkedList.insert(<span class="number">5</span>,<span class="number">3</span>);</span><br><span class="line">        myLinkedList.insert(<span class="number">6</span>,<span class="number">1</span>);</span><br><span class="line">        myLinkedList.remove(<span class="number">0</span>);</span><br><span class="line">        myLinkedList.output();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数组和链表的比较：</p>
<table>
<thead>
<tr>
<th></th>
<th>查找</th>
<th>更新</th>
<th>插入</th>
<th>删除</th>
</tr>
</thead>
<tbody><tr>
<td>数组</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>链表</td>
<td>O(n)</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
</tbody></table>
<p>对于读操作多写操作少的应用场景数组适合一些，对于需要频繁插入数据删除数据来说，链表合适一些</p>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>栈是一种线性数据结构，栈中的元素只能先入后出。最早进入的元素存放的位置叫作栈底，最后进入的元素存放的位置叫作栈顶。</p>
<h4 id="栈的基本操作"><a href="#栈的基本操作" class="headerlink" title="栈的基本操作"></a>栈的基本操作</h4><ul>
<li><p>入栈(push)</p>
<p>入栈操作就是把新元素放入栈中，只允许从栈顶一侧放入元素，新元素的位置将会成为新的栈顶</p>
</li>
<li><p>出栈(pop)</p>
<p>出栈操作是把元素从栈中弹出，只有栈顶元素才能允许出栈，出栈元素的前一个元素将会成为新的栈顶。</p>
</li>
</ul>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyStack</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] stack;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStack</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.stack = <span class="keyword">new</span> <span class="keyword">int</span>[capacity];</span><br><span class="line">        <span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> elem)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(size &gt; stack.length)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"数组越界"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        stack[size] = elem;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(size &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"栈为空"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> stack[size];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">output</span><span class="params">()</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"栈顶："</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = size-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            System.out.println(pop());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"栈底："</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        MyStack stack = <span class="keyword">new</span> MyStack(<span class="number">5</span>);</span><br><span class="line">        stack.push(<span class="number">5</span>);</span><br><span class="line">        stack.push(<span class="number">6</span>);</span><br><span class="line">        stack.push(<span class="number">52</span>);</span><br><span class="line">        System.out.println(stack.pop());</span><br><span class="line">        <span class="comment">// stack.output();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p><strong>队列</strong>是一种线性数据结构，队列中的元素只能先入后出，对列的出口端叫作<strong>队头</strong>(front)，队列的入口端叫作<strong>队尾</strong>(rear)。</p>
<h4 id="队列的基本操作"><a href="#队列的基本操作" class="headerlink" title="队列的基本操作"></a>队列的基本操作</h4><ul>
<li><p>入队（enqueue）</p>
<p>入队操作（enqueue）就是把新元素放入队列中，只允许在队尾的位置放入元素，新元素的下一个位置将会成为新的对尾。</p>
</li>
<li><p>出队（dequeue）</p>
<p>出队操作就是把元素移出队列，只允许在队头一侧移出元素，出队元素的后一个元素将会成为队头。</p>
</li>
</ul>
<p><strong>循环队列</strong>：在数组不做扩容的前提下，可以利用已出队元素留下的空间，让队尾指针重新指回数组的首位。<strong>一直到(队尾下标+1)%数组长度 = 队头下标，表示此队列已经满</strong>，队尾指针指向的位置永远空出1位，所以队列最大容量比数组长度小1。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] array;</span><br><span class="line">    <span class="comment">// 队头</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> front;</span><br><span class="line">    <span class="comment">// 队尾</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> rear;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.array = <span class="keyword">new</span> <span class="keyword">int</span>[capacity];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    入队操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(<span class="keyword">int</span> elem)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>((rear+<span class="number">1</span>)%array.length == front)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"队列已满"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        array[rear] = elem;</span><br><span class="line">        rear = (rear+<span class="number">1</span>)%array.length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dequeue</span><span class="params">()</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(rear==front)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"队列已空"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> dequeueElem = array[front];</span><br><span class="line">        front = (front+<span class="number">1</span>)%array.length;</span><br><span class="line">        <span class="keyword">return</span> dequeueElem;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">output</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = front;i!=rear;i=(i+<span class="number">1</span>)%array.length)&#123;</span><br><span class="line">            System.out.println(array[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        MyQueue queue = <span class="keyword">new</span> MyQueue(<span class="number">5</span>);</span><br><span class="line">        queue.enqueue(<span class="number">5</span>);</span><br><span class="line">        queue.enqueue(<span class="number">4</span>);</span><br><span class="line">        queue.enqueue(<span class="number">6</span>);</span><br><span class="line">        queue.enqueue(<span class="number">5</span>);</span><br><span class="line">        queue.output();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="栈和队列的应用"><a href="#栈和队列的应用" class="headerlink" title="栈和队列的应用"></a>栈和队列的应用</h3><p>栈的输出顺序和输入顺序相反，所以栈通常用于对“历史”的回溯，也就是逆流而上追溯“历史”。<br>例如实现递归的逻辑，就可以用栈来代替，因为栈可以回溯方法的调用链。</p>
<p>队列的输出顺序和输入顺序相同，所以队列通常用于对“历史”的回放，也就是按照“历史”顺序，把“历<br>史”重演一遍。<br>例如在多线程中，争夺公平锁的等待队列，就是按照访问顺序来决定线程在队列中的次序的。</p>
<h3 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h3><p>散列表也叫<strong>哈希表(hash table)</strong>，散列表在本质上也是一个数组。这种数据结构提供了键值对的映射关系。只要给出Key，就可以查找出它所匹配的Value，时间复杂度接近O(1)。</p>
<h4 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h4><p>在不同的编程语言中，哈希函数的实现也不一样，这里以Java为例，在Java及大多数面向对象编程语言中，每个对象都有自己的hashcode，hashcode是区分不同对象的重要标识，无论对象的自身类型是什么，它们的hashcode都是一个整型变量。最简单的转化方式是按照数组长度进行取模运算。</p>
<p><strong>index = HashCode(Key)%Array.length</strong></p>
<p>通过哈希函数，可以把字符串或其他类型的Key转化为数组的下标index。</p>
<h4 id="散列表的读写操作"><a href="#散列表的读写操作" class="headerlink" title="散列表的读写操作"></a>散列表的读写操作</h4><ul>
<li><p>写操作（put）</p>
<p>写操作就是在散列表中插入新的键值对，通过哈希函数，把Key转化为数组下标，如果数组下标没有对应的元素，就把这个Entry填充到数组下标的相应位置。由于数组的长度有限，当插入的Entry越来越多时，不同的Key通过哈希函数获得的下标也有可能相同，所以这就造成了哈希冲突。哈希冲突是无法避免的。解决哈希冲突的方法有两中；一种是开放寻址法，一种是链表法。在Java中开放寻址法用于ThreadLocal。HashMap使用的是链表法解决哈希冲突问题。HashMap数组的每个元素不仅是一个Entry对象，还是一个链表的头节点，每个Entry对象通过next指针指向它的下一个Entry节点。当新来的Entry映射到与之冲突的数组位置时，只需要插入到对应的链表中即可。</p>
</li>
<li><p>读操作（get）</p>
<p>读操作就是通过给定的Key，在散列表中查找对应的Value。通过哈希函数，把Key转化为数组的下标。找到数组下标对应的元素，如果找到了这个元素就返回对应数组的值；如果找不到就顺着这个数组的元素的链表往下找，是否能够找到与之对匹配的节点。</p>
</li>
<li><p>扩容（resize）</p>
<p>当经过多次元素插入，散列表达到一定的饱和时，key映射的位置发生冲突的几率会增加。大量的元素拥挤在相同的数组下标位置下，会形成很长的链表。对于后续的插入操作和查询操作的性能都有很大的影响，这时就需要扩容了。</p>
<p>散列表的扩容操作</p>
<ul>
<li>扩容，创建一个新的Entry空数组，长度为元素的两倍。</li>
<li>重新hash，遍历原Entry数组，把所有的Entry重新Hash到新数组中，因为长度扩容后，Hash的规则也随之变化。</li>
</ul>
<p>用Java中的散列表实现类HashMap为例，影响扩容的因素有两个：</p>
<p>Capacity：散列表的当前长度</p>
<p>LoadFactor：散列表的负载因子，默认值为0.75f</p>
<p>衡量HashMap需要扩容的条件如下：</p>
<p>HashMap.size &gt;= Capacity*LoadFactor</p>
</li>
</ul>
<h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><p>树（tree）是n（n&gt;=0）个节点的有限集。当n=0时，称为空树。在任意一个非空树中，有下面两个特点。</p>
<ul>
<li>有且仅有一个特定的称为根的节点。</li>
<li>当n&gt;1时，其余的节点可分为m（m&gt;0）个互不相交的有限集，每个集合本身又是一个树，并称为根的子树。</li>
</ul>
<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>二叉树是树的一种特殊形式。这种树结构的每个节点最多有2个子节点，也可能只有1个，或者没有孩子节点。二叉树的两个孩子节点，一个称为左孩子节点(left child)，一个称为右孩子节点（right child）,这两个孩子节点的顺序是固定的，不能够颠倒。</p>
<p>二叉树还有两种特殊的形式，一个叫作满二叉树，一个叫完全二叉树。</p>
<h4 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h4><p><strong>是一个二叉树的所有非叶子节点都存在左右节点，并且所有叶子节点都在同一层级上，那么这个树就是满二叉树。</strong>也就是说满二叉树的每个分支都是满的。</p>
<h4 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h4><p><strong>对一个有n个节点的二叉树，按层级顺序编号，则所有节点的编号为从1到n。如果这个树所有节点和同样深度的满二叉树的编号为从1到n的节点位置相同，则这个二叉树为完全二叉树。</strong></p>
<h4 id="二叉树的物理存储结构"><a href="#二叉树的物理存储结构" class="headerlink" title="二叉树的物理存储结构"></a>二叉树的物理存储结构</h4><ul>
<li><p>链式存储结构</p>
<p>链式存储结构的二叉树每个节点包含3部分：存储数据的data变量、指向左孩子的left指针、指向右孩子的right指针。</p>
</li>
<li><p>数组</p>
<p>使用数组存储，会按照层级顺序把二叉树的节点放到数组中对应的位置上。如果某个节点的左孩子或右孩子，则数组的相应位置也空出来。这样就可以更方便地在数组中定位二叉树的孩子节点和父节点。</p>
<p>假设一个父节点的下标是parent，那么它的左孩子的节点下标就是：<strong>leftchild=2*parent+1</strong>；右孩子节点下标就是：<strong>rightchild=2*parent+2</strong>。</p>
</li>
</ul>
<h4 id="二叉树的应用"><a href="#二叉树的应用" class="headerlink" title="二叉树的应用"></a>二叉树的应用</h4><ul>
<li><p>查找</p>
<p>将二叉树用作查找，有一种特殊的二叉树：二叉查找树（binary search tree）这种二叉树主要作用就是进行查找操作。</p>
<p>二叉查找树在二叉树的基础上增加了一下几个条件：</p>
<ul>
<li>如果左子树不为空，则左子树上所有节点的值均小于根节点的值。</li>
<li>如果右子树不为空，则右子树上所有节点的值均大于根节点的值。</li>
<li>左，右子树也都是二叉查找树。</li>
</ul>
<p>对于一个节点分布相对均衡的二叉查找树来说，如果节点总数是n，那么搜索节点的时间复杂度就是O(logn)，和树的深度一样。</p>
</li>
<li><p>维持相对顺序</p>
<p>二叉查找树要求左子树小于父节点，右子树大于父节点，这样就保证了二叉树的有序性。所有二叉树查找树还有一个名字——二叉排序树</p>
</li>
</ul>
<h4 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h4><p>从宏观的角度看，二叉树的遍历分为两大类：</p>
<p>深度优先遍历（前序遍历、中序遍历、后序遍历）。</p>
<ul>
<li><p>二叉树的遍历方式：二叉树的遍历有4种</p>
<ul>
<li><p>前序遍历</p>
<p>二叉树的前序遍历，输出的顺序是根节点、左子树、右子树。</p>
</li>
<li><p>中序遍历</p>
<p>二叉树的中序遍历，输出的顺序是左子树、根节点、右子树。</p>
</li>
<li><p>后序遍历</p>
<p>二叉树的后序遍历，输出的顺序是左子树、右子树、根节点。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line">  <span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">createBinaryTree</span><span class="params">(LinkedList&lt;Integer&gt; inputList)</span></span>&#123;</span><br><span class="line">          TreeNode node = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(inputList == <span class="keyword">null</span> || inputList.isEmpty())&#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          Integer data = inputList.removeFirst();</span><br><span class="line">          <span class="keyword">if</span>(data != <span class="keyword">null</span>)&#123;</span><br><span class="line">              node = <span class="keyword">new</span> TreeNode(data);</span><br><span class="line">              node.leftchild = createBinaryTree(inputList);</span><br><span class="line">              node.rightchild = createBinaryTree(inputList);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> node;        </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">      二叉树遍历</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">  </span><br><span class="line">      <span class="comment">/**前序遍历 */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrderTraverla</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">          <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          System.out.println(node.data);</span><br><span class="line">          preOrderTraverla(node.leftchild);</span><br><span class="line">          preOrderTraverla(node.rightchild);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/**中序遍历 */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inOrderTraveral</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">          <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          inOrderTraveral(node.leftchild);</span><br><span class="line">          System.out.println(node.data);</span><br><span class="line">          inOrderTraveral(node.rightchild);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/**后序遍历 */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">postOrderTraveral</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">          <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          postOrderTraveral(node.leftchild);</span><br><span class="line">          postOrderTraveral(node.rightchild);</span><br><span class="line">          System.out.println(node.data);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 树节点</span></span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span></span>&#123;</span><br><span class="line">          <span class="keyword">int</span> data;</span><br><span class="line">          TreeNode leftchild;</span><br><span class="line">          TreeNode rightchild;</span><br><span class="line">          TreeNode(<span class="keyword">int</span> data)&#123;</span><br><span class="line">              <span class="keyword">this</span>.data = data;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 利用栈来实现前序遍历</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrderTraverlaWithStack</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">          Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">          TreeNode treeNode = node;</span><br><span class="line">          <span class="keyword">while</span>(treeNode != <span class="keyword">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">              <span class="comment">// 迭代访问节点的左孩子，并入栈</span></span><br><span class="line">              <span class="keyword">while</span>(treeNode != <span class="keyword">null</span>)&#123;</span><br><span class="line">                  System.out.println(treeNode.data);</span><br><span class="line">                  stack.push(treeNode);</span><br><span class="line">                  treeNode = treeNode.leftchild;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">// 如果节点没有左孩纸，这弹出栈顶节点，访问节点右孩子</span></span><br><span class="line">              <span class="keyword">if</span>(!stack.isEmpty())&#123;</span><br><span class="line">                  treeNode = stack.pop();</span><br><span class="line">                  treeNode = treeNode.rightchild;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">          LinkedList&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;(Arrays.asList(<span class="keyword">new</span> Integer[]&#123;<span class="number">32</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="number">10</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="number">8</span>,<span class="keyword">null</span>,<span class="number">4</span>&#125;));</span><br><span class="line">          TreeNode tree = createBinaryTree(list);</span><br><span class="line">          System.out.println(<span class="string">"前序遍历(栈实现)"</span>);</span><br><span class="line">          <span class="comment">// preOrderTraverla(tree);</span></span><br><span class="line">          preOrderTraverlaWithStack(tree);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>广度优先遍历（层序遍历）。</p>
<ul>
<li><p>层序遍历</p>
<p>层序遍历就是按照二叉树从根节点到叶子节点的层次关系，一层一层横向遍历的各个节点。</p>
</li>
</ul>
</li>
</ul>
<h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><pre><code><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">levelOrderTraversal</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            System.out.println(node.data);</span><br><span class="line">            <span class="keyword">if</span>(node.leftchild != <span class="keyword">null</span>)&#123;</span><br><span class="line">                queue.offer(node.leftchild);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node.rightchild!= <span class="keyword">null</span>)&#123;</span><br><span class="line">                queue.offer(node.rightchild);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></code></pre><h2 id="二叉堆"><a href="#二叉堆" class="headerlink" title="二叉堆"></a>二叉堆</h2><p><strong>二叉堆</strong>本质上就是一种完全二叉树，分为<strong>最大堆</strong>和<strong>最小堆</strong>两类。最大堆的任何一个父节点的值都大于或等于它左右孩子节点的值。最小堆的任何一个父节点的值都小于或等于它左右孩子节点的值。二叉堆的根节点叫作堆顶。最大堆的堆顶是整个堆中的最大的元素；最小堆的堆顶是整个堆中的最小元素。</p>
<ul>
<li><p>二叉堆的特性</p>
<p>最大堆的堆顶是整个堆中的最大元素。</p>
<p>最小堆的堆顶是整个堆中的最小元素。</p>
</li>
</ul>
<h4 id="二叉堆的自我调整"><a href="#二叉堆的自我调整" class="headerlink" title="二叉堆的自我调整"></a>二叉堆的自我调整</h4><ul>
<li><p>插入元素</p>
<p>当二叉堆插入节点时，插入位置是完全二叉树的最后一个位置。</p>
</li>
<li><p>删除元素</p>
<p>二叉堆删除的节点是删除处于堆顶的节点。</p>
</li>
<li><p>构建二叉堆</p>
<p>构建二叉堆，就是把一个无序的完全二叉树调整为二叉堆，本质是让所有非叶子节点依次</p>
<p>“下沉”</p>
</li>
</ul>
<p>堆的插入、删除、构建操作的时间复杂度：</p>
<p>堆的插入操作是单一节点的“上浮”，堆的删除操作是单一节点的“下沉”，两个操作是的平均交换次数都是堆高度的一半，时间复杂度是O(logn)，堆的构建，需要所有非叶子节点依次“下沉”，时间复杂度是O(n)</p>
<h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHeap</span></span>&#123;</span><br><span class="line">    <span class="comment">// “上浮”调整</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">upAdjust</span><span class="params">(<span class="keyword">int</span> [] arr)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 假设找出最后一个元素节点(也就是叶子节点)。用于推导出其父节点</span></span><br><span class="line">        <span class="keyword">int</span> childIndex = arr.length-<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 根据左孩子节点（叶子节点）算出父节点。</span></span><br><span class="line">        <span class="keyword">int</span> parentIndex = (childIndex-<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 设置临时节点，用于保存插入叶子节点值，用于最后的赋值</span></span><br><span class="line">        <span class="keyword">int</span> temp = arr[childIndex];</span><br><span class="line">        <span class="keyword">while</span>(childIndex &gt; <span class="number">0</span> &amp;&amp; temp &lt; arr[parentIndex])&#123;</span><br><span class="line">            arr[childIndex] = arr[parentIndex];</span><br><span class="line">            childIndex = parentIndex;</span><br><span class="line">            parentIndex = (parentIndex-<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[childIndex] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">downAdjust</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">int</span> parentIndex,<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 用于保存父节点的值，最后赋值</span></span><br><span class="line">        <span class="keyword">int</span> temp = array[parentIndex];</span><br><span class="line">        <span class="keyword">int</span> childIndex = (<span class="number">2</span>*parentIndex)+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(childIndex &lt; length)&#123;</span><br><span class="line">            <span class="comment">// 如果有右孩子，且右孩子小于左孩子的值，则定位到右孩子</span></span><br><span class="line">            <span class="keyword">if</span>(childIndex+<span class="number">1</span> &lt; length &amp;&amp; array[childIndex+<span class="number">1</span>] &lt; array[childIndex])&#123;</span><br><span class="line">                childIndex++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果父节点小于任何一个孩子的值，直接跳出</span></span><br><span class="line">            <span class="keyword">if</span>(temp &lt;= array[childIndex])&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            array[parentIndex] = array[childIndex];</span><br><span class="line">            parentIndex = childIndex;</span><br><span class="line">            childIndex = (<span class="number">2</span>*childIndex)+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        array[parentIndex] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildHeap</span><span class="params">(<span class="keyword">int</span>[]array)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 从最后一个非叶子节点开始，依次做“下沉”调整</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = (array.length-<span class="number">2</span>)/<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            downAdjust(array,i,array.length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        upAdjust(array);</span><br><span class="line">        System.out.println(Arrays.toString(array));</span><br><span class="line">        array = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">7</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">10</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">6</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        buildHeap(array);</span><br><span class="line">        System.out.println(Arrays.toString(array));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h2><p>优先队列是基于二叉堆来实现的，优先队列不再遵循先进先出原则，而是分为两种情况：</p>
<ul>
<li>最大优先队列，无论入队顺序如何，都是当前最大的元素优先出队</li>
<li>最小优先队列，无论入队顺序如何，都是当前最小的元素优先出队</li>
</ul>
<h4 id="优先队列的实现"><a href="#优先队列的实现" class="headerlink" title="优先队列的实现"></a>优先队列的实现</h4><p>回顾二叉堆的特性可以知道：最大堆的堆顶是整个堆中的最大元素。最小堆的堆顶是整个堆中的最小元素。因此，可以使用最大堆来实现最大优先队列，每一次入队操作都是堆的插入操作，每一次出队操作都是删除堆顶节点。优先队列入队和出队的时间复杂度都是O(logn)。</p>
<h4 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPriorityQueue</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] array; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyPriorityQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 队列的初始长度是32</span></span><br><span class="line">        array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">32</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 入队</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enQueue</span><span class="params">(<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(size &gt;= array.length)&#123;</span><br><span class="line">            resize();</span><br><span class="line">        &#125;</span><br><span class="line">        array[size++] = key;</span><br><span class="line">        upAdjust();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deQueue</span><span class="params">()</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(size &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"这个队列为空"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 堆顶元素</span></span><br><span class="line">        <span class="keyword">int</span> head = array[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 让最后一个元素移动到堆顶</span></span><br><span class="line">        array[<span class="number">0</span>] = array[--size];</span><br><span class="line">        downAdjust();</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 上浮</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">upAdjust</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> childIndex = size-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> parentIndex = (childIndex-<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> temp = array[childIndex];</span><br><span class="line">        <span class="keyword">while</span>(childIndex &gt; <span class="number">0</span> &amp;&amp; temp &gt; array[parentIndex])&#123;</span><br><span class="line">            array[childIndex] = array[parentIndex];</span><br><span class="line">            childIndex = parentIndex;</span><br><span class="line">            parentIndex = parentIndex/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        array[childIndex] = temp;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 下沉</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">downAdjust</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// temp保存父节点的值，用于最后的赋值</span></span><br><span class="line">        <span class="keyword">int</span> parentIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> temp = array[parentIndex];</span><br><span class="line">        <span class="keyword">int</span> childIndex = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(childIndex &lt; size)&#123;</span><br><span class="line">            <span class="comment">// 如果有右孩子，且右孩子大于左孩子的值，则定位到右孩子</span></span><br><span class="line">            <span class="keyword">if</span>(childIndex+<span class="number">1</span> &lt; size &amp;&amp; array[childIndex+<span class="number">1</span>] &gt; array[childIndex])&#123;</span><br><span class="line">                childIndex++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(temp &gt; array[childIndex])&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            array[parentIndex] = array[childIndex];</span><br><span class="line">            parentIndex = childIndex;</span><br><span class="line">            childIndex = <span class="number">2</span>*childIndex+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        array[parentIndex] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> newSize = <span class="keyword">this</span>.size*<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">this</span>.array = Arrays.copyOf(<span class="keyword">this</span>.array,newSize);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        MyPriorityQueue priorityQueue = <span class="keyword">new</span> MyPriorityQueue();</span><br><span class="line">        priorityQueue.enQueue(<span class="number">3</span>);</span><br><span class="line">        priorityQueue.enQueue(<span class="number">5</span>);</span><br><span class="line">        priorityQueue.enQueue(<span class="number">10</span>);</span><br><span class="line">        priorityQueue.enQueue(<span class="number">2</span>);</span><br><span class="line">        priorityQueue.enQueue(<span class="number">7</span>);</span><br><span class="line">        System.out.println(<span class="string">"出队元素："</span>+priorityQueue.deQueue());</span><br><span class="line">        System.out.println(<span class="string">"出队元素："</span>+priorityQueue.deQueue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Git快速入门</title>
    <url>/2020/02/15/git/Git%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<ul>
<li><p>Git安装(Windowns系统为例)</p>
<ul>
<li><p>下载Git软件:</p>
<p>点击链接:<a href="https://git-scm.com/" target="_blank" rel="noopener">https://git-scm.com/</a></p>
<p><img src="https://raw.githubusercontent.com/yangshenghua97/Image/master/git1.png" alt=""></p>
<p>双击！</p>
<p>一路Next！</p>
</li>
</ul>
</li>
<li><h2 id="1-Git命令行"><a href="#1-Git命令行" class="headerlink" title="1 Git命令行"></a>1 Git命令行</h2><p>git简单易用，只要在终端输入$ <code>Git</code>，Git就会不带任何参数输出它的选项和常用的子命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git</span><br><span class="line"><span class="comment">#输入git后会输出一下选项，如果要得到一个完整的git子命令列表，可以输入 git help --all</span></span><br><span class="line">usage: git [--version] [--<span class="built_in">help</span>] [-C &lt;path&gt;] [-c &lt;name&gt;=&lt;value&gt;]</span><br><span class="line">           [--<span class="built_in">exec</span>-path[=&lt;path&gt;]] [--html-path] [--man-path] [--info-path]</span><br><span class="line">           [-p | --paginate | -P | --no-pager] [--no-replace-objects] [--bare]</span><br><span class="line">····················</span><br><span class="line">collaborate (see also: git <span class="built_in">help</span> workflows)</span><br><span class="line">   fetch      Download objects and refs from another repository</span><br><span class="line">   pull       Fetch from and integrate with another repository or a <span class="built_in">local</span> branch</span><br><span class="line">   push       Update remote refs along with associated objects .....</span><br></pre></td></tr></table></figure>

<ul>
<li><h2 id="2-Git使用快速入门"><a href="#2-Git使用快速入门" class="headerlink" title="2 Git使用快速入门"></a>2 Git使用快速入门</h2><ul>
<li><h4 id="2-1创建初始版本库"><a href="#2-1创建初始版本库" class="headerlink" title="2.1创建初始版本库"></a>2.1创建初始版本库</h4><p>首先在git终端下创建一个空文件夹:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#创建空文件夹 test/</span></span><br><span class="line">$ mkdir -p <span class="built_in">test</span>/</span><br><span class="line"><span class="comment">#进入到test文件夹</span></span><br><span class="line">$ <span class="built_in">cd</span> <span class="built_in">test</span>/</span><br><span class="line"><span class="comment">#执行git init命令</span></span><br><span class="line">$ git init</span><br><span class="line">Initialized empty Git repository <span class="keyword">in</span> /root/<span class="built_in">test</span>/.git/</span><br></pre></td></tr></table></figure>

<p>Git不会关心文件夹里是否为空，执行<code>git init</code> 命令创建了一个隐藏目录，在项目目录的顶层有个名为 <code>.git</code>文件夹，Git把所有修订的信息都放在这唯一的顶层目录里</p>
</li>
<li><h4 id="2-2-将文件添加到版本库中"><a href="#2-2-将文件添加到版本库中" class="headerlink" title="2.2 将文件添加到版本库中"></a>2.2 将文件添加到版本库中</h4><p>执行 git init 命令时，Git版本库都是空的，为了管理内容，需要明确的把内容放入版本库中。</p>
<p>使用 <code>git add file</code>[^1] 将file添加到版本库中。</p>
<p>例如:</p>
<p>在 <code>test</code>目录中创建一个文件<code>index.html</code>并把该文件添加到版本库中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> <span class="built_in">test</span>/</span><br><span class="line">$ touch index.html</span><br><span class="line">$ git add index.html</span><br></pre></td></tr></table></figure>

<p>[^1 ]: 如果目录中已经有很多的文件，使用<code>git add .</code>命令让Git把当前的目录及子目录中的文件都添加到版本库中</p>
<p>运行<code>git status</code> 命令显示中间状态的<code>index.html</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">  <span class="comment"># 这个命令显示新文件index.html将在下次提交时添加到版本库中</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><h4 id="2-3-版本库内文件的删除和重命名"><a href="#2-3-版本库内文件的删除和重命名" class="headerlink" title="2.3 版本库内文件的删除和重命名"></a>2.3 版本库内文件的删除和重命名</h4><ul>
<li><h5 id="文件删除"><a href="#文件删除" class="headerlink" title="文件删除"></a>文件删除</h5><p>执行命令 <code>git rm</code>可以删除版本库里不需要的文件</p>
<p>操作如下:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看版本库中的文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git ls-files</span></span><br><span class="line">index.html</span><br></pre></td></tr></table></figure>
<h1 id="执行git-rm-index-html即可删除版本库中的index-html文件"><a href="#执行git-rm-index-html即可删除版本库中的index-html文件" class="headerlink" title="执行git rm index.html即可删除版本库中的index.html文件"></a>执行git rm index.html即可删除版本库中的index.html文件</h1><p>$ git rm index.html</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line">- ##### 文件重命名</span><br><span class="line">  </span><br><span class="line">      在终端执行``git mv srcfile targetfile``即可以完成文件的重命名</span><br><span class="line">      </span><br><span class="line">      例如：</span><br><span class="line">    </span><br><span class="line">      ```<span class="keyword">shell</span></span><br><span class="line">    # 先查看版本库中的文件</span><br><span class="line">      $ git <span class="keyword">ls</span>-<span class="keyword">files</span></span><br><span class="line">    <span class="built_in">index</span>.html</span><br><span class="line">      # 执行git mv <span class="built_in">index</span>.html foo.html 将<span class="built_in">index</span>.html修改为foo.html</span><br><span class="line">    $ git mv <span class="built_in">index</span>.html foo.html</span><br><span class="line">      # 再次查看版本库文件</span><br><span class="line">    $ git <span class="keyword">ls</span>-<span class="keyword">files</span></span><br><span class="line">      foo.html</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>​    </p>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>版本控制管理</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Git提交</title>
    <url>/2020/02/15/git/Git%E6%8F%90%E4%BA%A4/</url>
    <content><![CDATA[<h2 id="吧啦吧啦乱七八遭的东西"><a href="#吧啦吧啦乱七八遭的东西" class="headerlink" title="吧啦吧啦乱七八遭的东西"></a>吧啦吧啦乱七八遭的东西</h2><p>在Git中，提交（commit）是用来记录版本库的变更的。当提交时，Git记录索引的快照并把快照放进对象库（简单的介绍）。提交的快照是串联在一起的，每张新的快照指向它的先驱。随着时间的推移，一系列的变更就表示一系列的提交。</p>
<p>Git提供一种机制来确定相对于另一个引用的提交，通常是分支的头。</p>
<p>在某些Git应用场景中，可能见过诸如这样的提交形式 master^ 。</p>
<p>在同一代提交中，插入符号 ^ 是用来选择不同的父提交。给定一个提交C，C^1 是其第一个父提交，C^2 是其第二个父提交，等等，如图:</p>
<p><img src="https://raw.githubusercontent.com/yangshenghua97/Image/master/commit.jpg" alt=""></p>
<p><img src="https://raw.githubusercontent.com/yangshenghua97/Image/master/commit1.jpg" alt=""></p>
<p>通过把引用与^ 和 ~ 组合，就可从引用的提交历史图中选出任意提交</p>
<h2 id="提交历史记录"><a href="#提交历史记录" class="headerlink" title="提交历史记录"></a>提交历史记录</h2><ul>
<li><p><strong>查看旧提交</strong> </p>
<p>显示提交历史记录的主要命令是 <strong><code>git log</code></strong>,在参数形式上，<strong><code>git log</code></strong>跟<strong><code>git log HEAD</code></strong>是一样的，输出每一个可从HEAD找到的历史记录中的提交日志信息。变更从HEAD提交开始显示，并从提交图中回溯。如果使用<strong><code>git log</code></strong></p>
<p>时提供一个提交名，那么这个日志将从该提交开始回溯输出。例如:<strong><code>git log master</code></strong></p>
</li>
</ul>
]]></content>
      <categories>
        <category>版本控制管理</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>关于Git文件管理</title>
    <url>/2020/02/12/git/%E5%85%B3%E4%BA%8EGit%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h3 id="git中的文件分类"><a href="#git中的文件分类" class="headerlink" title="git中的文件分类"></a>git中的文件分类</h3><p>​    Git将所有文件分为3类：已追踪的、被忽略的以及未追踪的</p>
<ul>
<li><p>已追踪的</p>
<p>已追踪的文件是指已经在版本库中的文件，或者是已暂存到索引中的文件。如果想将新文件<strong><code>newfile</code></strong>添加到已追踪的文件，执行 <strong><code>git add newfile</code></strong>即可</p>
</li>
<li><p>被忽略的</p>
<p>被忽略的文件必须在版本库中明确声明为不可见或被忽略，即使他可能会在工作目录中出现。一个软件项目通常都会有很多被忽略的文件。普通被忽略的文件包括临时文件、个人笔记、编译器输出文件以及构建过程中自动生成的大多数文件。Git维护一个默认的忽略文件列表，也可以配置版本库来识别其他文件。被忽略的文件会在后面介绍。</p>
</li>
<li><p>未追踪的</p>
<p>未追踪的文件是指那些不在版本库中的文件。</p>
</li>
</ul>
<p>下面举一个栗子:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git init</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">查看状态</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> On branch master</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Initial commit</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line">nothing to commit (create/copy files and use "git add" to track)</span><br><span class="line"><span class="meta">#</span><span class="bash">添加一个文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"new Data"</span> &gt;&gt; data</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> On branch master</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Initial commit</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Untracked files:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">"git add &lt;file&gt;..."</span> to include <span class="keyword">in</span> what will be committed)</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash">       data</span></span><br><span class="line">nothing added to commit but untracked files present (use "git add" to track)</span><br></pre></td></tr></table></figure>

<p>为了让Git忽略目录中的文件，只需将该文件名添加到一个特殊的文件<strong><code>.gitignore</code></strong>中就可以了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> touch main.o</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> On branch master</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Initial commit</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Untracked files:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">"git add &lt;file&gt;..."</span> to include <span class="keyword">in</span> what will be committed)</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash">       data</span></span><br><span class="line"><span class="meta">#</span><span class="bash">       main.o</span></span><br><span class="line">nothing added to commit but untracked files present (use "git add" to track)</span><br><span class="line"><span class="meta">#</span><span class="bash">将 main.o添加到.gitignore中</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> main.o &gt;&gt; .gitignore</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> On branch master</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Initial commit</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Untracked files:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">"git add &lt;file&gt;..."</span> to include <span class="keyword">in</span> what will be committed)</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash">       .gitignore</span></span><br><span class="line"><span class="meta">#</span><span class="bash">       data</span></span><br><span class="line">nothing added to commit but untracked files present (use "git add" to track)</span><br></pre></td></tr></table></figure>

<p>这样main.o就已经被忽略了，但是<strong><code>git status</code></strong>现在显示一个新的未追踪的文件 .gitignore。</p>
<h2 id="使用-git-add"><a href="#使用-git-add" class="headerlink" title="使用 git add"></a>使用 git add</h2><p><strong><code>git add</code></strong> 命令将暂存一个文件。就Git文件分类而言，如果一个文件是未追踪的，那么<strong><code>git add</code></strong>就会将文件的状态转化为已追踪的。如果git add作用于一个目录名，那么该目录下的文件以及子目录都会递归暂存起来。</p>
<p>这里还接着上面的栗子:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> On branch master</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Initial commit</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Untracked files:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">"git add &lt;file&gt;..."</span> to include <span class="keyword">in</span> what will be committed)</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash">       .gitignore</span></span><br><span class="line"><span class="meta">#</span><span class="bash">       data</span></span><br><span class="line">nothing added to commit but untracked files present (use "git add" to track)</span><br><span class="line"><span class="meta">#</span><span class="bash"> 将data、.gitignore两个文件添加至已追踪的分类</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add data .gitignore</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> On branch master</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Initial commit</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Changes to be committed:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">"git rm --cached &lt;file&gt;..."</span> to unstage)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">       new file:   .gitignore</span></span><br><span class="line"><span class="meta">#</span><span class="bash">       new file:   data</span></span><br></pre></td></tr></table></figure>

<p>在上面的栗子中使用<strong><code>git add</code></strong>后，暂存和追踪data和.gitignore文件，并准备下次提交是时添加到版本库中。</p>
<p>可以使用<strong><code>git ls-files</code></strong>命令查看隐藏在对象模型下的东西。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git ls-files</span></span><br><span class="line">.gitignore</span><br><span class="line">data</span><br></pre></td></tr></table></figure>

<p>在任何编辑之后，提交变更之前，请执行一次<strong><code>git add</code></strong>命令。</p>
<h2 id="使用-git-commit"><a href="#使用-git-commit" class="headerlink" title="使用 git commit"></a>使用 git commit</h2><h3 id="使用-git-commit-–all"><a href="#使用-git-commit-–all" class="headerlink" title="使用 git commit –all"></a>使用 git commit –all</h3><p><strong><code>git commit</code></strong> 的 <strong><code>-a</code></strong>或者 <strong><code>--all</code></strong>选项会导致执行提交之前自动暂存所有未暂存的和未追踪的文件变化，包括从工作副本中删除已追踪的文件</p>
<p>下面举个栗子:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">pwd</span></span></span><br><span class="line">/tmp/commit-all-example</span><br><span class="line"><span class="meta">#</span><span class="bash">创建测试版本库</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git init</span></span><br><span class="line">Initialized empty Git repository in /tmp/commit-all-example/.git/</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"Testfile1"</span> &gt;&gt; ready</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"Testfile2"</span> &gt;&gt; notyet</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add ready notyet</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">"Setup"</span></span></span><br><span class="line">[master (root-commit) 2b00dbf] Setup</span><br><span class="line"> 2 files changed, 2 insertions(+)</span><br><span class="line"> create mode 100644 notyet</span><br><span class="line"> create mode 100644 ready</span><br></pre></td></tr></table></figure>

<p>之后再次编辑<strong>ready</strong>文件，并用 <strong><code>git add</code></strong>把它添加到版本库中。然后编辑<strong>notyet</strong>文件保持它是未暂存的。</p>
<p>在一个子目录下添加一个文件，但是不要对它执行<strong><code>git add</code></strong>命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir subdir</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"Nope"</span> &gt;&gt; subdir/new</span></span><br></pre></td></tr></table></figure>

<p>当执行 <strong><code>git commit --all</code></strong>命令，Git会递归遍历整个版本库，暂存所有先前通过<strong><code>git add</code></strong>提交的已知的和修改的文件，然后提交它们，由于<strong>subdir/</strong> 一个全新的目录，而且目录下没有任何文件名或路径通过<strong><code>git add</code></strong>和<strong><code>git commit</code></strong>进行操作的，</p>
<p>So 即使是 –all选项也不能将其提交。</p>
<h3 id="关于提交日志消息"><a href="#关于提交日志消息" class="headerlink" title="关于提交日志消息"></a>关于提交日志消息</h3><p>​    如果不通过命令行直接提供日志消息（例如:<strong><code>git commit -m &quot;提交日志消息&quot;</code></strong>），Git会启动编辑器，并提示你写一个提交日志。</p>
<h2 id="使用-git-rm-命令"><a href="#使用-git-rm-命令" class="headerlink" title="使用 git rm 命令"></a>使用 git rm 命令</h2><p>​       git rm命令会在版本库中和目录中同时删除文件。</p>
<p>接着上面的栗子:</p>
<p>这里“意外”的添加了一个文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"Random"</span> &gt; oops</span></span><br><span class="line"><span class="meta">#</span><span class="bash">当执行git rm oops时，提示删除失败</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git rm oops</span></span><br><span class="line">fatal: pathspec 'oops' did not match any files</span><br></pre></td></tr></table></figure>

<p>​    为什么会这样，可以通过<strong><code>git ls-files</code></strong>命令查看版本库中的文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git ls-files</span></span><br><span class="line">notyet</span><br><span class="line">ready</span><br></pre></td></tr></table></figure>



<p>现在的版本库中没有<strong>oops</strong>这个文件，可通过<strong>git add oops</strong>命令将 oops文件加入到版本库中。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git add oops</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git ls-files</span></span><br><span class="line">notyet</span><br><span class="line">oops</span><br><span class="line">ready</span><br></pre></td></tr></table></figure>

<p>另外，要将一个文件由已暂存的转化为未暂存的,可以使用<strong><code>git rm --cached</code></strong>命令</p>
<p>比如要删除oops</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git rm --cached oops</span></span><br><span class="line">rm 'oops'</span><br></pre></td></tr></table></figure>

<p><strong><code>git rm --cached</code></strong>会删除索引中的文件并它文件保留在工作目录中，而<strong><code>git rm</code></strong>则会将文件从索引和工作目录中都删除。</p>
<p>如果想要删除一个已经提交的文件，通过简单的<strong><code>git rm filename</code></strong>命令来暂存这一请求</p>
<blockquote>
<p>还可以使用 <strong><code>git rm -f</code></strong>来强制删除文件。</p>
</blockquote>
<p>如果想保留的文件不小心删除了，可以通过版本控制系统的恢复功能进行恢复</p>
<p>具体的命令如下:</p>
<figure class="highlight vala"><table><tr><td class="code"><pre><span class="line"><span class="meta"># 加入不小心删除了oops文件</span></span><br><span class="line"><span class="meta"># 可以是下面的命令进行恢复</span></span><br><span class="line">git checkout HEAD -- oops</span><br></pre></td></tr></table></figure>

<h2 id="使用-git-mv"><a href="#使用-git-mv" class="headerlink" title="使用 git mv"></a>使用 git mv</h2><p>如果想要给一个文件重命名可以使用<strong><code>git mv srcfile newfile</code></strong>，git mv 命令会将 <strong>srcfile</strong>文件的文件名称改为<strong>newfiles</strong>，Git会在索引中删除<strong>srcfile</strong>文件的路径名，并添加<strong>newfile</strong>的路径名，至于srcfile文件里的内容，Git仍然会保存在对象库中，然后才会将它与newfile重新关联。git mv 还可以移动一个文件到一个目录中：<strong><code>git mv srcfile dir/</code></strong></p>
<h2 id="gitignore-文件"><a href="#gitignore-文件" class="headerlink" title=".gitignore 文件"></a>.gitignore 文件</h2><p>在前面简单介绍过<strong>.gitignore</strong>文件的作用。可以通过<strong>.gitignore</strong>文件来忽略不相干的文件。Git还支持一种更丰富的机制，一个<strong>.gitignore</strong>文件下可以包含一个文件名模式列表，指定哪些文件需要忽略。<strong>.gitignore</strong> 文件的格式如下。</p>
<ul>
<li>空行会被忽略，而以（#）号开头的行可以用于注释。然而，如果#跟在其他文本后面，它就不代表注释了。</li>
<li>一个简单的字面置文件名匹配任何目录中的同名文件。</li>
<li>目录名由末尾的（/）标记。这能匹配同名的目录和子目录，但不匹配文件或符号链接。</li>
<li>包含shell通配符，如（*）号，这种模式可扩展为shell通配模式。正如标准shell通配符一样，因为不能跨目录匹配，所以一个 * 只能匹配一个文件或目录名。</li>
<li>起始的 ！号会对该行其余部分的模式进行取反。</li>
</ul>
]]></content>
      <categories>
        <category>版本控制管理</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Scala集合</title>
    <url>/2020/01/07/scala/ScalaImpatient/Scala_Set/</url>
    <content><![CDATA[<h3 id="主要的集合特质"><a href="#主要的集合特质" class="headerlink" title="主要的集合特质"></a>主要的集合特质</h3><p><strong><code>Seq</code></strong>是一个有先后次序的值的序列，比如数组和列表。</p>
<p><strong><code>Set</code></strong>是一组没有先后顺序的值。在SortedSet中，元素以某种排过序的顺序被访问。</p>
<p><strong><code>Map</code></strong>是一组键值对，SortedMap按照键的排序访问其中的实体。</p>
<h3 id="可变和不可变集合"><a href="#可变和不可变集合" class="headerlink" title="可变和不可变集合"></a>可变和不可变集合</h3><p>Scala同时支持可变集合和不可变集合。不可变集合从不改变，因此，可以安全的共享其引用，甚至是在一个多线程的应用程序中也没问题。</p>
<p>Scala优先采用不可变集合。scala.collection包中的伴生对象产生出不可变集合</p>
]]></content>
      <categories>
        <category>Scala</category>
      </categories>
      <tags>
        <tag>Scala基础编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Scala高阶函数</title>
    <url>/2020/01/06/scala/ScalaImpatient/Scala_Function/</url>
    <content><![CDATA[<h3 id="作为值的函数"><a href="#作为值的函数" class="headerlink" title="作为值的函数"></a>作为值的函数</h3><p>在Scala中，函数是“头等公民”，和数字一样。可以在变量中存放函数：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.math._</span><br><span class="line"><span class="keyword">val</span> num = <span class="number">3.14</span></span><br><span class="line"><span class="keyword">val</span> fun = ceil _</span><br><span class="line">fun(num)</span><br></pre></td></tr></table></figure>

<p><strong><code>ceil</code></strong>函数后面的<strong><code>_</code></strong>意味着确实指的是这个函数，也就是讲_将ceil方法转成了函数。</p>
<p>在这里所看到的，使用的是普通的函数调用语法。可以对函数做两件事：</p>
<ul>
<li>调用它</li>
<li>传递它，存放在变量中，或者作为参数传递该给另一个函数</li>
</ul>
<p>以下是如何将<strong>fun</strong>传递给另一个函数：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="type">Array</span>(<span class="number">1.203</span>,<span class="number">5.001</span>,<span class="number">5.6894</span>,<span class="number">9.154515</span>).map(fun)</span><br><span class="line"><span class="comment">//Array(2.0, 6.0, 6.0, 10.0)</span></span><br></pre></td></tr></table></figure>

<h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><p>在Scala中，不需要给每个函数命名，就好比不需要给每个数字命名一样：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">(x:<span class="type">Double</span>) =&gt; <span class="number">3</span>*x</span><br><span class="line"></span><br><span class="line"><span class="type">Array</span>(<span class="number">3.152</span>,<span class="number">1.25</span>,<span class="number">8.13</span>,<span class="number">4.25</span>).map(triple)</span><br><span class="line"><span class="type">Array</span>(<span class="number">3.152</span>,<span class="number">1.25</span>,<span class="number">8.13</span>,<span class="number">4.25</span>).map((x:<span class="type">Double</span>)=&gt;<span class="number">3</span>*x)</span><br><span class="line"><span class="type">Array</span>(<span class="number">3.152</span>,<span class="number">1.25</span>,<span class="number">8.13</span>,<span class="number">4.25</span>).map&#123;(x:<span class="type">Double</span>)=&gt;<span class="number">3</span>*x&#125;</span><br></pre></td></tr></table></figure>

<p>也可以将这个函数存放在变量中：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> triple = (x:<span class="type">Double</span>) =&gt; <span class="number">3</span>*x</span><br></pre></td></tr></table></figure>

<p>但是不需要给函数命名。可以直接将它传递给另一个函数：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="type">Array</span>(<span class="number">3.152</span>,<span class="number">1.25</span>,<span class="number">8.13</span>,<span class="number">4.25</span>).map(triple)</span><br><span class="line"><span class="type">Array</span>(<span class="number">3.152</span>,<span class="number">1.25</span>,<span class="number">8.13</span>,<span class="number">4.25</span>).map((x:<span class="type">Double</span>)=&gt;<span class="number">3</span>*x)</span><br><span class="line"><span class="type">Array</span>(<span class="number">3.152</span>,<span class="number">1.25</span>,<span class="number">8.13</span>,<span class="number">4.25</span>).map&#123;(x:<span class="type">Double</span>)=&gt;<span class="number">3</span>*x&#125;</span><br></pre></td></tr></table></figure>

<h3 id="带函数参数的函数"><a href="#带函数参数的函数" class="headerlink" title="带函数参数的函数"></a>带函数参数的函数</h3><p>带函数参数的函数就是实现接收另一个函数作为参数的函数。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.math._</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">valueAtQuarter</span></span>(f: (<span class="type">Double</span>) =&gt; <span class="type">Double</span>) = f(<span class="number">0.25</span>)</span><br><span class="line">valueAtQuarter(ceil _)</span><br><span class="line">valueAtQuarter(sqrt _)</span><br></pre></td></tr></table></figure>

<p>这里的参数可以是任何接受Double并返回Double的函数。在上面的<strong>valueAtQuarter</strong>函数中，它是一个带有单个参数的函数，因为它的类型写成：(参数类型)=&gt;结果类型 。因此<strong>valueAtQuarter</strong>的类型为：<code>((Double)=&gt;Double) =&gt; Double</code>。像这样的一个接受函数参数的函数，被称为高阶函数。高阶函数也可以产出另一个函数。例如：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mulBy</span></span>(f:<span class="type">Double</span>) = (x:<span class="type">Double</span>) =&gt; f*x</span><br><span class="line"><span class="keyword">val</span> qu = mulBy(<span class="number">5</span>)</span><br><span class="line">qu(<span class="number">10</span>)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">50</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//另类玩法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mulBy1</span></span>(f:<span class="type">Double</span>,f1:<span class="type">Double</span>)=(x:<span class="type">Double</span>)=&gt;f*f1*x</span><br><span class="line"><span class="keyword">val</span> qu1 = mulBy1(<span class="number">5</span>,<span class="number">4</span>)</span><br><span class="line">qu1(<span class="number">2</span>)</span><br><span class="line"><span class="comment">//40</span></span><br></pre></td></tr></table></figure>

<p>mulBy函数有个类型为Double的函数，返回一个类型为(Double)=&gt;Double的函数，因此，它的类型为：<code>(Double)=&gt;((Double)=&gt;Double)</code></p>
<h3 id="参数类型推断"><a href="#参数类型推断" class="headerlink" title="参数类型推断"></a>参数类型推断</h3><p>当将一个匿名函数传递给另一个函数或方法时，Scala会尽可能帮助推断出类型信息，比如说，有时候不需要将代码写成：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">valueAtQuarter</span></span>(f: (<span class="type">Double</span>) =&gt; <span class="number">3</span>*f)</span><br></pre></td></tr></table></figure>

<p>函数<strong>valueAtQuarter</strong>方法知道会传入一个类型为(Double)=&gt;Double的函数，所以可以简单地写成：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">valueAtOneQuarter((x: <span class="type">Double</span>) =&gt; <span class="number">3</span> * x)</span><br><span class="line">valueAtOneQuarter((x) =&gt; <span class="number">3</span> * x)</span><br><span class="line">valueAtOneQuarter(x =&gt; <span class="number">3</span> * x)</span><br><span class="line">valueAtOneQuarter(<span class="number">3</span> * _)</span><br></pre></td></tr></table></figure>

<h3 id="常用的高阶函数"><a href="#常用的高阶函数" class="headerlink" title="常用的高阶函数"></a>常用的高阶函数</h3><ul>
<li><p><strong>map</strong></p>
<p>map函数，这个函数将一个函数应用到某个集合的所有元素并返回结果。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">(<span class="number">1</span> to <span class="number">10</span>).map(<span class="number">0.1</span>+_)</span><br><span class="line"><span class="comment">//Vector(1.1, 2.1, 3.1, 4.1, 5.1, 6.1, 7.1, 8.1, 9.1, 10.1)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">(<span class="number">1</span> to <span class="number">10</span>).map(<span class="string">"*"</span> * _).foreach(println _)</span><br></pre></td></tr></table></figure>

<p>这里还用到了foreach()，它和map很像，只不过它的函数并不返回任何值，foreach只是简单地将函数应用到每个元素而已。</p>
</li>
<li><p><strong>filter</strong></p>
<p>filter方法输出所有匹配的某个特定条件的元素：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">(<span class="number">1</span> to <span class="number">19</span>).filter(_ % <span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line"><span class="comment">//Vector(2, 4, 6, 8, 10, 12, 14, 16, 18)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>reduceLeft</strong></p>
<p>reduceLeft()方法接受一个二元的函数——即一个带有两个参数的函数——并将它应用到序列中的所有元素，从左到右。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="type">Array</span>(<span class="number">1</span>,<span class="number">5</span>,<span class="number">5</span>).reduceLeft(_ * _)</span><br><span class="line"><span class="comment">//25</span></span><br><span class="line">(<span class="number">1</span> to <span class="number">5</span>).reduceLeft(_ + _)</span><br><span class="line"><span class="comment">//Int = 120</span></span><br><span class="line"><span class="type">Array</span>(<span class="number">1</span>,<span class="number">5</span>,<span class="number">5</span>).reduceLeft(_ + _)</span><br><span class="line"><span class="comment">//Int = 11</span></span><br></pre></td></tr></table></figure>

<p>就如同：1*5*5=25</p>
</li>
<li><p><strong>sortWith</strong></p>
<p>sortWith()方法是一个二元排序的方法：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="string">"Mary had a little lamb"</span>.split(<span class="string">" "</span>).sortWith(_.length &lt; _.length)</span><br><span class="line"><span class="comment">//Array(a, had, Mary, lamb, little)</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h3><p>柯里化指的是将原来接受两个参数的函数变成新的接受一个参数的函数的过程。新的函数返回一个以原来有第二个参数作为参数的函数。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mul</span></span>(x:<span class="type">Int</span>,y:<span class="type">Int</span>) = x*y</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mul2</span></span>(x:<span class="type">Int</span>)=(y:<span class="type">Int</span>)=&gt;x*y</span><br><span class="line">mul2(<span class="number">5</span>)(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>Scala支持如下简写来定义这样的柯里化函数：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mul3</span></span>(x:<span class="type">Int</span>)(y:<span class="type">Int</span>)=x*y</span><br><span class="line">mul3(<span class="number">2</span>)(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p>多个参数不过是个掩饰，并不是什么编程语言的特质。有时候，可以用柯里化来把某个参数单独拎出来，以提供更多类型推断信息。</p>
<h3 id="控制抽象"><a href="#控制抽象" class="headerlink" title="控制抽象"></a>控制抽象</h3><p>在Scala中，可以将一系列的语句归组成不带参数也没有返回值的函数。例如：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">runInThread</span></span>(block:()=&gt;<span class="type">Unit</span>)&#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="type">Thread</span>&#123;</span><br><span class="line">        <span class="keyword">override</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">run</span></span>()&#123;</span><br><span class="line">            block()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.start()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码以类型()=&gt;Unit给出，但在调用该函数时，需要写一段不是很美观的()=&gt;</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">runInThread &#123;() =&gt; println(<span class="string">"Hi"</span>) ; <span class="type">Thread</span>.sleep(<span class="number">1000</span>); println(<span class="string">"Bye"</span>) &#125;</span><br></pre></td></tr></table></figure>

<p>要想在调用中省掉()=&gt;，可以使用换名调用表示法：在参数声明和调用该函数参数的地方略去()，保留=&gt;</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">runInThread</span></span>(block: =&gt; <span class="type">Unit</span>)&#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="type">Thread</span>()&#123;</span><br><span class="line">        <span class="keyword">override</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">run</span></span>()&#123;</span><br><span class="line">            block</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.start()</span><br><span class="line">&#125;</span><br><span class="line">runInThread&#123;println(<span class="string">"Yang"</span>,<span class="type">Thread</span>.sleep(<span class="number">2000</span>),println(<span class="string">"Ayang"</span>))&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Scala</category>
      </categories>
      <tags>
        <tag>Scala基础编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Scala文件操作</title>
    <url>/2020/01/05/scala/ScalaImpatient/Scala_FileRead/</url>
    <content><![CDATA[<h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><h3 id="读取行"><a href="#读取行" class="headerlink" title="读取行"></a>读取行</h3><p>要读取文件中的所有行，可以调用<strong><code>scala.io.Source</code></strong>对象的getLines方法：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.io.<span class="type">Source</span></span><br><span class="line"><span class="keyword">val</span> source = <span class="type">Source</span>.fromFile(<span class="string">"./myFile.txt"</span>,<span class="string">"utf-8"</span>);</span><br><span class="line"><span class="keyword">val</span> linesIter = source.getLines</span><br><span class="line"><span class="keyword">for</span>(l&lt;-linesIter)&#123;</span><br><span class="line">    println(l)</span><br><span class="line">&#125;</span><br><span class="line">source.close()</span><br></pre></td></tr></table></figure>

<h3 id="读取词法单元和数字"><a href="#读取词法单元和数字" class="headerlink" title="读取词法单元和数字"></a>读取词法单元和数字</h3><p>有一个快而脏的方式来读取源文件中的所有以空格隔开的词法单元</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> io._</span><br><span class="line"><span class="keyword">val</span> source = <span class="type">Source</span>.fromFile(<span class="string">"./values.txt"</span>,<span class="string">"utf-8"</span>)</span><br><span class="line"><span class="keyword">val</span> tokens = source.mkString.split(<span class="string">"\\s+"</span>)</span><br><span class="line"><span class="comment">// val numbers = for(w&lt;-tokens)yield w.toDouble</span></span><br><span class="line"><span class="keyword">val</span> numbers = tokens.map(_.toDouble)</span><br><span class="line">println(<span class="string">"num:"</span>+numbers.sum)</span><br></pre></td></tr></table></figure>

<h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p>想要用正则表达式，可以导入<strong><code>scala.util.matching.Regex</code></strong>类处理，要构建一个<strong>Regex</strong>对象，用<strong>String</strong>类的<strong><code>r</code></strong>方法即可</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> numPattern = <span class="string">"[0-9]+"</span>.r</span><br></pre></td></tr></table></figure>

<p>如果正则表达式包含反斜杠或引号的话，那么最好使用原始的字符串语法<strong><code>&quot;&quot;&quot;.....&quot;&quot;&quot;</code></strong></p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> wsnumPattern = <span class="string">""</span><span class="string">"\s+[0-9]+\s+"</span><span class="string">""</span>.r</span><br></pre></td></tr></table></figure>

<p><strong><code>findAllIn</code></strong>方法返回遍历所有匹配项的迭代器。可以使用<strong><code>for</code></strong>循环使用它：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(matchString&lt;-numPattern.findAllIn(<span class="string">"99 sd,98 asfd"</span>))&#123;</span><br><span class="line">    println(matchString)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> matches = numPattern.findAllIn(<span class="string">"99 sd,98 asfd"</span>).toArray</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Scala</category>
      </categories>
      <tags>
        <tag>Scala基础编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Scala特质</title>
    <url>/2020/01/05/scala/ScalaImpatient/Scala_Trait/</url>
    <content><![CDATA[<h3 id="当作接口使用的特质"><a href="#当作接口使用的特质" class="headerlink" title="当作接口使用的特质"></a>当作接口使用的特质</h3><p>Scala特质完全可以像Java接口那样工作。例如：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Logger</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">log</span></span>(msg:<span class="type">String</span>)<span class="comment">//抽象方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConsoleLogger</span> <span class="keyword">extends</span> <span class="title">Logger</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">log</span></span>(msg:<span class="type">String</span>)&#123;</span><br><span class="line">        println(msg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不需要将方法声明为<strong><code>abstract</code></strong>——特质中未被实现的方法默认就是抽象的。在重写特质的抽象方法时不需要给出<strong><code>override</code></strong>关键字。如果需要的特质不止一个，可以用<strong>with</strong>关键字来添加额外的特质：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConsoleLogger</span> <span class="keyword">extends</span> <span class="title">Logger</span> <span class="keyword">with</span> <span class="title">Cloneable</span></span></span><br></pre></td></tr></table></figure>

<h3 id="带有实现的特质"><a href="#带有实现的特质" class="headerlink" title="带有实现的特质"></a>带有实现的特质</h3><p>在Scala中，特质中的方法并不需要一定是抽象的。例如：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">ConsoleLogger</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">log</span></span>(msg:<span class="type">String</span>)&#123;</span><br><span class="line">        println(msg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Saving</span> <span class="keyword">extends</span> <span class="title">ConsoleLogger</span></span>&#123;</span><br><span class="line">    log(<span class="string">"Yang"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> s = <span class="keyword">new</span> <span class="type">Saving</span>()</span><br></pre></td></tr></table></figure>

<h3 id="叠加到一起的特质"><a href="#叠加到一起的特质" class="headerlink" title="叠加到一起的特质"></a>叠加到一起的特质</h3><p>一个特质可以继承另一个特质，从而实现叠加的效果。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Logger</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">log</span></span>(msg:<span class="type">String</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">ConsoleLogger</span> <span class="keyword">extends</span> <span class="title">Logger</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">log</span></span>(msg:<span class="type">String</span>)&#123;</span><br><span class="line">        println(msg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">TimestampLogger</span> <span class="keyword">extends</span> <span class="title">ConsoleLogger</span></span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">log</span></span>(msg:<span class="type">String</span>)&#123;</span><br><span class="line">        <span class="keyword">super</span>.log(<span class="keyword">new</span> java.util.<span class="type">Date</span>()+<span class="string">" "</span>+msg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">ShortLogger</span> <span class="keyword">extends</span> <span class="title">ConsoleLogger</span></span>&#123;</span><br><span class="line">    <span class="keyword">override</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">log</span></span>(msg:<span class="type">String</span>)&#123;</span><br><span class="line">        <span class="keyword">super</span>.log(<span class="keyword">if</span>(msg.length &lt;= <span class="number">15</span>) msg <span class="keyword">else</span> <span class="string">s"<span class="subst">$&#123;msg.substring(0,12)&#125;</span>..."</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">var</span> balance = <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SavingsAccount</span> <span class="keyword">extends</span> <span class="title">Account</span> <span class="keyword">with</span> <span class="title">Logger</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">withdraw</span></span>(amount:<span class="type">Double</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(amount&gt;balance)&#123;</span><br><span class="line">            log(<span class="string">"INsuff"</span>)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            balance -= amount</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Main</span> <span class="keyword">extends</span> <span class="title">App</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> acct1 = <span class="keyword">new</span> <span class="type">SavingsAccount</span> <span class="keyword">with</span> <span class="type">TimestampLogger</span> <span class="keyword">with</span> <span class="type">ShortLogger</span></span><br><span class="line">    <span class="keyword">val</span> acct2 = <span class="keyword">new</span> <span class="type">SavingsAccount</span> <span class="keyword">with</span> <span class="type">ShortLogger</span> <span class="keyword">with</span> <span class="type">TimestampLogger</span></span><br><span class="line">    acct1.withdraw(<span class="number">100</span>)</span><br><span class="line">    acct2.withdraw(<span class="number">100</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="当做富接口使用的特质"><a href="#当做富接口使用的特质" class="headerlink" title="当做富接口使用的特质"></a>当做富接口使用的特质</h3><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> out5</span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Logger</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">log</span></span>(msg:<span class="type">String</span>);</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">info</span></span>(msg:<span class="type">String</span>)&#123;log(<span class="string">"INFO:"</span>+msg)&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">warn</span></span>(msg:<span class="type">String</span>)&#123;log(<span class="string">"WARN:"</span>+msg)&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">severe</span></span>(msg:<span class="type">String</span>)&#123;log(<span class="string">"SEVERE:"</span>+msg)&#125;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">TimestampLogger</span> <span class="keyword">extends</span> <span class="title">Logger</span></span>&#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">log</span></span>(msg:<span class="type">String</span>)&#123;</span><br><span class="line">        <span class="keyword">super</span>.log(<span class="keyword">new</span> java.util.<span class="type">Date</span>()+<span class="string">" "</span>+msg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">ShortLogger</span> <span class="keyword">extends</span> <span class="title">Logger</span></span>&#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">log</span></span>(msg:<span class="type">String</span>)&#123;</span><br><span class="line">        <span class="keyword">super</span>.log(</span><br><span class="line">            <span class="keyword">if</span>(msg.length&lt;=<span class="number">15</span>) msg</span><br><span class="line">            <span class="keyword">else</span> <span class="string">s"<span class="subst">$&#123;msg.substring(0,12)&#125;</span>..."</span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">ConsoleLogger</span> <span class="keyword">extends</span> <span class="title">Logger</span></span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">log</span></span>(msg:<span class="type">String</span>)&#123;</span><br><span class="line">        println(<span class="string">"console: "</span>+msg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">var</span> balance = <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SavingsAccount</span> <span class="keyword">extends</span> <span class="title">Account</span> <span class="keyword">with</span> <span class="title">Logger</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">withdraw</span></span>(amount:<span class="type">Double</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(amount&gt;balance) log(<span class="string">"Insufficient funds"</span>)</span><br><span class="line">        <span class="keyword">else</span> balance -= amount</span><br><span class="line">        severe(<span class="string">"SSSSSSSS!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Main</span> <span class="keyword">extends</span> <span class="title">App</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> acct1 = <span class="keyword">new</span> <span class="type">SavingsAccount</span> <span class="keyword">with</span> <span class="type">ConsoleLogger</span> <span class="keyword">with</span> <span class="type">TimestampLogger</span> <span class="keyword">with</span> <span class="type">ShortLogger</span></span><br><span class="line">    acct1.withdraw(<span class="number">100</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">console: Sun Feb 28 17:31:21 CST 2021 Insufficient...</span></span><br><span class="line"><span class="comment">console: Sun Feb 28 17:31:21 CST 2021 SEVERE:SSSSSSSS</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="特质中的具体字段"><a href="#特质中的具体字段" class="headerlink" title="特质中的具体字段"></a>特质中的具体字段</h3><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> out8</span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Logger</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">log</span></span>(msg:<span class="type">String</span>);</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">info</span></span>(msg:<span class="type">String</span>)&#123;log(<span class="string">"INFO:"</span>+msg)&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">warn</span></span>(msg:<span class="type">String</span>)&#123;log(<span class="string">"WARN:"</span>+msg)&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">severe</span></span>(msg:<span class="type">String</span>)&#123;log(<span class="string">"SEVERE:"</span>+msg)&#125;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">TimestampLogger</span> <span class="keyword">extends</span> <span class="title">Logger</span></span>&#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">log</span></span>(msg:<span class="type">String</span>)&#123;</span><br><span class="line">        <span class="keyword">super</span>.log(<span class="keyword">new</span> java.util.<span class="type">Date</span>()+<span class="string">" "</span>+msg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">ShortLogger</span> <span class="keyword">extends</span> <span class="title">Logger</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> maxLength = <span class="number">15</span><span class="comment">//【】</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">log</span></span>(msg:<span class="type">String</span>)&#123;</span><br><span class="line">        <span class="keyword">super</span>.log(</span><br><span class="line">            <span class="keyword">if</span>(msg.length&lt;=maxLength) msg</span><br><span class="line">            <span class="keyword">else</span> <span class="string">s"<span class="subst">$&#123;msg.substring(0,12)&#125;</span>..."</span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">ConsoleLogger</span> <span class="keyword">extends</span> <span class="title">Logger</span></span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">log</span></span>(msg:<span class="type">String</span>)&#123;</span><br><span class="line">        println(<span class="string">"console: "</span>+msg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">var</span> balance = <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SavingsAccount</span> <span class="keyword">extends</span> <span class="title">Account</span> <span class="keyword">with</span> <span class="title">ConsoleLogger</span> <span class="keyword">with</span> <span class="title">ShortLogger</span></span>&#123;<span class="comment">//【】</span></span><br><span class="line">    <span class="keyword">var</span> interest = <span class="number">0.0</span><span class="comment">//【】</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">withdraw</span></span>(amount:<span class="type">Double</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(amount&gt;balance) log(<span class="string">"Insufficient funds"</span>)</span><br><span class="line">        <span class="keyword">else</span> balance -= amount</span><br><span class="line">        <span class="comment">// severe("SSSSSSSS!")</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Main</span> <span class="keyword">extends</span> <span class="title">App</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> acct1 = <span class="keyword">new</span> <span class="type">SavingsAccount</span></span><br><span class="line">    acct1.withdraw(<span class="number">100</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure>

<h3 id="特质中的抽象字段"><a href="#特质中的抽象字段" class="headerlink" title="特质中的抽象字段"></a>特质中的抽象字段</h3><p>特质中未被初始化的字段在具体的子类中必须重写。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> out9</span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Logger</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">log</span></span>(msg:<span class="type">String</span>);</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">info</span></span>(msg:<span class="type">String</span>)&#123;log(<span class="string">"INFO:"</span>+msg)&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">warn</span></span>(msg:<span class="type">String</span>)&#123;log(<span class="string">"WARN:"</span>+msg)&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">severe</span></span>(msg:<span class="type">String</span>)&#123;log(<span class="string">"SEVERE:"</span>+msg)&#125;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">TimestampLogger</span> <span class="keyword">extends</span> <span class="title">Logger</span></span>&#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">log</span></span>(msg:<span class="type">String</span>)&#123;</span><br><span class="line">        <span class="keyword">super</span>.log(<span class="keyword">new</span> java.util.<span class="type">Date</span>()+<span class="string">" "</span>+msg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">ShortLogger</span> <span class="keyword">extends</span> <span class="title">Logger</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> maxLength:<span class="type">Int</span><span class="comment">//抽象字段</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">log</span></span>(msg:<span class="type">String</span>)&#123;</span><br><span class="line">        <span class="keyword">super</span>.log(</span><br><span class="line">            <span class="keyword">if</span>(msg.length&lt;=maxLength) msg</span><br><span class="line">            <span class="keyword">else</span> <span class="string">s"<span class="subst">$&#123;msg.substring(0,12)&#125;</span>..."</span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">ConsoleLogger</span> <span class="keyword">extends</span> <span class="title">Logger</span></span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">log</span></span>(msg:<span class="type">String</span>)&#123;</span><br><span class="line">        println(<span class="string">"console: "</span>+msg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">var</span> balance = <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SavingsAccount</span> <span class="keyword">extends</span> <span class="title">Account</span> <span class="keyword">with</span> <span class="title">ConsoleLogger</span> <span class="keyword">with</span> <span class="title">ShortLogger</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> interest = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">val</span> maxLength = <span class="number">20</span><span class="comment">//重写maxLength</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">withdraw</span></span>(amount:<span class="type">Double</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(amount&gt;balance) log(<span class="string">"Insufficient funds"</span>)</span><br><span class="line">        <span class="keyword">else</span> balance -= amount</span><br><span class="line">        severe(<span class="string">"SSSSSSSS!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Main</span> <span class="keyword">extends</span> <span class="title">App</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> acct1 = <span class="keyword">new</span> <span class="type">SavingsAccount</span></span><br><span class="line">    acct1.withdraw(<span class="number">100</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="特质构造顺序"><a href="#特质构造顺序" class="headerlink" title="特质构造顺序"></a>特质构造顺序</h3><p>和类一样，特质也可以有构造器，有字段的初始化和其他特质体中的语句构成。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> out10</span><br><span class="line"><span class="keyword">import</span> java.io._</span><br><span class="line"><span class="keyword">import</span> java.util._</span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Logger</span></span>&#123;</span><br><span class="line">    println(<span class="string">"Constructing Logger"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">log</span></span>(msg:<span class="type">String</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">FileLogger</span> <span class="keyword">extends</span> <span class="title">Logger</span></span>&#123;</span><br><span class="line">    println(<span class="string">"Constructing FileLogger"</span>)</span><br><span class="line">    <span class="keyword">val</span> out = <span class="keyword">new</span> <span class="type">PrintWriter</span>(<span class="string">"./app.log"</span>)</span><br><span class="line">    out.println(<span class="string">s"# <span class="subst">$&#123;java.time.Instant.now()&#125;</span>"</span>) <span class="comment">// Also part of the constructor</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">log</span></span>(msg:<span class="type">String</span>)&#123;</span><br><span class="line">        out.println(msg)</span><br><span class="line">        out.flush()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">ShortLogger</span> <span class="keyword">extends</span> <span class="title">Logger</span></span>&#123;</span><br><span class="line">    println(<span class="string">"Constructing ShortLogger"</span>)</span><br><span class="line">    <span class="keyword">val</span> maxLength:<span class="type">Int</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">log</span></span>(msg:<span class="type">String</span>)&#123;</span><br><span class="line">        <span class="keyword">super</span>.log(</span><br><span class="line">            <span class="keyword">if</span> (msg.length &lt;= maxLength) msg</span><br><span class="line">            <span class="keyword">else</span> <span class="string">s"<span class="subst">$&#123;msg.substring(0, maxLength - 3)&#125;</span>..."</span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span></span>&#123;</span><br><span class="line">    println(<span class="string">"Constructing Account"</span>)    </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">var</span> balance = <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SavingsAccount</span> <span class="keyword">extends</span> <span class="title">Account</span> <span class="keyword">with</span> <span class="title">FileLogger</span> <span class="keyword">with</span> <span class="title">ShortLogger</span></span>&#123;</span><br><span class="line">    println(<span class="string">"Constructing SavingsAccount"</span>)</span><br><span class="line">    <span class="keyword">val</span> maxLength = <span class="number">15</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">withdraw</span></span>(amount:<span class="type">Double</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(amount&gt;balance)log(<span class="string">"Insufficient funds"</span>)</span><br><span class="line">        <span class="keyword">else</span> balance-=amount</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Main</span> <span class="keyword">extends</span> <span class="title">App</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> acct = <span class="keyword">new</span> <span class="type">SavingsAccount</span></span><br><span class="line">    acct.withdraw(<span class="number">100</span>)</span><br><span class="line">    println(<span class="string">"Look into app.log for the log message."</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Constructing Account</span></span><br><span class="line"><span class="comment">Constructing Logger</span></span><br><span class="line"><span class="comment">Constructing FileLogger</span></span><br><span class="line"><span class="comment">Constructing ShortLogger</span></span><br><span class="line"><span class="comment">Constructing SavingsAccount</span></span><br><span class="line"><span class="comment">Look into app.log for the log message.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>特质构造器的执行顺序：</p>
<ul>
<li>首先调用超类构造器</li>
<li>特质构造器在超类构造器之后、类构造器之前执行</li>
<li>特质由左到右被构造</li>
<li>每个特质当中，父特质先被构造</li>
<li>如果多个特质共有一个父特质，而这个父特质已经构造，则不会被再次构造</li>
<li>所有特质构造完毕，子类被构造</li>
</ul>
]]></content>
      <categories>
        <category>Scala</category>
      </categories>
      <tags>
        <tag>Scala基础编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Scala继承</title>
    <url>/2020/01/04/scala/ScalaImpatient/Scala_Extends/</url>
    <content><![CDATA[<h3 id="扩展类"><a href="#扩展类" class="headerlink" title="扩展类"></a>扩展类</h3><p>Scala扩展类的方式和Java一样，使用<strong><code>extends</code></strong>关键字：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> salary = <span class="number">0.0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在定义中给出子类需要而超类没有的字段和方法，或者重写超类的方法。</p>
<h3 id="重写方法"><a href="#重写方法" class="headerlink" title="重写方法"></a>重写方法</h3><p>在Scala中重写一个非抽象方法必须使用<strong><code>override</code></strong>修饰符：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">override</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">toString</span></span>() = &#123;</span><br><span class="line">        getClass.getName+<span class="string">"[name="</span>+name+<span class="string">"]"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>override修饰符可以在多个常见情况下给出有用的错误提示，包括：</p>
<ul>
<li>当拼错了重写的方法名</li>
<li>当不小心在新方法中使用了错误的参数类型</li>
<li>当在超类中引入新的方法，这个新的方法与子类的方法相抵触</li>
</ul>
<p>调用超类中的方法，使用<strong><code>super</code></strong>关键字：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">override</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">toString</span></span>()=&#123;</span><br><span class="line">        <span class="keyword">super</span>.toString+<span class="string">"[salary="</span>+salary+<span class="string">"]"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="超类构造"><a href="#超类构造" class="headerlink" title="超类构造"></a>超类构造</h3><p>类有一个主构造器和任意数量辅助构造器，而每个辅助构造器都必须对先前定义的辅助构造器或主构造器的调用开始。</p>
<p>这样带了的后果是，辅助构造器永远都不可能直接调用超类的构造器。</p>
<p>子类的辅助构造器最终都会调用主构造器。只有主构造器可以调用超类的构造器</p>
<h3 id="重写字段"><a href="#重写字段" class="headerlink" title="重写字段"></a>重写字段</h3><p>Scala的字段由一个私有字段和取值器/改值器方法构成。可以用另一个同名的val字段重写一个val。子类有一个私有字段和一个公有的getter方法，而这个getter方法重写了超类的getter方法。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">val name:<span class="type">String</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">override</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">toString</span></span>()=&#123;</span><br><span class="line">        getClass.getName+<span class="string">"[name="</span>+name+<span class="string">"]"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SecretAgent</span>(<span class="params">codename:<span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">Person</span>(<span class="params">codename</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">override</span></span><br><span class="line">    <span class="keyword">val</span> name = <span class="string">"sr"</span></span><br><span class="line">    <span class="keyword">override</span></span><br><span class="line">    <span class="keyword">val</span> toString = <span class="string">"ser"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>可以使用abstract关键字来标记不能实例化的类，通常这些因为它的某个类或某几个方法没有被完整定义。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">val name:<span class="type">String</span></span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">id</span></span>:<span class="type">Int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span>(<span class="params">name:<span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">id</span> </span>= name.hashCode</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> e = <span class="keyword">new</span> <span class="type">Employee</span>(<span class="string">"yang"</span>)</span><br><span class="line">e.id</span><br></pre></td></tr></table></figure>

<h3 id="抽象字段"><a href="#抽象字段" class="headerlink" title="抽象字段"></a>抽象字段</h3><p>除了抽象方法外，类还可以拥有抽象字段。抽象字段就是一个没有初始值的字段。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="comment">//带有抽象的getter方法的抽象字段</span></span><br><span class="line">    <span class="keyword">val</span> id:<span class="type">Int</span></span><br><span class="line">    <span class="comment">//带有抽象getter、setter方法</span></span><br><span class="line">    <span class="keyword">var</span> name:<span class="type">Strin</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Scala</category>
      </categories>
      <tags>
        <tag>Scala基础编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Scala的类与对象</title>
    <url>/2020/01/03/scala/ScalaImpatient/Scala_Classs/</url>
    <content><![CDATA[<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h3 id="简单类和无参方法"><a href="#简单类和无参方法" class="headerlink" title="简单类和无参方法"></a>简单类和无参方法</h3><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> value = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">increment</span></span>():<span class="type">Unit</span>=&#123;</span><br><span class="line">        value+=<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">current</span></span>():<span class="type">Int</span>=&#123;</span><br><span class="line">        value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> mycounter = <span class="keyword">new</span> <span class="type">Counter</span>()</span><br><span class="line">mycounter.increment()</span><br><span class="line">mycounter.increment()</span><br><span class="line">mycounter.increment()</span><br><span class="line">println(mycounter.current())</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="带getter和setter的属性"><a href="#带getter和setter的属性" class="headerlink" title="带getter和setter的属性"></a>带getter和setter的属性</h3><p>Scala对每个字段都提供getter和setter方法。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> age = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> fred = <span class="keyword">new</span> <span class="type">Person</span>()</span><br><span class="line">println(fred.age)</span><br><span class="line">fred.age=<span class="number">18</span></span><br><span class="line">println(fred.age)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>在上面的代码中可以看到，getter和setter分别叫做age和age=</p>
<h3 id="辅助构造器"><a href="#辅助构造器" class="headerlink" title="辅助构造器"></a>辅助构造器</h3><p>Scala类有一个构造器比其他所有构造器更为重要，那就是主构造器。除了主构造器之外，类还可以有任意多的辅助构造器：</p>
<ul>
<li>辅助构造器的名称为<strong>this</strong></li>
<li>每个辅助构造器都必须以一个对先前已定义的其他辅助构造器或主构造器的调用开始</li>
</ul>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> name = <span class="string">""</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> age = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">this</span></span>(name:<span class="type">String</span>)=&#123;</span><br><span class="line">        <span class="keyword">this</span>()</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">this</span></span>(name:<span class="type">String</span>,age:<span class="type">Int</span>)=&#123;</span><br><span class="line">        <span class="keyword">this</span>(name)</span><br><span class="line">        <span class="keyword">this</span>.age = age</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> p1 = <span class="keyword">new</span> <span class="type">Person</span></span><br><span class="line"><span class="keyword">val</span> p2 = <span class="keyword">new</span> <span class="type">Person</span>(<span class="string">"Fred"</span>)</span><br><span class="line"><span class="keyword">val</span> p3 = <span class="keyword">new</span> <span class="type">Person</span>(<span class="string">"Fred"</span>,<span class="number">47</span>)</span><br></pre></td></tr></table></figure>

<h3 id="主构造器"><a href="#主构造器" class="headerlink" title="主构造器"></a>主构造器</h3><p>在Scala中，每个类都有一个主构造器。主构造器并不以this方法定义，而是与类定义交织在一起。</p>
<ul>
<li>主构造器的参数直接放置在类名之后</li>
</ul>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">val name:<span class="type">String</span>,val age:<span class="type">Int</span></span>)</span>&#123;</span><br><span class="line">    println(<span class="string">"Just constructed"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">description</span></span>()=&#123;</span><br><span class="line">        name+<span class="string">" is "</span>+age+<span class="string">" Year old"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>主构造器会执行类定义中的所有语句。</li>
</ul>
<h3 id="嵌套类"><a href="#嵌套类" class="headerlink" title="嵌套类"></a>嵌套类</h3><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.collection.mutable.<span class="type">ArrayBuffer</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NetWork</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Member</span>(<span class="params">val name:<span class="type">String</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">val</span> contacts = <span class="keyword">new</span> <span class="type">ArrayBuffer</span>[<span class="type">Member</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> member = <span class="keyword">new</span> <span class="type">ArrayBuffer</span>[<span class="type">Member</span>]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">join</span></span>(name:<span class="type">String</span>)=&#123;</span><br><span class="line">        <span class="keyword">val</span> m = <span class="keyword">new</span> <span class="type">Member</span>(name)</span><br><span class="line">        member+=m</span><br><span class="line">        m</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> chatter = <span class="keyword">new</span> <span class="type">NetWork</span></span><br><span class="line"><span class="keyword">val</span> myFace = <span class="keyword">new</span> <span class="type">NetWork</span></span><br><span class="line"><span class="keyword">val</span> fred = chatter.join(<span class="string">"Fred"</span>)</span><br><span class="line"><span class="keyword">val</span> wilma = chatter.join(<span class="string">"Wilma"</span>)</span><br><span class="line">fred.contacts+=wilma</span><br><span class="line"><span class="keyword">val</span> barney = myFace.join(<span class="string">"Barney"</span>)</span><br><span class="line"><span class="comment">// fred.contacts+=barney</span></span><br></pre></td></tr></table></figure>

<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><h3 id="单例对象"><a href="#单例对象" class="headerlink" title="单例对象"></a>单例对象</h3><p>Scala没有静态方法或静态字段，可以用<strong>object</strong>这个语法结构来达到同样的目的。对象定义了某个类的单个实例，包含了想要的特性。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Accounts</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> lastNumber = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">newUniqueNumber</span></span>()=&#123;</span><br><span class="line">        lastNumber+=<span class="number">1</span>;</span><br><span class="line">        lastNumber</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Scala中可以用对象来实现：</p>
<ul>
<li>作为存放工具函数或常量的地方。</li>
<li>高效的共享单个不可变实例。</li>
<li>需要用单例来协调某个服务时</li>
</ul>
<h3 id="伴生对象"><a href="#伴生对象" class="headerlink" title="伴生对象"></a>伴生对象</h3><p>在Scala中，可以通过类和与类同名的“伴生”对象来达到同样的目的。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">:paste</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> id = <span class="type">Account</span>.newUniqueNumber()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> balance = <span class="number">0.0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deposit</span></span>(amount:<span class="type">Double</span>)=&#123;</span><br><span class="line">        balance += amount</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">description</span></span>() =&#123;</span><br><span class="line">        <span class="string">"Account "</span> + id + <span class="string">" with balance "</span> + balance</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Account</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> lastNumber = <span class="number">0</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">newUniqueNumber</span></span>()=&#123;</span><br><span class="line">        lastNumber+=<span class="number">1</span>;</span><br><span class="line">        lastNumber;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> acct1 = <span class="keyword">new</span> <span class="type">Account</span></span><br><span class="line"><span class="keyword">val</span> acct2 = <span class="keyword">new</span> <span class="type">Account</span></span><br><span class="line">acct1.deposit(<span class="number">10000</span>)</span><br><span class="line"><span class="keyword">val</span> d1 = acct1.description</span><br><span class="line"><span class="keyword">val</span> d2 = acct2.description</span><br></pre></td></tr></table></figure>

<p>类和它的伴生对象可以互相访问私有特性。它们必须存在同一个源文件中。</p>
<h3 id="扩展类或特质对象"><a href="#扩展类或特质对象" class="headerlink" title="扩展类或特质对象"></a>扩展类或特质对象</h3><p>一个<strong>object</strong>可以扩展类以及一个或多个特质，其结果是一个扩展了指定类以及特质的类的对象，同时拥有在对象定义中给出的所有特性。</p>
<p>一个有用的使用场景是给出被共享的对象。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">UndoableAction</span>(<span class="params">val description:<span class="type">String</span></span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">undo</span></span>():<span class="type">Unit</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">redo</span></span>():<span class="type">Unit</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">DoNothingAction</span> <span class="keyword">extends</span> <span class="title">UndoableAction</span>(<span class="params">"<span class="type">Do</span> <span class="type">Nothing</span>"</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">undo</span></span>()&#123;&#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">redo</span></span>()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> actions = <span class="type">Map</span>(<span class="string">"open"</span>-&gt;<span class="type">DoNothingAction</span>,<span class="string">"save"</span>-&gt;<span class="type">DoNothingAction</span>)</span><br><span class="line">actions(<span class="string">"open"</span>).description</span><br><span class="line">actions(<span class="string">"open"</span>)==actions(<span class="string">"save"</span>)</span><br></pre></td></tr></table></figure>

<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>Scala并没有枚举类型，不过标准类库中提供了一个<strong>Enumeration</strong>助手类，可以用于产生枚举</p>
<p>定义一个扩展Enumeration类的对象并以Value方法调用初始化枚举中所有可选的值</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TrafficLightColor</span> <span class="keyword">extends</span> <span class="title">Enumeration</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> <span class="type">Red</span>,<span class="type">Yellow</span>,<span class="type">Green</span> = <span class="type">Value</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">TrafficLightColor</span>.<span class="type">Yellow</span></span><br><span class="line"><span class="type">TrafficLightColor</span>.<span class="type">Green</span>.id</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TrafficLightColor</span> <span class="keyword">extends</span> <span class="title">Enumeration</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> <span class="type">Red</span> = <span class="type">Value</span>(<span class="number">0</span>,<span class="string">"Stop"</span>)</span><br><span class="line">    <span class="keyword">val</span> <span class="type">Yellow</span> = <span class="type">Value</span>(<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">val</span> <span class="type">Green</span> = <span class="type">Value</span>(<span class="string">"Go"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">TrafficLightColor.Value = Yellow</span></span><br><span class="line"><span class="comment">id:Int = 2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Scala</category>
      </categories>
      <tags>
        <tag>Scala基础编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Scala数组和集合</title>
    <url>/2020/01/02/scala/ScalaImpatient/Scala_Array/</url>
    <content><![CDATA[<h2 id="数组相关操作"><a href="#数组相关操作" class="headerlink" title="数组相关操作"></a>数组相关操作</h2><h3 id="定长数组"><a href="#定长数组" class="headerlink" title="定长数组"></a>定长数组</h3><p>如果需要一个长度不变的数组，可以用Scala中Array。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> num = <span class="keyword">new</span> <span class="type">Array</span>[<span class="type">Int</span>](<span class="number">10</span>)<span class="comment">//10元素的Int数组，所有元素初始化为0</span></span><br><span class="line"><span class="keyword">val</span> string = <span class="keyword">new</span> <span class="type">Array</span>[<span class="type">String</span>](<span class="number">10</span>)<span class="comment">//10元素的字符串数组，所有元素初始化为null</span></span><br><span class="line"><span class="keyword">val</span> s = <span class="type">Array</span>(<span class="string">"Hello"</span>,<span class="string">"World"</span>)</span><br><span class="line">s(<span class="number">0</span>) = <span class="string">"Yang"</span><span class="comment">//使用()来访问数组的元素</span></span><br><span class="line">s</span><br></pre></td></tr></table></figure>

<h3 id="变长数组"><a href="#变长数组" class="headerlink" title="变长数组"></a>变长数组</h3><p>用于那种长度按需要变化的数组，Scala中的变长数组为<strong>ArrayBuffer</strong></p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> collection.mutable.<span class="type">ArrayBuffer</span></span><br><span class="line"><span class="keyword">val</span> b = <span class="type">ArrayBuffer</span>[<span class="type">Int</span>]()</span><br><span class="line"><span class="comment">// 一个空的数组缓冲，准备存放整数</span></span><br><span class="line">b+=<span class="number">1</span><span class="comment">//用+=在尾端添加元素</span></span><br><span class="line"><span class="comment">// ArrayBuffer(1)</span></span><br><span class="line">b+=(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)<span class="comment">//在尾端添加多个元素，以括号包起来</span></span><br><span class="line">b++=<span class="type">Array</span>(<span class="number">8</span>,<span class="number">13</span>,<span class="number">21</span>)<span class="comment">//使用++=操作符追加任何集合</span></span><br><span class="line">b.trimEnd(<span class="number">5</span>)<span class="comment">//移除最后5个元素</span></span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> a = <span class="type">ArrayBuffer</span>[<span class="type">Int</span>]()</span><br><span class="line">a+=(<span class="number">5</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">4</span>)</span><br><span class="line">a.insert(<span class="number">2</span>,<span class="number">6</span>)<span class="comment">//在下标2之前插入</span></span><br><span class="line">a.insert(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>)<span class="comment">//可以插入任意多的元素</span></span><br><span class="line">a.remove(<span class="number">2</span>)<span class="comment">//移除</span></span><br><span class="line">a.remove(<span class="number">2</span>,<span class="number">3</span>)<span class="comment">//第二个参数的含义是要移除多少个元素</span></span><br><span class="line">a</span><br><span class="line"><span class="comment">// 将ArrayBuffer构建成Array,反过来toBuffer将Array转换为ArrayBuffer</span></span><br><span class="line"><span class="keyword">val</span> c = a.toArray</span><br><span class="line">c</span><br></pre></td></tr></table></figure>

<h3 id="遍历数组和数组缓冲"><a href="#遍历数组和数组缓冲" class="headerlink" title="遍历数组和数组缓冲"></a>遍历数组和数组缓冲</h3><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(i &lt;- <span class="number">0</span> until a.length)&#123;</span><br><span class="line">    println(i+<span class="string">":"</span>+a(i))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果在循环体中不需要用到数组下标，可以直接访问数组的元素</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(elem &lt;- a)&#123;</span><br><span class="line">    println(elem)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数组转换"><a href="#数组转换" class="headerlink" title="数组转换"></a>数组转换</h3><p>从一个数组出发，以某种方式对它进行转换是很简单的，这些转换动作不会修改原始数组，而是产生一个全新数组。</p>
<p>像这样用for推导式：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> a = <span class="type">Array</span>(<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>)</span><br><span class="line"><span class="keyword">val</span> result = <span class="keyword">for</span>(elem &lt;- a) <span class="keyword">yield</span> <span class="number">2</span>*elem</span><br><span class="line">result</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Array(4, 6, 10, 14, 18)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="映射和元组"><a href="#映射和元组" class="headerlink" title="映射和元组"></a>映射和元组</h2><p>可以这样来构建一个映射</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> scores = <span class="type">Map</span>(<span class="string">"Alice"</span>-&gt;<span class="number">10</span>,<span class="string">"Bob"</span>-&gt;<span class="number">3</span>,<span class="string">"Cindy"</span>-&gt;<span class="number">8</span>)</span><br></pre></td></tr></table></figure>

<p>上述的代码构造出一个不可变的Map[String,Int]，其值不能被改变。如果想构造一个可变的Map，则用</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> scores1 = collection.mutable.<span class="type">Map</span>(<span class="string">"Li"</span>-&gt;<span class="number">10</span>,<span class="string">"Yang"</span>-&gt;<span class="number">20</span>,<span class="string">"Cindy"</span>-&gt;<span class="number">18</span>)</span><br></pre></td></tr></table></figure>

<p>如果想要从一个空映射开始，则需要选定一个映射实现并给出类型参数：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> scores2 = <span class="keyword">new</span> collection.mutable.<span class="type">HashMap</span>[<span class="type">String</span>,<span class="type">Int</span>]()</span><br></pre></td></tr></table></figure>

<p>和Java的Map一样，Scala中，映射是键值对的集合。使用<strong><code>-&gt;</code></strong>操作符来创建键值对。例如：”A”-&gt;10</p>
<h3 id="获取映射中的值"><a href="#获取映射中的值" class="headerlink" title="获取映射中的值"></a>获取映射中的值</h3><p>在Scala中，函数和映射之间的相似性尤为明显，因为可以使用()表示法来查找某个键对应的值</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> bobsScore = scores1(<span class="string">"Li"</span>)</span><br></pre></td></tr></table></figure>

<p>如果映射并不包含请求中使用的键，则会抛出异常。要检查映射中是否有某个指定的键，可以使用contains方法</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> bobsScore1 = <span class="keyword">if</span>(scores0.contains(<span class="string">"Bob"</span>))&#123;</span><br><span class="line">    scores0(<span class="string">"Bob"</span>)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="keyword">val</span> bobsScore1 =</span><br></pre></td></tr></table></figure>

<h3 id="更新映射中的值"><a href="#更新映射中的值" class="headerlink" title="更新映射中的值"></a>更新映射中的值</h3><p>在可变的映射中，可以更新某个映射的值，或者添加一个新的映射关系，做法是在<strong>=</strong>号的左侧使用<strong>()</strong></p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">scores1(<span class="string">"Yang"</span>) = <span class="number">10</span><span class="comment">//更新键"Yang"对应的值</span></span><br><span class="line">scores1(<span class="string">"Fred"</span>) = <span class="number">7</span><span class="comment">//增加新的键/值对到映射中</span></span><br><span class="line">scores1+=(<span class="string">"Bob"</span>-&gt;<span class="number">20</span>,<span class="string">"Li"</span>-&gt;<span class="number">50</span>,<span class="string">"Cindy"</span>-&gt;<span class="number">18</span>)<span class="comment">//使用+=操作来添加多个关系</span></span><br><span class="line">scores1-=<span class="string">"Bob"</span><span class="comment">//要移除某个键和对应的值，使用-=操作符</span></span><br></pre></td></tr></table></figure>

<p>要从不可变映射中移除某个键，可以用<strong><code>-</code></strong>操作符来获取一个新的去该键的映射</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">scores0-<span class="string">"Alice"</span></span><br></pre></td></tr></table></figure>

<h3 id="迭代映射"><a href="#迭代映射" class="headerlink" title="迭代映射"></a>迭代映射</h3><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>((k,v)&lt;-scores0)&#123;</span><br><span class="line">    print(k+<span class="string">"-&gt;"</span>+v+<span class="string">" "</span>)</span><br><span class="line">&#125;</span><br><span class="line">scores0.keySet</span><br></pre></td></tr></table></figure>

<h3 id="已排序的映射"><a href="#已排序的映射" class="headerlink" title="已排序的映射"></a>已排序的映射</h3><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> sortMap = scala.collection.mutable.<span class="type">SortedMap</span>(<span class="string">"A"</span>-&gt;<span class="number">1</span>,<span class="string">"F"</span>-&gt;<span class="number">7</span>,<span class="string">"B"</span>-&gt;<span class="number">3</span>,<span class="string">"C"</span>-&gt;<span class="number">8</span>)</span><br></pre></td></tr></table></figure>

<h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><p>键值对是元组（tuple）的最简形态——元组是不同类型的值聚集。元组的值是通过将单个的值包含在圆括号中构成。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> t = (<span class="number">1</span>,<span class="number">3.14</span>,<span class="string">"Tuple"</span>)</span><br><span class="line"><span class="comment">//t: (Int, Double, String) = (1,3.14,Tuple)</span></span><br></pre></td></tr></table></figure>

<p>如果有一个元组：<strong><code>val t = (1,3.14,&quot;Tuple&quot;)</code></strong>。你就可以用方法<code>_1,_2,_3</code>访问其组元。例如：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">t._1</span><br><span class="line"><span class="comment">//1</span></span><br></pre></td></tr></table></figure>

<h3 id="拉链操作"><a href="#拉链操作" class="headerlink" title="拉链操作"></a>拉链操作</h3><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> sy = <span class="type">Array</span>(<span class="string">"&lt;"</span>,<span class="string">"-"</span>,<span class="string">"&gt;"</span>)</span><br><span class="line"><span class="keyword">val</span> counter = <span class="type">Array</span>(<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>)</span><br><span class="line"><span class="keyword">val</span> pairs = sy.zip(counter)</span><br><span class="line"><span class="comment">//pairs: Array[(String, Int)] = Array((&lt;,2), (-,1), (&gt;,3))</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Scala</category>
      </categories>
      <tags>
        <tag>Scala基础编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Scala基础</title>
    <url>/2020/01/01/scala/ScalaImpatient/Basic_Scala/</url>
    <content><![CDATA[<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>首先呢，在写代码之前呢，先确保电脑上已经安装了scala。然后在命令行界面上输入：<strong><code>scala</code></strong>命令，这样就进入了“REPL”界面。文章不打算使用这样的形式来编写代码。以后的代码段一律都是以<strong>.scala</strong>为后缀的代码源文件，对其进行编译并执行。</p>
<h3 id="声明值和变量"><a href="#声明值和变量" class="headerlink" title="声明值和变量"></a>声明值和变量</h3><p>在“REPL”界面中，Scala默认使用的变量名为res0，res1，res2这样的变量名。除了直接使用这些变量名之外。还可以自己定义变量名：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> out;</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">chapter</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args:<span class="type">Array</span>[<span class="type">String</span>])&#123;</span><br><span class="line">        <span class="keyword">val</span> answer = <span class="number">8</span>*<span class="number">5</span>;</span><br><span class="line">        println(<span class="string">"answer："</span>+answer);</span><br><span class="line">        <span class="keyword">var</span> counter = <span class="number">0</span>;</span><br><span class="line">        println(<span class="string">"counter："</span>+counter);</span><br><span class="line">        counter = <span class="number">1</span>;</span><br><span class="line">        println(<span class="string">"counter："</span>+counter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">answer：40</span></span><br><span class="line"><span class="comment">counter：0</span></span><br><span class="line"><span class="comment">counter：1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p> 变量名以<strong><code>val</code></strong>定义的值实际是一个常量，无法改变其内容。如果想要声明其值为可变的变量，可以使用<strong><code>var</code></strong></p>
<p>在scala中，尽量使用<strong>val</strong>来定义变量吧。大多数程序中并不需要那么多的<strong>var</strong>变量。在scala中不需要给出值或者变量的类型，这个信息可以用初始化时的表达式推断出来。当然了，在必要的时候，也可以指定类型。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> greeting:<span class="type">String</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">val</span> greeting:<span class="type">Any</span> = <span class="string">"Hello"</span>;</span><br></pre></td></tr></table></figure>

<h3 id="块表达式和赋值"><a href="#块表达式和赋值" class="headerlink" title="块表达式和赋值"></a>块表达式和赋值</h3><p>块语句是一个包含于<strong><code>{}</code></strong>中的语句序列。每当需要在逻辑分支或循环中放置多个动作时，可以使用块语句。块表达式包含一系列表达式，其结果也是一个表达式。块中最后一个表达式的值就是块的值。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.math._</span><br><span class="line"><span class="keyword">val</span> x0 = <span class="number">1.0</span>;</span><br><span class="line"><span class="keyword">val</span> y0 = <span class="number">1.0</span>;</span><br><span class="line"><span class="keyword">val</span> x = <span class="number">4.0</span>;</span><br><span class="line"><span class="keyword">val</span> y = <span class="number">5.0</span>;</span><br><span class="line"><span class="keyword">val</span> distance = &#123;</span><br><span class="line">    <span class="keyword">val</span> dx = x-x0;</span><br><span class="line">    <span class="keyword">val</span> dy = y-y0;</span><br><span class="line">    sqrt(dx*dx+dy*dy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个特性对于那种对于某个val的初始化需要分多步完成的情况很有用。</p>
<h3 id="常用类型"><a href="#常用类型" class="headerlink" title="常用类型"></a>常用类型</h3><p>Scala有7种数值类型：Byte，Char，Int，Long，Float，Double以及Boolean类型。这些类型都是类。Scala并不刻意区分基本类型和引用类型。Scala还提供了RichInt，RichDouble，RichChar等，这些类型提供了它们许多的便捷的方法。例如：<code>1.to(10)</code>之类的方法。</p>
<p>在Scala中，不需要要包装类型。在基本类型和包装类型之间的转换是Scala编译器的工作。</p>
<h3 id="算术和操作符重载"><a href="#算术和操作符重载" class="headerlink" title="算术和操作符重载"></a>算术和操作符重载</h3><p>在上面的代码中，例如：<code>val answer = 8*5+2</code>中的操作符。<strong><code>+-*/%</code></strong>完成的是它们通常的工作，位操作符也是一样。只是有一点特别的：这些操作符实际上是方法。例如：<strong><code>a+b</code></strong>实际上是a.+(b)调用的简写。这里的<strong>+</strong>是方法名。通常来说，可以用：</p>
<p><strong>a 方法 b</strong>作为<strong>a.方法(b)</strong>的简写。</p>
<p>和Java相比，Scala有一个显著的不同，Scala并没有提供<strong>++</strong>和<strong>–</strong>操作符，需要使用<strong>+=1</strong>或者<strong>-=1</strong></p>
<h3 id="调用函数和方法"><a href="#调用函数和方法" class="headerlink" title="调用函数和方法"></a>调用函数和方法</h3><p>相比于Java，在Scala中调用函数更为方便，不需要从某个类调用它的静态方法。</p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>要定义函数，需要该出函数的名称、参数和函数体：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">abs</span></span>(x:<span class="type">Double</span>) = &#123;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        x</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        -x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在定义函数的参数时，必须给出所有参数的类型，不过，只要函数不是递归的，就不需要指定返回类型。Scala编译器可以通过<strong>=</strong>符号右侧的表达式的类型推断出返回类型。</p>
<p>如果函数体需要多个表达式完成，可以代码块。块最后一个表达式的值就是函数的返回值。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fac</span></span>(n:<span class="type">Int</span>)=&#123;</span><br><span class="line">    <span class="keyword">var</span> r = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span>(i &lt;- <span class="number">1</span> to n)&#123;</span><br><span class="line">        r = r*i</span><br><span class="line">    &#125;</span><br><span class="line">    r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="默认参数和带名参数"><a href="#默认参数和带名参数" class="headerlink" title="默认参数和带名参数"></a>默认参数和带名参数</h3><p>在调用某些函数时并不显式地给出所有参数值，对于这些函数可以使用默认参数：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorate</span></span>(str:<span class="type">String</span>,left:<span class="type">String</span> =<span class="string">"["</span>,right:<span class="type">String</span>=<span class="string">"]"</span>)=&#123;</span><br><span class="line">    left+str+right</span><br><span class="line">&#125;</span><br><span class="line">decorate(<span class="string">"Hello"</span>)</span><br><span class="line">decorate(<span class="string">"Hello"</span>,<span class="string">"&lt;"</span>,<span class="string">"&gt;"</span>)</span><br><span class="line">decorate(left=<span class="string">"&lt;&lt;&lt;"</span>,str=<span class="string">"Scala"</span>,right=<span class="string">"&gt;&gt;&gt;"</span>)</span><br></pre></td></tr></table></figure>

<p>如果相对参数的数量，给出的值不够，默认参数会从后往前逐个应用进来。也可以在提供参数值的时候指定参数名，带名参数并不需要跟参数列表的顺序完全一致。带名参数可以让函数更加的可读。它们对于那些有很多默认参数的函数来说很有用。</p>
<h3 id="变长参数"><a href="#变长参数" class="headerlink" title="变长参数"></a>变长参数</h3><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span></span>(artgs:<span class="type">Int</span>*):<span class="type">Int</span>=&#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span>(artg&lt;-artgs)&#123;</span><br><span class="line">        result+=artg</span><br><span class="line">    &#125;</span><br><span class="line">    result</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> s = sum(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br></pre></td></tr></table></figure>

<p>函数得到一个类型为Seq的参数。如果已经有一个值的序列，这不能直接将其传入上述的函数。例如：<code>val s = sum(1 to 5)</code>这个用法是错误的。</p>
<p>如果sum函数被调用时传入的是单个参数，那么该参数必须是一个单个整数，而不是一个整数区间。解决这个问题的办法是告诉编译器你希望这个参数被当作参数序列处理。追加<strong><code>:_*</code></strong>。就像这样：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span></span>(artgs:<span class="type">Int</span>*):<span class="type">Int</span>=&#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span>(artg&lt;-artgs)&#123;</span><br><span class="line">        result+=artg</span><br><span class="line">    &#125;</span><br><span class="line">    result</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> s1 = sum(<span class="number">1</span> to <span class="number">10</span>:_*)<span class="comment">//</span></span><br></pre></td></tr></table></figure>

<h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p>Scala对于不返回值的函数有特殊的表示法。如果函数体包含在花括号<strong>{}</strong>中但没有前面的<strong>=</strong>号，那么返回类型就是<strong>Unit</strong>。这样的函数被称为<strong>过程</strong>。过程不返回值，调用它仅仅是为了它的副作用。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">box</span></span>(s:<span class="type">String</span>):<span class="type">Unit</span>=&#123;</span><br><span class="line">    <span class="keyword">var</span> border = <span class="string">"-"</span>*s.length+<span class="string">"--\n"</span></span><br><span class="line">    println(border+<span class="string">"|"</span>+s+<span class="string">"|\n"</span>+border)</span><br><span class="line">&#125;</span><br><span class="line">box(<span class="string">"Yangshenghua"</span>)</span><br></pre></td></tr></table></figure>

<h3 id="高级for循环和for推导式"><a href="#高级for循环和for推导式" class="headerlink" title="高级for循环和for推导式"></a>高级for循环和for推导式</h3><p>可以使用<strong>变量&lt;-表达式</strong>的形式提供多个生成器，用分号将它们隔开</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(i &lt;- <span class="number">1</span> to <span class="number">3</span>;j &lt;- <span class="number">1</span> to <span class="number">3</span>)&#123;</span><br><span class="line">    print((<span class="number">10</span>*i+j)+<span class="string">" "</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以定义任意多个的定义，引入可以在循环中使用的变量：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(i &lt;- <span class="number">1</span> to <span class="number">3</span>;from = <span class="number">4</span>-i;j &lt;- from to <span class="number">3</span>)&#123;</span><br><span class="line">    print((<span class="number">10</span>*i+j)+<span class="string">" "</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//13 22 23 31 32 33</span></span><br></pre></td></tr></table></figure>

<p>如果for循环体以yield开始，则该循环会构造出一个集合，每次迭代生成集合中的一个值：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> l = <span class="keyword">for</span>(i &lt;- <span class="number">1</span> to <span class="number">10</span>) <span class="keyword">yield</span> i%<span class="number">3</span></span><br><span class="line"><span class="comment">//Vector(1, 2, 0, 1, 2, 0, 1, 2, 0, 1)</span></span><br></pre></td></tr></table></figure>

<p>for推导式生成的集合与它的第一个生成器是类型兼容的。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(c &lt;- <span class="string">"Hello"</span>;i&lt;<span class="number">-0</span> to <span class="number">1</span>) <span class="keyword">yield</span> (c+i).toChar</span><br><span class="line"><span class="comment">//tring = HIeflmlmop</span></span><br><span class="line"><span class="keyword">for</span>(i &lt;- <span class="number">0</span> to <span class="number">1</span>;c &lt;- <span class="string">"Hello"</span>) <span class="keyword">yield</span> (c+i).toChar</span><br><span class="line"><span class="comment">//Vector(H, e, l, l, o, I, f, m, m, p)</span></span><br></pre></td></tr></table></figure>

<h3 id="懒值"><a href="#懒值" class="headerlink" title="懒值"></a>懒值</h3><p>当val被声明为<strong>lazy</strong>时，他的初始化将被推迟，直到首次使用它。</p>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>和Java一样，抛出的对象必须是java.lang.Throwable的子类。与Java不同的是，Scala没有受检异常，不需要声明函数或方法可能抛出的某种异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.math._</span><br><span class="line"><span class="function">def <span class="title">root</span><span class="params">(x:Double)</span></span>=&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        sqrt(x)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"X should not be negative"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    println(root(<span class="number">4</span>))</span><br><span class="line">    println(root(-<span class="number">4</span>))</span><br><span class="line">&#125;<span class="keyword">catch</span>&#123;</span><br><span class="line">    <span class="keyword">case</span> e:Exception =&gt; println(e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Scala</category>
      </categories>
      <tags>
        <tag>Scala基础编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发</title>
    <url>/2019/12/29/java/java%E5%9F%BA%E7%A1%80/%E3%80%9011%E3%80%91Java%E5%B9%B6%E5%8F%91/</url>
    <content><![CDATA[<h2 id="基本的线程机制"><a href="#基本的线程机制" class="headerlink" title="基本的线程机制"></a>基本的线程机制</h2><h3 id="定义任务"><a href="#定义任务" class="headerlink" title="定义任务"></a>定义任务</h3><p>线程可以驱动任务，因此需要一种描述任务的方式，这可以有<strong>Runnable</strong>接口来提供。要想定义任务，只需实现Runnable接口并编写<strong>run()</strong>方法，使得该任务执行。当从Runnable导出一个类时，必须具有run()方法，但是这个方法并没有什么特别的，run()方法不会产生任何内在的线程能力，要实现线程行为，必须显式的将一个任务添加到线程上。run()方法通常总会有某种形式的循环，使得任务一直运行下去直到不再需要，所以要设定跳出循环的条件。通常，run()被写成无限循环的形式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> out;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LiftOff</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> countDown = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> taskCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> id = taskCount++;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LiftOff</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LiftOff</span><span class="params">(<span class="keyword">int</span> countDown)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.countDown = countDown;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">status</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"#"</span>+id+<span class="string">"("</span>+(countDown&gt;<span class="number">0</span>?countDown:<span class="string">"LiftOff"</span>)+<span class="string">"),"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(countDown-- &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(status());</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将Runnable对象转变为工作任务的方式是把它提交给一个<strong>Thread</strong>类构造器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> out;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainThread</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]aegs)</span></span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> LiftOff());</span><br><span class="line">        t.start();</span><br><span class="line">        System.out.println(<span class="string">"Waiting for LiftOff"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Waiting for LiftOff</span></span><br><span class="line"><span class="comment">#0(9),</span></span><br><span class="line"><span class="comment">#0(8),</span></span><br><span class="line"><span class="comment">#0(7),</span></span><br><span class="line"><span class="comment">#0(6),</span></span><br><span class="line"><span class="comment">#0(5),</span></span><br><span class="line"><span class="comment">#0(4),</span></span><br><span class="line"><span class="comment">#0(3),</span></span><br><span class="line"><span class="comment">#0(2),</span></span><br><span class="line"><span class="comment">#0(1),</span></span><br><span class="line"><span class="comment">#0(LiftOff),</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>Thread</strong>构造器只需要一个<strong>Runnable</strong>对象，调用<strong>Thread</strong>对象的<strong>start()</strong>方法为线程执行必需的初始化操作，然后调用Runnable的<strong>run()</strong>方法，以便在这个新线程中启动该任务。</p>
<h3 id="使用Executor"><a href="#使用Executor" class="headerlink" title="使用Executor"></a>使用Executor</h3><p>在JDK1.5中java.util.concurrent包中的使用执行器（<strong>Executor</strong>）管理Thread对象，从而简化了并发编程。<strong>Executor</strong>在用户端和任务执行之间提供了一个间接层；Executor允许管理异步任务的执行，而无需显式地管理线程的生命周期。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> out;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CachedThreadPool</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line">            exec.execute(<span class="keyword">new</span> LiftOff());</span><br><span class="line">        &#125;</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">#4(9),</span></span><br><span class="line"><span class="comment">#1(9),</span></span><br><span class="line"><span class="comment">#2(9),</span></span><br><span class="line"><span class="comment">#2(8),</span></span><br><span class="line"><span class="comment">#0(9),</span></span><br><span class="line"><span class="comment">#5(9),</span></span><br><span class="line"><span class="comment">#3(9),</span></span><br><span class="line"><span class="comment">#5(8),</span></span><br><span class="line"><span class="comment">#0(8),</span></span><br><span class="line"><span class="comment">#2(7),</span></span><br><span class="line"><span class="comment">#1(8),</span></span><br><span class="line"><span class="comment">#4(8),</span></span><br><span class="line"><span class="comment">#1(7),</span></span><br><span class="line"><span class="comment">#2(6),</span></span><br><span class="line"><span class="comment">#0(7),</span></span><br><span class="line"><span class="comment">#5(7),</span></span><br><span class="line"><span class="comment">#3(8),</span></span><br><span class="line"><span class="comment">#5(6),</span></span><br><span class="line"><span class="comment">#0(6)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>ExecutorService（具有服务生命周期的Executor）知道如何构建恰当的上下文来执行Runnable对象。CacheThreadPool将为每个任务都创建一个线程。<strong>ExecutorService</strong>对象是使用静态<strong>Executor</strong>方法创建，这个方法可以确定其<strong>Executor</strong>类型。调用shutdown()方法可以防止新任务被提交给Executor，当前线程</p>
<p>可以将上面的代码中的<strong>CacheThreadPool</strong>替换为不同类型的<strong>Executor</strong>。<strong>FixedThreadPool</strong>使用了有限的线程集来执行所提交的任务。CacheThreadPool在程序执行过程中通常会创建与所需数量相同的线程，然后在它回收旧线程时停止创建新线程，因此它是首选的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> out;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FixedThreadPool</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        ExecutorService exec = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line">            exec.execute(<span class="keyword">new</span> LiftOff());</span><br><span class="line">        &#125;</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了<strong>FixedThreadPool</strong>，就可以一次性预先执行代价高昂的线程分配，因而也就可以限制线程的数量。</p>
<p><strong>SingleThreadExecutor</strong>就像是线程数量为1的<strong>FixedThreadPool</strong>。这对于希望在另一个线程连续运行的任何事物来说是非常有用的，对于希望在线程中运行的短任务也同样很方便。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> out;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleThreadPool</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        ExecutorService exec = Executors.newSingleThreadExecutor();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">        exec.execute(<span class="keyword">new</span> LiftOff());</span><br><span class="line">        &#125;</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">#0(9),</span></span><br><span class="line"><span class="comment">#0(8),</span></span><br><span class="line"><span class="comment">#0(7),</span></span><br><span class="line"><span class="comment">#0(6),</span></span><br><span class="line"><span class="comment">#0(5),</span></span><br><span class="line"><span class="comment">#0(4),</span></span><br><span class="line"><span class="comment">#0(3),</span></span><br><span class="line"><span class="comment">#0(2),</span></span><br><span class="line"><span class="comment">#0(1),</span></span><br><span class="line"><span class="comment">#0(LiftOff),</span></span><br><span class="line"><span class="comment">#1(9),</span></span><br><span class="line"><span class="comment">#1(8),</span></span><br><span class="line"><span class="comment">#1(7),</span></span><br><span class="line"><span class="comment">#1(6),</span></span><br><span class="line"><span class="comment">#1(5),</span></span><br><span class="line"><span class="comment">#1(4),</span></span><br><span class="line"><span class="comment">#1(3),</span></span><br><span class="line"><span class="comment">#1(2),</span></span><br><span class="line"><span class="comment">#1(1),</span></span><br><span class="line"><span class="comment">#1(LiftOff),</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>如果向<strong>SingleThreadExecutor</strong>提交多个任务，那么这些任务将排队执行，每个任务都会在下一个任务开始之前运行结束，所有的任务将使用相同的线程。每个任务都是按照它们被提交的顺序，并且是在下一个任务开始之前完成的。</p>
<h3 id="从任务中产生返回值"><a href="#从任务中产生返回值" class="headerlink" title="从任务中产生返回值"></a>从任务中产生返回值</h3><p>Runnable是执行工作的独立任务，但是它不返回任何值。如果希望任务字在完成时能够返回一个值，那么可以实现<strong>Callable</strong>接口。调用Callable中的call()方法获取返回值。并且必须使用<code>ExecutorService.submit()</code>调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> out;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaskWithResult</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TaskWithResult</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Result Value is "</span>+id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">        ArrayList&lt;Future&lt;String&gt;&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            results.add(exec.submit(<span class="keyword">new</span> TaskWithResult(i)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Future&lt;String&gt; fs = results.get(0);</span></span><br><span class="line">        <span class="comment">// System.out.println(fs.get());</span></span><br><span class="line">        <span class="comment">// exec.shutdown();</span></span><br><span class="line">        <span class="keyword">for</span>(Future&lt;String&gt; fs:results)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                System.out.println(fs.get());</span><br><span class="line">            &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">                exec.shutdown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Result Value is 0</span></span><br><span class="line"><span class="comment">Result Value is 1</span></span><br><span class="line"><span class="comment">Result Value is 2</span></span><br><span class="line"><span class="comment">Result Value is 3</span></span><br><span class="line"><span class="comment">Result Value is 4</span></span><br><span class="line"><span class="comment">Result Value is 5</span></span><br><span class="line"><span class="comment">Result Value is 6</span></span><br><span class="line"><span class="comment">Result Value is 7</span></span><br><span class="line"><span class="comment">Result Value is 8</span></span><br><span class="line"><span class="comment">Result Value is 9</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>使用<code>submit()</code>方法来执行<strong>Callable</strong>的导出类，submit()会产生<strong>Future</strong>对象，用Callable返回结果的特定类型进行了参数化。当任务执行完成时，它具有一个结果，可以调用<code>get()</code>方法来获取该结果。</p>
<h3 id="后台线程"><a href="#后台线程" class="headerlink" title="后台线程"></a>后台线程</h3><p>后台线程就是指在程序运行的时候在后台提供一种通用服务的线程，并且这种并不属于程序中不可或缺的部分。因此，当所有的非后台线程结束时，程序也就终止了，同时会杀死进程中的所有后台线程。反过来说，只要任何非后台线程还在运行，程序就不会终止。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> out;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleDaemons</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">                System.out.println(Thread.currentThread()+<span class="string">" "</span>+<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            Thread daemon = <span class="keyword">new</span> Thread(<span class="keyword">new</span> SimpleDaemons());</span><br><span class="line">            daemon.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">            daemon.start();</span><br><span class="line">            System.out.println(<span class="string">"All daemon started"</span>);</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">175</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">All daemon started</span></span><br><span class="line"><span class="comment">Thread[Thread-4,5,main] out.SimpleDaemons@493ee214</span></span><br><span class="line"><span class="comment">Thread[Thread-0,5,main] out.SimpleDaemons@6019722a</span></span><br><span class="line"><span class="comment">Thread[Thread-3,5,main] out.SimpleDaemons@322c0983</span></span><br><span class="line"><span class="comment">Thread[Thread-2,5,main] out.SimpleDaemons@310b8809</span></span><br><span class="line"><span class="comment">Thread[Thread-1,5,main] out.SimpleDaemons@3e4a0b0a</span></span><br><span class="line"><span class="comment">Thread[Thread-5,5,main] out.SimpleDaemons@5512a485</span></span><br><span class="line"><span class="comment">Thread[Thread-4,5,main] out.SimpleDaemons@493ee214</span></span><br><span class="line"><span class="comment">Thread[Thread-0,5,main] out.SimpleDaemons@6019722a</span></span><br><span class="line"><span class="comment">Thread[Thread-3,5,main] out.SimpleDaemons@322c0983</span></span><br><span class="line"><span class="comment">Thread[Thread-2,5,main] out.SimpleDaemons@310b8809</span></span><br><span class="line"><span class="comment">.....</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>必须在线程启动之前调用<code>setDaemon()</code>方法，才能把它设置为后台线程。</p>
<h3 id="加入一个线程"><a href="#加入一个线程" class="headerlink" title="加入一个线程"></a>加入一个线程</h3><p>一个线程可以在其他线程上调用join()方法，其效果是等待一段时间直到第二个线程结束才继续执行。如果某个线程在另一个线程上t调用<code>t.join()</code>，此线程将被挂起，直到目标线程t结束才恢复。也可以在调用join()时带上一个超时参数，这样如果目标线程在这段时间到期时还没有结束的话，join()方法会总能返回。对join()方法的调用可以被中断，做法就是在调用线程上调用interrupt()方法，这时，需要用到try-catch字句。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> out;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sleeper</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> duration;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Sleeper</span><span class="params">(String name,<span class="keyword">int</span> sleepTime)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        duration = sleepTime;</span><br><span class="line">        start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            sleep(duration);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            System.out.println(getName()+<span class="string">" interrupted "</span>+<span class="string">" isInterrupted() "</span>+interrupted());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(getName()+<span class="string">" has awakened "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Joiner</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Sleeper sleeper;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Joiner</span><span class="params">(String name,Sleeper sleeper)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.sleeper = sleeper;</span><br><span class="line">        start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            sleeper.join();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Interrupter"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(getName()+<span class="string">" Join completed "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Joining</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]ares)</span></span>&#123;</span><br><span class="line">        Sleeper sleepy = <span class="keyword">new</span> Sleeper(<span class="string">"Sleepy"</span>,<span class="number">1500</span>),</span><br><span class="line">        grumpy = <span class="keyword">new</span> Sleeper(<span class="string">"Grumpy"</span>,<span class="number">1500</span>);</span><br><span class="line">        Joiner dopey = <span class="keyword">new</span> Joiner(<span class="string">"Dopey"</span>,sleepy),</span><br><span class="line">        doc = <span class="keyword">new</span> Joiner(<span class="string">"Doc"</span>,grumpy);</span><br><span class="line">        grumpy.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Grumpy interrupted  isInterrupted() false</span></span><br><span class="line"><span class="comment">Doc Join completed</span></span><br><span class="line"><span class="comment">Sleepy has awakened</span></span><br><span class="line"><span class="comment">Dopey Join completed</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="共享受限资源"><a href="#共享受限资源" class="headerlink" title="共享受限资源"></a>共享受限资源</h2><h3 id="解决共享资源竞争"><a href="#解决共享资源竞争" class="headerlink" title="解决共享资源竞争"></a>解决共享资源竞争</h3><p>基本上所有的并发模式在解决线程冲突问题的时候，都是采取序列化访问共享资源的方案。这就意味着在给定时刻只允许一个任务访问共享资源。通常这是通过代码前面加上一条锁语句来实现，这就使得在一段时间内只有一个任务可以运行这段代码。因为锁语句产生了一种互斥的效果。所以这种机制常常称为<strong>互斥量</strong>。Java提供关键字<strong><code>syschronized</code></strong>的形式，为防止资源冲突提供了内置支持。当任务要执行被<strong>syschronized</strong>标记为。如果某个任务处于一个对标记为<strong>syschronized</strong>的方法在调用中，那么在这个线程从该方法返回之前，其他所有要调用类中任何标记为<strong>syschronized</strong>方法的线程都会被阻塞。下面是syschronized声明的方式：</p>
<p><code>syschronized void f(){}</code></p>
<p><code>syschronized void g(){}</code></p>
<p>所有对象都自动含有单一的锁。当在对象上调用其任意<strong>syschronized</strong>方法的时候，此对象都被加锁，这时该对象上的其他<strong>syschronized</strong>方法只有等到前一个方法调用完毕并释放了锁之后才能被调用。对于某个特定对象来说，其所有syschronized方法共享同一个锁，这可以被用来防止多个任务同时访问被编码为对象内存。</p>
<p>在使用并发时，一定将域设置为<strong>private</strong>，这很重要。否则，syschronized关键字就不能防止其他任务直接访问域，这样就会产生冲突。</p>
<p>一个任务可以多次获得对象的锁，如果一个方法在同一个对象上调用了第二个方法，后者又调用了同一对象的上另一个方法，就会发生这种情况。JVM负责跟踪对象被加锁的次数。如果一个对象被解锁，其计数变为0。在任务第一次给对象加锁的时候，计数变为1。每当这个相同的任务在这个对象上获得锁时，计数都会增加。显然，只有首先获得了锁的任务才能允许继续获取多个锁。每当任务离开一个syschronized方法，计数递减，当计数为零时，锁被完全释放，此时别的任务就可以使用此资源。</p>
<p>针对每个类，也有一个锁，所以<strong>syschronized static</strong>方法可以在类的范围内防止对static数据的并发访问。</p>
<p>应该在什么时候同步呢？可以运用一个大佬的同步规则：</p>
<p><strong>如果你正在写一个变量，它可能接下来将被另一个线程读取，或者正在读取一个上次已经被另一个线程写过的变量，那么你必须使用同步，并且，读写线程都必须使用相同的监视器锁同步。</strong></p>
<h3 id="使用显式Lock对象"><a href="#使用显式Lock对象" class="headerlink" title="使用显式Lock对象"></a>使用显式Lock对象</h3><p>Java 1.5的java.util.concurrent类库还包含有定义在java.util.concurrent.locks中显式的互斥机制。<strong>Lock</strong>对象必须被显式地创建、锁定和释放。因此，它与内建的锁形式相比，代码缺乏优雅性。但是，对于解决某些问题来说，它更灵活。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> out;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MutexEvenGenerator</span> <span class="keyword">extends</span> <span class="title">IntGenerator</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> currentEvenValue = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">// public synchronized int next()&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            ++currentEvenValue;</span><br><span class="line">            Thread.yield();</span><br><span class="line">            ++currentEvenValue;</span><br><span class="line">            <span class="keyword">return</span> currentEvenValue;</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        EvenChecker.test(<span class="keyword">new</span> MutexEvenGenerator());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**/</span></span><br></pre></td></tr></table></figure>

<p>MutexEvenGenerator添加了一个互斥调用的锁，并使用lock()和unlock()方法在方法内部创建了临界资源。但是使用<strong>Lock</strong>对象时，这里的惯用法是将其内部化，必须将unlock()方法置于<strong>try-finally</strong>字句中。这里还要注意的是，<strong>return</strong>语句必须在<strong>try</strong>子句中出现，以确保unlock()不会过早发生，从而将数据暴露给第二个任务。</p>
<p>尽管try-finally所需的代码比synchronized关键字多。但是这也代表了显式的Lock对象的一个优点。如果使用synchronized关键字时，某些事物失败，那么就会抛出一个异常。但是没有机会去做任何清理工作，以维护系统使其处于良好的状态。有了显式的 Lock对象，你就可以使用finally子句将系统维护在正确的状态。</p>
<p>当使用synchronized关键字时，需要写的代码量更少，并且用户出现错误的可能性也会降低，因此通常只有在解决特殊问题时，才显式使用Lock对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> out;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AttemptLocking</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">untimed</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> captured = lock.tryLock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"tryLock()："</span>+captured);</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(captured)&#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">timed</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> captured = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            captured = lock.tryLock(<span class="number">2</span>,TimeUnit.SECONDS);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"tryLock(2,TimeUnit.SECONDS)："</span>+captured);</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(captured)&#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]aegs)</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> AttemptLocking atl = <span class="keyword">new</span> AttemptLocking();</span><br><span class="line">        atl.untimed();</span><br><span class="line">        atl.timed();</span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            &#123;setDaemon(<span class="keyword">true</span>);&#125;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                atl.lock.lock();</span><br><span class="line">                System.out.println(<span class="string">"acquired"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">        Thread.yield();</span><br><span class="line">        atl.untimed();</span><br><span class="line">        atl.timed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">tryLock()：true</span></span><br><span class="line"><span class="comment">tryLock(2,TimeUnit.SECONDS)：true</span></span><br><span class="line"><span class="comment">tryLock()：true</span></span><br><span class="line"><span class="comment">tryLock(2,TimeUnit.SECONDS)：true</span></span><br><span class="line"><span class="comment">acquired</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>显式的Lock对象在加锁和释放锁的方面，相对于内建的<strong>synchronized</strong>锁来说，还赋予了更细粒度的控制力，这对于实现专有同步结构是很有用的。</p>
<h3 id="原子性和易变性"><a href="#原子性和易变性" class="headerlink" title="原子性和易变性"></a>原子性和易变性</h3><p>原子操作是不能被线程调度机制中断的操作，一旦操作开始，那么它就一定可以在可能发生的“上下文切换”之前执行完毕。</p>
<p>原子性可以应用于long和double之外的所有基本类型之上的“简单操作”。对于读取和写入除long和double之外的基本类型变量这样的操作，可以确保它们会被当作不可分的操作来操作内存。但是JVM可以将64位的读取和写入当作两个分离的32位操作来执行。这就产生了在一个读取和写入操作中间发生上下文的切换，从而导致不同的任务可以看到不正确的可能性。但是，但定义long或double变量时，如果使用volatile关键字，就会获得原子性。不同的JVM可以任意地提供更强的保证，但是不应该依赖平台相关的特性。</p>
<p><strong>volatile</strong>关键字确保了应用中的可见性，如果将一个域声明为<strong>volatile</strong>的，那么只要对这个域进行写操作，那么所有的读操作就都可以看到这个修改。即便使用了本地缓存，volatile域会立即写入内存中，而读操作就发生在内存中。</p>
<p>在非volatile域上的原子操作不必刷新到内存中去，因此其他读取这个域的任务也不会看到新的值。如果多个任务在同时访问某个域，那么这个域就应该是volatile的，否则，这个域就应该只能经由同步来访问。同步也会导致向内存中刷新，因此如果一个域完全有synchronized方法或语句块来防护，那么就不必将其设置为是volatile的。</p>
<p>一个任务所做的任何写操作对这个任务来说都是可见的，因此如果它只需要在这个任务内部内部可见，那么就不需要将其设置为volatile的。</p>
<p>当一个域的值依赖于它之前的值时，volatile就无法工作了。如果某个域的值受到其他域的值的限制，那么volatile也无法工作。</p>
<p>使用volatile而不是synchronized的唯一安全的情况是类中只有一个可变的域。当然了，第一选择应该是synchronized关键字。这是最安全的方式，而尝试其他任何方式都是有风险的。</p>
<h3 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h3><p>有时希望防止多个线程同时访问方法内部的部分代码，而不是防止访问整个方法。通过这种方式分离出来的代码被称为<strong>临界区</strong>，它也使用synchronized关键字来建立。在这里，<strong>synchronized</strong>被用来指定某个对象，此对象的锁被用来对花括号内的代码进行同步控制：</p>
<p><code>synchronized(syncObject){}</code></p>
<p>这也称之为<strong>同步控制块</strong>，在进入此段代码之前，必须得到syncObject对象的锁。如果其他线程已经得到这个锁，那么就得等到锁被释放以后，才能进入临界区。通过使用同步控制块，而不是对整个方法进行同步控制，可以使多个任务访问对象的时间性能得到显著的提高。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="线程之间的协助"><a href="#线程之间的协助" class="headerlink" title="线程之间的协助"></a>线程之间的协助</h2><h3 id="wait和notifyAll"><a href="#wait和notifyAll" class="headerlink" title="wait和notifyAll()"></a>wait和notifyAll()</h3><p>wait()、notify()以及notifyAll()这些方法是基类Object的一部分。所以，可以把这些方法放进任何同步控制方法里，实际上，只能在同步控制方法或同步控制块里调用这些方法，如果在非同步控制方法里调用这些方法，程序在运行时，将得到一个异常。调用这些方法的任务在调用这些方法前必须拥有对象的锁。</p>
<p>wait()使得可以等待某个条件发生变化，而改变这个条件超出了当前方法的控制能力。通常，这种条件将由另一个任务来改变。wait()会等待外部世界产生变化时将任务挂起，并且只有在notify()或notifyAll()发生时，即表示发生了某些事物，这个任务才会被唤醒并去检查说产生的变化。因此，wait()提供了一种在任务之间对活动同步的方式。</p>
<p>当调用wait()时，就是在声明：已经完成了所能做的事情，因此在这里等待，但是希望其他的synchronized操作在条件合适的情况下能够执行。</p>
<p>有两个版本的wait()。一种接受毫秒数作为参数，含义与sleep()方法里参数的意思相同。对于wait()而言：</p>
<ul>
<li>在wait()期间对象锁是释放的。</li>
<li>可以通过notify()、notifyAll()，或者令时间到期，从wait()中恢复执行。</li>
</ul>
<p>另一种wait()不接受任务参数。这种wait()将无限等待下去，直到线程接收到notify()或者notifyAll()的消息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> out;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> waxOn = <span class="keyword">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">waxed</span><span class="params">()</span></span>&#123;</span><br><span class="line">        waxOn = <span class="keyword">true</span>;</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">buffed</span><span class="params">()</span></span>&#123;</span><br><span class="line">        waxOn =<span class="keyword">false</span>;</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">waitForWaxing</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(waxOn == <span class="keyword">false</span>)&#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WaxOn</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Car car;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WaxOn</span><span class="params">(Car c)</span></span>&#123;</span><br><span class="line">        car = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(!Thread.interrupted())&#123;</span><br><span class="line">                System.out.println(<span class="string">" Wax On! "</span>);</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                car.waxed();</span><br><span class="line">                car.waitForWaxing();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Exiting via interrupt"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Ending Wax On task"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WaxOff</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Car car;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WaxOff</span><span class="params">(Car c)</span></span>&#123;</span><br><span class="line">        car = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(!Thread.interrupted())&#123;</span><br><span class="line">                car.waitForWaxing();</span><br><span class="line">                System.out.println(<span class="string">"Wax Off!"</span>);</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                car.buffed();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Exiting via interrupt"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">            System.out.println(<span class="string">"Ending Wax Off task"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaxOMatic</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Car car = <span class="keyword">new</span> Car();</span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">        exec.execute(<span class="keyword">new</span> WaxOn(car));</span><br><span class="line">        exec.execute(<span class="keyword">new</span> WaxOff(car));</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Wax On!</span></span><br><span class="line"><span class="comment"> Wax On!</span></span><br><span class="line"><span class="comment">Wax Off!</span></span><br><span class="line"><span class="comment"> Wax On!</span></span><br><span class="line"><span class="comment">Wax Off!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="新类库中的组件"><a href="#新类库中的组件" class="headerlink" title="新类库中的组件"></a>新类库中的组件</h2><h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><p>这个组件被用来同步一个或多个任务，强制它们等待由其任务执行的一组操作完成。</p>
<p>可以向<strong>CountDownLatch</strong>对象设置一个初始计数值，任何在这个对象上调用wait()的方法都被阻塞，直至这个计数值为0，其他任务在结束其工作时，可以在该对象上调用countDown()来减小这个数值。CountDownLatch被设计为只触发一次，计数值不能被重置。如果需要重置计数值的版本，则可使用<strong>CyclicBarrier</strong>。</p>
<p>调用countDown()的任务在产生这个调用时并没被阻塞，只有对await()的调用会被阻塞，直至计数值到达0。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> out;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaskPortion</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> id = counter++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch latch;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TaskPortion</span><span class="params">(CountDownLatch latch)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.latch = latch;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            doWork();</span><br><span class="line">            latch.countDown();<span class="comment">// 减少锁存数的计数，如果计数到零，则释放所有等待的线程</span></span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(rand.nextInt(<span class="number">2000</span>));</span><br><span class="line">        System.out.println(<span class="keyword">this</span>+<span class="string">"Completed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">"%1$-3d"</span>,id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WaitingTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> id = counter++;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch latch;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WaitingTask</span><span class="params">(CountDownLatch latch)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.latch = latch;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            </span><br><span class="line">            latch.await();<span class="comment">// 当前线程等待锁计数值降到零</span></span><br><span class="line">            System.out.println(<span class="string">"Latch barrier passed for "</span>+<span class="keyword">this</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            System.out.println(<span class="keyword">this</span>+<span class="string">"interrupted"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">"WaitingTask %1$-3d"</span>,id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchDemo</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIZE = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">        CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(SIZE);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            exec.execute(<span class="keyword">new</span> WaitingTask(latch));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            exec.execute(<span class="keyword">new</span> TaskPortion(latch));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Launched all tasks"</span>);</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Launched all tasks</span></span><br><span class="line"><span class="comment">7  Completed</span></span><br><span class="line"><span class="comment">9  Completed</span></span><br><span class="line"><span class="comment">5  Completed</span></span><br><span class="line"><span class="comment">···</span></span><br><span class="line"><span class="comment">3  Completed</span></span><br><span class="line"><span class="comment">Latch barrier passed for WaitingTask 1</span></span><br><span class="line"><span class="comment">Latch barrier passed for WaitingTask 8</span></span><br><span class="line"><span class="comment">···</span></span><br><span class="line"><span class="comment">Latch barrier passed for WaitingTask 5</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="CycliBarrier"><a href="#CycliBarrier" class="headerlink" title="CycliBarrier"></a>CycliBarrier</h3><p>CycliBarrier适用于创建一组任务，它们并行地执行工作，然后进行下一步骤之前等待，直至所有任务都完成。它使得所有的任务都将在栅栏处列队，因此可以一致地向前移动。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> out;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Horse</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> id = counter++;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> strides = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CyclicBarrier barrier;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Horse</span><span class="params">(CyclicBarrier barrier)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.barrier = barrier;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">getStrides</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> strides;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(!Thread.interrupted())&#123;</span><br><span class="line">                <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">                    strides += rand.nextInt(<span class="number">3</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            barrier.await();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Horse "</span>+id+<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">tracks</span><span class="params">()</span></span>&#123;</span><br><span class="line">        StringBuilder s = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;getStrides();i++)&#123;</span><br><span class="line">            s.append(<span class="string">"*"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        s.append(id);</span><br><span class="line">        <span class="keyword">return</span> s.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierDemo</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FINISH_LINE = <span class="number">75</span>;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Horse&gt; horselist = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">    <span class="keyword">private</span> CyclicBarrier barrier;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrierDemo</span><span class="params">(<span class="keyword">int</span> nhorse,<span class="keyword">final</span> <span class="keyword">int</span> pause)</span></span>&#123;</span><br><span class="line">        barrier = <span class="keyword">new</span> CyclicBarrier(nhorse,<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                StringBuilder s = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;FINISH_LINE;i++)&#123;</span><br><span class="line">                    s.append(<span class="string">"="</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(s);</span><br><span class="line">                <span class="keyword">for</span>(Horse h:horselist)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(h.getStrides()&gt;=FINISH_LINE)&#123;</span><br><span class="line">                        System.out.println(h+<span class="string">"won"</span>);</span><br><span class="line">                        exec.shutdownNow();</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    TimeUnit.MILLISECONDS.sleep(pause);</span><br><span class="line">                &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;nhorse;i++)&#123;</span><br><span class="line">            Horse horse = <span class="keyword">new</span> Horse(barrier);</span><br><span class="line">            horselist.add(horse);</span><br><span class="line">            exec.execute(horse);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> nhorse = <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">int</span> pause = <span class="number">200</span>;</span><br><span class="line">        <span class="keyword">if</span>(args.length&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> n = <span class="keyword">new</span> Integer(args[<span class="number">0</span>]);</span><br><span class="line">            nhorse = n&gt;<span class="number">0</span>?n:nhorse;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(args.length&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> p = <span class="keyword">new</span> Integer(args[<span class="number">1</span>]);</span><br><span class="line">            pause = p&gt;-<span class="number">1</span>?p:pause;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> CyclicBarrierDemo(nhorse,pause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h3><p>这是一种无界的BlockingQueue，用于放置实现<strong>Delayed</strong>接口的对象，其中的对象只能在其到期时才能从队列中取走。这种队列是有序的，即队头对象的延时到期的时间最长、如果没有任何延迟到期，那么就不会有任何头元素，并且<strong>poll()</strong>将返回null。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="性能调优"><a href="#性能调优" class="headerlink" title="性能调优"></a>性能调优</h2><p>在JavaSE5中的<strong><code>java.util.concurrent</code></strong>类库中添加了大量的用于提高性能的类。在阅读<strong>concurrent</strong>源码时，里面对java的容器类做了大量的优化，使其支持高并发。</p>
<h3 id="免锁容器"><a href="#免锁容器" class="headerlink" title="免锁容器"></a>免锁容器</h3><p>Java SE5特别的添加新的容器，通过使用更灵活的技术类消除加锁，从而提高线程安全的性能。</p>
<p>这些免锁容器背后的通用策略是：对容器的修改可以与读取操作同时发生，只要读取者只能看到完成修改的结果即可，修改是在容器数据结构的某个部分的一个单独副本上执行的，并且这个副本在修改过程中是不可视。只有当修改完成时，被修改的结构才会自动地与主数据结构进行交换，之后读取者就可以看到这个修改了。</p>
<p>在CopyOnWriteArrayList中，写入将导致创建整个底层数组的副本，而源数据将保留在原地，使得复制的数组在被修改时，读取操作可以安全地执行。当修改完成时，一个原子性的操作将把新的数组换入，使得新的读取操作可以看到这个新的修改。CopyOnWriteArrayList的好处之一是当多个迭代器同时遍历和修改这个列表时，不会抛出异常，因此不必编写特殊的代码去防范这种异常。</p>
<p>CopyOnWriteArraySet将使用CopyOnWriteArrayList来实现其免锁的行为。</p>
<p>ConcurrentHashMap和ConcurrentLinkedQueue使用了类似的技术，允许并发的读取和写入，但是容器中只有部分内容而不是整个容器可以被复制和修改。在任何修改在完成之前，读取者仍旧不能看到它们。</p>
<h3 id="比较各种Map实现"><a href="#比较各种Map实现" class="headerlink" title="比较各种Map实现"></a>比较各种Map实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java基础编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java字符串</title>
    <url>/2019/12/29/java/java%E5%9F%BA%E7%A1%80/%E3%80%9010%E3%80%91Java%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h2 id="String是不可变的"><a href="#String是不可变的" class="headerlink" title="String是不可变的"></a>String是不可变的</h2><p>String类中每一个看起来会修改String值的方法，实际上都是创建了一个全新的String对象，以包含修改后的字符串内容。而最初的String对象丝毫未动。</p>
<p>每当把String对象作为方法的参数时，都会复制一份引用，而该引用所指的对象其实一直在单一的物理内存的位置上。</p>
<h2 id="重载“-”"><a href="#重载“-”" class="headerlink" title="重载“+”"></a>重载“+”</h2><p>因为String对象具有只读特性，所以指向它的任何引用都不可能改变它的值，因此，也就不会对其他的引用有什么影响。不可变性会带来一定的效率问题。为String对象重载的“+”操作符就是一个例子。操作符“+”可以用来连接String。</p>
<h2 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h2><p>显式地创建<strong>StringBuilder</strong>可以预先为其指定大小。如果已经知道最终的字符串大概有多长，那么预先指定<strong>StringBuilder</strong>的大小可以避免多次重新分配缓冲。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> out;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WitherStringBuilder</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">explicit</span><span class="params">(String[]fields)</span></span>&#123;</span><br><span class="line">        StringBuilder result = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">20</span>;i++)&#123;</span><br><span class="line">            result.append(fields[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]rgs)</span></span>&#123;</span><br><span class="line">        String[] s = <span class="string">"afhdnbakdsopakflndgbufgikfsldfjidob"</span>.split(<span class="string">""</span>);</span><br><span class="line">        System.out.println(Arrays.toString(s));</span><br><span class="line">        String ss = explicit(s);</span><br><span class="line">        System.out.println(ss);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[a, f, h, d, n, b, a, k, d, s, o, p, a, k, f, l, n, d, g, b, u, f, g, i, k, f, s, l, d, f, j, i, d, o, b]</span></span><br><span class="line"><span class="comment">afhdnbakdsopakflndgb</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>StringBuilder</strong>提供了丰富而全面的方法，包括<strong>insert()</strong>，<strong>repleace()</strong>，<strong>substring()</strong>。但是最常用的还是<strong>append()</strong>和<strong>toString()</strong>。StringBuilder是JavaSE5引入的，在这之前Java用的是<strong>StringBuffer</strong>。StringBuffer是线程安全的，但是开销大了些。</p>
<h2 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h2><p>先来看段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> out;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleFormat</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">double</span> y = <span class="number">5.515215</span>D;</span><br><span class="line">        System.out.println(<span class="string">"Row 1: ["</span>+x+<span class="string">" "</span>+y+<span class="string">" ]"</span>);</span><br><span class="line">        System.out.format(<span class="string">"Row 1: [%d , %f]\n"</span>,x,y);</span><br><span class="line">        System.out.printf(<span class="string">"Row 1: [%d , %f]\n"</span>,x,y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Row 1: [5 5.515215 ]</span></span><br><span class="line"><span class="comment">Row 1: [5 , 5.515215]</span></span><br><span class="line"><span class="comment">Row 1: [5 , 5.515215]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>在上面的代码中，首先将x的值插入%d位置上，然后将y的值插入到%f的位置上。这些占位符称之为<strong>格式修饰符</strong>，它们不但说明插入数据的位置，同时还说明了将插入什么类型的变量，以及如何对其格式化。</p>
<h3 id="Formatter类"><a href="#Formatter类" class="headerlink" title="Formatter类"></a>Formatter类</h3><p>在Java中，所有新的格式化功能都有java.util.Formatter类处理。Formatter类将需要格式化的字符串与数据格式化成需要的结果。当创建一个Formatter对象的时候，需要向其构造器传递一些信息，告诉Formatter最终的结果将向哪里输出。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> out;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Turtle</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Formatter f;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Turtle</span><span class="params">(String name,Formatter f)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.f = f;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        f.format(<span class="string">"%s --&gt; ( %d %d )\n"</span>,name,x,y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        PrintStream outAlias = System.out;</span><br><span class="line">        Turtle tommy = <span class="keyword">new</span> Turtle(<span class="string">"tommy"</span>,<span class="keyword">new</span> Formatter(System.out));</span><br><span class="line">        Turtle terry = <span class="keyword">new</span> Turtle(<span class="string">"terry"</span>,<span class="keyword">new</span> Formatter(outAlias));</span><br><span class="line">        tommy.move(<span class="number">1</span>,<span class="number">5</span>);</span><br><span class="line">        terry.move(<span class="number">41</span>,<span class="number">56</span>);</span><br><span class="line">        tommy.move(<span class="number">14</span>,<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">tommy --&gt; ( 1 5 )</span></span><br><span class="line"><span class="comment">terry --&gt; ( 41 56 )</span></span><br><span class="line"><span class="comment">tommy --&gt; ( 14 4 )</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="格式化说明符"><a href="#格式化说明符" class="headerlink" title="格式化说明符"></a>格式化说明符</h3><p>在插入数据时，如果想要控制空格与对齐，那么需要更精细复杂的格式修饰符，下面是其抽象的语法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">%[argument_index$][flags][width][.precision]conversion</span><br></pre></td></tr></table></figure>

<p>最常见的应用是控制一个域的最小尺寸，这可以通过指定<strong>width</strong>来实现，Formatter对象通过在必要时添加空格，来确保一个域至少达到某个长度，在默认的情况下，数据是右对齐，不过可以使用“-”标志来改变对其方向。</p>
<p>与<strong>width</strong>相对的是<strong>precision</strong>，它用来指明最大尺寸。<strong>width</strong>可以应用于各种类型的数据转换，并且其行为方式都一样。则<strong>precision</strong>不然，不是所有类型的数据都能使用<strong>precision</strong>，而且，应用于不同类型的数据转换时，<strong>precision</strong>意义也不同。将<strong>precision</strong>应用与<strong>String</strong>时，表示打印<strong>String</strong>时输出字符的最大数量。而在将<strong>precision</strong>应用于浮点型数据时，表示小数部分要显示出来的位数，如果小数位数过多则舍入，太少则在尾部补零。由于整数没有小数部分，所以<strong>precision</strong>无法用于整数。如果应用于整数，则会触发异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> out;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Receipt</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> total = <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">private</span> Formatter f = <span class="keyword">new</span> Formatter(System.out);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printTitle</span><span class="params">()</span></span>&#123;</span><br><span class="line">        f.format(<span class="string">"%-15s %5s %10s\n"</span>,<span class="string">"Item"</span>,<span class="string">"Qty"</span>,<span class="string">"Price"</span>);</span><br><span class="line">        f.format(<span class="string">"%-15s %5s %10s\n"</span>,<span class="string">"----"</span>,<span class="string">"----"</span>,<span class="string">"----"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String name,<span class="keyword">int</span> qty,<span class="keyword">double</span> price)</span></span>&#123;</span><br><span class="line">        f.format(<span class="string">"%-15.15s %5d %10.2f\n"</span>,name,qty,price);</span><br><span class="line">        total+=price;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printTotal</span><span class="params">()</span></span>&#123;</span><br><span class="line">        f.format(<span class="string">"%-15s %5s %10.2f\n"</span>,<span class="string">"Tax"</span>,<span class="string">""</span>,total*<span class="number">0.06</span>);</span><br><span class="line">        f.format(<span class="string">"%-15s %5s %10s\n"</span>,<span class="string">""</span>,<span class="string">""</span>,<span class="string">"-----"</span>);</span><br><span class="line">        f.format(<span class="string">"%-15s %5s %10.2f\n"</span>,<span class="string">"Total"</span>,<span class="string">""</span>,total*<span class="number">0.06</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]ares)</span></span>&#123;</span><br><span class="line">        Receipt r = <span class="keyword">new</span> Receipt();</span><br><span class="line">        r.printTitle();</span><br><span class="line">        r.print(<span class="string">"Yang"</span>,<span class="number">4</span>,<span class="number">3.33</span>);</span><br><span class="line">        r.print(<span class="string">"s"</span>,<span class="number">8</span>,<span class="number">4</span>);</span><br><span class="line">        r.printTotal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Item              Qty      Price</span></span><br><span class="line"><span class="comment">----             ----       ----</span></span><br><span class="line"><span class="comment">Yang                4       3.33</span></span><br><span class="line"><span class="comment">s                   8       4.00</span></span><br><span class="line"><span class="comment">Tax                         0.98</span></span><br><span class="line"><span class="comment">                           -----</span></span><br><span class="line"><span class="comment">Total                       0.98</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="Formatter转换"><a href="#Formatter转换" class="headerlink" title="Formatter转换"></a>Formatter转换</h3><table>
<thead>
<tr>
<th>d 整数型</th>
<th>e 浮点数 （科学计数）</th>
</tr>
</thead>
<tbody><tr>
<td>c Unicode字符</td>
<td>x 整数（十六进制）</td>
</tr>
<tr>
<td>b Boolean值</td>
<td>h 散列码（十六进制）</td>
</tr>
<tr>
<td>s String</td>
<td>% 字符“%”</td>
</tr>
<tr>
<td>f 浮点数（十进制）</td>
<td></td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> out;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Conversion</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]areg)</span></span>&#123;</span><br><span class="line">        Formatter f = <span class="keyword">new</span> Formatter(System.out);</span><br><span class="line">        <span class="keyword">char</span> u = <span class="string">'k'</span>;</span><br><span class="line">        System.out.println(u);</span><br><span class="line">        f.format(<span class="string">"s：%s\n"</span>,u);</span><br><span class="line">        f.format(<span class="string">"c：%c\n"</span>,u);</span><br><span class="line">        f.format(<span class="string">"b：%b\n"</span>,u);</span><br><span class="line">        f.format(<span class="string">"h：%h\n"</span>,u);</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="keyword">int</span> v = <span class="number">121</span>;</span><br><span class="line">        System.out.println(v);</span><br><span class="line">        f.format(<span class="string">"s：%s\n"</span>,v);</span><br><span class="line">        f.format(<span class="string">"c：%c\n"</span>,v);</span><br><span class="line">        f.format(<span class="string">"b：%b\n"</span>,v);</span><br><span class="line">        f.format(<span class="string">"h：%h\n"</span>,v);</span><br><span class="line">        f.format(<span class="string">"x：%x\n"</span>,v);</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="keyword">double</span> x = <span class="number">121.454</span>;</span><br><span class="line">        System.out.println(x);</span><br><span class="line">        f.format(<span class="string">"s：%s\n"</span>,x);</span><br><span class="line">        <span class="comment">// f.format("c：%c\n",x);</span></span><br><span class="line">        f.format(<span class="string">"b：%b\n"</span>,x);</span><br><span class="line">        f.format(<span class="string">"h：%h\n"</span>,x);</span><br><span class="line">        <span class="comment">// f.format("x：%x\n",x);</span></span><br><span class="line">        f.format(<span class="string">"e：%e\n"</span>,x);</span><br><span class="line">        f.format(<span class="string">"f：%f\n"</span>,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">k</span></span><br><span class="line"><span class="comment">s：k</span></span><br><span class="line"><span class="comment">c：k</span></span><br><span class="line"><span class="comment">b：true</span></span><br><span class="line"><span class="comment">h：6b</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">121</span></span><br><span class="line"><span class="comment">s：121</span></span><br><span class="line"><span class="comment">c：y</span></span><br><span class="line"><span class="comment">b：true</span></span><br><span class="line"><span class="comment">h：79</span></span><br><span class="line"><span class="comment">x：79</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">121.454</span></span><br><span class="line"><span class="comment">s：121.454</span></span><br><span class="line"><span class="comment">b：true</span></span><br><span class="line"><span class="comment">h：165a459d</span></span><br><span class="line"><span class="comment">e：1.214540e+02</span></span><br><span class="line"><span class="comment">f：121.454000</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>正则表达式是一种强大而灵活的文本处理工具。使用正则表达式，能够以编程的方式，构造复杂的文本模式，并对输入的字符进行搜索。</p>
<h3 id="创建正则表达式"><a href="#创建正则表达式" class="headerlink" title="创建正则表达式"></a>创建正则表达式</h3><p>但需要使用正则表达式时，可以参考java.util.regex包中的Pattern类。</p>
<p>下面介绍使用正则表达式时需要掌握的知识：</p>
<ul>
<li><p>字符：</p>
<table>
<thead>
<tr>
<th>B</th>
<th>指定字符B</th>
</tr>
</thead>
<tbody><tr>
<td>\xhh</td>
<td>十六进制值为oxhh的字符</td>
</tr>
<tr>
<td>\uhhhh</td>
<td>十六进制表示为oxhhhh的Unicode字符</td>
</tr>
<tr>
<td>\t</td>
<td>制表符</td>
</tr>
<tr>
<td>\n</td>
<td>换行符</td>
</tr>
<tr>
<td>\r</td>
<td>回车</td>
</tr>
<tr>
<td>\e</td>
<td>转义</td>
</tr>
</tbody></table>
</li>
<li><p>字符类：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>.</th>
<th>任意字符</th>
</tr>
</thead>
<tbody><tr>
<td>[abc]</td>
<td>包含a,b,c的任何字符</td>
</tr>
<tr>
<td>[^abc]</td>
<td>除了a,b,c之外的任何字符</td>
</tr>
<tr>
<td>[a-zA-Z]</td>
<td>从a到z或从A到Z的任何字符</td>
</tr>
<tr>
<td>[abc&amp;&amp;[hij]]</td>
<td>任意a，b，c，h，i，j字符（与a|b|c|h|i|j）（合并）</td>
</tr>
<tr>
<td>[a-z&amp;&amp;[hij]]</td>
<td>任意h，i，j</td>
</tr>
<tr>
<td>\s</td>
<td>空白符</td>
</tr>
<tr>
<td>\S</td>
<td>非空白符</td>
</tr>
<tr>
<td>\d</td>
<td>数字[0-9]</td>
</tr>
<tr>
<td>\D</td>
<td>非数字</td>
</tr>
<tr>
<td>\w</td>
<td>词字符[a-zA-Z0-9]</td>
</tr>
</tbody></table>
<ul>
<li><p>逻辑操作符</p>
<table>
<thead>
<tr>
<th>XY</th>
<th>Y跟在X后面</th>
</tr>
</thead>
<tbody><tr>
<td>X|Y</td>
<td>X或Y</td>
</tr>
<tr>
<td>(X)</td>
<td>捕获组</td>
</tr>
</tbody></table>
</li>
<li><p>边界匹配符</p>
<table>
<thead>
<tr>
<th>^</th>
<th>一行的起始</th>
</tr>
</thead>
<tbody><tr>
<td>$</td>
<td>一行的结束</td>
</tr>
<tr>
<td>\b</td>
<td>词的边界</td>
</tr>
<tr>
<td>\B</td>
<td>非词边界</td>
</tr>
<tr>
<td>\G</td>
<td>前一个匹配的结束</td>
</tr>
</tbody></table>
</li>
</ul>
<p>来看一段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> out;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rudolph</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        String[] strs = &#123;<span class="string">"Rudolph"</span>,<span class="string">"[rR]udolph"</span>,<span class="string">"[rR][aeiou][a-z]ol.*"</span>,<span class="string">"R.*"</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(String str:strs)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Rudolph"</span>.matches(str));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">true</span></span><br><span class="line"><span class="comment">true</span></span><br><span class="line"><span class="comment">true</span></span><br><span class="line"><span class="comment">true</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h3><p><strong>量词</strong>描述的是一个模式匹配输入文本的方式</p>
<ul>
<li><p>贪婪型</p>
<p>贪婪型表达式会为所有可能的模式发现尽可能多的匹配。一个经典理由就是假设模式仅能匹配第一个可能的字符组，如果它是贪婪的，那么它就会继续往下匹配。</p>
</li>
<li><p>勉强型</p>
<p>使用问号来指定，这个量词匹配满足模式所需的最少字符数。</p>
</li>
<li><p>占有型</p>
<p>这类的量词只有在Java中能够使用，其他的语言不能。当正则表达式被应用于字符串时，它会产生相当多的状态，以便在匹配失败时，可以回溯，而占有型量词并不能保存这些中间状态，因此可以防止回溯。常常用于防止正则表达式失控，因此可以让正则表达式执行起来更有效。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>贪婪型</th>
<th>勉强型</th>
<th>占有型</th>
<th>如何匹配</th>
</tr>
</thead>
<tbody><tr>
<td>X?</td>
<td>X??</td>
<td>X?+</td>
<td>一个或零个X</td>
</tr>
<tr>
<td>X*</td>
<td>X*?</td>
<td>X*+</td>
<td>零个或多个X</td>
</tr>
<tr>
<td>X+</td>
<td>X+?</td>
<td>X++</td>
<td>一个或多个X</td>
</tr>
<tr>
<td>X{n}</td>
<td>X{n}?</td>
<td>X{n}+</td>
<td>恰好n次X</td>
</tr>
<tr>
<td>X{n,}</td>
<td>X{n,}?</td>
<td>X{n,m}+</td>
<td>至少n次X</td>
</tr>
<tr>
<td>X{n,m}</td>
<td>X{n,m}?</td>
<td>X{n,m}+</td>
<td>X至少n次，且不超过m次</td>
</tr>
</tbody></table>
<p>应该注意一点，表达式X通常必须要用圆括号括起来，以便它能够按照期望的效果去执行。例如：abc+，应该为(abc)+</p>
<p>接下来介绍两个与正则表达式相关的类：<strong>Pattern</strong>和<strong>Matcher</strong></p>
<h3 id="Pattern和Matcher"><a href="#Pattern和Matcher" class="headerlink" title="Pattern和Matcher"></a><strong>Pattern</strong>和<strong>Matcher</strong></h3><p>一般来说必须功能有限的String类，有时更希望使用功能强大的正则表达式对象。只需要导入java,util.regex包。然后用static Pattern.complie()方法来编译正则表达式即可。它会根据String类型的正则表达式生成一个Pattern对象。接下来，把想要检索的字符串传入Pattern对象的matcher()方法。matcher()会生成一个Matcher对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> out;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestRegularExpression</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(args.length&lt;<span class="number">2</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Bye"</span>);</span><br><span class="line">            System.exit(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Input：\""</span>+args[<span class="number">0</span>]+<span class="string">"\""</span>);</span><br><span class="line">        <span class="keyword">for</span>(String s:args)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Regular expression：\""</span>+s+<span class="string">"\""</span>);</span><br><span class="line">            Pattern p = Pattern.compile(s);</span><br><span class="line">            Matcher m = p.matcher(args[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">while</span>(m.find())&#123;</span><br><span class="line">                System.out.println(<span class="string">"Match \""</span>+ m.group()+</span><br><span class="line">                <span class="string">"\"at positions"</span>+m.start()+<span class="string">"-"</span>+(m.end()-<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">cmd:java -cp ./ out.TestRegularExpression abcabcabcabcabcabcabc <span class="string">"abc+"</span> <span class="string">"(abc)+"</span> <span class="string">"(abc)&#123;2,&#125;"</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Input："abcabcabcabcabcabcabc"</span></span><br><span class="line"><span class="comment">Regular expression："abcabcabcabcabcabcabc"</span></span><br><span class="line"><span class="comment">Match "abcabcabcabcabcabcabc"at positions0-20</span></span><br><span class="line"><span class="comment">Regular expression："abc+"</span></span><br><span class="line"><span class="comment">Match "abc"at positions0-2</span></span><br><span class="line"><span class="comment">Match "abc"at positions3-5</span></span><br><span class="line"><span class="comment">Match "abc"at positions6-8</span></span><br><span class="line"><span class="comment">Match "abc"at positions9-11</span></span><br><span class="line"><span class="comment">Match "abc"at positions12-14</span></span><br><span class="line"><span class="comment">Match "abc"at positions15-17</span></span><br><span class="line"><span class="comment">Match "abc"at positions18-20</span></span><br><span class="line"><span class="comment">Regular expression："(abc)+"</span></span><br><span class="line"><span class="comment">Match "abcabcabcabcabcabcabc"at positions0-20</span></span><br><span class="line"><span class="comment">Regular expression："(abc)&#123;2,&#125;"</span></span><br><span class="line"><span class="comment">Match "abcabcabcabcabcabcabc"at positions0-20</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> out;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Finding</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        Matcher m = Pattern.compile(<span class="string">"\\w+"</span>).matcher(<span class="string">"Evening is full of the linnet`s wings"</span>);</span><br><span class="line">        <span class="keyword">while</span>(m.find())&#123;</span><br><span class="line">            System.out.print(m.group()+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(m.find(i))&#123;</span><br><span class="line">            System.out.print(m.group()+<span class="string">" "</span>);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Evening is full of the linnet s wings</span></span><br><span class="line"><span class="comment">Evening vening ening ning ing ng g is is s full full ull ll l of of f the the he e linnet linnet innet nnet net et t s s wings wings ings ngs gs s</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>Pattern标记</p>
<p>Pattern的compile()方法还有一个版本，它接受一个标记参数，以调整匹配的行为：</p>
<p><code>compile(String regx,int flag)</code></p>
<p>其中的<strong>flag</strong>来自一下Pattern类的常量</p>
<table>
<thead>
<tr>
<th>编译标记</th>
<th>效果</th>
</tr>
</thead>
<tbody><tr>
<td>Pattern.CANON_EQ</td>
<td>两个字符当且仅当它们的完全规范分解相匹配时，就认为它们是匹配的。</td>
</tr>
<tr>
<td>Pattern.CASE_INSENSITIVE</td>
<td>默认情况下，大小写不敏感的匹配假设只有US-ASCII字符集中的字符才能进行。这个标记不考虑允许模式匹配不必考虑大小写。通过结合UNICODE_CASE标记，基于Unicode的大小写不敏感的匹配就会开启</td>
</tr>
<tr>
<td>Pattern.COMMENTS</td>
<td>空格字符将被忽略，并且以#开始直到行末的注释也会被忽略掉。</td>
</tr>
<tr>
<td>Pattern.DOTALL</td>
<td>表达式”.”匹配所有字符，包括行终结符。默认情况下，“.”表达式不匹配行终结符</td>
</tr>
<tr>
<td>Pattern.MULTILINE</td>
<td>在多行模式下，表达式^和$分别匹配一行的开始和结束。 ^还匹配输入字符串的开始，而$还匹配输入字符串的结尾。</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> out;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReFlags</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        Pattern p = Pattern.compile(<span class="string">"^java"</span>,Pattern.CASE_INSENSITIVE|Pattern.MULTILINE);</span><br><span class="line">        Matcher m = p.matcher(<span class="string">"java has regex\nJava has regex\n"</span>+</span><br><span class="line">        <span class="string">"JAVA has pertty good\n"</span>+</span><br><span class="line">        <span class="string">"Reggs a in Java"</span></span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">while</span>(m.find())&#123;</span><br><span class="line">            System.out.println(m.group());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">java</span></span><br><span class="line"><span class="comment">Java</span></span><br><span class="line"><span class="comment">JAVA</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java基础编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java集合框架</title>
    <url>/2019/12/27/java/java%E5%9F%BA%E7%A1%80/%E3%80%909%E3%80%91Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>Java集合框架的用途就是保存对象，并将其划分为两个不同的概念：</p>
<p>（1）<strong>Collection</strong>：一个独立元素的序列，这些元素都服从一条或多条规则。<strong>List</strong>必须按照插入的顺序保存元素，而<strong>Set</strong>不能有重复元素。<strong>Queue</strong>按照排队规则来确定对象的产生顺序。</p>
<p>（2）<strong>Map</strong>，一组成对的<strong>键值对</strong>对象，允许使用键来查找。</p>
<p>Collection接口概括了序列的概念——一种存放一组对象的方式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> out;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleCollection</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        Collection&lt;Integer&gt; c = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            c.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> a:c)&#123;<span class="comment">//所有的Collection都可以使用foreach语法</span></span><br><span class="line">            System.out.println(a);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(c.size());</span><br><span class="line">        <span class="comment">// System.out.println(c);</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">0</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment">7</span></span><br><span class="line"><span class="comment">8</span></span><br><span class="line"><span class="comment">9</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">10</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="添加一组元素"><a href="#添加一组元素" class="headerlink" title="添加一组元素"></a>添加一组元素</h2><p>java.util包中的<strong>Arrays</strong>和Collection类中都有很多实用方法，可以在一个Collection中添加一组元素。Arrays.asList()方法接受一个数组或是一个用逗号分隔的元素列表，并将其转换为一个List对象。</p>
<p><strong>Collections.addAll()</strong>方法接受一个Collection对象，以及一个数组或是一个用逗号分割的列表。将元素添加到Collection中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> out;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AddingGroups</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        Collection&lt;Integer&gt; collection = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Integer[] moreInts = &#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        <span class="comment">//将moreInts数组加入到collection中</span></span><br><span class="line">        collection.addAll(Arrays.asList(moreInts));</span><br><span class="line">        <span class="comment">//将数组加入到collection中</span></span><br><span class="line">        Collections.addAll(collection,<span class="number">12</span>,<span class="number">45</span>,<span class="number">78</span>);</span><br><span class="line">        Collections.addAll(collection,moreInts);</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; list = Arrays.asList(<span class="number">15</span>,<span class="number">4</span>,<span class="number">51</span>,<span class="number">54</span>,<span class="number">541</span>,<span class="number">52</span>,<span class="number">4</span>,<span class="number">51</span>,<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"list："</span>+list);</span><br><span class="line">        <span class="comment">//修改index对应的值</span></span><br><span class="line">        list.set(<span class="number">1</span>,<span class="number">99</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"collection："</span>+collection);</span><br><span class="line">        System.out.println(<span class="string">"list："</span>+list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">list：[15, 4, 51, 54, 541, 52, 4, 51, 5]</span></span><br><span class="line"><span class="comment">collection：[1, 4, 6, 5, 4, 5, 4, 8, 7, 4, 12, 45, 78, 1, 4, 6, 5, 4, 5, 4, 8, 7, 4]</span></span><br><span class="line"><span class="comment">list：[15, 99, 51, 54, 541, 52, 4, 51, 5]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>Collection</strong>的构造器可以接受另一个<strong>Collection</strong>，用它来将自身初始化，因此可以使用<strong>Arrays.asList()</strong>来为这个构造器产生输入。但是，Collection.addAll()方法运行起来要快的多，而且构建一个不包含元素的Collection，然后调用Collection.addAll()这种方式很方便，因此它是首选的方式。</p>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p><strong>List</strong>承诺可以将元素维护在特定的序列中。<strong>List</strong>接口在Collection的基础上添加了大量的方法，使得可以在List的中间插入和移除元素。</p>
<ul>
<li><p>有两种类型List：</p>
<p>基本的<strong>ArrayList</strong>，它长于随机访问元素，但是在List的中间插入和移除元素时较慢。</p>
<p><strong>LinkedList</strong>，它通过代价较低的在List中间进行的插入和删除操作，提供了优化的顺序访问。LinkedList再随机访问方面相对比较慢。</p>
</li>
</ul>
<p>contains()方法用来确定某个元素是否在列表中。remove()方法可以移除一个元素。更多的List方法去查阅官方文档。</p>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p><strong>Set</strong>不保存重复的元素。<strong>Set</strong>中最常被使用的是测试归属性，因此，查找就成为了Set中最重要的操作。<strong>Set</strong>具有与<strong>Collection</strong>完全一样的接口，因此没有任何额外的功能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> out;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SetOfInteger</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">        Set&lt;Integer&gt; inset = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            inset.add(rand.nextInt(<span class="number">30</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(inset);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>Set</strong>的归属性测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> out;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SetOperations</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        Set&lt;String&gt; sets = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        Collections.addAll(sets,<span class="string">"a b c d e f g h i j k l"</span>.split(<span class="string">" "</span>));</span><br><span class="line">        sets.add(<span class="string">"m"</span>);</span><br><span class="line">        System.out.println(<span class="string">"h :"</span>+sets.contains(<span class="string">"h"</span>));</span><br><span class="line">        System.out.println(<span class="string">"n :"</span>+sets.contains(<span class="string">"n"</span>));</span><br><span class="line">        System.out.println(<span class="string">"m :"</span>+sets.contains(<span class="string">"m"</span>));</span><br><span class="line">        System.out.println(sets);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">h :true</span></span><br><span class="line"><span class="comment">n :false</span></span><br><span class="line"><span class="comment">m :true</span></span><br><span class="line"><span class="comment">[a, b, c, d, e, f, g, h, i, j, k, l, m]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><p>队列是一个<strong>先进先出</strong>的容器。即从容器的一端放入元素，从另一端取出，并且元素放入容器的顺序与取出的顺序是相同的。LinkedList提供了方法以支持队列的行为，并且它实现了<strong>Queue</strong>接口，因此LinkedList可以用作Queue的一种实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> out;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printQ</span><span class="params">(Queue queue)</span></span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(queue.peek() != <span class="keyword">null</span>)&#123;</span><br><span class="line">                System.out.print(queue.remove()+<span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            queue.offer(rand.nextInt(i+<span class="number">10</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        printQ(queue);</span><br><span class="line">        Queue&lt;Character&gt; qc = <span class="keyword">new</span> LinkedList&lt;Character&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c:<span class="string">"Bsdfsshgdh"</span>.toCharArray())&#123;</span><br><span class="line">            qc.offer(c);</span><br><span class="line">        &#125;</span><br><span class="line">        printQ(qc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">8 1 1 1 5 14 3 1 0 1</span></span><br><span class="line"><span class="comment">B s d f s s h g d h</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>上面的代码中offer()方法是与Queue相关的方法之一，<strong>在允许情况下，将一个元素插入队尾，或者返回false。peek()和element()都将在不移除的情况下放回队头，peek()方法在队列为空时返回null,而element()会抛出异常。poll()和remove()方法将移除并返回对头，poll()在队头为空时返回null,而remove()会返回异常。</strong></p>
<h3 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> out;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PriorityQueueDemo</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        PriorityQueue&lt;Integer&gt; priorityeueue = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;();</span><br><span class="line">        Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            priorityeueue.offer(rand.nextInt(i+<span class="number">10</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        QueueDemo.printQ(priorityeueue);</span><br><span class="line">        List&lt;Integer&gt; ints = Arrays.asList(<span class="number">25</span>,<span class="number">1</span>,<span class="number">54</span>,<span class="number">51</span>,<span class="number">86</span>,<span class="number">5</span>,<span class="number">45</span>,<span class="number">79</span>,<span class="number">89</span>,<span class="number">56</span>,<span class="number">75</span>,<span class="number">63</span>,<span class="number">12</span>,<span class="number">25</span>,<span class="number">4</span>);</span><br><span class="line">        priorityeueue = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;(ints);</span><br><span class="line">        QueueDemo.printQ(priorityeueue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">0 1 1 1 1 1 3 5 8 14</span></span><br><span class="line"><span class="comment">1 4 5 12 25 25 45 51 54 56 63 75 79 86 89</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>当在PriorityQueue上调用offer()方法来插入元素时，元素会在队列中被排序。默认的排序将使用元素在队列中的自然顺序，PriorityQueue可以在确保当你调用peek()、poll()、remove()方法时，获取的元素将是队列中优先级最高的元素。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java基础编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java内部类</title>
    <url>/2019/12/25/java/java%E5%9F%BA%E7%A1%80/%E3%80%908%E3%80%91Java%E5%86%85%E9%83%A8%E7%B1%BB/</url>
    <content><![CDATA[<h2 id="创建内部类"><a href="#创建内部类" class="headerlink" title="创建内部类"></a>创建内部类</h2><p>创建内部类就是在把类的定义置于外围类的里面。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> out;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel1</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Contents</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">11</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Destination</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String label;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Destination</span><span class="params">(String whereTo)</span></span>&#123;</span><br><span class="line">            label = whereTo;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">readLable</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> label;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ship</span><span class="params">(String dest)</span></span>&#123;</span><br><span class="line">        Contents c = <span class="keyword">new</span> Contents();</span><br><span class="line">        Destination d = <span class="keyword">new</span> Destination(dest);</span><br><span class="line">        System.out.println(d.readLable());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        Parcel1 p = <span class="keyword">new</span> Parcel1();</span><br><span class="line">        p.ship(<span class="string">"Tasmania"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Tasmania</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>如果想从外部类的静态方法之外的任意位置创建某个内部类的对象，那么必须具体地指明这个对象的类型：<strong>OuterClassName.InnerClassName</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> out;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel2</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Contents</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">11</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Contents："</span>+i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Destination</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String label;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Destination</span><span class="params">(String whereTo)</span></span>&#123;</span><br><span class="line">            label = whereTo;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">readLable</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> label;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Destination："</span>+label;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Destination <span class="title">to</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Destination(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Contents <span class="title">contents</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Contents();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ship</span><span class="params">(String dest)</span></span>&#123;</span><br><span class="line">        Contents c = <span class="keyword">new</span> Contents();</span><br><span class="line">        <span class="comment">// System.out.println(c);</span></span><br><span class="line"></span><br><span class="line">        Destination d = to(dest);</span><br><span class="line">        <span class="comment">// System.out.println(d);</span></span><br><span class="line"></span><br><span class="line">        System.out.println(d.readLable());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        Parcel2 p = <span class="keyword">new</span> Parcel2();</span><br><span class="line">        p.ship(<span class="string">"Tasmania"</span>);</span><br><span class="line"></span><br><span class="line">        Parcel2 q = <span class="keyword">new</span> Parcel2();</span><br><span class="line">        Parcel2.Contents c = q.contents();</span><br><span class="line">        System.out.println(c);</span><br><span class="line"></span><br><span class="line">        Parcel2.Destination d = q.to(<span class="string">"TOOOOOOOOOO"</span>);</span><br><span class="line">        System.out.println(d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Tasmania</span></span><br><span class="line"><span class="comment">Contents：11</span></span><br><span class="line"><span class="comment">Destination：TOOOOOOOOOO</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="链接到外部类"><a href="#链接到外部类" class="headerlink" title="链接到外部类"></a>链接到外部类</h2><p>当生成一个内部类的对象时，此对象与制造它的外围对象之间就有了一种联系，所以它能访问其外围对象的所有成员，而不需任何特殊条件。此外，内部类还拥有其外围类的所有元素访问权。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> out;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Selector</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">end</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Object <span class="title">current</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sequence</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object[]items;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> next=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Sequence</span><span class="params">(<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">        items = <span class="keyword">new</span> Object[size];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(next &lt; items.length)&#123;</span><br><span class="line">            items[next++] = x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">SequenceSelector</span> <span class="keyword">implements</span> <span class="title">Selector</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">end</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> i == items.length;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">current</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> items[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">next</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; items.length)&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Selector <span class="title">selector</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SequenceSelector();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        Sequence sequence = <span class="keyword">new</span> Sequence(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            sequence.add(Integer.toString(i));</span><br><span class="line">        &#125;</span><br><span class="line">        Selector s = sequence.selector();</span><br><span class="line">        <span class="keyword">while</span>(!s.end())&#123;</span><br><span class="line">            System.out.println(s.current()+<span class="string">" "</span>);</span><br><span class="line">            s.next();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">0</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment">7</span></span><br><span class="line"><span class="comment">8</span></span><br><span class="line"><span class="comment">9</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="使用-this和-new"><a href="#使用-this和-new" class="headerlink" title="使用.this和.new"></a>使用.this和.new</h2><p>如果需要生成外部类对象的引用，可以使用外部类的名字后面紧跟<strong><code>.this</code></strong>。这样产生的引用自动的具有正确的类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> out;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dotthis</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Dotthis.f()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Dotthis <span class="title">outer</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Dotthis.<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Inner <span class="title">inner</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Inner();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        Dotthis dt = <span class="keyword">new</span> Dotthis();</span><br><span class="line">        Dotthis.Inner dti = dt.inner();</span><br><span class="line">        dti.outer().f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Dotthis.f()</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>有时可能需要告知某些对象，去创建其某个内部类的对象。要实现这个目的，必须使用<strong><code>new</code></strong>表达式中提供对其他外部类对象的引用，这里使用<strong><code>.new</code></strong>语法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> out;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DotNew</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Inner</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Inner()"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DotNew</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"DotNew()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        DotNew dn = <span class="keyword">new</span> DotNew();</span><br><span class="line">        DotNew.Inner dni = dn.<span class="keyword">new</span> Inner();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">DotNew()</span></span><br><span class="line"><span class="comment">Inner()</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>在拥有外部类对象之前是不能创建内部类对象的。这是因为内部类对象会暗自连接到创建它的外部类对象上，但是，如果创建的嵌套类（静态内部类），那么它就不需要对其外部类对象的引用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> out;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel3</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Contents</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">11</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Contents："</span>+i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Destination</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String label;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Destination</span><span class="params">(String whereTo)</span></span>&#123;</span><br><span class="line">            label = whereTo;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">readLable</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> label;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Destination："</span>+label;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Destination <span class="title">to</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Destination(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Contents <span class="title">contents</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Contents();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ship</span><span class="params">(String dest)</span></span>&#123;</span><br><span class="line">        Contents c = <span class="keyword">new</span> Contents();</span><br><span class="line">        System.out.println(c);</span><br><span class="line"></span><br><span class="line">        Destination d = to(dest);</span><br><span class="line">        System.out.println(d);</span><br><span class="line"></span><br><span class="line">        System.out.println(d.readLable());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        Parcel3 p = <span class="keyword">new</span> Parcel3();</span><br><span class="line">        p.ship(<span class="string">"Tasmania"</span>);</span><br><span class="line"></span><br><span class="line">        Parcel3.Contents c = p.<span class="keyword">new</span> Contents();</span><br><span class="line">        System.out.println(c);</span><br><span class="line">        </span><br><span class="line">        Parcel3.Destination d = p.<span class="keyword">new</span> Destination(<span class="string">"TOOOOOOOOOO"</span>);</span><br><span class="line">        System.out.println(d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Contents：11</span></span><br><span class="line"><span class="comment">Destination：Tasmania</span></span><br><span class="line"><span class="comment">Tasmania</span></span><br><span class="line"><span class="comment">Contents：11</span></span><br><span class="line"><span class="comment">Destination：TOOOOOOOOOO</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><p>先来看一段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> out;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Content</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Content</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.i = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> out;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parce7b</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Content <span class="title">content</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Content(x)&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">super</span>.value()*<span class="number">47</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        Parce7b p = <span class="keyword">new</span> Parce7b();</span><br><span class="line">        Content c = p.content(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>在匿名内部类中，使用了默认的构造器来生成Content。如果基类中需要一个有参数的构造器，那么需要简单的地传递合适的参数给基类构造器即可。在匿名内部类末尾的分号，并不是用来标记此内部类结束的，实际上，它标记的是表达式的结束，只不过这个表达式正巧包含了匿名内部类罢了。</p>
<p>在匿名类中定义字段时，还能够对其执行初始化操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> out;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Destination</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Destination"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parce9</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Destination <span class="title">destination</span><span class="params">(<span class="keyword">final</span> String dest)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Destination()&#123;</span><br><span class="line">            <span class="keyword">private</span> String lable = dest;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">readLable</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="keyword">return</span> lable;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        Parce9 p = <span class="keyword">new</span> Parce9();</span><br><span class="line">        Destination d = p.destination(<span class="string">"T"</span>);</span><br><span class="line">        System.out.println(d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Destination</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>如果定义一个匿名内部类，并希望它使用一个在其外部定义的对象，那么编译器会要求其参数是<strong>final</strong>的。</p>
<p>在匿名类中不可能有命名构造器，但是通过实例初始化，就能达到匿名内部类创建一个构造器的效果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> out;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parce10</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Destination <span class="title">destination</span><span class="params">(String dest,<span class="keyword">float</span> price)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Destination()&#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">int</span> cost;</span><br><span class="line">            &#123;</span><br><span class="line">                cost = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(cost &lt; <span class="number">10</span>)&#123;</span><br><span class="line">                    System.out.println(<span class="string">"Over "</span>+price);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">private</span> String lable = dest;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">readLable</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="keyword">return</span> lable;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        Parce10 p = <span class="keyword">new</span> Parce10();</span><br><span class="line">        Destination d = p.destination(<span class="string">"Yang"</span>,<span class="number">1122</span>);</span><br><span class="line">        System.out.println(d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Over 1122.0</span></span><br><span class="line"><span class="comment">Destination</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>嵌套类</p>
<p>如果不需要内部类对象与其外围类对象之间有联系，那么可以将内部类声明为<strong>static</strong>。这通通常称为<strong>嵌套类</strong>。普通内部类对象隐式地保存了一个引用，指向创建它的外围类对象。然而，当内部类是<strong>static</strong>时。就不是这个情况了。</p>
<p>嵌套类意味着：</p>
<ul>
<li>要创建嵌套类的对象，并不需要其外围类的对象。</li>
<li>不能从嵌套类的对象中访问非静态的外围类对象。</li>
</ul>
<p>普通内部类的字段和方法，只能用在类的外部层次上，所以普通内部类不能有<strong>static数据</strong>和<strong>static字段</strong>，也不能包含嵌套类，但是嵌套类可以包含所有这一切：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> out;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parce11</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ParceContents</span> <span class="keyword">extends</span> <span class="title">Content</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">11</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ParceDestination</span> <span class="keyword">extends</span> <span class="title">Destination</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String lable;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">ParceDestination</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">            lable = s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">readLable</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> lable;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AnotherLevel</span></span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">            <span class="keyword">static</span> <span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Destination <span class="title">destination</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ParceDestination(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Content <span class="title">content</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ParceContents();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        Content c = <span class="keyword">new</span> Content();</span><br><span class="line">        Destination d = destination(<span class="string">"T"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="内部类的继承"><a href="#内部类的继承" class="headerlink" title="内部类的继承"></a>内部类的继承</h2><p>内部类的构造器必须连接到指向其外围类对象的引用，所以在继承内部类的时候，问题有些复杂。问题在于，那个指向外围类对象的引用必须初始化，而在导出类中不再存在可连接的默认对象。要解决这个问题，必须使用特殊的语法来明确说清它们之间的关联</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> out;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WithInner</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InheritInner</span> <span class="keyword">extends</span> <span class="title">WithInner</span>.<span class="title">Inner</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InheritInner</span><span class="params">(WithInner wi)</span></span>&#123;</span><br><span class="line">        wi.<span class="keyword">super</span>();</span><br><span class="line">        System.out.println(<span class="string">"InheritInner constructor"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        WithInner wi = <span class="keyword">new</span> WithInner();</span><br><span class="line">        InheritInner inh = <span class="keyword">new</span> InheritInner(wi);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">InheritInner constructor</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>InheritInner</strong>只继承自内部类，而不是外部类。但是当要生成一个构造器时，默认的构造器并不算好，而且不能只是传递一个指向外围类对象的引用。此外，必须在构造器内部使用如下语法：<code>enclosingClassReference.super()</code></p>
<h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><p>可以在一个方法内部或任意的作用域内定义内部类。理由如下：</p>
<ul>
<li>实现了某些类型的接口，于是可以创建并返回对其的引用。</li>
<li>想创建一个类辅助解决方案，但是又不希望这个类时公共可用的。</li>
</ul>
<p>在方法的作用域内创建一个完整的类。这称之为<strong>局部内部类</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> out;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parce5</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Destination <span class="title">destinations</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">PDestination</span> <span class="keyword">implements</span> <span class="title">Destination</span></span>&#123;</span><br><span class="line">            <span class="keyword">private</span> String label;</span><br><span class="line">            <span class="function"><span class="keyword">private</span> <span class="title">PDestination</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">                label = s;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">readLabel</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> label;&#125;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"PDestination"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PDestination(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        Parce5 p = <span class="keyword">new</span> Parce5();</span><br><span class="line">        Destination d = p.destinations(<span class="string">"T"</span>);</span><br><span class="line">        System.out.println(d.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">PDestination</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>内部类还可以在任意作用域内嵌入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> out;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel6</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">internalTracking</span><span class="params">(<span class="keyword">boolean</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(b)&#123;</span><br><span class="line">            <span class="class"><span class="keyword">class</span> <span class="title">TrackingSlip</span></span>&#123;</span><br><span class="line">                <span class="keyword">private</span> String id;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="title">TrackingSlip</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">                    id = s;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="function">String <span class="title">getSlip</span><span class="params">()</span></span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> id;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">"TrackingSlip id = "</span>+id;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            TrackingSlip ts = <span class="keyword">new</span> TrackingSlip(<span class="string">"slip"</span>);</span><br><span class="line">            System.out.println(ts);</span><br><span class="line">            String s = ts.getSlip();</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">track</span><span class="params">()</span></span>&#123;</span><br><span class="line">        internalTracking(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]arfs)</span></span>&#123;</span><br><span class="line">        Parcel6 p = <span class="keyword">new</span> Parcel6();</span><br><span class="line">        p.track();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">TrackingSlip id = slip</span></span><br><span class="line"><span class="comment">slip</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>在定义内部类的作用域外，内部类的对象引用是不能使用的。</p>
<p>局部内部类不能有访问权限修饰词，因为它不是外围类的一部分，但是它可以访问当前代码块内的常量，以及此外围类的所以成员。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> out;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Counter</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalInnerClass</span></span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">   <span class="function">Counter <span class="title">getCounter</span><span class="params">(<span class="keyword">final</span> String name)</span></span>&#123;</span><br><span class="line">       <span class="class"><span class="keyword">class</span> <span class="title">LocalCount</span> <span class="keyword">implements</span> <span class="title">Counter</span></span>&#123;</span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="title">LocalCount</span><span class="params">()</span></span>&#123;</span><br><span class="line">               System.out.println(<span class="string">"LocalCount()"</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">()</span></span>&#123;</span><br><span class="line">               System.out.println(name);</span><br><span class="line">               <span class="keyword">return</span> count++;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> LocalCount();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function">Counter <span class="title">getCounter2</span><span class="params">(<span class="keyword">final</span> String name)</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> Counter()&#123;</span><br><span class="line">           &#123;</span><br><span class="line">               System.out.println(<span class="string">"Counter"</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">()</span></span>&#123;</span><br><span class="line">               System.out.println(name);</span><br><span class="line">               <span class="keyword">return</span> count++;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">       LocalInnerClass lic = <span class="keyword">new</span> LocalInnerClass();</span><br><span class="line">       Counter c1 = lic.getCounter(<span class="string">"Local inner"</span>),</span><br><span class="line">       c2 = lic.getCounter2(<span class="string">"Anonymous inner"</span>);</span><br><span class="line">       System.out.println(c1.next());</span><br><span class="line">       System.out.println(c2.next());</span><br><span class="line">       </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">LocalCount()</span></span><br><span class="line"><span class="comment">Counter</span></span><br><span class="line"><span class="comment">Local inner</span></span><br><span class="line"><span class="comment">0</span></span><br><span class="line"><span class="comment">Anonymous inner</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>既然局部内部类的名字在方法外是不可见的，那为什么仍然使用局部内部类而不是匿名内部类呢？这个问题的解答是：需要一个已命名的构造器，或者需要重载构造器，而匿名内部类只能用于实例初始化。另一个理由是，需要不止一个该内部类的对象。</p>
<h2 id="为啥需要内部类"><a href="#为啥需要内部类" class="headerlink" title="为啥需要内部类"></a>为啥需要内部类</h2><p>内部类继承自某个类或实现某个接口，内部类的代码操作创建它的外围类的对象。所以可以认为内部类提供了某种进入其外围类的窗口。</p>
<p>使用内部类最吸引人的原因是：</p>
<p><strong>每个内部类都独立的继承自一个实现，所以无论外围类是否已经继承了某个实现，对于内部类来说都没有影响。</strong></p>
<p>内部类使得多重继承的解决方案变得完整。接口解决了部分问题，而内部类有效的实现了“多重继承”，内部类允许继承多个非接口类型。</p>
<p>使用内部类，还可以获得其他的特性：</p>
<ul>
<li>内部类可以有多个实例，每个实例都有自己的状态，并且与其外围类对象的信息相互独立</li>
<li>在单个外围类中，可以让多个内部类以不同的方式实现同一接口，或继承同一个类。</li>
<li>创建内部类对象的时刻并不依赖外围类对象的创建。</li>
<li>内部类并没有令人迷惑的“is-a”关系，它就是一个独立提体。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java基础编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java抽象类和接口</title>
    <url>/2019/12/23/java/java%E5%9F%BA%E7%A1%80/%E3%80%907%E3%80%91Java%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<h2 id="抽象类和抽象方法"><a href="#抽象类和抽象方法" class="headerlink" title="抽象类和抽象方法"></a>抽象类和抽象方法</h2><p>使用<strong><code>abstract</code></strong>关键字来创建<strong>抽象类</strong>和<strong>抽象方法</strong>，其语法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过创建<strong>抽象类</strong>是希望通过这个通用接口操纵一系列类，不同的子类可以用不同的方式表示此抽象类。抽象类建立起了一种基本形式，以此表示所有导出类的共同部分。</p>
<p>Java还提供了一个叫<strong>抽象方法</strong>的机制，这种方法是不完整的，仅有声明而没有方法体。包含抽象方法的类称之为抽象类，如果一个类包含一个或多个抽象方法，那么该类必须被限定为<strong>抽象的</strong>。由于为抽象类创建对象是不安全的，所以在创建抽象对象时，编译器会报错。这样就保证了抽象类的纯粹性。</p>
<p>如果从一个抽象类继承，并想创建新类的对象，那么就必须为基类的所有方法提供方法定义。如果不这样做，那么导出类便也是抽象类，且编译器会强制我们用<strong>abstract</strong>关键字类限定这个类。</p>
<p>抽象类的并不需要所有的方法都是抽象的，所以仅需将某些方法声明为抽象的即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> interfaces;</span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Instrument</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(String n)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">what</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Instrument"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">adjust</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wind</span> <span class="keyword">extends</span> <span class="title">Instrument</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Wind.play()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">what</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Wind"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">adjust</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Wind.adjust()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Music4</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tune</span><span class="params">(Instrument i,String s)</span></span>&#123;</span><br><span class="line">        i.play(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tuneAll</span><span class="params">(Instrument[]e)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(Instrument i:e)&#123;</span><br><span class="line">            tune(i,<span class="string">"tune"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        Instrument i = <span class="keyword">new</span> Wind();</span><br><span class="line">        tune(i,<span class="string">"gogo"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Wind.play()</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>创建抽象类和抽象方法非常有用，因为它们可以使类的抽象性明确起来，并告诉用户和编译器打算怎样来使用它们。抽象类还是很有用的重构工具，因为它们可以很容易地将公共方法沿着继承层次结构向上移动。</p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p><strong><code>interface</code></strong>关键字使抽象的概念更进一步，<strong>interface</strong>关键字产生一个完完全全抽象的类，它根本就没有任何具体实现。只提供了形式，而未提供任何具体实现。</p>
<p>想要创建一个接口，需要用<strong><code>interface</code></strong>关键字来代替<strong>class</strong>关键字。可以在<strong>interface</strong>关键字前面添加<strong>public</strong>关键字，如果不添加public关键字，则它只具有包访问权限。接口也可以包含域，但这些域隐式地是<strong>static</strong>和<strong>final</strong>的。</p>
<p>某个类要实现一个接口，需要使用<strong><code>implements</code></strong>关键字来实现。</p>
<p>可以选择在接口中显式地将方法声明为<strong>public</strong>的，但即使不这么做，它们也是<strong>public</strong>的。当要实现一个接口时，在接口中被定义的方法必须被定义为<strong>public</strong>的；否则，它们将只得到默认的包访问权限，其可访问权限就被降低了。</p>
<h3 id="接口中的域"><a href="#接口中的域" class="headerlink" title="接口中的域"></a>接口中的域</h3><p>在接口中的任何域都自动是<strong>public</strong>、<strong>static</strong>和<strong>final</strong>的，所以接口就成为了一种便捷的创建常量组的工具。在接口中不能定义为“空final”，也就创建域的时候必须要初始化。</p>
<h3 id="通过继承来扩展接口"><a href="#通过继承来扩展接口" class="headerlink" title="通过继承来扩展接口"></a>通过继承来扩展接口</h3><p>通过继承，可以很容易地在接口中添加新的方法声明，还可通过继承在新接口中组合数个接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> out;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Monster</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">menace</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">DangerMonster</span> <span class="keyword">extends</span> <span class="title">Monster</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Lethal</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">kill</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DragonZilla</span> <span class="keyword">implements</span> <span class="title">DangerMonster</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">menace</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Vampire</span> <span class="keyword">extends</span> <span class="title">DangerMonster</span>,<span class="title">Lethal</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">drinkBlood</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VeryBadVampire</span> <span class="keyword">implements</span> <span class="title">Vampire</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">menace</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">kill</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drinkBlood</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HorrorShow</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">u</span><span class="params">(Monster m)</span></span>&#123;m.menace();&#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">v</span><span class="params">(DangerMonster d)</span></span>&#123;</span><br><span class="line">        d.menace();</span><br><span class="line">        d.destroy();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">w</span><span class="params">(Lethal l)</span></span>&#123;</span><br><span class="line">        l.kill();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        DangerMonster bancy = <span class="keyword">new</span> DragonZilla();</span><br><span class="line">        u(bancy);</span><br><span class="line">        v(bancy);</span><br><span class="line">        Vampire va = <span class="keyword">new</span> VeryBadVampire();</span><br><span class="line">        u(va);</span><br><span class="line">        v(va);</span><br><span class="line">        w(va);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///~</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java基础编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java类的复用</title>
    <url>/2019/12/21/java/java%E5%9F%BA%E7%A1%80/%E3%80%906%E3%80%91Java%E7%B1%BB%E7%9A%84%E5%A4%8D%E7%94%A8/</url>
    <content><![CDATA[<h2 id="继承语法"><a href="#继承语法" class="headerlink" title="继承语法"></a>继承语法</h2><p><strong>继承</strong>可以说是所有面向对象编程语言中不可缺少的部分。在Java中，当创建一个类时，总是在继承，除非已明确的指出要从其他类中继承，否则就是在隐式地从Java的标准根类<strong>Object</strong>进行继承。使用继承时，在类名后面使用<strong><code>extends</code></strong>关键字来实现继承。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> reusing;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cleanser</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String s = <span class="string">"Cleanser"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">append</span><span class="params">(String i)</span></span>&#123;</span><br><span class="line">        s += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dilute</span><span class="params">()</span></span>&#123;</span><br><span class="line">        append(<span class="string">" dilute() "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">()</span></span>&#123;</span><br><span class="line">        append(<span class="string">" apply() "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        Cleanser c = <span class="keyword">new</span> Cleanser();</span><br><span class="line">        c.dilute();</span><br><span class="line">        c.apply();</span><br><span class="line">        System.out.println(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Detergent</span> <span class="keyword">extends</span> <span class="title">Cleanser</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foam</span><span class="params">()</span></span>&#123;</span><br><span class="line">        append(<span class="string">" foam() "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        Detergent d = <span class="keyword">new</span> Detergent();</span><br><span class="line">        d.dilute();</span><br><span class="line">        d.apply();</span><br><span class="line">        d.foam();</span><br><span class="line">        System.out.println(d);</span><br><span class="line">        System.out.println(<span class="string">"Test base class"</span>);</span><br><span class="line">        Cleanser.main(args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Cleanser dilute()  apply()  foam()</span></span><br><span class="line"><span class="comment">Test base class</span></span><br><span class="line"><span class="comment">Cleanser dilute()  apply()</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>在继承的过程中，并不一定非得使用基类的方法。也可以是在导出类中添加新方法，其添加的方式与类中添加任意方法一样，即对其加以定义即可。</p>
<h3 id="初始化基类"><a href="#初始化基类" class="headerlink" title="初始化基类"></a>初始化基类</h3><p>初始化基类涉及到基类和导出类，从外部来看，导出类就像是一个与基类具有相同接口的新类。但继承并不只是复制基类的接口。当创建了一个导出类的对象时，该对象包含了一个基类的子对象。这个子对象与使用的基类直接创建的对象是一样的。二者的区别在于，导出类来自于外部，而基类的子对象被包装在导出类对象的内部。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> reusing;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Art</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Art</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Atr Constrcutor"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Drawing</span> <span class="keyword">extends</span> <span class="title">Art</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Drawing</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Drawing Constrcutor"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cartoon</span> <span class="keyword">extends</span> <span class="title">Drawing</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cartoon</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Cartoon Constrcutor"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        Cartoon cartoon = <span class="keyword">new</span> Cartoon();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Atr Constrcutor</span></span><br><span class="line"><span class="comment">Drawing Constrcutor</span></span><br><span class="line"><span class="comment">Cartoon Constrcutor</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>在上述的代码中可发现，构建过程是从基类“向外”扩展的，所以基类在导出类构造器可以访问它之前就已经做完了初始化。即使不为导出类创建构造器。</p>
<h3 id="带参数的构造器"><a href="#带参数的构造器" class="headerlink" title="带参数的构造器"></a>带参数的构造器</h3><p>如果在使用继承时，基类中明确的创建了带有参数的构造器，就必须使用关键字<strong><code>super</code></strong>显式地编写调用基类构造器的语句，并且配以适当的参数列表。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> reusing;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Game</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Game</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"constructor Args：int i = "</span>+i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chess</span> <span class="keyword">extends</span> <span class="title">Game</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Chess</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="number">2</span>);</span><br><span class="line">    System.out.println(<span class="string">"class Chess constructor"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        Chess c = <span class="keyword">new</span> Chess();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">class Game constructor Args：int i = 2</span></span><br><span class="line"><span class="comment">class Chess constructor</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>调用基类构造器必须是在导出类构造器中要做的第一件事。</p>
<h3 id="名称屏蔽"><a href="#名称屏蔽" class="headerlink" title="名称屏蔽"></a>名称屏蔽</h3><p>如果Java的基类拥有某个已被多次重载的方法名称，那么在导出类中重新定义该方法名称并不会屏蔽其在基类中任何重载方法的版本。因此，无论是在该层或者是在基类中对方法进行定义，重载机制都可以正常工作。看下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> reusing;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Homer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">doh</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"doh(char): "</span>+c);</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">doh</span><span class="params">(<span class="keyword">float</span> f)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"doh(float): "</span>+f);</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Milhouse</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bart</span> <span class="keyword">extends</span> <span class="title">Homer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doh</span><span class="params">(Milhouse m)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"doh(Milhouse m)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hide</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        Bart b = <span class="keyword">new</span> Bart();</span><br><span class="line">        b.doh(<span class="number">1</span>);</span><br><span class="line">        b.doh(<span class="string">'x'</span>);</span><br><span class="line">        b.doh(<span class="number">1.0f</span>);</span><br><span class="line">        b.doh(<span class="keyword">new</span> Milhouse());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">doh(float): 1.0</span></span><br><span class="line"><span class="comment">doh(char): x</span></span><br><span class="line"><span class="comment">doh(float): 1.0</span></span><br><span class="line"><span class="comment">doh(Milhouse m)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>在JavaSE5中增加了<strong><code>@Override</code></strong>注解,当想要覆写某个方法时，可以选择添加这个注解，在不留意重载而并非覆写了该方法时，编译器会生成一条错误消息</p>
<h3 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a>向上转型</h3><p>在讲向上转型前先看一段代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> reusing;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Instrument</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"play()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tune</span><span class="params">(Instrument i)</span></span>&#123;</span><br><span class="line">        i.play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wind</span> <span class="keyword">extends</span> <span class="title">Instrument</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        Wind w = <span class="keyword">new</span> Wind();</span><br><span class="line">        Instrument.tune(w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">play()</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>由于继承可以确保基类中所有的方法在导出类中也同样有效，所以能够向基类发送的所有信息同样也可以向导出类发送。如果Instrument类具有一个play()方法，那么Wind类也将同样具备。也就是说Wind对象也是一种类型的Instrument。</p>
<ul>
<li><p>何为向上转型</p>
<p>来看一个UML图吧：</p>
<p><img src="C:%5CUsers%5C%E6%9D%A8%5CDesktop%5C%E6%97%A0%E6%A0%87%E9%A2%98.png" alt=""></p>
<p>将根置于页面的顶端，然后逐渐向下。由导出类转型为基类，在继承图上是向上移动的，因此称为<strong><code>向上转型</code></strong>。由于向上转型是从一个较专用类型转向较通用类型的转换。所以总是很安全的，也就是说导出类是基类的超集。导出类可能比基类含有更多的方法，但它必须至少具备基类中所含的方法。在向上转型的过程中，类接口中唯一可能发生的就是丢失方法，而不是获取它们。</p>
</li>
</ul>
<h3 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h3><p>可能使用到<strong><code>final</code></strong>关键字的情况：数据、方法、类。</p>
<h4 id="final数据"><a href="#final数据" class="headerlink" title="final数据"></a>final数据</h4><p>许多编程语言中都会有某种方法，来向编译器告知一块数据是恒定不变的。比如：</p>
<ul>
<li>一个恒定不变的<strong>编译时常量</strong></li>
<li>一个在运行是被初始化，而不希望它被改变的</li>
</ul>
<p>对于编译期常量的情况，编译器可以将该常量值代入任何用到它的计算中。<strong>在Java中，这类常量必须是基本数据类型，并且以关键字<code>final</code>表示，在对这个常量进行定义时，必须对其进行赋值。</strong></p>
<blockquote>
<p>一个既是static又是final的域只占据一段不能改变的存储空间。</p>
</blockquote>
<p>对于基本类型使用final使数值恒定不变；而用于对象引用，final使引用恒定不变。一旦引用被初始化指向一个对象，就无法在把它指向另一个对象。然而，对象其自身却是可以被修改的，Java并未提供使任何对象恒定不变的途径。这也适用于数组。来看一段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> reusing;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Value</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Value</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.i = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalData</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FinalData</span><span class="params">(String id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> ValueOne = <span class="number">9</span>; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> Value_Two = <span class="number">99</span>; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> Value_THERE = <span class="number">39</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> i4 = rand.nextInt(<span class="number">20</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INT_5 = rand.nextInt(<span class="number">20</span>);</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">private</span> Value v1 = <span class="keyword">new</span> Value(<span class="number">11</span>);</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Value v2 = <span class="keyword">new</span> Value(<span class="number">22</span>);</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Value VAL_3 = <span class="keyword">new</span> Value(<span class="number">33</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span>[] a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id+<span class="string">": "</span>+<span class="string">"i4: "</span>+i4+<span class="string">" INT_5: "</span>+INT_5;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        FinalData f1 = <span class="keyword">new</span> FinalData(<span class="string">"f1"</span>);</span><br><span class="line">        </span><br><span class="line">        f1.v2.i++;</span><br><span class="line">        </span><br><span class="line">        f1.v1 = <span class="keyword">new</span> Value(<span class="number">9</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;f1.a.length;i++)&#123;</span><br><span class="line">            f1.a[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        System.out.println(f1);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"Create new FinalData"</span>);</span><br><span class="line">        </span><br><span class="line">        FinalData f2 = <span class="keyword">new</span> FinalData(<span class="string">"f2"</span>);</span><br><span class="line">        </span><br><span class="line">        System.out.println(f1);</span><br><span class="line">        </span><br><span class="line">        System.out.println(f2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">f1: i4: 15 INT_5: 18</span></span><br><span class="line"><span class="comment">Create new FinalData</span></span><br><span class="line"><span class="comment">f1: i4: 15 INT_5: 18</span></span><br><span class="line"><span class="comment">f2: i4: 13 INT_5: 18</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="空白final"><a href="#空白final" class="headerlink" title="空白final"></a>空白final</h4><p>Java允许生成一个“空白final”，空白final就是指被声明为final但有未给定初始值的域。无论什么情况，编译器都确保空白final在使用前必须被初始化。但是，空白final在关键final的使用上提供了更大的灵活性，因此，一个类中final域就可以做到根据对象而有所不同，却又保持器恒定不变的特性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> reusing;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Poppet</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Poppet</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.i = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"i = "</span>+i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlankFinal</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Poppet p;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BlankFinal</span><span class="params">()</span></span>&#123;</span><br><span class="line">        j = <span class="number">1</span>;</span><br><span class="line">        p = <span class="keyword">new</span> Poppet(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BlankFinal</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        j = x;</span><br><span class="line">        p = <span class="keyword">new</span> Poppet(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"i = "</span>+i+<span class="string">" j = "</span>+j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]aegs)</span></span>&#123;</span><br><span class="line">        BlankFinal b1 = <span class="keyword">new</span> BlankFinal();</span><br><span class="line">        BlankFinal b2 = <span class="keyword">new</span> BlankFinal(<span class="number">47</span>);</span><br><span class="line">        System.out.println(b1);</span><br><span class="line">        System.out.println(b2);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">i = 0 j = 1</span></span><br><span class="line"><span class="comment">i = 0 j = 47</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>必须在域的定义处或者每个构造器中对final进行赋值，这正是final域在使用前总是被初始化的原因所在。</p>
<h3 id="final参数"><a href="#final参数" class="headerlink" title="final参数"></a>final参数</h3><p>Java允许在参数列表中以声明的方式将参数指明为final。这意味着无法在方法中更改参数引用所指向的对象。</p>
<h3 id="final方法"><a href="#final方法" class="headerlink" title="final方法"></a>final方法</h3><p>使用final方法的原因是把方法锁住，以防任何继承类修改它的含义。还有一个原因是考虑到效率，但是在最近的Java版本中，不再需要使用final方法来提升效率了。当只有在想要明确禁止覆盖时，才将方法设置为final。</p>
<h3 id="final和private关键字"><a href="#final和private关键字" class="headerlink" title="final和private关键字"></a>final和private关键字</h3><p>类中的所有private方法隐式地指定为final的，由于无法取用private方法，所以也就无法覆盖它。可以对private方法添加final修饰词，但是这样做没有什么意义。</p>
<h3 id="final类"><a href="#final类" class="headerlink" title="final类"></a>final类</h3><p>当将某个类的整体定义为final时，就表明了不打算继承该类。不希望该类有子类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> reusing;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmallBrain</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Dinosaur</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">    SmallBrain sm = <span class="keyword">new</span> SmallBrain();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Jurassic</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        Dinosaur n = <span class="keyword">new</span> Dinosaur();</span><br><span class="line">        n.f();</span><br><span class="line">        n.i = <span class="number">40</span>;</span><br><span class="line">        n.j++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**/</span></span><br></pre></td></tr></table></figure>

<p>final域可以根据个人的意愿选择是或不是，不论类是否定义为final，同样的这也适用于final域。然而，由于final类禁止继承，所以final类中的所有方法都隐式的指定为final的，因为无法覆盖它们。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java基础编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java访问权限控制</title>
    <url>/2019/12/19/java/java%E5%9F%BA%E7%A1%80/%E3%80%905%E3%80%91Java%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<p>Java提供了访问权限修饰词，访问权限控制的等级，从最大到最小依次为：<strong><code>public</code></strong>、<strong><code>protected</code></strong>、<strong><code>包访问权限</code></strong>、<strong><code>private</code></strong>。Java使用关键字<strong><code>package</code></strong>来影响访问权限修饰词的使用。</p>
<p>在Java中提供了大量的标准类库，如果想要在自己定义的类文件中使用这些标准的类库，可以使用<strong><code>import</code></strong>关键字来导入想要使用的类库。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> access;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleImport</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        list.add(<span class="string">"YangAY"</span>);</span><br><span class="line">        System.out.println(list.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[YangAY]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>上面的代码中<code>import java.util.ArrayList;</code>将java.util下的<strong>ArrayList</strong>类导入到类中来使用。</p>
<p>如果SingleImport.java的代码没有使用<strong><code>package</code></strong>来声明一个包，那么Java编译器就会自动将该类声明为<strong>默认包</strong>。</p>
<h2 id="代码组织"><a href="#代码组织" class="headerlink" title="代码组织"></a>代码组织</h2><p>当编写一个Java源代码文件时，此代码源文件称为编译单元。每个编译单元都必须有一个后缀名<strong><code>.java</code></strong>，而在编译单元内则可以有一个<strong><code>public</code></strong>类，该类的名称必须和文件名相同，包括大小写（不包括后缀名.java），每个编译单元只能有一个public类，否则编译不通过。</p>
<p>当编译通过一个.java文件时，在.java文件中的每个类都会有一个输出文件，该输出文件的名称和.java文件名相同，只是后缀名为<strong>.class</strong>。</p>
<p>如果希望一些类从属于一个包中，可以使用<strong>package</strong>关键字指明，使用package语句，必须是在.java文件中的最开头中声明。在文件中写：<strong>package access;</strong>就表示在声明编译单元是名为access包的一部分。也就是讲声明的public类名称是位于access名称的包下。如果想要使用该类名称的必须在使用前结合<strong>import</strong>关键字指定<strong>包名.类名</strong>。来看一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> access.mypackage;<span class="comment">//必须在代码的第一行</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"ClassName:MyClass Method:f()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> access;</span><br><span class="line"><span class="keyword">import</span> access.mypackage.MyClass;<span class="comment">//导入MyClass;包名.类名</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleImport</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> MyClass().f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">ClassName:MyClass Method:f()</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>这个例子中，创建了两个.java文件：<strong>MyClass.java</strong>和<strong>SingleImport.java</strong>，在MyClass.java中<strong>package access.mypackage;</strong>将该编译单元放入ccess.mypackage包中。在SingleImport.java中使用<strong>import access.mypackage.MyClass;</strong>将access.mypackage.MyClass类导入到SingleImport类中，并调用MyClass中的<strong>f()</strong>方法。</p>
<p>下面来说说Java的访问权限修饰词</p>
<h2 id="Java访问权限修饰词"><a href="#Java访问权限修饰词" class="headerlink" title="Java访问权限修饰词"></a>Java访问权限修饰词</h2><h3 id="包访问权限"><a href="#包访问权限" class="headerlink" title="包访问权限"></a>包访问权限</h3><p>如果不提供任何访问权限修饰词，称之为“包访问权限”；也叫<strong>默认访问权限</strong>，也就意味着在当前包中的所有其他类对于这个具有默认访问权限的类的成员都具有访问的权利，除非某些成员是使用<strong>private</strong>修饰的。包访问权限允许将包内的所有相关的类组合起来，以使它们彼此可以轻松的互相作用。</p>
<h3 id="public访问权限"><a href="#public访问权限" class="headerlink" title="public访问权限"></a>public访问权限</h3><p>使用关键public，就意味着public之后紧跟着的成员的声明自己对于每个人都是有用的。</p>
<h3 id="private访问权限"><a href="#private访问权限" class="headerlink" title="private访问权限"></a>private访问权限</h3><p><strong><code>private</code></strong>关键字的意思是，除了包含该成员的类之外，其他任何类都无法访问这个成员。由于处于同一包内的其他类是不能访问private成员的，因此这等于是自己隔离了自己。为此private就允许你随意改变该成员，不需要去考虑这样做是否影响到包内的其他类。</p>
<h3 id="protected访问权限"><a href="#protected访问权限" class="headerlink" title="protected访问权限"></a>protected访问权限</h3><p>关键字<strong><code>protected</code></strong>处理的是继承的概念，通过继承可以利用一个现有的基类。基类的创建者会希望有个特定的成员，把对它的访问权限赋予派生类而不是所有类。这就需要<strong>protected</strong>来完成这一工作。protected也提供包访问权限，相同包内的其他类可以访问<strong>protected</strong>元素。</p>
<h3 id="类的访问权限"><a href="#类的访问权限" class="headerlink" title="类的访问权限"></a>类的访问权限</h3><p>为了控制某个类的访问权限，访问权限修饰符必须出现于关键字<strong><code>class</code></strong>之前。比如这样写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>类既不能是<strong>private</strong>，也不可是<strong>protected</strong>。对于类的访问权限，仅有两个选择：包访问权限或者是public，如果不希望其他人对该类拥有访问权限，可以将所有构造器都指定为<strong>private</strong>，从而阻止任何人创建该类对象，如果在该类的static成员内创建，那就另说了。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java基础编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java类的初始化与清理</title>
    <url>/2019/12/17/java/java%E5%9F%BA%E7%A1%80/%E3%80%904%E3%80%91Java%E7%B1%BB%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E6%B8%85%E7%90%86/</url>
    <content><![CDATA[<p>在Java中，通过提供构造器，类的设计者可确保每个对象都会得到初始化。创建对象时，如果器类具有构造器，Java就会在用户操作对象之前自动调用相应的构造器，从而确保初始化化的进行。在Java中采取了构造器与类名相同的方案。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> initialization;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rock</span></span>&#123;</span><br><span class="line">    Rock()&#123;</span><br><span class="line">        System.out.println(<span class="string">"Rock"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Rock</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"Rock "</span>+i+<span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleConstructor</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        Rock r = <span class="keyword">new</span> Rock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Rock</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>在创建对象时：<strong><code>new Rock();</code></strong>将会为对象分配储存空间，并调用相应的构造器。</p>
<p>不接受任何参数的构造器称为<strong><code>默认构造器</code></strong>,也称为<strong>无参构造器</strong>，当然了，构造器也能带有形式参数，方便指定如何创建对象。有了构造器的形式参数，就可以在初始化对象过程中提供实际参数。</p>
<p>构造器是一种特殊类型的方法，因为构造器没有返回值，这个与普通方法中的返回值为空（void）不同，构造器不会返回任何东西。</p>
<h2 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h2><p>构造器的名字已经由类名所决定，那就只能有一个构造器名，那想要多种方式创建一个对象怎么怎么办呢？解决方式就是使用<strong><code>方法重载</code></strong></p>
<p>方法重载就是让方法名相同而形式参数不同，所以在创建构造器是可以使构造器名与类名一致，但是形式参数列表不同即可创建不同的构造器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> initialization;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tree</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Tree</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"无参构造器"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Tree</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        h = i;</span><br><span class="line">        System.out.println(<span class="string">"有参构造器"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我叫杨阿阳"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">(<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我叫杨阿阳,今年"</span>+age+<span class="string">"岁"</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Overloading</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        <span class="comment">// Tree t = new Tree(55);</span></span><br><span class="line">        Tree t = <span class="keyword">new</span> Tree();</span><br><span class="line">        t.info();</span><br><span class="line">        t.info(<span class="number">23</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">//有参构造器</span></span><br><span class="line"><span class="comment">无参构造器</span></span><br><span class="line"><span class="comment">我叫杨阿阳</span></span><br><span class="line"><span class="comment">我叫杨阿阳,今年23岁</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>区分重载方法</p>
<p>每个重载方法都有独一无二的参数类型列表。甚至参数顺序的不同也可以区分出两个方法。</p>
</li>
</ul>
<h2 id="默认构造器"><a href="#默认构造器" class="headerlink" title="默认构造器"></a>默认构造器</h2><p>默认构造器也叫无参构造器，是没有形式参数的，它的作用是创建一个“默认对象”。如果在定义的类中没有定义构造器，那么编译器会自动创建一个默认构造器。来看一段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> initialization;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultConstructor</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        Bird b = <span class="keyword">new</span> Bird();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码中创建了一个新对象：<code>Bird b = new Bird();</code>，并调用默认构造器——即使没有创建构造器。但是如果已经定义了一个构造器，编译器就不会帮你自动创建默认构造器。上面的代码再改改：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> initialization;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Bird</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Bird</span><span class="params">(<span class="keyword">double</span> d)</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultConstructor</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        Bird b = <span class="keyword">new</span> Bird(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">/*如果你这样写</span></span><br><span class="line"><span class="comment">        Bird b1 = new Bird();</span></span><br><span class="line"><span class="comment">        编译器就会报错</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h2><p>有时可能为一个类写了多个构造器，也有可能想在一个构造器中调用另一个构造器，以免代码重复。使用this关键字就可以做到这一点。</p>
<p>通常写<strong><code>this</code></strong>的时候，都是指“这个对象”或者“当前对象”，而且它本身表示对当前对象的引用。在构造器中，如果为this添加参数列表，那么就有了不同的含义。这将产生对符合此参数列表的某个构造器的明确调用；因此，调用其他构造器就有了直接的途径：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> initialization;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Flower</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> petCount = <span class="number">0</span>;</span><br><span class="line">    String s = <span class="string">"initial value"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Flower</span><span class="params">(<span class="keyword">int</span> petal)</span></span>&#123;</span><br><span class="line">        petCount = petal;</span><br><span class="line">        System.out.println(<span class="string">"Constructor w/ petCount="</span>+petCount);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Flower</span><span class="params">(String ss)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Constructor w/ s="</span>+ss);</span><br><span class="line">        s = ss;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Flower</span><span class="params">(String s,<span class="keyword">int</span> petals)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(petals);</span><br><span class="line">        <span class="keyword">this</span>.s = s;</span><br><span class="line">        System.out.println(<span class="string">"String &amp; int args"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Flower</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="string">"hello"</span>,<span class="number">23</span>);</span><br><span class="line">        System.out.println(<span class="string">"default constructor"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printPetalCount</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"petalCount = "</span>+petCount+<span class="string">" s= "</span>+s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        Flower f = <span class="keyword">new</span> Flower();</span><br><span class="line">        f.printPetalCount();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Constructor w/ petCount=23</span></span><br><span class="line"><span class="comment">String &amp; int args</span></span><br><span class="line"><span class="comment">default constructor</span></span><br><span class="line"><span class="comment">petalCount = 23 s= hello</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>注意上面代码中<code>public Flower(String s,int petals)</code>的声明，尽管可以用this一个构造器，但却不能调用两个。另外，必须将构造器调用置于最起始处，否则编译器会报错。由于参数<strong>s</strong>的名称和数据成员<strong>s</strong>的名字相同，所以会产生歧义，使用<code>this.s</code>来代表数据成员就能解决歧义问题。</p>
<h2 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h2><p>用<strong><code>static</code></strong>修饰的方法就没有<strong>this</strong>关键字。在static方法的内部不能调用非静态方法。而且可以在没有创建任何对象的情况下，仅仅通过类本身来调用static方法。这实际是static方法的主要用途。static方法很像全局方法，虽然Java中禁止使用全局方法，但在类中置入static方法就可以访问其他的static方法和static域。使用static方法时，由于不存在this，所以不是通过“向对象发送消息”的方式来进行的。</p>
<h2 id="成员变量初始化"><a href="#成员变量初始化" class="headerlink" title="成员变量初始化"></a>成员变量初始化</h2><p>Java尽力的保证所有的变量在使用前都能得到恰当的初始化。对于方法的局部变量，Java以编译时错误的形式来实现这个保证。比如下面的代码就是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    i++;<span class="comment">//这是错误的，没有进行初始化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>未初始化的局部变量更有可能是程序员的疏忽大意。所以采取默认值反而会掩盖这种失误。因此强制在编写程序时提供一个初始值，往往能够有助于找出代码中的缺陷。</p>
<p>要是类的数据字段基本类型，不初始化，貌似没有什么问题，因为每个基本类型数据成员保证都会有一个初始值。</p>
<p>比如下面的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> initialization;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitialValues</span></span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> b;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">long</span> l;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printlnInitValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"boolean defaultValue "</span>+b);</span><br><span class="line">        System.out.println(<span class="string">"int defaultValue "</span>+i);</span><br><span class="line">        System.out.println(<span class="string">"char defaultValue "</span>+c);</span><br><span class="line">        System.out.println(<span class="string">"long defaultValue "</span>+l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> InitialValues().printlnInitValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">boolean defaultValue false</span></span><br><span class="line"><span class="comment">int defaultValue 0</span></span><br><span class="line"><span class="comment">char defaultValue</span></span><br><span class="line"><span class="comment">long defaultValue 0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="构造器初始化"><a href="#构造器初始化" class="headerlink" title="构造器初始化"></a>构造器初始化</h2><p>使用构造器来进行初始化，在运行时，可以调用方法或者执行某些动作确定初始值，这给编程带来了很大的灵活性。</p>
<h3 id="构造器初始化顺序"><a href="#构造器初始化顺序" class="headerlink" title="构造器初始化顺序"></a>构造器初始化顺序</h3><p>在类的内部，变量定义的顺序的先后确定了初始化的顺序。即便变量的定义散布与方法定义之间，它们仍会在任何方法被调用之前得到初始化。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> initialization;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Window</span><span class="params">(<span class="keyword">int</span> marker)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Window("</span>+marker+<span class="string">")"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">House</span></span>&#123;</span><br><span class="line">    Window w1 = <span class="keyword">new</span> Window(<span class="number">1</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">House</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"House()"</span>);</span><br><span class="line">        w3 = <span class="keyword">new</span> Window(<span class="number">33</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Window w2 = <span class="keyword">new</span> Window(<span class="number">2</span>);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"show()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Window w3 = <span class="keyword">new</span> Window(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderOfInit</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        House h = <span class="keyword">new</span> House();</span><br><span class="line">        h.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Window(1)</span></span><br><span class="line"><span class="comment">Window(2)</span></span><br><span class="line"><span class="comment">Window(3)</span></span><br><span class="line"><span class="comment">House()</span></span><br><span class="line"><span class="comment">Window(33)</span></span><br><span class="line"><span class="comment">show()</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="静态数据域初始化"><a href="#静态数据域初始化" class="headerlink" title="静态数据域初始化"></a>静态数据域初始化</h2><p>static关键字不能应用于局部变量，因此它只能作用于域。如果一个域是静态的基本类型域，且没有对它进行初始化，那么它就会获得基本类型的标准初始值；如果它是一个对象引用，那么它的默认初始值就是<strong>null</strong>。想要了解静态域何时会初始化，可看看下面的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> initialization;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bowl</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Bowl</span><span class="params">(<span class="keyword">int</span> marker)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Bowl("</span>+marker+<span class="string">")"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fc1</span><span class="params">(<span class="keyword">int</span> marker)</span></span>&#123;</span><br><span class="line">       System.out.println(<span class="string">"fc1("</span>+marker+<span class="string">")"</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Table</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Bowl bowl1 = <span class="keyword">new</span> Bowl(<span class="number">1</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Table</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Table"</span>);</span><br><span class="line">        bowl1.fc1(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fc2</span><span class="params">(<span class="keyword">int</span> marker)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"fc2("</span>+marker+<span class="string">")"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> Bowl bowl2 = <span class="keyword">new</span> Bowl(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cupbord</span></span>&#123;</span><br><span class="line">    Bowl bowl3 = <span class="keyword">new</span> Bowl(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">static</span> Bowl bowl4 = <span class="keyword">new</span> Bowl(<span class="number">4</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cupbord</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Cupbord"</span>);</span><br><span class="line">        bowl4.fc1(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fc3</span><span class="params">(<span class="keyword">int</span> marker)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"fc3("</span>+marker+<span class="string">")"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> Bowl Bowl5 = <span class="keyword">new</span> Bowl(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Staticinit</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Create new Cupbord() in main"</span>);</span><br><span class="line">        <span class="keyword">new</span> Cupbord();</span><br><span class="line">        System.out.println(<span class="string">"Create new Cupbord() in main"</span>);</span><br><span class="line">        <span class="keyword">new</span> Cupbord();</span><br><span class="line">        table.fc2(<span class="number">1</span>);</span><br><span class="line">        cupbord.fc3(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> Table table = <span class="keyword">new</span> Table();</span><br><span class="line">    <span class="keyword">static</span> Cupbord cupbord = <span class="keyword">new</span> Cupbord();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Bowl(1)</span></span><br><span class="line"><span class="comment">Bowl(2)</span></span><br><span class="line"><span class="comment">Table</span></span><br><span class="line"><span class="comment">fc1(1)</span></span><br><span class="line"><span class="comment">Bowl(4)</span></span><br><span class="line"><span class="comment">Bowl(5)</span></span><br><span class="line"><span class="comment">Bowl(3)</span></span><br><span class="line"><span class="comment">Cupbord</span></span><br><span class="line"><span class="comment">fc1(2)</span></span><br><span class="line"><span class="comment">Create new Cupbord() in main</span></span><br><span class="line"><span class="comment">Bowl(3)</span></span><br><span class="line"><span class="comment">Cupbord</span></span><br><span class="line"><span class="comment">fc1(2)</span></span><br><span class="line"><span class="comment">Create new Cupbord() in main</span></span><br><span class="line"><span class="comment">Bowl(3)</span></span><br><span class="line"><span class="comment">Cupbord</span></span><br><span class="line"><span class="comment">fc1(2)</span></span><br><span class="line"><span class="comment">fc2(1)</span></span><br><span class="line"><span class="comment">fc3(1)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>【这段代码有点点不容易懂，以后慢慢看吧】</p>
<p><strong>初始化的顺序是先初始化静态对象，而后是非静态对象</strong></p>
<p>这里做一个小小的总结：这里假设用Test类；</p>
<ul>
<li>即使没有显式的使用static关键字，构造器实际上也是静态方法。因此，当首次创建类型为Test的对象时，或者Test类的静态方法/静态域首次被访问时，Java解释器必须查找类路径，定位Test.class文件。</li>
<li>然后载入Test.class，有关静态初始化的所有动作都会执行，因此，静态初始化只在Class对象首次加载时进行一次。</li>
<li>当用new Test()创建对象的时候，首先将在堆上为Test对象分配足够的存储空间。</li>
<li>这块存储空间会被清零，这就自动的将Test对象中的所有基本类型数据都设置成了默认值，而引用则被设置成null。</li>
<li>执行所有出现于字段定义处的初始化动作。</li>
<li>执行构造器。</li>
</ul>
<h2 id="显式的静态初始化"><a href="#显式的静态初始化" class="headerlink" title="显式的静态初始化"></a>显式的静态初始化</h2><p>Java允许将多个静态初始化动作组成一个特殊的“静态子句”，例如下面的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> initialization;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Spoon</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        i = <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码与其他静态初始化动作一样，这段代码仅执行一次：当首次生成这个类的一个对象时，或者首次访问属于那个类的静态数据成员时。例如下面的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> initialization;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cup</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cup</span><span class="params">(<span class="keyword">int</span> marke)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Cup("</span>+marke+<span class="string">")"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> marke)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"f("</span>+marke+<span class="string">")"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cups</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Cup cup1;</span><br><span class="line">    <span class="keyword">static</span> Cup cup2;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        cup1 = <span class="keyword">new</span> Cup(<span class="number">1</span>);</span><br><span class="line">        cup2 = <span class="keyword">new</span> Cup(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cups</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Cups()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExplicitStatic</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Inside main"</span>);</span><br><span class="line">        Cups.cup1.f(<span class="number">9</span>);<span class="comment">//[1]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//static Cups cups1 = new Cups();//[2]</span></span><br><span class="line">    <span class="comment">//static Cups cups2 = new Cups();//[2]</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Inside main</span></span><br><span class="line"><span class="comment">Cup(1)</span></span><br><span class="line"><span class="comment">Cup(2)</span></span><br><span class="line"><span class="comment">f(9)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>无论是通过【1】的那行访问静态的cup1对象，还是把【1】处的代码注释掉，去运行【2】处的代码，Cups的静态初始化动作都会得到执行，如果都把【1】【2】同时注释掉，Cups的静态初始化就不会进行，此外，注释一行还是两行【2】处的代码都没有关系，因为静态初始化只进行一次。</p>
<h2 id="非静态实例初始化"><a href="#非静态实例初始化" class="headerlink" title="非静态实例初始化"></a>非静态实例初始化</h2><p>Java中有被称为实例初始化的类似语法，用来初始化每个对象的非静态变量。实例初始化块是在构造器之前执行</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> initialization;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mug</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Mug</span><span class="params">(<span class="keyword">int</span> mark)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Mug("</span>+mark+<span class="string">")"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> mark)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"f("</span>+mark+<span class="string">")"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mugs</span></span>&#123;</span><br><span class="line">    Mug mug1;</span><br><span class="line">    Mug mug2;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Mugs</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Mugs"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        mug1 = <span class="keyword">new</span> Mug(<span class="number">1</span>);</span><br><span class="line">        mug2 = <span class="keyword">new</span> Mug(<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">"mug1 &amp; mug2 init"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Mugs</span><span class="params">(<span class="keyword">int</span> mark)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Mugs("</span>+mark+<span class="string">")"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Inside main"</span>);</span><br><span class="line">        <span class="keyword">new</span> Mugs();</span><br><span class="line">        System.out.println(<span class="string">"new Mugs() completed"</span>);</span><br><span class="line">        <span class="keyword">new</span> Mugs(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">"new Mugs(int) completed"</span>);        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Inside main</span></span><br><span class="line"><span class="comment">Mug(1)</span></span><br><span class="line"><span class="comment">Mug(2)</span></span><br><span class="line"><span class="comment">mug1 &amp; mug2 init</span></span><br><span class="line"><span class="comment">Mugs</span></span><br><span class="line"><span class="comment">new Mugs() completed</span></span><br><span class="line"><span class="comment">Mug(1)</span></span><br><span class="line"><span class="comment">Mug(2)</span></span><br><span class="line"><span class="comment">mug1 &amp; mug2 init</span></span><br><span class="line"><span class="comment">Mugs(1)</span></span><br><span class="line"><span class="comment">new Mugs(int) completed</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="可变参数列表"><a href="#可变参数列表" class="headerlink" title="可变参数列表"></a>可变参数列表</h2><p>在方法的形式参数里使用<strong><code>...</code></strong>来表示<strong>可变参数列表</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> initialization;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OptionalTrainlingArguments</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fc</span><span class="params">(<span class="keyword">int</span> i,String...argsnuments)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"i="</span>+i+<span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">for</span>(String s:argsnuments)&#123;</span><br><span class="line">            System.out.println(s+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        fc(<span class="number">0</span>);</span><br><span class="line">        fc(<span class="number">1</span>,<span class="string">"yang"</span>);</span><br><span class="line">        fc(<span class="number">2</span>,<span class="string">"yang"</span>,<span class="string">"a"</span>,<span class="string">"yang"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">i=0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">i=1</span></span><br><span class="line"><span class="comment">yang</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">i=2</span></span><br><span class="line"><span class="comment">yang</span></span><br><span class="line"><span class="comment">a</span></span><br><span class="line"><span class="comment">yang</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>在可变参数列表中可以使用任何类型的参数，包括基本类型。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java基础编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java流程控制</title>
    <url>/2019/12/15/java/java%E5%9F%BA%E7%A1%80/%E3%80%903%E3%80%91Java%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<h2 id="if-else"><a href="#if-else" class="headerlink" title="if-else"></a>if-else</h2><p>if-else语句是控制程序流程的基本形式。其中的else是可选的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">boolean</span>-exp)&#123;</span><br><span class="line">    statement</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">boolean</span>-exp)&#123;</span><br><span class="line">    statement</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    statement</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><p>while，do-while和for用来控制循环，语句会重复执行，直到起控制作用的布尔表达式得到假的结果为止。</p>
<ul>
<li>while循环格式：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">boolean</span>-exp)&#123;</span><br><span class="line">    statement</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>do-while循环格式：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    statement</span><br><span class="line">&#125;<span class="keyword">while</span>(<span class="keyword">boolean</span>-exp)&#123;</span><br><span class="line">    statement</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>while和do-while的唯一区别就是do-while中的语句至少会执行一次，即便表达式第一次就被计算为false。while比do-while更常用些。</p>
<ul>
<li><p>for循环<br>for循环是经常使用的迭代形式，在第一次迭代之前要进行初始化。随后，它会进行条件测试，而在每次迭代结束时，进行某次形式的“进步”。<br>for循环的格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(inti;<span class="keyword">boolean</span>-exp;step)&#123;</span><br><span class="line">    statement</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化表达式（init），布尔表达式（boolean-exp），进步（step）运算，都可以为空。每次迭代前会测试布尔表达式，若获得的结果为false，就会执行for语句后面的代码行。每次循环结束，会执行一次进步。</p>
</li>
</ul>
<h2 id="Foreach语法"><a href="#Foreach语法" class="headerlink" title="Foreach语法"></a>Foreach语法</h2><p>JavaSE5引入一种新的更加简洁的for语法用于数组和容器，即foreach语法，foreach语法不必创建int变量去对由访问项构成的序列进行计数，foreach将自动产生每一项。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> control;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForeachTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">        <span class="keyword">float</span> f[] = <span class="keyword">new</span> <span class="keyword">float</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            f[i] = rand.nextFloat();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">float</span> x:f)&#123;</span><br><span class="line">            System.out.println(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">0.72711575</span></span><br><span class="line"><span class="comment">0.39982635</span></span><br><span class="line"><span class="comment">0.5309454</span></span><br><span class="line"><span class="comment">0.0534122</span></span><br><span class="line"><span class="comment">0.16020656</span></span><br><span class="line"><span class="comment">0.57799757</span></span><br><span class="line"><span class="comment">0.18847865</span></span><br><span class="line"><span class="comment">0.4170137</span></span><br><span class="line"><span class="comment">0.51660204</span></span><br><span class="line"><span class="comment">0.73734957</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="return语句"><a href="#return语句" class="headerlink" title="return语句"></a>return语句</h2><p><strong>return</strong>关键词有两方面的用途：一方面指定一个方法返回什么值，另一方面它会导致当前的方法退出，并返回那个值。</p>
<p>如果在返回<strong>void</strong>方法中没有return语句，那么在该方法的结尾处会有一个隐式的return，因此在方法中并非总是必须要有一个return语句。如果一个方法声明它将返回void之外的其他东西，那么必须确保每条代码路径都会将返回一个值。</p>
<h2 id="break和continue"><a href="#break和continue" class="headerlink" title="break和continue"></a>break和continue</h2><p>在任何迭代语句的主体部分，都可用break和continue控制循环的流程。break用于强制退出循环，不执行循环中的剩余语句。continue则停止执行当前的迭代，然后退回循环起始处，开始下一次迭代。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> control;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BreakAndContinue</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">47</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">9</span> != <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            System.out.print(i+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">int</span> j = i*<span class="number">27</span>;</span><br><span class="line">            <span class="keyword">if</span>(j == <span class="number">1269</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">10</span> != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(i+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">0 9 18 27 36 45</span></span><br><span class="line"><span class="comment">10 20 30 40</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="switch控制语句"><a href="#switch控制语句" class="headerlink" title="switch控制语句"></a>switch控制语句</h2><p>switch有时被归为一种选择语句。根据整数表达式的值，switch语句可以从一系列代码中选出一段去执行。</p>
<p>格式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(integral-selector)&#123;</span><br><span class="line">    <span class="keyword">case</span> integral-value1:statement;<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> integral-value2:statement;<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> integral-value3:statement;<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> integral-value4:statement;<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:statement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>integral-selector（整数选择因子）是一个能够产生整数值的表达式，switch能够将这个表达式的结果与每个integral-value相比较。若发现相符，就执行对应的语句。若没有发现相符的，就执行default语句。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java基础编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java操作符</title>
    <url>/2019/12/11/java/java%E5%9F%BA%E7%A1%80/%E3%80%902%E3%80%91Java%E6%93%8D%E4%BD%9C%E7%AC%A6/</url>
    <content><![CDATA[<h2 id="使用Java操作符"><a href="#使用Java操作符" class="headerlink" title="使用Java操作符"></a>使用Java操作符</h2><p>操作符接受一个或多个参数，并生成一个新值。参数的形式与普通的方法调用不同，但是效果是一样的。操作数作用于操作数，并生成一个新值，有些操作数可能会改变操作数自身的值，称之为“副作用”。几乎所有的操作符都只能操作“基本类型”。列外的操作符是“=”、“==”、“!=”，这些操作符能操作所有的对象。此外，String类支持“+”和“+=”操作符。</p>
<h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2><p>当一个表达式中存在多个操作符时，操作符的优先级就决定了各部分的计算顺序。Java对计算顺序做了特别的规定。最简单的规则就是先乘除后加减。应给使用括号明确规定计算顺序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> operators;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Precedence</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">1</span>,y = <span class="number">2</span>,z = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> a = x + y - <span class="number">2</span>/<span class="number">2</span> + z;<span class="comment">//(1)</span></span><br><span class="line">        <span class="keyword">int</span> b = x + (y-<span class="number">2</span>)/(<span class="number">2</span>+z);<span class="comment">//(2)</span></span><br><span class="line">        System.out.println(<span class="string">"a = "</span> + a + <span class="string">" b = "</span> + b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*output</span></span><br><span class="line"><span class="comment">a = 5 b = 1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>语句（1）和语句（2）看上去大体相同，但是输出的结果却截然不同，这就是使用括号与不使用括号的结果。</p>
<h2 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h2><p>赋值操作使用操作符“=”。所表达的意思是：取右边的值，把右边的值复制给左边的变量，右值可以是任何常数、变量或者表达式。但左值必须是一个明确的、已经命名了的变量，必须有一个物理空间可以存储等号右边的值。比方说：将一个常数赋值给一个整型变量a：</p>
<p><strong>int a =  2;</strong></p>
<p>不能把任何东西赋值给一个常数，常数不能作为左值（不能说4 = a）。</p>
<p>基本类型的赋值比较简单。基本类型存储了实际的数值，而不是指向一个对象的引用（这个后面的内容会介绍）。所以在为其赋值的时候，是直接将一个地方的内容复制到另一个地方。例如基本类型a和b，使用a=b时，是就是把b的值赋值给a变量。如修改a的值，b不会受到影响。</p>
<p>对一个对象进行操作时，真正操作的是对对象的引用。所以将一个对象赋值给另一个对象，实际是将引用从一个地方复制到另一个地方。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> operators;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tank</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> level;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Assignment</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        Tank t1 = <span class="keyword">new</span> Tank();</span><br><span class="line">        Tank t2 = <span class="keyword">new</span> Tank();</span><br><span class="line">        t1.level = <span class="number">1</span>;</span><br><span class="line">        t2.level = <span class="number">6</span>;</span><br><span class="line">        System.out.println(<span class="string">"【1】 t1.level="</span>+t1.level+</span><br><span class="line">        <span class="string">",t2.level="</span>+t2.level</span><br><span class="line">        );</span><br><span class="line">        t1 = t2;</span><br><span class="line">        <span class="comment">// t1.level = t2.level;</span></span><br><span class="line">        System.out.println(<span class="string">"【2】 t1.level="</span>+t1.level+</span><br><span class="line">        <span class="string">",t2.level="</span>+t2.level</span><br><span class="line">        );</span><br><span class="line">        t1.level = <span class="number">30</span>;</span><br><span class="line">        System.out.println(<span class="string">"【3】 t1.level="</span>+t1.level+</span><br><span class="line">        <span class="string">",t2.level="</span>+t2.level</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*output</span></span><br><span class="line"><span class="comment">【1】 t1.level=1,t2.level=6</span></span><br><span class="line"><span class="comment">【2】 t1.level=6,t2.level=6</span></span><br><span class="line"><span class="comment">【3】 t1.level=30,t2.level=30</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>Tank类的两个实例（t1，t2）是在main()里创建的。对每个Tank类的对象level域都赋予不同的值，随后将t2赋值给t1，接着修改t1的level域。在对t1赋值时，这个引用被覆盖，也就是这个引用丢失了，这种现象称之为“别名现象”，如果想避免“别名现象”，就需要写明调用的域；像这样上述代码中的15行所写那样<strong><code>t1.level = t2.level;</code></strong></p>
<h2 id="基本算术操作符"><a href="#基本算术操作符" class="headerlink" title="基本算术操作符"></a>基本算术操作符</h2><p>Java的基本算术操作符包含加号（+）、减号（-）、除号（/）、乘号（*）以及取模操作符（%）。说明一下，整数除法会直接去掉结果的小数位，不是四舍五入圆整的结果。</p>
<p>下面展示各种算术操作符的用法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> operators;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MathOps</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        Random r = <span class="keyword">new</span> Random(<span class="number">50</span>);</span><br><span class="line">        <span class="keyword">int</span> i,j,k;</span><br><span class="line">        </span><br><span class="line">        j = r.nextInt(<span class="number">100</span>)+<span class="number">1</span>;</span><br><span class="line">        System.out.println(<span class="string">"j："</span>+j);</span><br><span class="line">        k = r.nextInt(<span class="number">100</span>)+<span class="number">1</span>;</span><br><span class="line">        System.out.println(<span class="string">"k:"</span>+k);</span><br><span class="line"></span><br><span class="line">        i = j+k;</span><br><span class="line">        System.out.println(<span class="string">"+:"</span>+i);</span><br><span class="line">        </span><br><span class="line">        i = j-k;</span><br><span class="line">        System.out.println(<span class="string">"-:"</span>+i);</span><br><span class="line">        </span><br><span class="line">        i = j*k;</span><br><span class="line">        System.out.println(<span class="string">"*:"</span>+i);</span><br><span class="line"></span><br><span class="line">        i = j/k;</span><br><span class="line">        System.out.println(<span class="string">"/:"</span>+i);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">float</span> u,v,w;</span><br><span class="line"></span><br><span class="line">        v = r.nextFloat();</span><br><span class="line">        System.out.println(<span class="string">"v="</span>+v);</span><br><span class="line"></span><br><span class="line">        w = r.nextFloat();</span><br><span class="line">        System.out.println(<span class="string">"w="</span>+w);</span><br><span class="line"></span><br><span class="line">        u = v+w;</span><br><span class="line">        System.out.println(<span class="string">"v+w="</span>+u);</span><br><span class="line"></span><br><span class="line">        u = v-w;</span><br><span class="line">        System.out.println(<span class="string">"v-w="</span>+u);</span><br><span class="line"></span><br><span class="line">        u = v*w;</span><br><span class="line">        System.out.println(<span class="string">"v*w="</span>+u);</span><br><span class="line"></span><br><span class="line">        u = v/w;</span><br><span class="line">        System.out.println(<span class="string">"v/w="</span>+u);</span><br><span class="line"></span><br><span class="line">        u+=v;</span><br><span class="line">        System.out.println(<span class="string">"u+=v "</span>+u);</span><br><span class="line"></span><br><span class="line">        u-=v;</span><br><span class="line">        System.out.println(<span class="string">"u-=v "</span>+u);</span><br><span class="line"></span><br><span class="line">        u*=v;</span><br><span class="line">        System.out.println(<span class="string">"u*=v "</span>+u);</span><br><span class="line"></span><br><span class="line">        u/=v;</span><br><span class="line">        System.out.println(<span class="string">"u/=v "</span>+u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="一元加、减操作符"><a href="#一元加、减操作符" class="headerlink" title="一元加、减操作符"></a>一元加、减操作符</h3><p>一元减号用于转变数据的符号，一元加号只是为了与一元减号相对应，一元加号唯一的作用仅仅是将较小类型的操作数提升为int</p>
<h2 id="自动递增和递减"><a href="#自动递增和递减" class="headerlink" title="自动递增和递减"></a>自动递增和递减</h2><p>递增和递减运算是两种快捷的运算方式，递增操作符是<strong><code>++</code></strong>，表示“增加一个单位”；递减操作符是<strong><code>--</code></strong>，表示“减少一个单位”。递增和递减操作符不仅改变了变量，而且还改变了以变量的值作为生成的结果。</p>
<p>两种操作符各有两种使用方式，通常称为<strong>前缀式</strong>和<strong>后缀式</strong>。“<strong>前缀式递增</strong>”表示“++”操作符位于变量或表达式的前面；而“<strong>后缀递增</strong>”表示“++”操作符位于变量或表达式的后面。相应的，“<strong>前缀式递减</strong>”表示“–”操作符位于变量或表达式的前面；而“<strong>后缀递减</strong>”表示“–”操作符位于变量或表达式的后面。<strong>对于前缀式递增和前缀式递减，会先执行运算，再生成值。而对于后缀式递增和后缀式递减，会先生成值，在执行运算</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AutoInc</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        System.out.println(<span class="string">"i = "</span>+i);</span><br><span class="line">        System.out.println(<span class="string">"++i = "</span>+ ++i);</span><br><span class="line">        System.out.println(<span class="string">"i++ = "</span>+ i++);</span><br><span class="line">        System.out.println(<span class="string">"i = "</span>+ i);</span><br><span class="line">        System.out.println(<span class="string">"--i = "</span>+ --i);</span><br><span class="line">        System.out.println(<span class="string">"i-- = "</span>+ i--);</span><br><span class="line">        System.out.println(<span class="string">"i = "</span>+ i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="关系操作符"><a href="#关系操作符" class="headerlink" title="关系操作符"></a>关系操作符</h2><p>关系操作符生成的是一个<strong><code>boolean</code></strong>结果，计算的是操作数的值之间的关系。如果关系是真的关系表达式会生成<strong><code>true</code></strong>；如果关系不真实的则关系表达式生成<strong><code>false</code></strong>。<strong>关系操作符包括小于(&lt;)、大于(&gt;)、小于或等于(&lt;=)、大于或等于(&gt;=)、等于(==)以及不等于(!=)。</strong>等于或不等于适用于所有的基本数据类型，其他比较符不适用与boolean类型，boolean值只能为true和false，“大于”和“小于”没有实际意义。</p>
<h3 id="测试对象等价性"><a href="#测试对象等价性" class="headerlink" title="测试对象等价性"></a>测试对象等价性</h3><p>关系操作符==和!=也适用于所有对象，看一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> operators;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Equivalence</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        Integer n1 = <span class="keyword">new</span> Integer(<span class="number">47</span>);</span><br><span class="line">        Integer n2 = <span class="keyword">new</span> Integer(<span class="number">47</span>);</span><br><span class="line">        System.out.println(n1==n2);</span><br><span class="line">        System.out.println(n1!=n2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*output</span></span><br><span class="line"><span class="comment">false</span></span><br><span class="line"><span class="comment">true</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>操作符==和!=比较的是对象的引用。</p>
<p>如果想比较两个对象的实际内容是否相同，必须使用对象都适用的特殊方法<strong>equals()</strong>。这个方法不适用于“基本类型”，基本类型直接使用==和!=即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> operators;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EqualsMethod</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        Integer n1 = <span class="keyword">new</span> Integer(<span class="number">47</span>);</span><br><span class="line">        Integer n2 = <span class="keyword">new</span> Integer(<span class="number">47</span>);</span><br><span class="line">        System.out.println(n1.equals(n2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*output</span></span><br><span class="line"><span class="comment">true</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="逻辑操作符"><a href="#逻辑操作符" class="headerlink" title="逻辑操作符"></a>逻辑操作符</h2><p>逻辑操作符<strong>“与”（&amp;&amp;）、“或”（||）、“非”（!）</strong>能够根据参数的逻辑关系，生成一个<strong>布尔值（true或false）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> operators;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bool</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        Random r = <span class="keyword">new</span> Random(<span class="number">52</span>);</span><br><span class="line">        <span class="keyword">int</span> i = r.nextInt(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">int</span> j = r.nextInt(<span class="number">100</span>);</span><br><span class="line">        System.out.println(<span class="string">"i = "</span>+i);</span><br><span class="line">        System.out.println(<span class="string">"j = "</span>+j);</span><br><span class="line">        System.out.println(<span class="string">"i &gt; j is "</span>+(i &gt; j));</span><br><span class="line">        System.out.println(<span class="string">"i &lt; j is "</span>+(i &lt; j));</span><br><span class="line">        System.out.println(<span class="string">"i &gt;= j is "</span>+(i &gt;= j));</span><br><span class="line">        System.out.println(<span class="string">"i &lt;= j is "</span>+(i &lt;= j));</span><br><span class="line">        <span class="comment">// System.out.println("i != j is "+(i != j));</span></span><br><span class="line">        <span class="comment">// System.out.println("i &amp;&amp; j is "+(i &amp;&amp; j));</span></span><br><span class="line">        <span class="comment">// System.out.println("i &amp;&amp; j is "+(i || j));</span></span><br><span class="line">        <span class="comment">// System.out.println("!i is "+ !i);</span></span><br><span class="line">        System.out.println(</span><br><span class="line">            <span class="string">"(i&lt;10) &amp;&amp; (j&lt;10) is "</span>+ ((i&lt;<span class="number">10</span>) &amp;&amp; (j&lt;<span class="number">10</span>))</span><br><span class="line">        );</span><br><span class="line">         System.out.println(</span><br><span class="line">            <span class="string">"(i&lt;10) || (j&lt;10) is "</span>+ ((i&lt;<span class="number">10</span>) || (j&lt;<span class="number">10</span>))</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">i = 71</span></span><br><span class="line"><span class="comment">j = 19</span></span><br><span class="line"><span class="comment">i &gt; j is true</span></span><br><span class="line"><span class="comment">i &lt; j is false</span></span><br><span class="line"><span class="comment">i &gt;= j is true</span></span><br><span class="line"><span class="comment">i &lt;= j is false</span></span><br><span class="line"><span class="comment">(i&lt;10) &amp;&amp; (j&lt;10) is false</span></span><br><span class="line"><span class="comment">(i&lt;10) || (j&lt;10) is false</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="短路"><a href="#短路" class="headerlink" title="短路"></a>短路</h3><p>“短路”现象，即一旦能够明确无误的确定整个表达式的值，就不再计算表达式余下的部分，整个逻辑表达式靠后的部分有可能不会被运算。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> operators;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShortCircuit</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">test1</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"test1("</span>+v+<span class="string">")"</span>);</span><br><span class="line">        System.out.println(<span class="string">"result："</span>+(v&lt;<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">return</span> v&lt;<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">test2</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"test2("</span>+v+<span class="string">")"</span>);</span><br><span class="line">        System.out.println(<span class="string">"result："</span>+(v&lt;<span class="number">2</span>));</span><br><span class="line">        <span class="keyword">return</span> v&lt;<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">test3</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"test3("</span>+v+<span class="string">")"</span>);</span><br><span class="line">        System.out.println(<span class="string">"result："</span>+(v&lt;<span class="number">3</span>));</span><br><span class="line">        <span class="keyword">return</span> v&lt;<span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> b = test1(<span class="number">0</span>) &amp;&amp; test2(<span class="number">2</span>) &amp;&amp; test3(<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">"expression is "</span>+b+<span class="string">"\n"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//没意义</span></span><br><span class="line">        <span class="comment">// b = test1(1) || test2(5) || test3(2);</span></span><br><span class="line">        <span class="comment">// System.out.println("expression is "+b);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*output</span></span><br><span class="line"><span class="comment">test1(0)</span></span><br><span class="line"><span class="comment">result：true</span></span><br><span class="line"><span class="comment">test2(2)</span></span><br><span class="line"><span class="comment">result：false</span></span><br><span class="line"><span class="comment">expression is false</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="直接常量"><a href="#直接常量" class="headerlink" title="直接常量"></a>直接常量</h2><p>如果在程序中使用<strong><code>直接变量</code></strong>，编译器可以准确地知道生成什么样的类型，但有时候这种情况会变的模棱两可。这时候可以使用与直接量相关的某些字符来额外增加一些信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> operators;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Literals</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i1 = <span class="number">0x2f</span>;</span><br><span class="line">        System.out.println(i1+<span class="string">" i1："</span>+Integer.toBinaryString(i1));</span><br><span class="line">        <span class="keyword">int</span> i2 = <span class="number">0x2F</span>;</span><br><span class="line">        System.out.println(i2+<span class="string">" i2："</span>+Integer.toBinaryString(i2));</span><br><span class="line">        <span class="keyword">int</span> i3 = <span class="number">0177</span>;</span><br><span class="line">        System.out.println(i3+<span class="string">" i3："</span>+Integer.toBinaryString(i3));</span><br><span class="line">        <span class="keyword">char</span> c = <span class="number">0xffff</span>;</span><br><span class="line">        System.out.println(c+<span class="string">" c："</span>+Integer.toBinaryString(c));</span><br><span class="line">        <span class="keyword">byte</span> b = <span class="number">0x7f</span>;</span><br><span class="line">        System.out.println(b+<span class="string">" b："</span>+Integer.toBinaryString(b));</span><br><span class="line">        <span class="keyword">short</span> s = <span class="number">0x7fff</span>;</span><br><span class="line">        System.out.println(s+<span class="string">" s："</span>+Integer.toBinaryString(s));</span><br><span class="line">        <span class="keyword">float</span> f1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">float</span> f2 = <span class="number">1f</span>;</span><br><span class="line">        <span class="keyword">float</span> f3 = <span class="number">1F</span>;</span><br><span class="line">        <span class="keyword">double</span> d1 = <span class="number">1</span>d;</span><br><span class="line">        <span class="keyword">double</span> d2 = <span class="number">1</span>D;</span><br><span class="line">        <span class="keyword">double</span> d3 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> l1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> l2 = <span class="number">1l</span>;</span><br><span class="line">        <span class="keyword">long</span> l3 = <span class="number">1L</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*output</span></span><br><span class="line"><span class="comment">47 i1：101111</span></span><br><span class="line"><span class="comment">47 i2：101111</span></span><br><span class="line"><span class="comment">127 i3：1111111</span></span><br><span class="line"><span class="comment">? c：1111111111111111</span></span><br><span class="line"><span class="comment">127 b：1111111</span></span><br><span class="line"><span class="comment">32767 s：111111111111111</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>直接常量后面的后缀字符代表着它的类型。比如；后缀为l或者为L的代表long，后缀为F或者f的代表float。十六进制数适用于所有的整数数据类型，以前缀0x（0X），后面跟随0-9或小写（或大写）a-f来表示。如果试图将一个变量初始化成超出自身表示范围的值，编译器会提示错误信息。在上面的代码中，如果给char、byte以及short所能表示的最大的十六进制值超出表示范围，编译器会将值自动转换为int型，并提示需要对这次赋值进行“窄化转型”。</p>
<h2 id="指数记数法"><a href="#指数记数法" class="headerlink" title="指数记数法"></a>指数记数法</h2><p>在java中要表示10的2次方，使用<strong><code>1E2</code></strong>来表示。“<strong>E</strong>”表示以10为底</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> operators;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exponents</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">double</span> expFloat1 = <span class="number">1.3e-45</span>d;</span><br><span class="line">        <span class="keyword">float</span> expFloat2 = <span class="number">1.3E-45F</span>;</span><br><span class="line">        <span class="keyword">double</span> exp3 = <span class="number">5E2</span>;</span><br><span class="line">        System.out.println(expFloat1);</span><br><span class="line">        System.out.println(expFloat2);</span><br><span class="line">        System.out.println(exp3);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.3E-45</span></span><br><span class="line"><span class="comment">1.4E-45</span></span><br><span class="line"><span class="comment">500.0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="按位操作符"><a href="#按位操作符" class="headerlink" title="按位操作符"></a>按位操作符</h2><p>按位操作符用来操作整数基本数据类型中的单个“比特(bit)”，也就是二进制位。按位操作符会对两个参数中对应的位执行布尔代数运算，并最终生成一个结果。</p>
<p>按位操作的规则如下：</p>
<p><strong>如果两个输入位都是1，则按位“与”操作符（&amp;）生成一个输出为1；否则生成一个输出位0。</strong></p>
<p><strong>如果两个输入位里只要有一个是1，则按位“或”操作符（|）生成一个输出位1；只有在两个输入位都是0的情况下，才会生成一个输入位0。</strong></p>
<p><strong>如果输入位的某一位是1，但不全都是1，那么按位“异或”操作符（^）生成一个输出位1。</strong></p>
<p><strong>按位“非”（~）生成与输入位</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BitwiseOperators</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i1 = <span class="number">0xaaaaaaaa</span>;</span><br><span class="line">        <span class="keyword">int</span> i2 = <span class="number">0x55555555</span>;</span><br><span class="line">        System.out.println(<span class="string">"i1 = "</span>+Integer.toBinaryString(i1));</span><br><span class="line">        System.out.println(<span class="string">"i2 = "</span>+Integer.toBinaryString(i2));</span><br><span class="line">        System.out.println(<span class="string">"~i1 = "</span>+Integer.toBinaryString(~i1));</span><br><span class="line">        System.out.println(<span class="string">"~i2 = "</span>+Integer.toBinaryString(~i2));</span><br><span class="line">        System.out.println(<span class="string">"i1 &amp; i1 = "</span>+Integer.toBinaryString(i1 &amp; i1));</span><br><span class="line">        System.out.println(<span class="string">"i1 | i1 = "</span>+Integer.toBinaryString(i1 | i1));</span><br><span class="line">        System.out.println(<span class="string">"i1 ^ i1 = "</span>+Integer.toBinaryString(i1 ^ i1));</span><br><span class="line">        System.out.println(<span class="string">"i1 &amp; i2 = "</span>+Integer.toBinaryString(i1 &amp; i2));</span><br><span class="line">        System.out.println(<span class="string">"i1 | i2 = "</span>+Integer.toBinaryString(i1 | i2));</span><br><span class="line">        System.out.println(<span class="string">"i1 ^ i2 = "</span>+Integer.toBinaryString(i1 ^ i2));</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">i1 = 10101010101010101010101010101010</span></span><br><span class="line"><span class="comment">i2 = 1010101010101010101010101010101</span></span><br><span class="line"><span class="comment">~i1 = 1010101010101010101010101010101</span></span><br><span class="line"><span class="comment">~i2 = 10101010101010101010101010101010</span></span><br><span class="line"><span class="comment">i1 &amp; i1 = 10101010101010101010101010101010</span></span><br><span class="line"><span class="comment">i1 | i1 = 10101010101010101010101010101010</span></span><br><span class="line"><span class="comment">i1 ^ i1 = 0</span></span><br><span class="line"><span class="comment">i1 &amp; i2 = 0</span></span><br><span class="line"><span class="comment">i1 | i2 = 11111111111111111111111111111111</span></span><br><span class="line"><span class="comment">i1 ^ i2 = 11111111111111111111111111111111</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<p>按位操作符可与等号（=）联合使用，以便合并运算和赋值：&amp;=、|=、^=都是合法的；但是按位非操作符（~）不能与等号联合使用，因为它是一元操作符</p>
<p>将布尔类型作为一种单比特值对待，可对它执行按位“与”，按位“或”，按位“异或”运算，但是不能对其进行按位“非”运算，对于布尔值，按位操作符具有与逻辑操作符相同的效果，只是按位操作符不会有短路的效果。</p>
<h2 id="移位操作符"><a href="#移位操作符" class="headerlink" title="移位操作符"></a>移位操作符</h2><p>移位操作符的运算对象也是二进制位。移位操作符只可用于处理整数类型。左移位操作符（<strong><code>&lt;&lt;</code></strong>）能够按照操作符右侧指定的位数将操作符左边的操作数向左移动（在低位补0）。“有符号”右移位操作符（<strong><code>&gt;&gt;</code></strong>）按照操作符右侧指定的位数将操作符左边的操作数向右移动。“有符号”右移位操作符使用“符号扩展”：若符号为正，则在高位插入0；若符号为负，则在高位插入1。Java增加了一种“无符号”右移位操作符（<strong><code>&gt;&gt;&gt;</code></strong>）,使用“零扩展”：无论正负，都在高位插入0。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BitManipulation</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">        <span class="keyword">int</span> i = rand.nextInt();</span><br><span class="line">        <span class="keyword">int</span> j = rand.nextInt();</span><br><span class="line">        printBinaryInt(<span class="string">"-1"</span>,-<span class="number">1</span>);</span><br><span class="line">        printBinaryInt(<span class="string">"+1"</span>,+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> maxpos = <span class="number">2147483647</span>;</span><br><span class="line">        printBinaryInt(<span class="string">"maxpos"</span>,maxpos);</span><br><span class="line">        <span class="keyword">int</span> maxneg = -<span class="number">2147483648</span>;</span><br><span class="line">        printBinaryInt(<span class="string">"maxneg"</span>,maxneg);</span><br><span class="line">        printBinaryInt(<span class="string">"i"</span>,i);</span><br><span class="line">        printBinaryInt(<span class="string">"~i"</span>,~i);</span><br><span class="line">        printBinaryInt(<span class="string">"-i"</span>,-i);</span><br><span class="line">        printBinaryInt(<span class="string">"j"</span>,j);</span><br><span class="line">        printBinaryInt(<span class="string">"i&amp;j"</span>,i&amp;j);</span><br><span class="line">        printBinaryInt(<span class="string">"i|j"</span>,i|j);</span><br><span class="line">        printBinaryInt(<span class="string">"i^j"</span>,i^j);</span><br><span class="line">        printBinaryInt(<span class="string">"i&lt;&lt;5"</span>,i&lt;&lt;<span class="number">5</span>);</span><br><span class="line">        printBinaryInt(<span class="string">"i&gt;&gt;5"</span>,i&gt;&gt;<span class="number">5</span>);</span><br><span class="line">        printBinaryInt(<span class="string">"(~i)&gt;&gt;5"</span>,(~i)&gt;&gt;<span class="number">5</span>);</span><br><span class="line">        printBinaryInt(<span class="string">"i&gt;&gt;&gt;5"</span>,i&gt;&gt;&gt;<span class="number">5</span>);</span><br><span class="line">        printBinaryInt(<span class="string">"(~i)&gt;&gt;&gt;5"</span>,(~i)&gt;&gt;&gt;<span class="number">5</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">long</span> l = rand.nextLong();</span><br><span class="line">        <span class="keyword">long</span> m = rand.nextLong();</span><br><span class="line">        printBinaryLong(<span class="string">"l"</span>,l);</span><br><span class="line">        printBinaryLong(<span class="string">"~l"</span>,~l);</span><br><span class="line">        printBinaryLong(<span class="string">"-l"</span>,-l);</span><br><span class="line">        printBinaryLong(<span class="string">"m"</span>,m);</span><br><span class="line">        printBinaryLong(<span class="string">"l&amp;m"</span>,l&amp;m);</span><br><span class="line">        printBinaryLong(<span class="string">"l|m"</span>,l|m);</span><br><span class="line">        printBinaryLong(<span class="string">"l^m"</span>,l^m);</span><br><span class="line">        printBinaryLong(<span class="string">"l&lt;&lt;5"</span>,l&lt;&lt;<span class="number">5</span>);</span><br><span class="line">        printBinaryLong(<span class="string">"l&gt;&gt;5"</span>,l&gt;&gt;<span class="number">5</span>);</span><br><span class="line">        printBinaryLong(<span class="string">"(~l)&gt;&gt;5"</span>,(~l)&gt;&gt;<span class="number">5</span>);</span><br><span class="line">        printBinaryLong(<span class="string">"l&gt;&gt;&gt;5"</span>,l&gt;&gt;&gt;<span class="number">5</span>);</span><br><span class="line">        printBinaryLong(<span class="string">"(~l)&gt;&gt;&gt;5"</span>,(~l)&gt;&gt;&gt;<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printBinaryInt</span><span class="params">(String s,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        System.out.println(s+<span class="string">",int："</span> + i + <span class="string">", binary：\n"</span>+Integer.toBinaryString(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printBinaryLong</span><span class="params">(String s,<span class="keyword">long</span> l)</span></span>&#123;</span><br><span class="line">        System.out.println(s+<span class="string">",Long："</span>+l+<span class="string">", binary：\n"</span>+Long.toBinaryString(l));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">-1,int：-1, binary：</span></span><br><span class="line"><span class="comment">11111111111111111111111111111111</span></span><br><span class="line"><span class="comment">+1,int：1, binary：</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">maxpos,int：2147483647, binary：</span></span><br><span class="line"><span class="comment">1111111111111111111111111111111</span></span><br><span class="line"><span class="comment">maxneg,int：-2147483648, binary：</span></span><br><span class="line"><span class="comment">10000000000000000000000000000000</span></span><br><span class="line"><span class="comment">i,int：-1172028779, binary：</span></span><br><span class="line"><span class="comment">10111010001001000100001010010101</span></span><br><span class="line"><span class="comment">~i,int：1172028778, binary：</span></span><br><span class="line"><span class="comment">1000101110110111011110101101010</span></span><br><span class="line"><span class="comment">-i,int：1172028779, binary：</span></span><br><span class="line"><span class="comment">1000101110110111011110101101011</span></span><br><span class="line"><span class="comment">j,int：1717241110, binary：</span></span><br><span class="line"><span class="comment">1100110010110110000010100010110</span></span><br><span class="line"><span class="comment">i&amp;j,int：570425364, binary：</span></span><br><span class="line"><span class="comment">100010000000000000000000010100</span></span><br><span class="line"><span class="comment">i|j,int：-25213033, binary：</span></span><br><span class="line"><span class="comment">11111110011111110100011110010111</span></span><br><span class="line"><span class="comment">i^j,int：-595638397, binary：</span></span><br><span class="line"><span class="comment">11011100011111110100011110000011</span></span><br><span class="line"><span class="comment">i&lt;&lt;5,int：1149784736, binary：</span></span><br><span class="line"><span class="comment">1000100100010000101001010100000</span></span><br><span class="line"><span class="comment">i&gt;&gt;5,int：-36625900, binary：</span></span><br><span class="line"><span class="comment">11111101110100010010001000010100</span></span><br><span class="line"><span class="comment">(~i)&gt;&gt;5,int：36625899, binary：</span></span><br><span class="line"><span class="comment">10001011101101110111101011</span></span><br><span class="line"><span class="comment">i&gt;&gt;&gt;5,int：97591828, binary：</span></span><br><span class="line"><span class="comment">101110100010010001000010100</span></span><br><span class="line"><span class="comment">(~i)&gt;&gt;&gt;5,int：36625899, binary：</span></span><br><span class="line"><span class="comment">10001011101101110111101011</span></span><br><span class="line"><span class="comment">l,Long：-8652529054300476342, binary：</span></span><br><span class="line"><span class="comment">1000011111101100000010101010101100001101101011000110110001001010</span></span><br><span class="line"><span class="comment">~l,Long：8652529054300476341, binary：</span></span><br><span class="line"><span class="comment">111100000010011111101010101010011110010010100111001001110110101</span></span><br><span class="line"><span class="comment">-l,Long：8652529054300476342, binary：</span></span><br><span class="line"><span class="comment">111100000010011111101010101010011110010010100111001001110110110</span></span><br><span class="line"><span class="comment">m,Long：2955289354441303771, binary：</span></span><br><span class="line"><span class="comment">10100100000011010011000000001010010011111101111010011011011011</span></span><br><span class="line"><span class="comment">l&amp;m,Long：72066398748419146, binary：</span></span><br><span class="line"><span class="comment">100000000000010000000001000000001101001000010010001001010</span></span><br><span class="line"><span class="comment">l|m,Long：-5769306098607591717, binary：</span></span><br><span class="line"><span class="comment">1010111111101111010011101010101110011111111111111110111011011011</span></span><br><span class="line"><span class="comment">l^m,Long：-5841372497356010863, binary：</span></span><br><span class="line"><span class="comment">1010111011101111010001101010100110011110010110111100101010010001</span></span><br><span class="line"><span class="comment">l&lt;&lt;5,Long：-179768631971968704, binary：</span></span><br><span class="line"><span class="comment">1111110110000001010101010110000110110101100011011000100101000000</span></span><br><span class="line"><span class="comment">l&gt;&gt;5,Long：-270391532946889886, binary：</span></span><br><span class="line"><span class="comment">1111110000111111011000000101010101011000011011010110001101100010</span></span><br><span class="line"><span class="comment">(~l)&gt;&gt;5,Long：270391532946889885, binary：</span></span><br><span class="line"><span class="comment">1111000000100111111010101010100111100100101001110010011101</span></span><br><span class="line"><span class="comment">l&gt;&gt;&gt;5,Long：306069219356533602, binary：</span></span><br><span class="line"><span class="comment">10000111111011000000101010101011000011011010110001101100010</span></span><br><span class="line"><span class="comment">(~l)&gt;&gt;&gt;5,Long：270391532946889885, binary：</span></span><br><span class="line"><span class="comment">1111000000100111111010101010100111100100101001110010011101</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<p>移位可与等号组合使用（&lt;&lt;=、&gt;&gt;=、&gt;&gt;&gt;=）。操作符左边的值会移动由右边的值指定的位数，再将得到的结果赋值给左边的变量。在进行“无符号”右移位赋值操作时，可能会对遇到一个问题：如果对byte、short值进行“无符号”右移位运算时，得到的结果可能不是正确的结果。它们会先被转换成int类型，在进行右移操作，然后被截断，赋值给原来的类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">URShift</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = -<span class="number">1</span>;</span><br><span class="line">        System.out.println(<span class="string">"i "</span>+Integer.toBinaryString(i));</span><br><span class="line">        i&gt;&gt;&gt;=<span class="number">10</span>;</span><br><span class="line">        System.out.println(<span class="string">"i&gt;&gt;&gt;=10 "</span>+Integer.toBinaryString(i));</span><br><span class="line">        <span class="keyword">long</span> l = -<span class="number">1</span>;</span><br><span class="line">        System.out.println(<span class="string">"l "</span>+Long.toBinaryString(l));</span><br><span class="line">        l &gt;&gt;&gt;= <span class="number">10</span>;</span><br><span class="line">        System.out.println(<span class="string">"l &gt;&gt;&gt;= 10 "</span>+Long.toBinaryString(l));</span><br><span class="line">        <span class="keyword">short</span> s = -<span class="number">1</span>;</span><br><span class="line">        System.out.println(<span class="string">"s "</span>+Integer.toBinaryString(s));</span><br><span class="line">        s&gt;&gt;&gt;=<span class="number">10</span>;</span><br><span class="line">        System.out.println(<span class="string">"s&gt;&gt;&gt;=10 "</span>+Integer.toBinaryString(s));</span><br><span class="line">        <span class="keyword">byte</span> b = -<span class="number">1</span>;</span><br><span class="line">        System.out.println(<span class="string">"b "</span>+Integer.toBinaryString(b));</span><br><span class="line">        b &gt;&gt;&gt;= <span class="number">10</span>;</span><br><span class="line">        System.out.println(<span class="string">"b&gt;&gt;&gt;=10 "</span>+Integer.toBinaryString(b));</span><br><span class="line">        b = -<span class="number">1</span>;</span><br><span class="line">        System.out.println(<span class="string">"b "</span>+Integer.toBinaryString(b));</span><br><span class="line">        <span class="comment">// b &gt;&gt;&gt; 10; 编译错误</span></span><br><span class="line">        System.out.println(<span class="string">"b&gt;&gt;&gt;10 "</span>+Integer.toBinaryString(b&gt;&gt;&gt;<span class="number">10</span>));</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">i 11111111111111111111111111111111</span></span><br><span class="line"><span class="comment">i&gt;&gt;&gt;=10 1111111111111111111111</span></span><br><span class="line"><span class="comment">l 1111111111111111111111111111111111111111111111111111111111111111</span></span><br><span class="line"><span class="comment">l &gt;&gt;&gt;= 10 111111111111111111111111111111111111111111111111111111</span></span><br><span class="line"><span class="comment">s 11111111111111111111111111111111</span></span><br><span class="line"><span class="comment">s&gt;&gt;&gt;=10 11111111111111111111111111111111</span></span><br><span class="line"><span class="comment">b 11111111111111111111111111111111</span></span><br><span class="line"><span class="comment">b&gt;&gt;&gt;=10 11111111111111111111111111111111</span></span><br><span class="line"><span class="comment">b 11111111111111111111111111111111</span></span><br><span class="line"><span class="comment">b&gt;&gt;&gt;10 1111111111111111111111</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>如果对char、byte或者short类型的数值进行移位操作，那在移位进行之前，它们被转换成int类型，并且得到的结果也是一个int类型的值。只有数值右端的低5位才有用。这样可以防止移位超过int型值所具有的位数。对一个long类型的数值进行移位处理，最后得到的结果也是long，结果只用到了数值右端的低6位，防止移位超过long型数值具有的位数。</p>
<h2 id="三目运算"><a href="#三目运算" class="headerlink" title="三目运算"></a>三目运算</h2><p><strong><code>三目运算操作符</code></strong>也称条件操作符，它有三个操作数，其表达式如下：</p>
<p><code>boolean exp?value0:value1</code></p>
<p>如果<strong>boolean-exp</strong>（布尔表达式）的结果位<strong>true</strong>，就计算<strong>value0</strong>，而且这个计算结果也就是操作符的最终产生的值。如果<strong>boolean-exp</strong>的结果为<strong>false</strong>，就计算<strong>value1</strong>，同样这个计算结果也就成为了操作符最终产生的值。</p>
<p>三目运算也可以使用普通的<strong><code>if-else</code></strong>语句，但是三目运算符更加的简洁。但三目运算操作符与if-else完全不同，因为它会产生一个值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> operators;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TernaryIfElse</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ternary</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i&lt;<span class="number">10</span> ? i*<span class="number">100</span> : i*<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">IfElse</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">10</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> i*<span class="number">10</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> i*<span class="number">100</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        System.out.println(ternary(<span class="number">11</span>));</span><br><span class="line">        System.out.println(ternary(<span class="number">10</span>));</span><br><span class="line">        System.out.println(IfElse(<span class="number">9</span>));</span><br><span class="line">        System.out.println(IfElse(<span class="number">10</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">110</span></span><br><span class="line"><span class="comment">100</span></span><br><span class="line"><span class="comment">90</span></span><br><span class="line"><span class="comment">1000</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="类型转换操作符"><a href="#类型转换操作符" class="headerlink" title="类型转换操作符"></a>类型转换操作符</h2><p><strong>类型转换（cast）</strong>。在适当的时候，Java会将一种数据类型自动转换为另一种。类型转换运算允许显式的进行这种类型的转换，或者在不能自动进行转换的时候强制进行类型转换。想要执行类型转换，需要将希望得到的数据类型置于括号中，放在要进行类型转换的值的左边。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> operators;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Casting</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">200</span>;</span><br><span class="line">        <span class="keyword">long</span> l = (<span class="keyword">int</span>)i;</span><br><span class="line">        l = i;</span><br><span class="line">        <span class="keyword">long</span> l2 = <span class="number">200</span>;</span><br><span class="line">        i = (<span class="keyword">int</span>)l2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="窄化转换"><a href="#窄化转换" class="headerlink" title="窄化转换"></a>窄化转换</h3><p>在Java中，类型转换是一种比较安全的操作，但如果要执行一种名为<strong><code>窄化转换</code></strong>的操作（将能容纳更多信息的数据类型转换成无法容纳那么多信息的类型），就可能面临信息丢失的风险。</p>
<h3 id="截尾和舍入"><a href="#截尾和舍入" class="headerlink" title="截尾和舍入"></a>截尾和舍入</h3><p>在执行窄化转换时，必须注意截尾和舍入问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> operators;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CastingNumbers</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">double</span> above = <span class="number">0.7</span>,below = <span class="number">0.4</span>;</span><br><span class="line">        <span class="keyword">float</span> fabove = <span class="number">0.7f</span>,fbelow = <span class="number">0.4f</span>;</span><br><span class="line">        System.out.println(<span class="string">"(int)above "</span>+(<span class="keyword">int</span>)above);</span><br><span class="line">        System.out.println(<span class="string">"(int)below "</span>+(<span class="keyword">int</span>)below);</span><br><span class="line">        System.out.println(<span class="string">"(int)fabove "</span>+(<span class="keyword">int</span>)fabove);</span><br><span class="line">        System.out.println(<span class="string">"(int)fbelow "</span>+(<span class="keyword">int</span>)fbelow);</span><br><span class="line">        System.out.println(<span class="string">"Math.round(above) "</span>+Math.round(above));</span><br><span class="line">        System.out.println(<span class="string">"Math.round(below) "</span>+Math.round(below));</span><br><span class="line">        System.out.println(<span class="string">"Math.round(fabove) "</span>+Math.round(fabove));</span><br><span class="line">        System.out.println(<span class="string">"Math.round(fbelow) "</span>+Math.round(fbelow));</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">(int)above 0</span></span><br><span class="line"><span class="comment">(int)below 0</span></span><br><span class="line"><span class="comment">(int)fabove 0</span></span><br><span class="line"><span class="comment">(int)fbelow 0</span></span><br><span class="line"><span class="comment">Math.round(above) 1</span></span><br><span class="line"><span class="comment">Math.round(below) 0</span></span><br><span class="line"><span class="comment">Math.round(fabove) 1</span></span><br><span class="line"><span class="comment">Math.round(fbelow) 0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>如果要对结果进行舍入，就需要使用<strong>java.lang.Math</strong>中的<strong><code>round</code></strong>方法</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java基础编程</tag>
      </tags>
  </entry>
  <entry>
    <title>一切皆对象</title>
    <url>/2019/12/09/java/java%E5%9F%BA%E7%A1%80/%E3%80%901%E3%80%91%E4%B8%87%E7%89%A9%E7%9A%86%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h2 id="引用操作对象"><a href="#引用操作对象" class="headerlink" title="引用操作对象"></a>引用操作对象</h2><p>每种编程语言都有自己的操作内存中元素的方式。需要注意到将要处理的数据是什么类型。是直接操作元素，还是基于某种特殊的语法间接表示来操作对象呢？</p>
<p>在Java里将这些做了简化。将一切都视为对象，可采取单一固定的语法。操作的标识符实际上是对象的一个“引用”。拥有一个引用，并不一定需要有一个对象与它关联。所有。如果需要操作一个句子或者词，则可以创建一个<strong><code>String</code></strong>引用，像这样：<strong><code>String s</code></strong>。这只是创建一个引用，并不是对象。一种正确的用法是：创建一个引用的同时便进行初始化：<strong><code>String s = &quot;Object&quot;;</code></strong></p>
<h2 id="创建所有对象"><a href="#创建所有对象" class="headerlink" title="创建所有对象"></a>创建所有对象</h2><p>创建了一个引用，希望这个引用能与一个对象相关联。通常用<strong><code>new</code></strong>操作符来实现与此对象相关联。所以上面的例子可以写成：<strong><code>String s = new String(&quot;Object&quot;)</code></strong></p>
<h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><p>Java要确定每种基本类型所占据的储存空间大小。每种类型的大小不会像其他语言那样随机器硬件架构的变化而变化。储存空间大小的不变性是Java程序比其他编程语言程序更具可移植性的原因之一。</p>
<table>
<thead>
<tr>
<th>基本类型</th>
<th>大小</th>
<th>最小值</th>
<th>最大值</th>
<th>包装器类型</th>
</tr>
</thead>
<tbody><tr>
<td>boolean</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>Boolean</td>
</tr>
<tr>
<td>char</td>
<td>16bit</td>
<td>Unicode 0</td>
<td>Unicode 2[^^][^ 16]-1</td>
<td>Character</td>
</tr>
<tr>
<td>byte</td>
<td>8bit</td>
<td>-128</td>
<td>+127</td>
<td>Byte</td>
</tr>
<tr>
<td>short</td>
<td>16bit</td>
<td>-2[^^ 15]</td>
<td>+12[^^15]-1</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td>32bit</td>
<td>-2[^^31]</td>
<td>+2[^^31]-1</td>
<td>Integer</td>
</tr>
<tr>
<td>long</td>
<td>64bit</td>
<td>-2[^^63]</td>
<td>+2[^^63]-1</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>32bit</td>
<td>IEEE754</td>
<td>IEEE754</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>64bit</td>
<td>IEEE754</td>
<td>IEEE754</td>
<td>Double</td>
</tr>
<tr>
<td>void</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>Void</td>
</tr>
</tbody></table>
<p>所有这些类型都有正负号，因此不需要去寻找它们的无符号数值类型</p>
<p><strong><code>boolean</code></strong>类型所占据的储存空间大小没有明确规定，仅指定了能够取字面值<strong>true</strong>和<strong>false</strong>。自JavaSE5后，上面列举的基本类型，在将其初始化是都能自动拆装为对应的包装类型（自动拆装箱）。基本类型具有的包装器类。使得可以在堆中创建一个非基本对象，用来表示对应的基本类型。</p>
<h3 id="基本类型的默认值"><a href="#基本类型的默认值" class="headerlink" title="基本类型的默认值"></a>基本类型的默认值</h3><table>
<thead>
<tr>
<th>基本类型</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>boolean</td>
<td>false</td>
</tr>
<tr>
<td>char</td>
<td>‘\u0000’</td>
</tr>
<tr>
<td>byte</td>
<td>(byte)0</td>
</tr>
<tr>
<td>short</td>
<td>(short)0</td>
</tr>
<tr>
<td>int</td>
<td>0</td>
</tr>
<tr>
<td>long</td>
<td>0L</td>
</tr>
<tr>
<td>float</td>
<td>0.0f</td>
</tr>
<tr>
<td>double</td>
<td>0.0d</td>
</tr>
</tbody></table>
<p>若某个基本数据类型没有初始化，Java也会确保它获得一个默认值，如上图</p>
<h3 id="高精度数字"><a href="#高精度数字" class="headerlink" title="高精度数字"></a>高精度数字</h3><p>Java提供了两个用于高精度计算的类型：<strong>BigInteger</strong>和<strong>BigDecimal</strong>。BigInteger可以支持任意精度的整数，BigDecimal支持任何精度的定点数。这两个没有对应的基本类型，即使它们基本上属于“包装器类”的范畴。这两个类包含的方法，提供的操作与基本类型所能执行的操作相似，能够应用于int和float操作，同样可用BigInteger或BigDecimal，只是必须以方法调用的方式取代运算符方式来实现。</p>
<h2 id="Java的作用域"><a href="#Java的作用域" class="headerlink" title="Java的作用域"></a>Java的作用域</h2><p>在大多数过程型语言中都有<strong>作用域</strong>(scope)的概念，作用域决定了在其内定义的变量名可见性和生命周期。作用域由花括号<strong><code>{}</code></strong>的位置决定。在作用域里定义的变量只可用与作用域结束之前。</p>
<p>Java对象不具备和基本类型一样的生命周期。当用new创建一个Java对象时，这个对象可以存活于作用域之外。举个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    String s = <span class="keyword">new</span> String(<span class="string">"a string"</span>);</span><br><span class="line">&#125;<span class="comment">//End of scope</span></span><br></pre></td></tr></table></figure>

<p>引用s在作用域终点就消失了，但是s指向的String对象仍能继续占据内存空间。在上面的代码段中，无法在这个作用域之外访问这个对象，因为对它的唯一引用已经超过了作用域的范围。</p>
<p>Java中，用new创建的对象，如果需要就会一直保留下去，这就带来了一个问题，如果Java让对象一直保存下去，那么这些对象是不是将填满内存空间？这是C++存在的问题，Java中不会存在。Java有一个叫<strong>垃圾回收器</strong>的东西，用来监视用new创建的所有对象，并辨别出那些不会再被引用的对象。随后释放这些对象的内存空间，以便供其他新的对象使用。这样消除了内存泄露的问题。</p>
<h2 id="如何定义一个类"><a href="#如何定义一个类" class="headerlink" title="如何定义一个类"></a>如何定义一个类</h2><p>在大多数面向对象编程的程序语言中使用关键字<strong><code>class</code></strong>来定义一个新的类型。class关键字后紧跟着的是新类型的名称。像这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就给Java引入了一个新的类型。如何可以通过new关键字来创建这个类的对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClassName cn = <span class="keyword">new</span> ClassName();</span><br></pre></td></tr></table></figure>

<h2 id="方法、字段、参数和返回值"><a href="#方法、字段、参数和返回值" class="headerlink" title="方法、字段、参数和返回值"></a>方法、字段、参数和返回值</h2><p>一旦定义了一个类，就可以在类中设置两种类型的元素：字段和方法。字段可以是任意类型的对象，可通过其引用与其进行通信；也可以是基本类型中的一种。如果字段是对某个对象的引用，那么必须初始化该引用，以便使其与实际对象相关联。每个对象都有用来存储器字段的空间；普通字段不能在对象间共享。</p>
<p>Java的<strong>方法</strong>决定了一个对象能够接收什么样的消息。方法的基本组成部分包括：名称、参数列表、返回值、方法体。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">ReturnType <span class="title">methodName</span><span class="params">(Argument list)</span></span>&#123;</span><br><span class="line">    <span class="comment">//Method body</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回类型描述的是调用方法之后从方法返回的值。参数列表给出了要传给方法的信息的类型和名称。方法名和参数列表(合称“方法签名”)唯一的标识出某个方法。</p>
<h3 id="参数列表"><a href="#参数列表" class="headerlink" title="参数列表"></a>参数列表</h3><p>方法的参数列表指定要传递给方法什么信息。假设某个方法接受String为参数，其定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">storage</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.length()*<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法中可以了解到<strong><code>return</code></strong>关键字的用法,它包含两方面：代表此方法已经执行结束，离开此方法。如果此方法产生一个值，这个值要放在return关键字后面。</p>
<p>如果返回类型是<strong><code>void</code></strong>，return关键字的作用只是用来退出方法，所以，没有必要到方法结束时才离开，可以在任何地方返回。但如果返回类型不是<strong>void</strong>，那么无论何处返回，编译器都会强制返回一个正确类型的返回值。</p>
<h2 id="创建一个Java程序"><a href="#创建一个Java程序" class="headerlink" title="创建一个Java程序"></a>创建一个Java程序</h2><p><code>Objects/HelloDate.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> objects;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloDate</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello World"</span>);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的<code>HelloDate</code>Java程序，类的名称和文件名必须要相同，如果创建一个独立的运行程序，那么文件中必须存在某个类的类名与该文件同名，并且那个类必须包含一个名为main()的方法。</p>
<p>使用关键字<strong><code>import</code></strong>关键字准确的告诉编译器需要的类是什么，<strong>import</strong>指示编译器导入一个包，也就是一个类库。</p>
<p>当什么一个事物是<strong><code>static</code></strong>时，就意味着这个域或者方法不会包含它的那个类的任何对象实例关联在一起。所以即使从未创建某个类的任何对象，也可以调用其static方法或访问static域。将static关键字放在定义之前，就可以将字段或方法设定为static。使用类名使用static变量的首选方式，这样不仅可以强调变量是static结构，而且在某些情况下还为编译器进行优化提供机会。<strong>static方法的一个重要用法是在不创建任何对象的前提下就可以调用它</strong>。</p>
<h2 id="编译和运行Java程序"><a href="#编译和运行Java程序" class="headerlink" title="编译和运行Java程序"></a>编译和运行Java程序</h2><p>程序代码编写完成后接下来就是对代码进行编译会运行：</p>
<p>这个过程要确保机器安装好了JDK环境，同时还要设定好路径，方便机器能够找到<strong><code>javac</code></strong>和<strong><code>java</code></strong>这两个文件。</p>
<p>编译前面的代码：<strong>Objects/HelloDate.java</strong>。</p>
<p>键入<strong><code>javac -d . -encoding utf-8 HelloDate.java</code></strong>。这条命令表示编译HelloDate.java文件，使用的是utf-8编码，并自动在当前目录下创建<strong>objects</strong>文件夹，在objects文件夹下生成<strong><code>HelloDate.class</code></strong>文件。如果这个过程顺利完成，则不会有任何输出信息，说明一切都正常。</p>
<p>编译好代码后，运行<strong>HelloDate</strong>的java程序</p>
<p>键入<strong><code>java -cp ./ objects.HelloDate</code></strong>即可运行这个Java程序。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java基础编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java枚举类型</title>
    <url>/2019/12/07/java/java%E5%9F%BA%E7%A1%80/%E3%80%9019%E3%80%91Java%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h3 id="Enum关键字"><a href="#Enum关键字" class="headerlink" title="Enum关键字"></a>Enum关键字</h3><p><strong><code>enum</code></strong>关键字，在需要群组并使用枚举类型集合时，可以很方便的处理。由于枚举类型的实例是常量，因此命名时大都使用大写。在创建enum时，编译器会自动添加一些有用的特性，,比如会创建toString()方法，便于显示某个enum实例的名字。编译器还会创建ordinal()方法，用来表示某个特定<strong>enum常量</strong>的声明顺序。<strong><code>static values()</code></strong>方法产生常量值构成的数组,还会生成一个相关的类，这个类继承自<strong><code>java.lang.Enum</code></strong></p>
<p>下面看代码实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">              <span class="comment">//values()方法用于产生常量值构成的数组</span></span><br><span class="line">		<span class="keyword">for</span>(Spiciness s:Spiciness.values()) &#123;</span><br><span class="line">             <span class="comment">//ordinal()方法，用来表示某个特定**enum常量**的声明顺序</span></span><br><span class="line">			System.out.println(s+<span class="string">" ,"</span>+s.ordinal());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Spiciness &#123;</span><br><span class="line"><span class="comment">//声明enum常量时通常使用大写字母</span></span><br><span class="line">	NOT,</span><br><span class="line">	MILD,</span><br><span class="line">	MEDIUM,</span><br><span class="line">	HOT</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleEnumeUse</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Spiciness howhot = Spiciness.MILD;</span><br><span class="line">		System.out.println(howhot);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>enum还有一个实用的特性，可以在<strong><code>switch</code></strong>语句块中使用</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> EnumType.demo1.Spiciness.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Burrito</span> &#123;</span></span><br><span class="line">	Spiciness deg;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Burrito</span><span class="params">(Spiciness s)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.deg = s;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">describe</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"This Burrito"</span>);</span><br><span class="line">		<span class="keyword">switch</span> (deg) &#123;</span><br><span class="line">		<span class="keyword">case</span> NOT:</span><br><span class="line">			System.out.<span class="built_in">println</span>(<span class="string">"not"</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> MILD:</span><br><span class="line">			System.out.<span class="built_in">println</span>(<span class="string">"this MILD"</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> MEDIUM:</span><br><span class="line">			System.out.<span class="built_in">println</span>(<span class="string">"a little hot"</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> HOT:</span><br><span class="line">			System.out.<span class="built_in">println</span>(<span class="string">"this is HOT"</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">		Burrito plain = <span class="keyword">new</span> Burrito(HOT);</span><br><span class="line">		plain.describe();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于switch是要在有限的可能值集合中进行选择，因此与enum能很好的进行组合。</p>
<h3 id="将静态导入应用于enum"><a href="#将静态导入应用于enum" class="headerlink" title="将静态导入应用于enum"></a>将静态导入应用于enum</h3><p>使用<strong><code>static import</code></strong>能够将enum实例的标识符带入当前的命名空间，所以无需再用enum类型来修饰enum实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Spiciness &#123;</span><br><span class="line">	NOT,</span><br><span class="line">	MILD,</span><br><span class="line">	MEDIUM,</span><br><span class="line">	HOT</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//static import导入Spiciness</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> EnumType.demo1.Spiciness.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImportEnum</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println(HOT);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="向enum中添加新方法"><a href="#向enum中添加新方法" class="headerlink" title="向enum中添加新方法"></a>向enum中添加新方法</h3><p>如果希望每个枚举能够返回对自身的描述，<strong>而不是使用toString实现</strong>，这只能返回枚举实例的名字。为此，需要提供一个构造器，专门负责处理这个额外的信息，然后添加一个方法，返回这个描述信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> EnumFunction &#123;</span><br><span class="line">	NAME(<span class="string">"我是杨阿阳"</span>),</span><br><span class="line">	AGE(<span class="string">"23"</span>);</span><br><span class="line">	<span class="keyword">private</span> String decript;</span><br><span class="line"> 	EnumFunction(String decript)&#123;</span><br><span class="line"> 		<span class="keyword">this</span>.decript = decript;</span><br><span class="line"> 	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getDecript</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> decript;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(EnumFunction e:EnumFunction.values()) &#123;</span><br><span class="line">			System.out.println(e+<span class="string">": "</span>+e.getDecript());</span><br><span class="line">		&#125;</span><br><span class="line">        System.out.println(EnumFunction.AGE.getDecript());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//outinfo~</span></span><br><span class="line">NAME: 我是杨阿阳</span><br><span class="line">AGE: <span class="number">23</span></span><br><span class="line"><span class="number">23</span></span><br></pre></td></tr></table></figure>

<p>在定义<strong>enum方法时</strong>，必须在enum实例序列的最后添加一个分号。同时必须先定义enum实例。如果在定义enum实例前定义任何方法或属性，那么编译时就会报错。在定义enum时将enum的构造器修饰为<strong><code>private</code></strong></p>
<h3 id="常量相关的方法"><a href="#常量相关的方法" class="headerlink" title="常量相关的方法"></a>常量相关的方法</h3><p>在enum中可以声明常量方法，从而为每个enum实例赋予各自不同的行为。如果要实现常量相关的方法，需要为enum定义一个或多个<strong><code>abstract方法</code></strong>，然后为每个enum实例实现该抽象方法。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> ConstantSpecificMethod &#123;</span><br><span class="line">	DATA_TIME&#123;</span><br><span class="line">		<span class="function"><span class="keyword">String</span> <span class="title">getinfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="string">"getinfo1"</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	ClassPath&#123;</span><br><span class="line">		<span class="function"><span class="keyword">String</span> <span class="title">getinfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="string">"getinfo2"</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="function">abstract <span class="keyword">String</span> <span class="title">getinfo</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">		ConstantSpecificMethod s = ConstantSpecificMethod.ClassPath;</span><br><span class="line">		System.out.<span class="built_in">println</span>(s.getinfo());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过相应的enum实例，可以调用其上的方法，上面的代码也称为<strong>表驱动的代码</strong>，这跟设计模式里的命令模式有些相似</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java基础编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发基础Java中的锁</title>
    <url>/2019/04/30/java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80Java%E4%B8%AD%E7%9A%84%E9%94%81/</url>
    <content><![CDATA[<p>锁是用来控制多个线程访问共享资源的方式，一个锁能够防止多个线程同时访问共享资源。</p>
<h3 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h3><p>在<strong><code>Lock</code></strong>接口出现之前，Java通过synchronized关键字实现锁功能，JDK 1.5之后，在并发包中新增了Lock接口来实现锁功能，有与synchronized关键字类似功能，只是在使用时需要显示的获取锁和释放锁，拥有了锁释放和获取的可操作性、可中断性等synchronized关键字不具备的特性。在使用synchronized关键字会隐式的获取锁和释放锁，但锁的获取和释放固化，即先获取后释放。Lock接口的实现基本上是通过聚合一个同步器（<strong><code>AQS</code></strong>）的子类来完成线程访问控制。</p>
<p>Lock接口的使用方式：</p>
<figure class="highlight cos"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Lock</span> <span class="keyword">lock</span> = <span class="keyword">new</span> ReentrantLock()<span class="comment">;</span></span><br><span class="line"><span class="keyword">lock</span>.<span class="keyword">lock</span>()<span class="comment">;</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">&#125;finally&#123;</span><br><span class="line">	<span class="keyword">lock</span>.unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码示例中要注意：获取锁的过程不要写在<strong><code>try</code></strong>中，因为在获取锁时发生异常，异常抛出的同时，也会导致锁无故释放。</p>
<h4 id="比较synchronized和ReentrantLock"><a href="#比较synchronized和ReentrantLock" class="headerlink" title="比较synchronized和ReentrantLock"></a>比较synchronized和ReentrantLock</h4><ul>
<li><p>锁的实现</p>
<p>synchronized是JVM实现的，而ReentrantLock是JDK实现</p>
</li>
<li><p>性能新版Java对synchronized进行了很多的优化，synchronized与ReentrantLock大致相同。</p>
</li>
<li><p>等待可中断</p>
<p>当持有锁的线程长期不释放锁，正在等待的线程可以选择放弃等待，改为处理其他事情。ReentrantLock可以中断，而synchronized不可以中断</p>
</li>
<li><p>公平锁</p>
<p>公平锁是指多个线程在等待同一锁时，必须按照申请的时间顺序来依次获得锁。synchronized中的锁是非公平的，ReentrantLock默认也是非公平，但也是可以公平的</p>
</li>
<li><p>锁绑定多个条件</p>
<p>一个ReentrantLock可以同时绑定多个Condition对象</p>
</li>
</ul>
<h4 id="如何选择呢？"><a href="#如何选择呢？" class="headerlink" title="如何选择呢？"></a>如何选择呢？</h4><p>优先使用synchronized，除非需要使用ReentrantLock的高级功能，因为synchronized是JVM实现的一种锁机制，JVM原生的支持，而ReentrantLock不是所有的JDK都支持，synchronized不用担心没有锁而造成死锁问题，JVM会确保锁的释放。</p>
<h3 id="重入锁"><a href="#重入锁" class="headerlink" title="重入锁"></a>重入锁</h3><p>重入锁ReentrantLock，支持重进入的锁，表示该锁功能支持一个线程对资源的重复加锁。</p>
<h4 id="实现重进入"><a href="#实现重进入" class="headerlink" title="实现重进入"></a>实现重进入</h4><p><strong>重进入是指任意线程在获取锁之后能够再次获取该锁而不会被锁所阻塞，这个特性需要解决两个问题：</strong></p>
<ul>
<li><strong>线程再次获取锁</strong>：所需要去识别获取锁的线程是否为当前占据锁的线程，如果是则再次成功获取。</li>
<li><strong>锁的最终释放</strong>：线程重复n次获取锁，随后第n次释放该锁后，其他线程能够获取到该锁。锁的最终释放要求锁对于获取进行计数自增，计数表示当前锁被重复获取的次数，而锁被释放时，计数自减当计数等于0时表示已经释放成功。</li>
</ul>
<p>重入锁是通过组合自定义<strong><code>同步器</code></strong>来实现锁的获取和释放。获取同步状态的代码如下：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">final boolean nonfair<span class="constructor">TryAcquire(<span class="params">int</span> <span class="params">acquires</span>)</span> &#123;</span><br><span class="line">            final Thread current = <span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>;</span><br><span class="line">            <span class="built_in">int</span> c = get<span class="constructor">State()</span>;</span><br><span class="line">            <span class="keyword">if</span> (c<span class="operator"> == </span><span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (compare<span class="constructor">AndSetState(0, <span class="params">acquires</span>)</span>) &#123;</span><br><span class="line">                    set<span class="constructor">ExclusiveOwnerThread(<span class="params">current</span>)</span>;</span><br><span class="line">                    return <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current<span class="operator"> == </span>get<span class="constructor">ExclusiveOwnerThread()</span>) &#123;</span><br><span class="line">                <span class="built_in">int</span> nextc = c + acquires;</span><br><span class="line">                <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                    throw <span class="keyword">new</span> <span class="constructor">Error(<span class="string">"Maximum lock count exceeded"</span>)</span>;</span><br><span class="line">                set<span class="constructor">State(<span class="params">nextc</span>)</span>;</span><br><span class="line">                return <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            return <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>通过判断当前线程是否为获取锁的线程来决定获取操作是否成功，如果是获取锁的线程再次请求，则将同步状态值进行增加并返回true，表示获取同步状态成功。</p>
<h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p>读写锁维护一对锁，一个读锁和一个写锁，通过分离读锁和写锁使得并发性相比一般的排他锁有了更大的提升，读写锁的性能都会比排它锁好，因为大多数场景读操作对于写操作，在这样的情况下读写锁能够提供排它锁更好的并发性和吞吐量，</p>
<p><img src="https://raw.githubusercontent.com/yangshenghua97/Image/master/ReadAndWriterLock.png" alt=""></p>
<h4 id="读写锁的实现"><a href="#读写锁的实现" class="headerlink" title="读写锁的实现"></a>读写锁的实现</h4><ul>
<li><p>读写状态的设计</p>
<p>读写锁同样依赖自定义同步器来实现同步功能，而读写状态就是其同步器的同步状态。读写锁的自定义同步器需要在同步同步状态上维护多个读线程和一个写线程的状态，状态的设计成为读写锁实现的关键。</p>
<p>如果在一个整型变量上维护多种状态，就一定需要“按位切割使用”这个变量，读写锁将变量切分成两个部分，高16为表示读，低16位表示写</p>
<p><img src="https://raw.githubusercontent.com/yangshenghua97/Image/master/ReadAndWriterStatu.png" alt=""></p>
</li>
<li><p>写锁的获取与释放</p>
<p>写锁是一个支持重进入的排它锁，如果当前线程已经获取了写锁，则增加写状态。如果当前线程在获取写锁时，读锁已经被获取或者该线程不是已经获取写锁的线程，则当前线程进入等待状态。写锁的释放与ReentrantLock的释放过程基本相似，每次释放均减少写状态，当写状态为0时表示写锁已经被释放，从而等待读写线程能够继续访问读写锁，同时前次的写线程的修改对后续读写线程可见。</p>
</li>
<li><p>读锁的获取与释放</p>
<p>读锁是一个支持重进入的共享锁，能够被多个线程同时获取，在没有其他的写线程访问时，读锁总会被成功的获取，而所做的只是增加读状态，如果当前线程已经获取了读锁，则增加读状。如果当前线程在获取读锁时，写锁已被其他线程获取，则进入等待状态。</p>
</li>
<li><p>锁降级</p>
<p>锁降级指的是<strong>写锁降级为读锁</strong>。如果当前线程拥有写锁，然后将其释放，最后在获取读锁，这种分段完成的过程不能称为锁降级。锁降级是指把持住写锁，再获取到读锁，随后释放写锁的过程。锁降级中读锁释放主要是为了保证数据的可见性。</p>
</li>
</ul>
<h3 id="队列同步器"><a href="#队列同步器" class="headerlink" title="队列同步器"></a>队列同步器</h3><p>队列同步器<strong><code>AbstractQueuedSynchronizer</code></strong>，是用来构建锁或者其他同步组件的基本框架，使用一个<strong>int</strong>成员变量表示同步状态，通过内置FIFO队列来完成资源的获取线程的排队工作。</p>
<p><img src="https://raw.githubusercontent.com/yangshenghua97/Image/master/AQS.png" alt=""></p>
<p>同步器是实现锁的关键，在锁的实现中聚合同步器，利用同步器实现锁的语义。二者的关系是：锁是面向使用者，定义了使用者与锁交互的接口，隐藏了实现细节；同步器则面向锁的实现者，简化了锁的实现方式，屏蔽了同步状态管理、线程的排队、等待与唤醒等底层操作。同步器的主要使用方式是继承，子类通过继承同步器并实现它的抽象方法来管理同步器状态。</p>
<h3 id="队列同步器的实现分析"><a href="#队列同步器的实现分析" class="headerlink" title="队列同步器的实现分析"></a>队列同步器的实现分析</h3><h4 id="同步队列"><a href="#同步队列" class="headerlink" title="同步队列"></a>同步队列</h4><p>同步器依赖内部的同步队列来完成同步状态的管理，当前线程获取同步状态失败时，同步器会将当前线程以及等待状态的信息够造成一个节点将其加入到同步队列，同时会阻塞当前线程，当同步状态释放时，会把首节点中的线程唤醒，使其再次尝试获取同步器状态。</p>
<p>节点是构成同步队列的基础，同步器拥有首节点和尾节点，没有成功获取同步状态的线程会成为节点加入到该队列的尾部。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发基础</title>
    <url>/2019/04/30/java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80Java/</url>
    <content><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<ul>
<li><a href=""></a></li>
<li><a href=""></a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发容器和框架</title>
    <url>/2019/04/25/java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E5%92%8C%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<p><strong>ConcurrentHashMap</strong></p>
<hr>
<p>​    在多线程环境中，使用HashMap可能会导致程序死循环，使用线程安全的HashTable效率低效，所以便有了                <strong>ConcurrentHashMap</strong>。</p>
<p>ConcurrentHashMap利用锁的分断技术可有效提升并发访问率，在容器里有多把锁，每一把锁用于锁容器其中一部分数据，当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效提升并发访问效率。容器中有多把锁，每把锁用于锁容器其中的一部分数据，那么当多线程访问容器里不同的数据段时，线程之间就不会存在锁竞争，从而提高并发访问效率。</p>
<h3 id="ConcurrentHashMap的结构"><a href="#ConcurrentHashMap的结构" class="headerlink" title="ConcurrentHashMap的结构"></a>ConcurrentHashMap的结构</h3><p>ConcurrentHashMap由Segment数组结构和HashEntry数组结构组成。Segment是一种可重入锁；HashEntry用于存储键值对数据，一个ConcurrentHashMap包含一个Segment数组。Segment数组的结构和HashMap类似，是一种数组和链表结构，一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素，每个Segment守护一个HashEntry数组里的元素，当对HashEntry数组的数据进行修改时，必须先获得与它对应的Segment锁。</p>
<p><img src="https://raw.githubusercontent.com/yangshenghua97/Image/master/ConcurrentHashMap.png" alt=""></p>
<h3 id="ConcurrentHashMap初始化"><a href="#ConcurrentHashMap初始化" class="headerlink" title="ConcurrentHashMap初始化"></a>ConcurrentHashMap初始化</h3><h4 id="初始化Segment数组"><a href="#初始化Segment数组" class="headerlink" title="初始化Segment数组"></a>初始化Segment数组</h4><p>segments数组的长度ssize是通过ConcurrencyLevel计算得出，为了可以通过按位与的散列算法定位Segments数组的索引，必须保证segments数组的长度是2的N次方，所以必须计算出一个大于或等于concurrencyLevel的最小的2的N次方值来作为segments数组的长度。下面是segments数组的源代码</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(concurrencyLevel &gt; MAX_SEGMENTS)&#123;</span><br><span class="line">	concurrencyLevel = MAX_SEGMENTS;</span><br><span class="line">	<span class="built_in">int</span> sshift = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">int</span> ssize = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(ssize &lt; concurrencyLevel)&#123;</span><br><span class="line">		++sshift;</span><br><span class="line">		ssize &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	segmentShift = <span class="number">32</span> - sshift;</span><br><span class="line">	segmentMask = ssize <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">this</span>.segments = Segment.newArray(ssize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>concurrencyLevel的最大值是65535，Segments数组的长度最大为65536对应的二进制数组</p>
</blockquote>
<h4 id="初始化segmentShift和segmentMask"><a href="#初始化segmentShift和segmentMask" class="headerlink" title="初始化segmentShift和segmentMask"></a>初始化segmentShift和segmentMask</h4><p>这两个全局变量需要定位segments的散列算法里使用，sshift等于ssize从1向左移位的次数，在默认情况下concurrencyLevel等于161需要向左移位移动4次，所以sshift等于4segmentShift用于定位参与散列运算的位数，segmentShift等于32减sshift，所以等于28。</p>
<h4 id="定位Segment"><a href="#定位Segment" class="headerlink" title="定位Segment"></a>定位Segment</h4><p>ConcurrentHashMap使用分段锁Segment保护不同的数据，在插入和获取元素的时候，必须通过散列算法定位到Segment，然后在进行再散列，减少散列冲突，使元素能够均匀地分布在不同的Segment上，提高容器的存取效率。</p>
<p>散列算法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Segment&lt;K,V&gt; <span class="title">segmentFor</span><span class="params">(<span class="keyword">int</span> hash)</span></span>&#123;</span><br><span class="line">	<span class="comment">//segmentShift默认为28，SegmentMask为15</span></span><br><span class="line">	<span class="keyword">return</span> segments[(hash&gt;&gt;&gt;segmentShift)&amp;segmentMask];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="初始化每个segment"><a href="#初始化每个segment" class="headerlink" title="初始化每个segment"></a>初始化每个segment</h4><p>输入参数initialCapacity是ConcurrentHashMap的初始化容量，loadfactor是每个segment的负载因子，在构造方法中需要通过这两个参数来初始化数组中的每个segment。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(initialCapacity &gt;MAXIMUM_CAPACITY)&#123;</span><br><span class="line">	initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">	<span class="built_in">int</span> c = initialCapacity/ssize;</span><br><span class="line">	<span class="keyword">if</span>(c * ssize &lt; initialCapacity)&#123;</span><br><span class="line">		++c;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">int</span> cap = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(cap &lt; c)&#123;</span><br><span class="line">		cap &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>;i&lt;<span class="keyword">this</span>.segments.length;i++)&#123;</span><br><span class="line">		<span class="keyword">this</span>.segments[i] = new Segment&lt;K,V&gt;(cap,loadFactor);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ConcurrentHashMap的操作"><a href="#ConcurrentHashMap的操作" class="headerlink" title="ConcurrentHashMap的操作"></a>ConcurrentHashMap的操作</h4><ul>
<li><h5 id="get操作"><a href="#get操作" class="headerlink" title="get操作"></a>get操作</h5><p>get操作先经过一次再散列，然后使用这个散列值通过散列运算定位到Segment，在通过散列算法定位到元素。</p>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="built_in">get</span>(<span class="keyword">Object</span> <span class="built_in">key</span>)&#123;</span><br><span class="line">	<span class="built_in">int</span> hash = hash(<span class="built_in">key</span>.hashCode());</span><br><span class="line">	<span class="keyword">return</span> segmentFor(hash).<span class="built_in">get</span>(<span class="built_in">key</span>,hash);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>get</code></strong>操作之所以高效是因为整个get过程不需要加锁，除非读到的值是空才会加锁重读。get方法里面将要使用的共享变量都定义为<strong><code>volatile</code></strong>,定义成volatile的变量，能够在线程之间保持可见性，能够被多线程同时读，并且保证不会读到过期的值，在get操作里只需要读不需要写共享变量count和value，所以不需要加锁。不会读到过期的值，是因为根据Java内存模型Happen-before原则，对volatile字段的写入优先于读操作，即使两个线程同时修改和获取volatile变量，get操作也能够拿到最新的值。</p>
</li>
<li><h5 id="put操作"><a href="#put操作" class="headerlink" title="put操作"></a>put操作</h5><p>由于put操作需要对共享变量进行写入操作，为了线程安全，在操作共享变量是必须加锁。插入操作需经历两步：（1）判断是否需要对Segment数组里的HashEntry数组进行扩容；（2）定位添加元素的为位置，然后将其放在HashEntry数组中。根据上面的两个步骤这里又抛出两个问题：是否需要扩容、如何扩容。</p>
<p><strong>是否需要扩容</strong>：在插入元素前会先判断Segment里的HashEntry数组是否超过容量，如果超过阈值，则对数组进行扩容（Segment的扩容判断比HashMap更恰当，因为HashMap是在插入元素后判断元素是否已经达到容量，如果达到了就进行扩容），</p>
<p><strong>如果扩容</strong>：在扩容的时候，为了高效ConcurrentHashMap不会对整个容器进行扩容，而只是对某个Segment数组进行扩容</p>
</li>
<li><h5 id="size操作"><a href="#size操作" class="headerlink" title="size操作"></a>size操作</h5><p>在统计size的时候会把所有Segment的put、remove、clean方法全部加锁，这种做法会变得非常低效，ConcurrentHashMap先尝试通过两次不加锁Segment的方式来统计各个Segment大小，通过过程中容器的count发生了变化，则再采用加锁的方式来统计所有Segment的大小，那么ConcurrentHashMap如何判断容器是否发生变化？使用modCount变量，在put、remove、clean方法里操作元素前都会将变量modCount进行加一操作，那么在统计size前后比较modCount是否发生变化，从而知道容器大小是否发生变化。</p>
</li>
</ul>
<h3 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h3><p>ConcurrentLinkedQueue是个基于链表节点的无界线程安全队列，采用先进先出的规则对节点进行排序，当添加一个元素时，会添加到队列的尾部；当获取一个元素时会返回队列的头元素。采用CAS算法实现。</p>
<h4 id="ConcurrentLinkedQueue的入队列"><a href="#ConcurrentLinkedQueue的入队列" class="headerlink" title="ConcurrentLinkedQueue的入队列"></a>ConcurrentLinkedQueue的入队列</h4><h5 id="入队列过程"><a href="#入队列过程" class="headerlink" title="入队列过程"></a>入队列过程</h5><p>入队列就是将入队节点添加到队列的尾部，在单线程下入队列比较简单，但在多线程同时进行入对的时候就复杂了许多，这个过程可能会有其他线程入队的情况，如果有个线程正在入队，那么这个线程就必须获取尾节点，然后设置尾结点的下一个节点为入队节点，要是这时有另一个线程插队，那么队列的尾节点就会发生变化，当前线程停止入队操作。这里就需要用到CAS算法</p>
<h5 id="出队列过程"><a href="#出队列过程" class="headerlink" title="出队列过程"></a>出队列过程</h5><p>出队列就是从队列里返回一个节点元素，并清空该节点对元素的引用。首先获取头节点的元素，然后判断头节点元素是否为空，如果为空，表示另外一个线程已经进行了一次出队操作将该节点的元素取走，如果不为空，则使用CAS的方式将头节点的引用设置为null，如果CAS成功，则直接返回头节点的元素，如果不为空表示另外一个线程已经进行了一次出队操作更新过了head头节点，导致元素发生变化，需要重新获取头节点。</p>
<h3 id="Java中的阻塞队列"><a href="#Java中的阻塞队列" class="headerlink" title="Java中的阻塞队列"></a>Java中的阻塞队列</h3><p>什么是阻塞队列：阻塞队列是个支持阻塞的插入方法和阻塞的移除方法的队列；</p>
<ul>
<li>支持阻塞的插入方法：当队列满时，队列会阻塞插入元素的线程直到队列不满。</li>
<li>支持阻塞的移除方法：当队列空时，获取元素的线程会等待队列变为非空</li>
</ul>
<h4 id="阻塞队列的实现原理"><a href="#阻塞队列的实现原理" class="headerlink" title="阻塞队列的实现原理"></a>阻塞队列的实现原理</h4><ul>
<li>使用通知模式实现：通知模式就是当生产者往满的队列里添加元素时会阻塞生产者，当消费者消费了一个队列中的元素后，会通知生产者当前队列可用。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL基础（二）</title>
    <url>/2019/04/05/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/SQL%E5%9F%BA%E7%A1%802/</url>
    <content><![CDATA[<h2 id="过滤数据"><a href="#过滤数据" class="headerlink" title="过滤数据"></a>过滤数据</h2><h3 id="百分号（-）通配符"><a href="#百分号（-）通配符" class="headerlink" title="百分号（%）通配符"></a>百分号（%）通配符</h3><p><strong><code>%</code></strong>表示任何字符出现任意次数。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_id,prod_name</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_name <span class="keyword">LIKE</span> <span class="string">'jet%'</span>;</span><br></pre></td></tr></table></figure>

<p>上面的SQL检索任意以jet为开头的词，%告诉MYSQL接受jet之后的任意字符，不论它有多少字符。通配符可在搜索模式中任意位置使用，并且可以使用多个通配符</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_id,prod_name</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_name <span class="keyword">LIKE</span> <span class="string">'%anvil%'</span>;</span><br></pre></td></tr></table></figure>

<h3 id="下划线（-）通配符"><a href="#下划线（-）通配符" class="headerlink" title="下划线（_）通配符"></a>下划线（_）通配符</h3><p>下划线通配符只匹配单个字符而不是多个字符。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_id,prod_name</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_name <span class="keyword">LIKE</span> <span class="string">'_ ton anvil'</span></span><br></pre></td></tr></table></figure>

<h3 id="使用通配符的技巧"><a href="#使用通配符的技巧" class="headerlink" title="使用通配符的技巧"></a>使用通配符的技巧</h3><ul>
<li>不要过度使用通配符，如果其他操作符能达到相同的效果，应该使用其他操作符；</li>
<li>在确实需要使用通配符时，除非绝对有必要，否则不要把通配符放在搜索模式的开始处。如果把通配符置于开始处，搜索起来很慢；</li>
<li>仔细注意通配符的位置，如果犯错位置。可能不会得到想要的数据；</li>
</ul>
<h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p>MySQL中使用<strong><code>REGEXP</code></strong>关键字指定正则表达式的字符匹配。</p>
<p>正则表达式常用的字符匹配列表</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>^</td>
<td>匹配文本的开始字符</td>
</tr>
<tr>
<td>$</td>
<td>匹配文本的结束字符</td>
</tr>
<tr>
<td>.</td>
<td>匹配任何单一字符</td>
</tr>
<tr>
<td>*</td>
<td>匹配零个或多个在在它前面的字符</td>
</tr>
<tr>
<td>+</td>
<td>匹配前面的字符1次或多次</td>
</tr>
<tr>
<td>字符串</td>
<td>匹配包含指定的字符串的文本</td>
</tr>
<tr>
<td>[字符集合]</td>
<td>匹配字符集合中的任何一个字符</td>
</tr>
<tr>
<td>[^]</td>
<td>匹配不在括号中的任何字符</td>
</tr>
<tr>
<td>字符串{n,}</td>
<td>匹配前面的字符串至少n次</td>
</tr>
<tr>
<td>字符串{n,m}</td>
<td>匹配前面的字符串至少n次，至多m次。</td>
</tr>
<tr>
<td>|</td>
<td>进行OR匹配</td>
</tr>
</tbody></table>
<p>正则表达式经典例子：</p>
<p>基本字符匹配</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_name REGEXP <span class="string">'1000'</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_name;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_name REGEXP <span class="string">'.000'</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_name;</span><br></pre></td></tr></table></figure>

<p>进行OR匹配</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_name REGEXP <span class="string">'1000|2000'</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_name;</span><br></pre></td></tr></table></figure>

<p>范围匹配</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_name REGEXP <span class="string">'[1-5] Ton'</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_name;</span><br></pre></td></tr></table></figure>

<p>匹配特殊字符</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_name</span><br><span class="line"><span class="keyword">FROM</span> vendors</span><br><span class="line"><span class="keyword">WHERE</span> vend_name REGEXP <span class="string">'\\.'</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_name;</span><br></pre></td></tr></table></figure>

<h2 id="MYSQL函数"><a href="#MYSQL函数" class="headerlink" title="MYSQL函数"></a>MYSQL函数</h2><h3 id="文本处理函数"><a href="#文本处理函数" class="headerlink" title="文本处理函数"></a>文本处理函数</h3><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Left()</td>
<td>返回字符串左边的字符</td>
</tr>
<tr>
<td>Length()</td>
<td>返回字符串的长度</td>
</tr>
<tr>
<td>Locate()</td>
<td>找出字符串的一个子串</td>
</tr>
<tr>
<td>Lower()</td>
<td>将字符串转换为小写</td>
</tr>
<tr>
<td>LTrim()</td>
<td>去掉字符串左边的空格</td>
</tr>
<tr>
<td>Right()</td>
<td>去掉字符串右边的字符</td>
</tr>
<tr>
<td>RTrim()</td>
<td>去掉字符串右边的空格</td>
</tr>
<tr>
<td>Upper()</td>
<td>将字符串转换为大写</td>
</tr>
</tbody></table>
<p>经典例子</p>
<p>将字符串转换为大写</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_name,<span class="built_in">Upper</span>(vend_name)</span><br><span class="line"><span class="keyword">FROM</span> vendors</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> vend_name;</span><br></pre></td></tr></table></figure>

<h3 id="日期时间处理函数"><a href="#日期时间处理函数" class="headerlink" title="日期时间处理函数"></a>日期时间处理函数</h3><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>AddDate()</td>
<td>增加一个日期（天，周等）</td>
</tr>
<tr>
<td>AddTime()</td>
<td>增加一个时间（时，分等）</td>
</tr>
<tr>
<td>CurDate()</td>
<td>获取当前日期</td>
</tr>
<tr>
<td>CurTime()</td>
<td>获取当前时间</td>
</tr>
<tr>
<td>Date()</td>
<td>返回日期时间的日期部分</td>
</tr>
<tr>
<td>DateDiff()</td>
<td>计算两个日期之差</td>
</tr>
<tr>
<td>Time()</td>
<td>返回一个日期时间的时间部分</td>
</tr>
<tr>
<td>Now()</td>
<td>返回当前日期和时间</td>
</tr>
</tbody></table>
<h3 id="聚集函数"><a href="#聚集函数" class="headerlink" title="聚集函数"></a>聚集函数</h3><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>AVG()</td>
<td>计算某一列的平均值</td>
</tr>
<tr>
<td>COUNT()</td>
<td>获取某一列的行数</td>
</tr>
<tr>
<td>MAX()</td>
<td>获取某一列的最大值</td>
</tr>
<tr>
<td>MIN()</td>
<td>获取某一列的最小值</td>
</tr>
<tr>
<td>SUM()</td>
<td>获取某一列值之和</td>
</tr>
</tbody></table>
<h2 id="数据分组"><a href="#数据分组" class="headerlink" title="数据分组"></a>数据分组</h2><h3 id="创建分组"><a href="#创建分组" class="headerlink" title="创建分组"></a>创建分组</h3><p>分组是在SELECT语句的<strong><code>GROUP BY</code></strong>子句中建立的。</p>
<p>举个例子：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">SELECT vend_id,COUNT(*) as num_prods</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line">GROUP BY vend_id;</span><br></pre></td></tr></table></figure>

<p>使用<strong><code>GROUP BY</code></strong>子句的一些规定</p>
<ul>
<li>GROUP BY子句可以包含任意数目的列。使得能够对分组进行嵌套，为数据分组提供更细致的控制。</li>
<li>如果GROUP BY子句中嵌套了分组，数据将在最后规定的分组上进行汇总。</li>
<li>GROUP BY子句中列出每个列都必须是检索列或是有效的表达式。如果在SELECT中使用表达式，则必须在GROUP BY子句中指定相同的表达式。不能使用别名。</li>
<li>除聚集函数语句外，SELECT语句中每个列都必须在GROUP BY子句中给出。</li>
<li>如果分组列中具有NULL值，则NULL将作为一个分组返回。如果列中有多行NULL值，他们将分为一组。</li>
<li>GROUP BY子句必须出现在WHERE子句之后，ORDER BY子句之前。</li>
</ul>
<h3 id="过滤分组：HAVING"><a href="#过滤分组：HAVING" class="headerlink" title="过滤分组：HAVING"></a>过滤分组：<strong><code>HAVING</code></strong></h3><p>使用<strong><code>HAVING</code></strong>对分组进行过滤，基于分组聚集值进行分组。</p>
<p>举几个例子</p>
<figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_id,COUNT<span class="comment">(*) as num_prods</span></span><br><span class="line"><span class="comment">FROM products</span></span><br><span class="line"><span class="comment">GROUP BY vend_id</span></span><br><span class="line"><span class="comment">HAVING COUNT(*)</span>&gt;<span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">SELECT order_num,SUM(quantity*item_price) as ordertotal</span><br><span class="line"><span class="keyword">FROM</span> orderitems</span><br><span class="line">GROUP BY order_num</span><br><span class="line">HAVING SUM(quantity*item_price) &gt;=50;</span><br></pre></td></tr></table></figure>

<h3 id="SELECT子句顺序"><a href="#SELECT子句顺序" class="headerlink" title="SELECT子句顺序"></a>SELECT子句顺序</h3><p>以下语句由上至下的顺序</p>
<p><strong><code>SELECT</code></strong>：要返回的列或表达式</p>
<p><strong><code>FROM</code></strong>：从中检索数据的表</p>
<p><strong><code>WHERE</code></strong>：行级过滤</p>
<p><strong><code>GROUP BY</code></strong>：分组说明</p>
<p><strong><code>HAVING</code></strong>：组级过滤</p>
<p><strong><code>ORDER BY</code></strong>：输出排序顺序</p>
<p><strong><code>LIMIT</code></strong>：遥检索的行数</p>
<h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><p>子查询就是嵌套在其他查询中的查询。</p>
<h3 id="利用子查询过滤"><a href="#利用子查询过滤" class="headerlink" title="利用子查询过滤"></a>利用子查询过滤</h3><figure class="highlight sas"><table><tr><td class="code"><pre><span class="line"><span class="meta">SELECT</span> cust_id</span><br><span class="line"><span class="meta">FROM</span> orders</span><br><span class="line"><span class="meta">WHERE</span> order_num <span class="meta">IN(</span></span><br><span class="line"><span class="meta">SELECT</span> order_num</span><br><span class="line"><span class="meta">FROM</span> orderitems</span><br><span class="line"><span class="meta">WHERE</span> prod_id = <span class="string">'TNT2'</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>上面的<strong>SELECT</strong>语句中子查询总是从内向外处理，上面的SQL语句实际上执行了两个SELECT操作。</p>
<p>在<strong>WHERE</strong>子句中使用子查询能够编写出功能很强并且很灵活的SQL语句。对于能嵌套的子查询的数目没有限制，但在实际应用中对于性能的要求，不能嵌套太多的子查询。</p>
<h3 id="用作计算字段使用子查询"><a href="#用作计算字段使用子查询" class="headerlink" title="用作计算字段使用子查询"></a>用作计算字段使用子查询</h3><figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_name,cust_state,(</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(*)</span><br><span class="line"><span class="keyword">FROM</span> orders</span><br><span class="line"><span class="keyword">WHERE</span> orders.cust_id = customers.cust_id) <span class="keyword">as</span> orders</span><br><span class="line"><span class="keyword">FROM</span> customers</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> cust_name;</span><br></pre></td></tr></table></figure>

<h2 id="联结表"><a href="#联结表" class="headerlink" title="联结表"></a>联结表</h2><h3 id="创建联结"><a href="#创建联结" class="headerlink" title="创建联结"></a>创建联结</h3><p>联结的创建非常简单，规定要联结的所有表以及他们如何关联即可。</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_name,prod_name,prod_price</span><br><span class="line"><span class="keyword">FROM</span> vendors <span class="keyword">as</span> vend,products <span class="keyword">as</span> prd</span><br><span class="line"><span class="keyword">WHERE</span> vend.vend_id = prd.vend_id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> vend_name,prod_name;</span><br></pre></td></tr></table></figure>

<h3 id="内部联结"><a href="#内部联结" class="headerlink" title="内部联结"></a>内部联结</h3><p>基于两个表之间的相等测试，称为内部联结。</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_name,prod_name,prod_price</span><br><span class="line"><span class="keyword">FROM</span> vendors <span class="keyword">as</span> vend,<span class="keyword">INNER</span> <span class="keyword">JOIN</span> products <span class="keyword">as</span> prod</span><br><span class="line"><span class="keyword">ON</span> vend.vend_id = prod.vend_id;</span><br></pre></td></tr></table></figure>

<p>两个表之间的关系是<strong>FROM</strong>子句的组成部分，以<strong>INNER JOIN</strong>指定，在使用这种语法时，联结条件用特定的<strong>ON</strong>子句而不是WHERE子句给出。传递给ON的实际条件与传递给WHERE的相同。</p>
<h3 id="自联结"><a href="#自联结" class="headerlink" title="自联结"></a>自联结</h3><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT </span><span class="built_in">p1</span>.prod_id,<span class="built_in">p1</span>.prod_name</span><br><span class="line"><span class="symbol">FROM</span> products as <span class="built_in">p1</span>,products as <span class="built_in">p2</span></span><br><span class="line"><span class="symbol">WHERE</span> <span class="built_in">p1</span>.vend_id = <span class="built_in">p2</span>.vend_id</span><br><span class="line"><span class="keyword">AND</span></span><br><span class="line"><span class="keyword">p2.prod_id </span>= <span class="string">'DTNTR'</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>自联结通常作为外部语句用来替代从相同表中检索数据时使用的子查询语句。</p>
<h3 id="外部联结"><a href="#外部联结" class="headerlink" title="外部联结"></a>外部联结</h3><p>看下面的例子：</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> customers.cust_id,orders.order_num</span><br><span class="line"><span class="keyword">FROM</span> customers </span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> </span><br><span class="line">orders</span><br><span class="line"><span class="keyword">ON</span> customers.cust_id = orders.cust_id;</span><br></pre></td></tr></table></figure>

<p>在使用OUTER JOIN语法时，必须使用RIGHT或LEFT关键字指定包含其所有行的表（RIGHT指出的是OUTER JOIN右边的表，而LEFT指出的是OUTER JOIN左边的表）</p>
<h3 id="使用联结和联结条件"><a href="#使用联结和联结条件" class="headerlink" title="使用联结和联结条件"></a>使用联结和联结条件</h3><ul>
<li>注意所使用的联结类型，一般使用内部联结，但使用外部联结也是有效的；</li>
<li>保证使用正确的联结条件，否则将返回不正确的数据；</li>
<li>应该总是提供联结条件，否则会得笛卡儿积；</li>
<li>在一个联结中可以包含多个表，甚至对于每个联结可以采用不同的联结类型。虽然这样做合法的，一般也很有用，但应该在一起测试他们之前，分别测试每个联结，这将是故障排除更为简单；</li>
</ul>
<h2 id="组合查询"><a href="#组合查询" class="headerlink" title="组合查询"></a>组合查询</h2><p>组合查询将结果作为单个查询结果集返回。这些组合查询通常称为复合查询。</p>
<p>下面的情况，需要使用组合查询</p>
<ul>
<li>在单个查询浙江哦你从不同的表中返回类型类似结构的数据；</li>
<li>对单个表执行多个查询，按单个查询返回数据；</li>
</ul>
<h3 id="创建组合查询-—-使用UNION"><a href="#创建组合查询-—-使用UNION" class="headerlink" title="创建组合查询 —  使用UNION"></a>创建组合查询 —  使用<strong><code>UNION</code></strong></h3><p><strong><code>UNION</code></strong>的使用很简单，写出每个SELECT语句，在各条语句之间放上关键字</p>
<p>举个例子：</p>
<p>第一条select语句</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_id,prod_id,prod_price</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_price &lt;= <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p>第二条select语句</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_id,prod_id,prod_price</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> vend_id <span class="keyword">IN</span>(<span class="number">1001</span>,<span class="number">1002</span>);</span><br></pre></td></tr></table></figure>

<p>复合两个语句</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_id,prod_id,prod_price</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_price &lt;= <span class="number">5</span>;</span><br><span class="line">UNION</span><br><span class="line"><span class="keyword">SELECT</span> vend_id,prod_id,prod_price</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> vend_id <span class="keyword">IN</span>(<span class="number">1001</span>,<span class="number">1002</span>);</span><br></pre></td></tr></table></figure>

<h3 id="UNION规则"><a href="#UNION规则" class="headerlink" title="UNION规则"></a>UNION规则</h3><ul>
<li>UNION必须有<strong>两条或者两条以上</strong>SELECT语句组成，语句之间用关键字UNION分隔；</li>
<li>UNION中的每个查询<strong>必须包含相同的列，表达式或聚集函数</strong>（不过各个列不需要以相同的次序列出）；</li>
<li>列数据类型必须兼容：类型不必完全相同，但必须是DBSM可以隐式转换的类型；</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<p>《MySQL必知必会》人民邮电出版社</p>
<p>《MySQL 从入门到精通》清华大学出版社</p>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title>vim基本命令</title>
    <url>/2019/04/04/%E5%85%B6%E4%BB%96/vim%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th><strong>h或者向左箭头</strong></th>
<th><strong>光标向左移动一个字符</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>j或者向下箭头</strong></td>
<td><strong>光标向下移动一个字符</strong></td>
</tr>
<tr>
<td><strong>k或者向上箭头</strong></td>
<td><strong>光标向上移动一个字符</strong></td>
</tr>
<tr>
<td><strong>l或者向右箭头</strong></td>
<td><strong>光标向右移动一个字符</strong></td>
</tr>
<tr>
<td><strong>Page Down</strong></td>
<td><strong>屏幕向下移动一页</strong></td>
</tr>
<tr>
<td><strong>Page Up</strong></td>
<td><strong>屏幕向上移动一页</strong></td>
</tr>
<tr>
<td><strong>n<space></strong></td>
<td><strong>n表示数字，按下数字再按空格键，光标会向右移动这一行的n个字符</strong></td>
</tr>
<tr>
<td><strong>功能键[Home]</strong></td>
<td><strong>移动到这一行的最前面字符处</strong></td>
</tr>
<tr>
<td><strong>功能键[End]</strong></td>
<td><strong>移动到这一行的最后面字符处</strong></td>
</tr>
<tr>
<td><strong>G</strong></td>
<td><strong>移动到这个文件的最后一行</strong></td>
</tr>
<tr>
<td><strong>nG</strong></td>
<td><strong>移动到这个文件的第n行</strong></td>
</tr>
<tr>
<td><strong>n<Enter></strong></td>
<td><strong>光标向下移动n行</strong></td>
</tr>
<tr>
<td><strong>/word</strong></td>
<td><strong>向光标之下寻找一个名称为word的字符</strong></td>
</tr>
<tr>
<td><strong>:n1,n2s/word1/word2/g</strong></td>
<td><strong>在第n1与n2行之间寻找word1这个字符串，并将该字符串替换为word2</strong></td>
</tr>
<tr>
<td><strong>:1,$s/word1/word3/g</strong></td>
<td><strong>在第1与最后一行之间寻找word1这个字符串，并将该字符串替换为word2</strong></td>
</tr>
<tr>
<td><strong>:1,$s/word1/word4/gc</strong></td>
<td><strong>在第1与最后一行之间寻找word1这个字符串，并将该字符串替换为word2，且在替换前显示提示字符给用户确认是否需要替换</strong></td>
</tr>
<tr>
<td><strong>x与X</strong></td>
<td><strong>在一行中x为向后删除一个字符(相当于[del]),X为向前删除一个字符(相当于退格键)</strong></td>
</tr>
<tr>
<td><strong>dd</strong></td>
<td><strong>删除(剪切)光标所在的那一整行</strong></td>
</tr>
<tr>
<td><strong>ndd</strong></td>
<td><strong>删除(剪切)光标所在的向下n行</strong></td>
</tr>
<tr>
<td><strong>yy</strong></td>
<td><strong>复制光标所在的那一行</strong></td>
</tr>
<tr>
<td><strong>nyy</strong></td>
<td><strong>复制光标所在的向下n行</strong></td>
</tr>
<tr>
<td><strong>p与P</strong></td>
<td><strong>p为将已复制的数据在光标下一行粘贴，P则为粘贴在光标的上一行。</strong></td>
</tr>
<tr>
<td><strong>u</strong></td>
<td><strong>恢复前一个操作</strong></td>
</tr>
<tr>
<td><strong>[ctrl]+r</strong></td>
<td><strong>重做上一个操作</strong></td>
</tr>
<tr>
<td><strong>.</strong></td>
<td><strong>重复前一个操作</strong></td>
</tr>
<tr>
<td><strong>i、a、o</strong></td>
<td><strong>进入插入模式</strong></td>
</tr>
<tr>
<td><strong>r或者R</strong></td>
<td><strong>进入替换模式</strong></td>
</tr>
<tr>
<td><strong>[Esc]</strong></td>
<td><strong>退出编辑模式</strong></td>
</tr>
<tr>
<td><strong>:w</strong></td>
<td><strong>将编辑的数据写入硬盘中</strong></td>
</tr>
<tr>
<td><strong>:q</strong></td>
<td><strong>退出vim</strong></td>
</tr>
<tr>
<td><strong>:wq</strong></td>
<td><strong>保存后退出</strong></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux进程管理</title>
    <url>/2019/03/27/Linux/Linux%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="什么是进程"><a href="#什么是进程" class="headerlink" title="什么是进程"></a>什么是进程</h1><p>如何产生一个进程？程序一般是放置在物理磁盘中，然后通过用户的执行来触发，触发后会加载内存中成为一个个体，这就是进程，为了让系统可以管理这个进程，进程会给予执行者权限/属性等参数，以及进程所需的脚本或数据，最后在给予一个PID。操作系统通过这个PID来判断该进程是否具有执行权限。过程如下图；</p>
<p><img src="https://raw.githubusercontent.com/yangshenghua97/Image/master/process.png" alt=""></p>
<p>举个常见的例子，我们在操作Linux的时候通过登录系统分给我们一个shell(bash)终端，这个shell终端具有一个PID，这个<strong><code>PID</code></strong>就是由UID/GID而来。当这个进程执行其他作业时，那么由这个进程衍生出来的其他进程在一般状态下，会沿用这个进程的相关权限。</p>
<p><strong>关于程序和进程的总结</strong>：</p>
<ul>
<li><strong>程序：通常为二进制程序，放置在存储媒介中，以物理文件的形式存在</strong></li>
<li><strong>进程：程序被触发后，执行者的权限与属性、程序的代码与所需的数据等都会被加载到内存中，操作系统给予这个内存中的单元一个标识符（PID）所以所进程就是一个正在运行时的程序</strong></li>
</ul>
<p><strong>程序调用的流程（fork and exec）</strong>：Linux的程序调用通常称为<strong><code>fork-and-exec</code></strong>的流程。进程都会借由父进程以复制（<strong><code>fork</code></strong>）的方式产生一个一模一样的子进程，然后被复制出来的子进程再以<strong><code>exec</code></strong>方式执行实际要执行的进程，最终就成为一个子进程。</p>
<p>具体流程就像下面的图片</p>
<p><img src="https://raw.githubusercontent.com/yangshenghua97/Image/master/forkandexec.png" alt=""></p>
<p>常驻在内存当中的进程通常都是负责一些系统所提供的功能以服务用户的各项任务，因此这些常驻进程称之为<strong>服务</strong></p>
<h1 id="任务管理"><a href="#任务管理" class="headerlink" title="任务管理"></a>任务管理</h1><h2 id="什么是任务管理"><a href="#什么是任务管理" class="headerlink" title="什么是任务管理"></a>什么是任务管理</h2><p>任务管理是用在bash环境下的，当登录系统获取 bash shell之后，在单一终端下同时执行多个任务的管理操作，执行任务管理的操作中，每个任务都是目前bash的子进程，彼此之间都是有相关性。</p>
<ul>
<li><p>前台与后台</p>
<p>说到终端，这里说一下前台与后台；</p>
<p>可以出现提示字符让你操作的环境称为前台，其他任务就可以放入后台去暂停或运行，放入后台的任务是不可以使用【ctrl+c】来终止的</p>
</li>
</ul>
<p>要执行bash的任务管理必须要注意的限制：</p>
<ul>
<li>这些任务所触发的进程必须是来自你shell的子进程（只管理自己的bash）；</li>
<li>前台：可以控制与执行命令的这个环境称为前台任务；</li>
<li>后台：可以自动执行任务，无法使用【ctrl+c】终止，可使用<strong><code>bg</code></strong>、<strong><code>fg</code></strong>（这两个命名后面会讲解）调用该任务；</li>
<li>后台中【执行】的进程不能等待或输入；</li>
</ul>
<h2 id="任务控制的管理"><a href="#任务控制的管理" class="headerlink" title="任务控制的管理"></a>任务控制的管理</h2><ul>
<li><p>直接将命令扔到后台去执行的<strong><code>&amp;</code></strong></p>
<p>如果想要同时执行多个任务，利用<strong><code>&amp;</code></strong>可以将某些任务直接丢到后台环境，这样就可以继续操作前台的工作任务</p>
<p>例如需要后台执行一个java程序可以这样做：</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">java </span>-<span class="keyword">jar </span>xxxx.<span class="keyword">jar </span>&amp;</span><br><span class="line">[<span class="number">1</span>] <span class="number">7851</span></span><br></pre></td></tr></table></figure>

<p>当命令后面加上<strong><code>&amp;</code></strong>代表着该命令丢到后台执行，此时bash会给予这个命令一个<strong>任务号码【job number】</strong>，就如上面代码的那个【1】。后面的7851则是该命令触发的【PID】。当这个任务执行完毕后bash会返回如下信息，表示[1]这个任务已经执行完毕；</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-attr">[1]</span>+ <span class="selector-tag">Done</span> <span class="selector-tag">java</span> <span class="selector-tag">-jar</span> <span class="selector-tag">xxxx</span><span class="selector-class">.jar</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>将目前的任务丢到后台中暂停：【<strong><code>ctrl-z</code></strong>】</p>
<p>将一个正在执行的任务，扔到后台去暂停，使用【ctrl+c】组合键可以实现，使用【ctrl+c】丢到后台当中的任务都是停止状态</p>
</li>
</ul>
<ul>
<li><p>查看目前的后台任务状态：<strong><code>jobs</code></strong></p>
<p>命令格式：<strong><code>jobs [-lrs]</code></strong></p>
<p>选项与参数：</p>
<p><strong><code>-l</code></strong>：列出【job number】、【PID】与命令串；</p>
<p><strong><code>-r</code></strong>：仅列出正在后台运行的任务；</p>
<p><strong><code>-s</code></strong>：仅列出正在后台停止的任务；</p>
<p>看一个案例：将vim和vi丢到后台</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ vim &amp;</span><br><span class="line">[<span class="number">1</span>] <span class="number">11439</span></span><br><span class="line">$ vi &amp;</span><br><span class="line">[<span class="number">2</span>] <span class="number">11440</span></span><br><span class="line">$ jobs -l</span><br><span class="line">[<span class="number">1</span>]- <span class="number">11439</span> Stopped (tty output)    vim</span><br><span class="line">[<span class="number">2</span>]+ <span class="number">11440</span> Stopped (tty output)    vi</span><br></pre></td></tr></table></figure>

<p>在上面输出的案例里，有+，-号，<strong><code>+</code></strong>号代表最近被放到后台的任务号码，<strong><code>-</code></strong>号代表最近第二个被放到后台中的任务号码，而第三个以后的任务，就不会有+-号出现</p>
</li>
</ul>
<ul>
<li><p>将后台任务拿到前台处理：<strong><code>fg</code></strong></p>
<p>命令格式：<strong><code>fg %jobnumber</code></strong></p>
<p>以上面案例基础上将vim和vi放到前台：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">jobs</span> -l</span></span><br><span class="line">[1]- 11439 Stopped (tty output)    vim</span><br><span class="line">[2]+ 11440 Stopped (tty output)    vi</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 将vim放到前台处理</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">fg</span> %1</span></span><br><span class="line">vim</span><br><span class="line">...</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>让任务在后台下的状态变成运行中：<strong><code>bg %jobnumber</code></strong></p>
<p>将还在后台停止的vi在后台运行</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ bg %<span class="number">1</span></span><br><span class="line">[<span class="number">1</span>]+ vi &amp;</span><br></pre></td></tr></table></figure>

<p>就像上面的输出结果那样，命令串后面有一个【&amp;】符号，代表该任务别被启动到后台了</p>
</li>
</ul>
<ul>
<li><p>管理后台当中的任务：<strong><code>kill</code></strong></p>
<p>如果想要将该任务直接删除或者重新启动，就可以用<strong><code>kill</code></strong>命令，使用这个命名时需要给这个命令一个信号（signal）</p>
<p>命令格式：<strong><code>kill -signal %jobnumber</code></strong></p>
<p>选项与参数：</p>
<p><strong><code>signal</code></strong>：代表后面的接的任务有什么样的指示，下面列举几个常用的信号</p>
<p><strong><code>-1</code></strong>：重新读取一次参数的配置文件；</p>
<p><strong><code>-2</code></strong>：表示有键盘输入【ctrl-c】同样的操作；</p>
<p><strong><code>-9</code></strong>：立刻强制删除一个任务；</p>
<p><strong><code>-15</code></strong>：以正常的进程方式终止一项任务；</p>
<p><strong>-9这信号通常是在【强制删除一个不正常的任务】是使用的，-15则是以正常步骤结束一项任务，这个信号也是默认值；</strong></p>
</li>
</ul>
<ul>
<li><p>脱机运行</p>
<p>通常登录系统，系统会给当前的登录账号一个终端进程，在这个终端下运行的进程，如果终端退出则这些进程也会同时退出，所以Linux才有脱机管理。</p>
<p>如果需要退出系统后让进程继续运行，则需要使用<strong><code>nohup</code></strong>命令</p>
<p>命令格式：<strong><code>nohup [命令与参数]</code></strong>    在终端前台任务</p>
<p>​            <strong><code>nohup [命令与参数]</code></strong> &amp; 在终端后台任务</p>
<p><strong><code>nohup</code></strong>命令并不支持bash内置命令,所以命令只能是外部命令。</p>
</li>
</ul>
<h1 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h1><h2 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h2><ul>
<li>将某个时间点的进程运行情况截取下来：<strong><code>ps</code></strong><ul>
<li><strong><code>ps aux</code></strong>：查看系统所有的进程</li>
</ul>
</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><blockquote>
</blockquote>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL基础（一）</title>
    <url>/2019/03/27/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/SQL%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>这篇文章主要以MySQL数据库进行讲解</p>
<p>在阅读本文之前假设已经安装MySQL数据库。请先构建好数据源，如果没有安装MYSQL数据库可以通过下面的在线网站构建数据源并练习SQL语句</p>
<p><strong>SQL在线练习网站：<a href="http://sqlfiddle.com/" target="_blank" rel="noopener">http://sqlfiddle.com/</a></strong></p>
<p><strong>源数据下载：</strong><a href="https://forta.com/wp-content/uploads/books/0672327120/mysql_scripts.zip" target="_blank" rel="noopener">https://forta.com/wp-content/uploads/books/0672327120/mysql_scripts.zip</a></p>
<hr>
<h1 id="SQL语言分类"><a href="#SQL语言分类" class="headerlink" title="SQL语言分类"></a>SQL语言分类</h1><p>SQL语言主要分为三类：</p>
<ul>
<li>DML（Data Manipulation Language）：数据操作语言，常用的增删改查就属于DML，操作的对象是数据表中的对象。</li>
<li>DDL（Data  Definition Language）：数据定义语言。建表，建立数据库就属于DDL</li>
<li>DCL（Data Control Language）：数据控制语言，提交回滚，数据库安全管理等属于DCL</li>
</ul>
<p>本文将逐一介绍这三个SQL语言分类的简单讲解。</p>
<h1 id="检索数据"><a href="#检索数据" class="headerlink" title="检索数据"></a>检索数据</h1><h2 id="SELECT语句"><a href="#SELECT语句" class="headerlink" title="SELECT语句"></a>SELECT语句</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">#建products表并插入数据</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> products</span><br><span class="line">(</span><br><span class="line">  prod_id    <span class="built_in">char</span>(<span class="number">10</span>)      <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  vend_id    <span class="built_in">int</span>           <span class="keyword">NOT</span> <span class="literal">NULL</span> ,</span><br><span class="line">  prod_name  <span class="built_in">char</span>(<span class="number">255</span>)     <span class="keyword">NOT</span> <span class="literal">NULL</span> ,</span><br><span class="line">  prod_price <span class="built_in">decimal</span>(<span class="number">8</span>,<span class="number">2</span>)  <span class="keyword">NOT</span> <span class="literal">NULL</span> ,</span><br><span class="line">  prod_desc  <span class="built_in">text</span>          <span class="literal">NULL</span> ,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span>(prod_id)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> products(prod_id, vend_id, prod_name, prod_price, prod_desc)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">'ANV01'</span>, <span class="number">1001</span>, <span class="string">'.5 ton anvil'</span>, <span class="number">5.99</span>, <span class="string">'.5 ton anvil, black, complete with handy hook'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> products(prod_id, vend_id, prod_name, prod_price, prod_desc)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">'ANV02'</span>, <span class="number">1001</span>, <span class="string">'1 ton anvil'</span>, <span class="number">9.99</span>, <span class="string">'1 ton anvil, black, complete with handy hook and carrying case'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> products(prod_id, vend_id, prod_name, prod_price, prod_desc)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">'OL1'</span>, <span class="number">1002</span>, <span class="string">'Oil can'</span>, <span class="number">8.99</span>, <span class="string">'Oil can, red'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> products(prod_id, vend_id, prod_name, prod_price, prod_desc)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">'FU1'</span>, <span class="number">1002</span>, <span class="string">'Fuses'</span>, <span class="number">3.42</span>, <span class="string">'1 dozen, extra long'</span>);</span><br></pre></td></tr></table></figure>

<h3 id="检索单个列"><a href="#检索单个列" class="headerlink" title="检索单个列"></a>检索单个列</h3><p>语法：<strong><code>SELECT 列名 FROM 表名</code></strong></p>
<p>检索prod_name列</p>
<figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">SELECT prod_name FROM products;</span><br><span class="line"><span class="comment">#结果为</span></span><br><span class="line">|<span class="string">    prod_name </span>|</span><br><span class="line">|<span class="string">--------------</span>|</span><br><span class="line">|<span class="string"> .5 ton anvil </span>|</span><br><span class="line">|<span class="string">  1 ton anvil </span>|</span><br><span class="line">|<span class="string">        Fuses </span>|</span><br><span class="line">|<span class="string">      Oil can </span>|</span><br></pre></td></tr></table></figure>

<ul>
<li>上面的语句利用SELECT语句从products表中检索一个列为prod_name。所需列名在<strong><code>SELECT</code></strong>关键字后面给出，<strong><code>FROM</code></strong>关键字指定要从哪个表检索数据</li>
</ul>
<h3 id="检索多个列"><a href="#检索多个列" class="headerlink" title="检索多个列"></a>检索多个列</h3><p>语法：<strong><code>SELECT 列名1,列名2... FROM 表名</code></strong></p>
<ul>
<li>要从一个表中检索多个列，使用SELECT语句，后面键入多个列名，列名之间必须以逗号隔开</li>
</ul>
<blockquote>
<p>当心逗号：在选择多个列时，一定要在列名之间加逗号，最后一个列名之后不用加</p>
</blockquote>
<p>还是以上面的数据源为例，检索prod_id、prod_name两列</p>
<figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">SELECT prod_id,prod_name FROM products;</span><br><span class="line"><span class="comment">#其结果如下：</span></span><br><span class="line">|<span class="string"> prod_id </span>|<span class="string">    prod_name </span>|</span><br><span class="line">|<span class="string">---------</span>|<span class="string">--------------</span>|</span><br><span class="line">|<span class="string">   ANV01 </span>|<span class="string"> .5 ton anvil </span>|</span><br><span class="line">|<span class="string">   ANV02 </span>|<span class="string">  1 ton anvil </span>|</span><br><span class="line">|<span class="string">     FU1 </span>|<span class="string">        Fuses </span>|</span><br><span class="line">|<span class="string">     OL1 </span>|<span class="string">      Oil can </span>|</span><br></pre></td></tr></table></figure>

<h3 id="检索所有列"><a href="#检索所有列" class="headerlink" title="检索所有列"></a>检索所有列</h3><p>语法：<strong><code>SELECT * FROM 表名</code></strong></p>
<ul>
<li>检索所有列时，给定一个通配符（<strong><code>*</code></strong>）,则会检索表中的所有列。</li>
</ul>
<figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">SELECT * FROM products;</span><br><span class="line">prod_id | <span class="type">vend_id</span> | <span class="type">prod_name</span>  | <span class="type">prod_price</span>  | <span class="type">prod_desc</span></span><br><span class="line">  ANV01	|  <span class="type">1001</span>	  | <span class="type">.5</span> ton anvil |  <span class="type">5</span><span class="number">.99</span>	| <span class="type">.5</span> ton anvil, black</span><br><span class="line">  ANV02	|  <span class="type">1001</span>	  | <span class="type">1</span> ton anvil |  <span class="type">9</span><span class="number">.99</span>	    | <span class="type">1</span> ton anvil, black</span><br></pre></td></tr></table></figure>

<h3 id="检索不同的行（DISTINCT）"><a href="#检索不同的行（DISTINCT）" class="headerlink" title="检索不同的行（DISTINCT）"></a>检索不同的行（DISTINCT）</h3><p>语法：<strong><code>SELECT DISTINCT 列名 FROM 表名</code></strong></p>
<p>要检索出有不同值的列表，使用<strong><code>DISTINCT</code></strong>关键字，此关键字必须直接放在列名的前面。此关键字指示MySQL只返回不同的值，这里的DISTINCT不能部分使用，它应用于所有列而不仅是前置它的列。</p>
<figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">SELECT DISTINCT vend_id FROM products;</span><br><span class="line">|<span class="string"> vend_id </span>|</span><br><span class="line">|<span class="string">---------</span>|</span><br><span class="line">|<span class="string">    1001 </span>|</span><br><span class="line">|<span class="string">    1002 </span>|</span><br></pre></td></tr></table></figure>

<h3 id="限制结果（LIMIT）"><a href="#限制结果（LIMIT）" class="headerlink" title="限制结果（LIMIT）"></a>限制结果（LIMIT）</h3><p>限制返回的行数。可以有两个参数，第一个参数为起始行，从 0 开始；第二个参数为返回的总行数。</p>
<p>语法：</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 列名<span class="number">1</span>,列名<span class="number">2</span>,... </span><br><span class="line"><span class="keyword">FROM</span> 表名</span><br><span class="line"><span class="keyword">LIMIT</span> starts,<span class="built_in">count</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong><code>count</code></strong>：检索取多少行</p>
</li>
<li><p><strong><code>starts</code></strong>：从第几行开始，注意这里的开始行从0开始</p>
</li>
</ul>
<p>返回前五行：</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> products <span class="keyword">LIMIT</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> products <span class="keyword">LIMIT</span> <span class="number">0</span>,<span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>带一个值的<strong><code>LIMIT</code></strong>总是从第一行开始，给出的数为返回的行数。带两个值的<strong><code>LIMIT</code></strong>可以指定从行号为第一个值的位置开始。</p>
<h1 id="过滤数据"><a href="#过滤数据" class="headerlink" title="过滤数据"></a>过滤数据</h1><h2 id="使用WHERE子句"><a href="#使用WHERE子句" class="headerlink" title="使用WHERE子句"></a>使用WHERE子句</h2><p>在SELECT语句中，数据根据<strong><code>WHERE</code></strong>子句中指定的搜索条件进行过滤。WHERE子句在表名后给出。在同时使用<strong><code>ORDER BY</code></strong>和WHERE子句时，应该让ORDER BY位于WHERE之后</p>
<h3 id="WHERE子句操作符"><a href="#WHERE子句操作符" class="headerlink" title="WHERE子句操作符"></a>WHERE子句操作符</h3><p>语法：</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 列名<span class="number">1</span>,列名<span class="number">2</span>,<span class="params">...</span> </span><br><span class="line">FROM 表名</span><br><span class="line"><span class="keyword">WHERE</span> 条件</span><br></pre></td></tr></table></figure>

<p>MYSQL支持以下所有条件操作符：</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>=</td>
<td>等于</td>
</tr>
<tr>
<td>&lt;&gt;</td>
<td>不等于</td>
</tr>
<tr>
<td>!=</td>
<td>不等于</td>
</tr>
<tr>
<td>&lt;</td>
<td>小于</td>
</tr>
<tr>
<td>&lt;=</td>
<td>小于等于</td>
</tr>
<tr>
<td>&gt;</td>
<td>大于</td>
</tr>
<tr>
<td>&gt;=</td>
<td>大于等于</td>
</tr>
<tr>
<td>BETWEEN</td>
<td>在指定的两个值之间</td>
</tr>
<tr>
<td>IS NULL</td>
<td>为NULL值</td>
</tr>
</tbody></table>
<h3 id="过滤单个值"><a href="#过滤单个值" class="headerlink" title="过滤单个值"></a>过滤单个值</h3><p>过滤prod_name=’fuses’的数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name,prod_price</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_name=<span class="string">'fuses'</span>;</span><br></pre></td></tr></table></figure>
<p>过滤价格小于10元的数据 </p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name,prod_price</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_price&lt;<span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>过滤价格小于等于10元的数据</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name,prod_price</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_price&lt;=<span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<h3 id="过滤不匹配"><a href="#过滤不匹配" class="headerlink" title="过滤不匹配"></a>过滤不匹配</h3><p>过滤vend_id不是1002的数据</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name,prod_price</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> vend_id != <span class="number">1002</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果条件值为字符串类型，则需要引用引号，如果条件值为数值类型，则不需要引用引号</p>
</blockquote>
<h3 id="过滤范围值-BETWEEN"><a href="#过滤范围值-BETWEEN" class="headerlink" title="过滤范围值(BETWEEN)"></a>过滤范围值(BETWEEN)</h3><p>如果需要检查某个范围的值，可以使用<strong><code>BETWEEN</code></strong>操作符。其语法与其他WHERE子句的操作符不同。BETWEEN需要两个值，过滤范围的开始值和结束值。在范围使用BETWEEN时，必须指定两个值——所需范围的低端值和高端值。这两个值必须用<strong><code>AND</code></strong>关键字分隔。BETWEEN匹配范围中的所有值，包括指定的开始值和结束值。</p>
<p>过滤价格在5元和10元之间的所有产品</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name,prod_price</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_price <span class="keyword">BETWEEN</span> <span class="number">5</span> <span class="keyword">AND</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<h3 id="空值过滤-IS-NULL"><a href="#空值过滤-IS-NULL" class="headerlink" title="空值过滤(IS NULL)"></a>空值过滤(IS NULL)</h3><p>WHERE子句 <strong><code>IS NULL</code></strong>用来检查具有<strong>NULL</strong>值的列。</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_price <span class="keyword">IS</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<h2 id="组合WHERE子句"><a href="#组合WHERE子句" class="headerlink" title="组合WHERE子句"></a>组合WHERE子句</h2><h3 id="AND操作符"><a href="#AND操作符" class="headerlink" title="AND操作符"></a><strong><code>AND</code></strong>操作符</h3><p>为了通过不止一个列在过滤，可使用<strong><code>AND</code></strong>操作符给WHERE子句附加条件，用来指示检索满足所有给定的条件的行。</p>
<p>案例：</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_id,prod_price,prod_name</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> vend_id = <span class="number">1003</span> <span class="keyword">AND</span> prod_price &lt;= <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<h3 id="OR操作符："><a href="#OR操作符：" class="headerlink" title="OR操作符："></a><strong><code>OR</code></strong>操作符：</h3><p>用于过滤检索匹配任意一条件的行</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_id,prod_price,prod_name</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> vend_id = <span class="number">1003</span> <span class="keyword">OR</span> prod_price &lt;= <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<h3 id="IN操作符"><a href="#IN操作符" class="headerlink" title="IN操作符"></a><strong><code>IN</code></strong>操作符</h3><p><strong><code>IN</code></strong>操作符用于指定条件范围，范围中每个条件都可以进行匹配。<strong>IN</strong>在WHERE中用来指定匹配值的关键字，功能与OR相当</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name,prod_price</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> vend_id <span class="keyword">IN</span>(<span class="number">1002</span>,<span class="number">1003</span>)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_name;</span><br></pre></td></tr></table></figure>

<p><strong><code>IN</code></strong>操作符的优点如下：</p>
<ul>
<li>当需要匹配的值比较多时，IN操作符的语法更清楚且更直观；</li>
<li><strong>IN</strong>操作符一般比OR操作符执行更快；</li>
<li>在使用<strong>IN</strong>时，计算的次序更容易管理；</li>
<li><strong>IN</strong>的一最大优点就是可以包含其他SELECT语句，使得能够更动态地建立WHERE子句；</li>
</ul>
<h3 id="NOT操作符："><a href="#NOT操作符：" class="headerlink" title="NOT操作符："></a><strong><code>NOT</code></strong>操作符：</h3><p><strong><code>NOT</code></strong>用在WHERE子句中，用来否定后跟的条件表达式，MYSQL中的NOT，支持NOT对IN，BETWEEN和EXISTS子句取反。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><blockquote>
<p>《MySQL必知必会》人民邮电出版社</p>
<p>《MySQL 从入门到精通》清华大学出版社</p>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux账号管理与权限设置</title>
    <url>/2019/03/21/Linux/Linux%E8%B4%A6%E5%8F%B7%E7%AE%A1%E7%90%86%E4%B8%8E%E6%9D%83%E9%99%90%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
</blockquote>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>文件与文件系统压缩</title>
    <url>/2019/03/20/Linux/%E6%96%87%E4%BB%B6%E4%B8%8E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%8E%8B%E7%BC%A9/</url>
    <content><![CDATA[<h3 id="Linux系统常见的压缩命令"><a href="#Linux系统常见的压缩命令" class="headerlink" title="Linux系统常见的压缩命令"></a>Linux系统常见的压缩命令</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">*<span class="selector-class">.z</span> <span class="selector-tag">compress</span>程序压缩的文件；</span><br><span class="line">*<span class="selector-class">.zip</span> <span class="selector-tag">zip</span>程序压缩的文件；</span><br><span class="line">*<span class="selector-class">.gz</span> <span class="selector-tag">gzip</span>程序压缩的文件；</span><br><span class="line">*<span class="selector-class">.bz2</span> <span class="selector-tag">bzip2</span>程序压缩的文件；</span><br><span class="line">*<span class="selector-class">.xz</span> <span class="selector-tag">xz</span>程序压缩的文件；</span><br><span class="line">*<span class="selector-class">.tar</span> <span class="selector-tag">tar</span>程序打包的文件，并没有压缩过；</span><br><span class="line">*<span class="selector-class">.tar</span><span class="selector-class">.gz</span> <span class="selector-tag">tar</span>程序打包的文件，并经过<span class="selector-tag">gzip</span>的压缩</span><br><span class="line">*<span class="selector-class">.tar</span><span class="selector-class">.bz2</span> <span class="selector-tag">tar</span>程序打包的文件，并经过<span class="selector-tag">bzip2</span>的压缩</span><br><span class="line">*<span class="selector-class">.tar</span><span class="selector-class">.xz</span> <span class="selector-tag">tar</span>程序打包的文件，并经过<span class="selector-tag">xz</span>的压缩</span><br></pre></td></tr></table></figure>

<ul>
<li><p>gzip，zcat</p>
<p><strong><code>gzip</code></strong>可以说是应用最广泛的压缩命令。下面介绍这些命令;</p>
<ul>
<li><p><strong><code>gzip [-cdtv#] 文件名</code></strong></p>
<p>选项和参数：</p>
<p><strong><code>-c</code></strong>：将压缩的数据输出到屏幕上，可通过数据流重定向来处理；</p>
<p><strong><code>-d</code></strong>：解压缩的参数</p>
<p><strong><code>-t</code></strong>：可以用来检验一个压缩文件的一致性，看看文件是否有误</p>
<p><strong><code>-#</code></strong>：#表示压缩级别，-1最快，但压缩比最差，-9最慢，压缩比最好，默认为-6</p>
</li>
</ul>
</li>
<li><p>xz，xzcat</p>
<p>命令格式</p>
<p><strong><code>xz [-dtlkc#] 文件名</code></strong></p>
<p><strong><code>xcat 文件名.xz</code></strong></p>
<p>选项与参数:</p>
<p><strong><code>-d</code></strong>：解压缩；</p>
<p><strong><code>-t</code></strong>：测试压缩文件的完整性；</p>
<p><strong><code>-l</code></strong>：列出压缩文件的相关信息；</p>
<p><strong><code>-k</code></strong>：保留原本文件不删除</p>
<p><strong><code>-c</code></strong>：将数据在屏幕上输出</p>
<p><strong><code>-#</code></strong>：压缩级别</p>
</li>
</ul>
<h3 id="打包名命名：tar"><a href="#打包名命名：tar" class="headerlink" title="打包名命名：tar"></a>打包名命名：<strong><code>tar</code></strong></h3><p>命名格式：<br><strong><code>tat [-z][-j][-J][cv][-f 待建里的文件名] filename ...</code></strong>：打包与压缩<br><strong><code>tar [-z][-j][-J][tv][-f 既有的tar文件名]</code></strong>：查看文件名<br><strong><code>tar [-z][-j][-J][xv][-f 既有的tar文件名] [-C 目录]</code></strong>：解压缩<br>选项与参数：<br><strong><code>-c</code></strong>：建立打包文件，可搭配-v来查看过程中被打包的文件名；<br><strong><code>-t</code></strong>：查看打包文件的内容含有哪些文件名，重点看文件名；<br><strong><code>-x</code></strong>：解包或解压缩，可以搭配<strong><code>-C</code></strong>在特定目录解压；<br><strong><code>-z</code></strong>：通过gzip的支持进行压缩/解压缩：此时文件名最好为<strong>*.tar.gz</strong>；<br><strong><code>-C 目录</code></strong>：若要在特定目录解压缩，可以使用这个选项；<br><strong><code>-f finame</code></strong>：<strong>-f</strong>后面要立刻接要被处理的文件名<br><strong><code>--exclude=FILE</code></strong>：在压缩过程中，不要将FILE打包<br>注意：<strong><code>-c、-t、-x</code></strong>不可同时出现<br>常使用的命令组合：<br><strong><code>tar -zcvf filename.tar.gz</code></strong>、<strong><code>tar -jcvf filename.tar.bz2</code></strong>：压缩<br><strong><code>tar -ztvf filename.tar.gz</code></strong>、<strong><code>tar -jtvf filename.tar.bz2</code></strong>：查询<br><strong><code>tar -zxvf filename.tar.gz -C 目录</code></strong>、<strong><code>tar -jxvf filename.tar.bz2 -C 目录</code></strong>：解压缩</p>
<h3 id="常见的压缩与备份工具"><a href="#常见的压缩与备份工具" class="headerlink" title="常见的压缩与备份工具"></a>常见的压缩与备份工具</h3><h4 id="dd"><a href="#dd" class="headerlink" title="dd"></a>dd</h4><p>命令格式：<strong><code>dd if=input_file of=output_file bs=block_size count=number</code></strong></p>
<p>选项与参数：</p>
<p><strong><code>if</code></strong>：输如设备</p>
<p><strong><code>of</code></strong>：输出设备</p>
<p><strong><code>bs</code></strong>：设置的一个block的大小，若未指定则默认是512Bytes（一个扇区大小）</p>
<p><strong><code>count</code></strong>：多少个bs</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
</blockquote>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux的文件与目录管理</title>
    <url>/2019/03/18/Linux/Linux%E7%9A%84%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h3 id="目录相关操作"><a href="#目录相关操作" class="headerlink" title="目录相关操作"></a>目录相关操作</h3><p>对于目录相关的命名首先要介绍的一个命令是目录切换命令：<strong><code>cd</code></strong></p>
<p>还有一些比较特殊的目录：</p>
<ul>
<li><strong><code>.</code></strong>：代表此层目录；</li>
<li><strong><code>..</code></strong>：代表上一层目录；</li>
<li><strong><code>-</code></strong>：代表前一个工作目录；</li>
<li><strong><code>~</code></strong>：代表目前使用者身份所在的家目录</li>
<li><strong><code>~account</code></strong>：代表<strong>account</strong>这个使用者的家目录</li>
</ul>
<h4 id="处理目录的命令："><a href="#处理目录的命令：" class="headerlink" title="处理目录的命令："></a>处理目录的命令：</h4><ul>
<li><p><strong><code>cd（change directory）</code></strong>：切换目录</p>
<p>命令格式：<strong><code>cd [相对路径或绝对路径]</code></strong></p>
<p><strong>利用相对路径的写法必须确认的目前的路径才能正确地去到想要的目录</strong></p>
<p>下面看几个例子</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#切换到tmp目录</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> /tmp</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">pwd</span></span></span><br><span class="line">/tmp</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#回到家目录</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> ~</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">pwd</span></span></span><br><span class="line">/root</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#回到上一次的工作目录</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> -</span></span><br><span class="line">/tmp</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#当前的工作目录在/tmp，回到上一级目录</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> ..</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">pwd</span></span></span><br><span class="line">/</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>pwd（显示目前所在的目录）</code></strong></p>
<p>命令格式：<strong><code>pwd [-p]</code></strong></p>
<p>​                    选项与参数：-p：显示出真正的目录，而非使用链接路径</p>
</li>
<li><p><strong><code>mkdir</code></strong>：建立新目录</p>
<p>命令格式</p>
<p><strong><code>mkdir [-mp] 目录名称</code></strong></p>
<p>选项与参数：</p>
<p><strong><code>-m</code></strong>：设置文件的权限。直接设置，不需使用默认权限（<strong>umask</strong>）</p>
<p><strong><code>-p</code></strong>：递归创建子目录</p>
<p>下面举几个例子：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#在当前的工作目录下创建test0目录</span></span><br><span class="line"><span class="string">$</span> <span class="string">mkdir</span> <span class="string">test0</span></span><br><span class="line"><span class="string">drwxr-xr-x</span> <span class="number">2</span> <span class="string">root</span> <span class="string">root</span> <span class="number">4096</span> <span class="string">Mar</span> <span class="number">19</span> <span class="number">16</span><span class="string">:58</span> <span class="string">test0</span></span><br><span class="line"><span class="comment">##在当前的工作目录下递归创建test1/test2/test3这样的多层目录</span></span><br><span class="line"><span class="string">$</span> <span class="string">mkdir</span> <span class="string">-p</span> <span class="string">test1/test2/test3</span></span><br></pre></td></tr></table></figure>

<p>一般创建目录大都是使用默认权限（umask），mkdir可以在创建目录时可以指定权限，例如：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ mkdir -m <span class="number">711</span> test2</span><br><span class="line">drwx--x--x <span class="number">2</span> root root <span class="number">4096</span> Mar <span class="number">19</span> <span class="number">17</span>:<span class="number">07</span> test2</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>rmdir</code></strong>：删除“空”目录<br>命令格式：rmdir [-p] 目录名称<br>被删除的目录里不能存在其他的文件和目录，如果想要一次性删除一个目录以及该目录其下的子目录可以使用<strong><code>rm -rf 目录名称</code></strong>,但这样不是太安全，还是使用<strong><code>rmdir</code></strong>比较安全。</p>
</li>
</ul>
<h4 id="文件与目录管理"><a href="#文件与目录管理" class="headerlink" title="文件与目录管理"></a>文件与目录管理</h4><h5 id="文件与目录查看：ls"><a href="#文件与目录查看：ls" class="headerlink" title="文件与目录查看：ls"></a>文件与目录查看：<strong><code>ls</code></strong></h5><p>命名格式：<strong><code>ls [-adlh]</code></strong> 文件名或目录名称</p>
<p>选项参数：</p>
<p><strong><code>-a</code></strong>：全部的文件，包括隐藏文件（开头为.的文件）一起列出</p>
<p><strong><code>-d</code></strong>：仅列出目录本身，而不是列出目录内的文件数据</p>
<p><strong><code>-h</code></strong>：将文件大小以及人类易读的方式（GB，KB，MB）列出</p>
<p><strong><code>-l</code></strong>：详细信息显示，包括文件的属性与权限等数据</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">##列出root目录下的所有文件</span><br><span class="line">$ ls -al ~</span><br><span class="line">dr-xr-x---.  <span class="number">9</span> root root <span class="number">4096</span> Mar <span class="number">19</span> <span class="number">17</span>:<span class="number">07</span> .</span><br><span class="line">dr-xr-xr-x. <span class="number">18</span> root root <span class="number">4096</span> Mar <span class="number">14</span> <span class="number">16</span>:<span class="number">57</span> ..</span><br><span class="line">-rw-------   <span class="number">1</span> root root <span class="number">5185</span> Mar <span class="number">18</span> <span class="number">23</span>:<span class="number">42</span> .bash_history</span><br><span class="line">······</span><br><span class="line">drwxr-xr-x   <span class="number">2</span> root root <span class="number">4096</span> Mar <span class="number">19</span> <span class="number">16</span>:<span class="number">58</span> test0</span><br><span class="line">drwxr-xr-x   <span class="number">3</span> root root <span class="number">4096</span> Mar <span class="number">19</span> <span class="number">17</span>:<span class="number">00</span> test1</span><br><span class="line">drwx--x--x   <span class="number">2</span> root root <span class="number">4096</span> Mar <span class="number">19</span> <span class="number">17</span>:<span class="number">07</span> test2</span><br><span class="line">-rw-rw-rw-   <span class="number">1</span> root root    <span class="number">0</span> Mar <span class="number">18</span> <span class="number">01</span>:<span class="number">49</span> test.txt</span><br></pre></td></tr></table></figure>

<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">##列出root目录下的所有文件,以人类易读的方式</span><br><span class="line">$ ls -alh ~</span><br><span class="line">dr-xr-x---.  <span class="number">9</span> root root <span class="number">4.0</span>K Mar <span class="number">19</span> <span class="number">17</span>:<span class="number">07</span> .</span><br><span class="line">dr-xr-xr-x. <span class="number">18</span> root root <span class="number">4.0</span>K Mar <span class="number">14</span> <span class="number">16</span>:<span class="number">57</span> ..</span><br><span class="line">-rw-------   <span class="number">1</span> root root <span class="number">5.1</span>K Mar <span class="number">18</span> <span class="number">23</span>:<span class="number">42</span> .bash_history</span><br><span class="line">······</span><br><span class="line">drwxr-xr-x   <span class="number">2</span> root root <span class="number">4.0</span>K Mar <span class="number">19</span> <span class="number">16</span>:<span class="number">58</span> test0</span><br><span class="line">drwxr-xr-x   <span class="number">3</span> root root <span class="number">4.0</span>K Mar <span class="number">19</span> <span class="number">17</span>:<span class="number">00</span> test1</span><br><span class="line">drwx--x--x   <span class="number">2</span> root root <span class="number">4.0</span>K Mar <span class="number">19</span> <span class="number">17</span>:<span class="number">07</span> test2</span><br><span class="line">-rw-rw-rw-   <span class="number">1</span> root root    <span class="number">0</span> Mar <span class="number">18</span> <span class="number">01</span>:<span class="number">49</span> test.txt</span><br></pre></td></tr></table></figure>

<h4 id="复制、删除、移动：cp、rm、mv"><a href="#复制、删除、移动：cp、rm、mv" class="headerlink" title="复制、删除、移动：cp、rm、mv"></a>复制、删除、移动：<strong><code>cp</code></strong>、<strong><code>rm</code></strong>、<strong><code>mv</code></strong></h4><ul>
<li><p><strong><code>cp</code></strong>:复制文件或目录</p>
<p>命令格式：<strong><code>cp [-ipr] 源文件（source） 目标文件（dest）</code></strong></p>
<p>选项与参数：</p>
<p><strong><code>-a</code></strong>：参考下面的<strong><code>-dr</code></strong>选项</p>
<p><strong><code>-d</code></strong>：若源文件为链接文件属性，则复制链接文件属性而非文件本身</p>
<p><strong><code>-i</code></strong>：若目标文件已经存在，在覆盖时会先询问操作的进行</p>
<p><strong><code>-p</code></strong>：连同文件的属性一起复制，不使用默认属性</p>
<p><strong><code>-r</code></strong>：递归复制，用于目录的复制操作</p>
<p>在默认的条件中，<strong><code>cp</code></strong>的源文件与目标文件的权限是不同的，目标文件的拥有者通常会是命令操作本身。</p>
</li>
<li><p><strong><code>rm</code></strong>（删除文件或目录）</p>
<p>命令格式：<strong><code>rm [-fir] 文件或目录</code></strong></p>
<p>选项与参数：</p>
<p><strong><code>-f</code></strong>：强制的意思</p>
<p><strong><code>-I</code></strong>：交互模式，在删除之前会询问使用是否操作</p>
<p><strong><code>-r</code></strong>：递归删除</p>
<p>通常这个命令在使用时要十分小心，在删除前要认真确定删除的文件或目录是否正确，避免误删除的情况</p>
<figure class="highlight vala"><table><tr><td class="code"><pre><span class="line"><span class="meta">#删除test1文件夹</span></span><br><span class="line"><span class="meta">#连同目录下的所有子目录一并强制删除</span></span><br><span class="line">$ rm -rf test1 </span><br><span class="line"><span class="meta">#删除文件也是如此</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>mv（移动文件与目录或重命名）</code></strong></p>
<p>命令格式：<strong><code>mv [-fiu] source dest</code></strong></p>
<p>选项与参数：</p>
<p><strong><code>-f</code></strong>：强制执行</p>
<p><strong><code>-i</code></strong>：若目标文件已经存在，会询问是否覆盖</p>
<p><strong><code>-u</code></strong>：若目标文件已存在，且<strong>source</strong>比较新，才会更新</p>
<p>这里举几个例子：</p>
<p>将<strong>test.txt</strong>文件移动到<strong>test0</strong>文件夹中</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">$ mv <span class="keyword">test</span>.txt test0</span><br><span class="line">$ <span class="keyword">ls</span> test0</span><br><span class="line"><span class="keyword">test</span>.txt</span><br></pre></td></tr></table></figure>

<p>将<strong>test0</strong>文件夹重命名为<strong>test3</strong></p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>mv test0 test4</span><br><span class="line"><span class="variable">$ </span>ls .</span><br><span class="line">test3</span><br></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li><p>修改文件时间或创建新文件：<strong><code>touch</code></strong></p>
<p>命令格式：<strong><code>touch [-acdmt] 文件名</code></strong></p>
<p>选项与参数：</p>
<p>​    <strong><code>-a</code></strong>：仅自定义access time；</p>
<p>​    <strong><code>-c</code></strong>：仅修改文件时间，若该文件不存在则不创建新文件；</p>
<p>​    <strong><code>-d</code></strong>：后面可以接想要自定义的日期而不用目前的日期；</p>
<p>​    <strong><code>-m</code></strong>：修改mtime</p>
<p>​    <strong><code>-t</code></strong>：后面可以接想要自定义的时间而不是使用目前的日期，格式为[YYYYMMDDhhmm]</p>
<p>touch命令最常用的情况是：</p>
<ul>
<li><strong>创建一个空文件</strong></li>
<li><strong>将某个文件日期自定义为目前</strong></li>
</ul>
<p>举几个例子：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">#创建一个空文件</span><br><span class="line">$ touch test1</span><br><span class="line">-rw-r--r--  <span class="number">1</span> root root <span class="number">0</span> Mar <span class="number">21</span> <span class="number">12</span>:<span class="number">03</span> test1</span><br><span class="line">#修改日期为：<span class="number">2020</span>/<span class="number">02</span>/<span class="number">21</span> <span class="number">00</span>:<span class="number">00</span></span><br><span class="line">$ touch -t <span class="number">202002210000</span> test1</span><br><span class="line">-rw-r--r--  <span class="number">1</span> root root <span class="number">0</span> Feb <span class="number">21</span> <span class="number">00</span>:<span class="number">00</span> test1</span><br></pre></td></tr></table></figure>
<h3 id="文件与目录的默认权限与隐藏权限"><a href="#文件与目录的默认权限与隐藏权限" class="headerlink" title="文件与目录的默认权限与隐藏权限"></a>文件与目录的默认权限与隐藏权限</h3><h4 id="文件默认权限：umask"><a href="#文件默认权限：umask" class="headerlink" title="文件默认权限：umask"></a>文件默认权限：<strong><code>umask</code></strong></h4><p>umask是指定目前用户在创建文件或者目录时的权限默认值。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">使用<span class="built_in">umask</span>查看默认权限</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">umask</span></span></span><br><span class="line">0022 //与一般权限有关的是后面三个数字</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">umask</span> -S</span></span><br><span class="line">u=rwx,g=rx,o=rx</span><br></pre></td></tr></table></figure>

<p>默认情况下：</p>
<ul>
<li><p>若用户创建文件则默认没有（x）执行权限，也就是只有<strong><code>rw</code></strong>这两个项目,也就是最大为666，默认权限为：</p>
<p> <strong><code>-rw-rw-rw-</code></strong></p>
</li>
<li><p>若用户创建目录则由于x是与是否可以进入目录有关的，因此默认为所有权限均开放，即777</p>
<p><strong><code>drwxrwxrwx</code></strong></p>
</li>
</ul>
</li>
</ul>
<p><strong>umaks的数字指的是该默认值需要减掉的权限</strong></p>
<p>通过上面<strong><code>umask=0022</code></strong>进行说明。因为umask=0022，user没有被拿掉任何权限，group与others的权限被拿掉了2（也就是<strong>w</strong>权限）（r、w、x每个权限的数字在《Linux文件权限与目录简介》一篇中介绍过）那么用户：</p>
<ul>
<li><strong>创建文件时：（-rw-rw-rw-）-（- - - - - w - - w -）==&gt; - rw-r- -r- - ,最后创建文件时的权限：666-022=644</strong></li>
<li><strong>创建目录时：（drwxrwxrwx）-（d - - - - w- - w-）==&gt; drwxr-xr-x最后创建目录时的权限：777-022=755</strong></li>
</ul>
<p>创建一个文件和一个目录：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ umask</span><br><span class="line"><span class="number">0022</span></span><br><span class="line">$ touch test0</span><br><span class="line"><span class="number">666</span><span class="number">-022</span>=<span class="number">644</span></span><br><span class="line">-rw-r--r--  <span class="number">1</span> root root <span class="number">0</span> Mar <span class="number">21</span> <span class="number">12</span>:<span class="number">49</span> test0</span><br><span class="line"> <span class="number">6</span>  <span class="number">4</span>  <span class="number">4</span></span><br><span class="line">#创建目录</span><br><span class="line">$ mkdir test.d</span><br><span class="line"><span class="number">777</span><span class="number">-022</span>=<span class="number">755</span></span><br><span class="line">drwxr-xr-x  <span class="number">2</span> root roo <span class="number">4096</span> Mar <span class="number">21</span> <span class="number">12</span>:<span class="number">53</span> test.d</span><br><span class="line">  <span class="number">7</span>  <span class="number">5</span>  <span class="number">5</span></span><br></pre></td></tr></table></figure>
<h4 id="文件隐藏属性"><a href="#文件隐藏属性" class="headerlink" title="文件隐藏属性"></a>文件隐藏属性</h4><ul>
<li><p>配置文件隐藏属性：<strong><code>chattr [+-=][ASacdistu] 文件或目录名称</code></strong></p>
<p>常用选项与参数：<br><strong><code>+</code></strong>：增加某个特殊参数，其他原本存在参数不动；<br><strong><code>-</code></strong>：减少某个特殊参数，其他原本存在参数不动；<br><strong><code>=</code></strong>：直接设置参数，且仅有后面接的参数；<br><strong><code>a</code></strong>：当设置这个<strong>a</strong>之后，这个文件将只能增加数据，而不能删除也不能修改数据，只有root才能设置这个属性；<br><strong><code>i</code></strong>：当设置<strong>i</strong>之后，可以让一个文件不能被删除、改名、设置链接也无法写入或新增数据；</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>touch test23</span><br><span class="line"><span class="variable">$ </span>chattr +i test23</span><br><span class="line"><span class="variable">$ </span>rm -rf test23</span><br><span class="line"><span class="comment">#不能删除</span></span><br><span class="line"><span class="symbol">rm:</span> cannot remove test23：Operation <span class="keyword">not</span> permitted</span><br></pre></td></tr></table></figure>
</li>
<li><p>显示文件隐藏属性：<strong><code>lsattr [-adR] 文件或目录</code></strong></p>
<p>选项与参数：</p>
<p><strong><code>-a</code></strong>：将隐藏文件的属性显示出来</p>
<p><strong><code>-d</code></strong>：如果接的目录，仅列出目录本身的属性而非目录内的文件名</p>
<p><strong><code>-R</code></strong>：连同子目录的数据也一并列出来</p>
<p>接着上面的例子：</p>
<figure class="highlight brainfuck"><table><tr><td class="code"><pre><span class="line"><span class="comment">$</span> <span class="comment">lsattr</span> <span class="literal">-</span><span class="comment">aR</span> <span class="comment">test23</span></span><br><span class="line"><span class="comment"></span>--<span class="literal">-</span><span class="literal">-</span><span class="comment">i</span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">e</span>-- <span class="comment">test23</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="命令与文件的查找"><a href="#命令与文件的查找" class="headerlink" title="命令与文件的查找"></a>命令与文件的查找</h4><h5 id="脚本文件查找"><a href="#脚本文件查找" class="headerlink" title="脚本文件查找"></a>脚本文件查找</h5><ul>
<li><p>查找执行文件：<strong><code>which [-a] command</code></strong></p>
<p>选项或参数：</p>
<p><strong><code>-a</code></strong>：将所有由PATH目录中可以找到的命令均列出，而不止第一个被找到的命令名称</p>
<p>这个命令是根据【PATH】这个环境变量所规范的路径，去查找执行文件的文件名。</p>
</li>
</ul>
<h5 id="文件查找"><a href="#文件查找" class="headerlink" title="文件查找"></a>文件查找</h5><ul>
<li><p>由一些特定的目录中查找文件：<strong><code>whereis [-bmsu] 文件或目录</code></strong></p>
<p>选项与参数：</p>
<p><strong><code>-l</code></strong>：可以列出whereis会去查询的几个主要目录；</p>
<p><strong><code>-b</code></strong>：只找binary（二进制）格式文件；</p>
<p><strong><code>-m</code></strong>：只找在说明文件manual路径下的文件；</p>
<p><strong><code>-s</code></strong>：只找source源文件；</p>
<p><strong><code>-u</code></strong>：查找不在上述三个项目当中的其他特殊文件；</p>
</li>
<li><p><strong><code>locate [-ir] keyword</code></strong></p>
<p>选项与参数：</p>
<p><strong><code>-i</code></strong>：忽略大小写的差异；</p>
<p><strong><code>-c</code></strong>：不输出文件名，计算找到的文件数量；</p>
<p><strong><code>-l</code></strong>：仅输出几行的意思；</p>
<p><strong><code>-S</code></strong>：输出locate所使用的数据库文件的相关信息，包括该数据库记录文件/目录数量等；</p>
<p><strong><code>-r</code></strong>：后面可接正则表达式的显示方式；</p>
</li>
<li><p><strong><code>find [PATH] [option] [action]</code></strong>没事别用这个命令神慢~</p>
</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<p>《鸟哥的Linux私房菜—基础学习篇（第四版）》 鸟哥著 人民邮电出版社</p>
</blockquote>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux文件权限与目录简介</title>
    <url>/2019/03/16/Linux/Linux%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E4%B8%8E%E7%9B%AE%E5%BD%95%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h3 id="Linux文件权限与文件属性"><a href="#Linux文件权限与文件属性" class="headerlink" title="Linux文件权限与文件属性"></a>Linux文件权限与文件属性</h3><h4 id="Linux文件属性"><a href="#Linux文件属性" class="headerlink" title="Linux文件属性"></a>Linux文件属性</h4><p>先来看下面的Linux文件属性信息:</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">-rw-r--r--. <span class="number">1</span> root root <span class="number">29</span> Nov <span class="number">18</span> <span class="number">00</span>:<span class="number">00</span> test.txt</span><br><span class="line">drwxr-xr-x. <span class="number">4</span> root root <span class="number">39</span> Oct  <span class="number">8</span> <span class="number">14</span>:<span class="number">39</span> opt</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/yangshenghua97/Image/master/fileinfo.png" alt=""></p>
<ul>
<li><p>第一栏代表这个文件的类型与权限</p>
<ul>
<li><p>第一个字符代表这个文件是目录、文件或是链接文件等</p>
<p><img src="https://raw.githubusercontent.com/yangshenghua97/Image/master/%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90.png" alt=""></p>
<ul>
<li>当为[d]则为目录，例如像上面的文件名【opt】就是一个目录</li>
<li>当为[-]则是文件，例如像上面的文件名【test.txt】就是一个文件</li>
<li>当为[l]则是链接文件</li>
<li>当为[b]则是设备文件里面的可供存储的周边设备</li>
</ul>
</li>
<li><p>当为[c]则是设备文件里面的串行端口设备</p>
</li>
</ul>
</li>
</ul>
<p>上面图片中后面的三个组表示<strong>文件拥有者</strong>、<strong>文件所属用户组</strong>、<strong>其他人</strong>的文件权限</p>
  <figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">r</span> <span class="string">可读</span></span><br><span class="line"><span class="attr">w</span> <span class="string">可写</span></span><br><span class="line"><span class="attr">x</span> <span class="string">可执行</span></span><br><span class="line"><span class="meta">-</span> <span class="string">无权限</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>第一组为文件拥有者可具备的权限。</strong></li>
<li><strong>第二组为加入此用户组的账号的权限</strong></li>
<li><strong>第三组为非本人且没有加入本用户组的其他账号的权限</strong></li>
</ul>
<ul>
<li><p>第二栏表示多少文件名链接到此节点</p>
</li>
<li><p>第三栏表示这个文件或目录的拥有者账号</p>
</li>
<li><p>第四栏表示这个文件的所属用户组</p>
</li>
<li><p>第五栏为这个文件的容量大小，默认单位为Bytes，如果想看更人性化的可以输入<strong><code>ls -alh</code></strong></p>
</li>
<li><p>第六栏为这个文件创建日期或是最近修该日期</p>
</li>
<li><p>第七栏为文件名，如果文件名之前多一个<strong><code>.</code></strong>,则代表这个文件为隐藏文件。</p>
</li>
</ul>
<h4 id="如何修改文件属性与权限"><a href="#如何修改文件属性与权限" class="headerlink" title="如何修改文件属性与权限"></a>如何修改文件属性与权限</h4><ul>
<li><p>几个修改用户组、拥有者、各种身份的权限命令</p>
<ul>
<li><strong><code>chgrp</code></strong>：修改文件所属用户组</li>
<li><strong><code>chown</code></strong>：修改文件拥有者</li>
<li><strong><code>chmod</code></strong>：修改文件的权限，SUID、SGID、SBIT等的特性</li>
</ul>
</li>
<li><h5 id="修改所属用户组：chgrp"><a href="#修改所属用户组：chgrp" class="headerlink" title="修改所属用户组：chgrp"></a>修改所属用户组：<strong><code>chgrp</code></strong></h5><p>修改一个文件的用户组直接使用<strong><code>chgrp</code></strong>命令修改即可，这个命令就是change group的缩写</p>
<p>命令格式：</p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">chgrp [-<span class="symbol">R</span>] [系统用户] dirname/filename ...</span><br><span class="line">  -<span class="symbol">R</span>：进行递归修改，</span><br></pre></td></tr></table></figure>

<p>现在系统中有<strong>yang</strong>这个用户，将<strong>test.txt</strong>文件的用户组修改为<strong>yang</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ -rw-r--r--. <span class="number">1</span> root root <span class="number">29</span> Nov <span class="number">18</span> <span class="number">00</span>:<span class="number">00</span> test.txt</span><br><span class="line">$ chgrp yang test.txt</span><br><span class="line">$ ls -al</span><br><span class="line">#已经将test.txt文件的所属用户组修改为yang</span><br><span class="line">$ -rw-r--r--. <span class="number">1</span> root yang <span class="number">29</span> Nov <span class="number">18</span> <span class="number">00</span>:<span class="number">00</span> test.txt</span><br></pre></td></tr></table></figure>
</li>
<li><h5 id="修改文件拥有者：chown"><a href="#修改文件拥有者：chown" class="headerlink" title="修改文件拥有者：chown"></a>修改文件拥有者：<strong><code>chown</code></strong></h5><p>要修改文件为指定的用户，系统里必须有这个指定用户账号</p>
<p>命名格式：</p>
<figure class="highlight tp"><table><tr><td class="code"><pre><span class="line">chown [-<span class="keyword">R</span>] 账号名称 文件或目录</span><br><span class="line">chown [-<span class="keyword">R</span>] 账号名称:用户组名称 文件或目录</span><br><span class="line">-<span class="keyword">R</span>：进行递归修改，如果要连目录下的所有子目录或文件同时更改文件拥有者的话，加上-<span class="keyword">R</span>选项即可</span><br></pre></td></tr></table></figure>

<p>还是上面的那个<strong>test.txt</strong>文件，将其的文件拥有者修改为<strong>yang</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ -rw-r--r--.  <span class="number">1</span> root yang <span class="number">29</span> Nov <span class="number">18</span> <span class="number">00</span>:<span class="number">00</span> test.txt</span><br><span class="line">$ chown yang test.txt</span><br><span class="line">$ ls -al</span><br><span class="line">$ -rw-r--r--.  <span class="number">1</span> yang yang <span class="number">29</span> Nov <span class="number">18</span> <span class="number">00</span>:<span class="number">00</span> test.txt</span><br><span class="line">#将test.txt的拥有者和用户组修改回root</span><br><span class="line">$ chown root:root test.txt</span><br><span class="line">$ -rw-r--r--. <span class="number">1</span> root root <span class="number">29</span> Nov <span class="number">18</span> <span class="number">00</span>:<span class="number">00</span> test.txt</span><br></pre></td></tr></table></figure>

<p>chown也可以使用【chown user.group file】,在拥有者与用户组间加上【<strong>.</strong>】也可以修改。</p>
</li>
<li><h5 id="目录与文件权限的意义"><a href="#目录与文件权限的意义" class="headerlink" title="目录与文件权限的意义"></a>目录与文件权限的意义</h5><ul>
<li><h6 id="权限对文件的重要性"><a href="#权限对文件的重要性" class="headerlink" title="权限对文件的重要性"></a>权限对文件的重要性</h6><p>权限对于文件来说，意义是这样的：</p>
<ul>
<li><p><strong><code>r（read）</code></strong>：可读取此文件的实际内容</p>
</li>
<li><p><strong><code>w（write）</code></strong>：可以编辑、新增或是修改该文件的内容（但不可以删除该文件哦）</p>
</li>
<li><p><strong><code>x（eXecute）</code></strong>：该文件具有可以被系统执行的权限</p>
<p>在Linux下面，文件是否有执行能力，是根据是否具有【x】这个权限来决定的，和文件名没有绝对的关系</p>
</li>
</ul>
</li>
<li><h6 id="权限对目录的重要性"><a href="#权限对目录的重要性" class="headerlink" title="权限对目录的重要性"></a>权限对目录的重要性</h6><p>目录的主要内容在记录文件名列表，文件名与目录有强烈的关联。对于目录，r、w、x的意义如下：</p>
<ul>
<li><p><strong><code>r</code></strong>：表示具有读取目录结构列表的权限，所有当具有读取一个目录的权限（r）时，表示可以查询该目录下的文件名的数据。</p>
</li>
<li><p><strong><code>w</code></strong>：这个是对于目录的可写入权限，表示用户具有改动改目录结构列表的权限。也就是下面这些权限：</p>
<ul>
<li>建立新的文件与目录</li>
<li>删除已经存在的文件与目录</li>
<li>将已存在的文件或目录进行更名</li>
<li>移动该目录内的文件、目录位置</li>
</ul>
</li>
<li><p><strong><code>x</code></strong>：</p>
<p>目录的x表示的是当前用户能否进入该目录成工作目录。就是说可以通过<strong><code>cd</code></strong>命令切换到改目录下。如果当前用户在某目录下不具有<strong>x</strong>的权限，那么就无法切换到改目录下，也就无法在改目录下进行任何操作，即使有该目录的<strong><code>r</code></strong>和<strong><code>w</code></strong>权限也不好使。</p>
</li>
</ul>
<p>注意：要开放目录给任何人浏览时，应该至少也要给予<strong><code>r</code></strong>及<strong><code>x</code></strong>权限</p>
</li>
</ul>
</li>
<li><h5 id="修改文件权限：chmod"><a href="#修改文件权限：chmod" class="headerlink" title="修改文件权限：chmod"></a>修改文件权限：<strong><code>chmod</code></strong></h5><p>命名格式语法：</p>
<figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line">chmod [-R] <span class="built_in">xyz</span> 文件或目录</span><br><span class="line">  <span class="built_in">xyz</span>：数字类型的权限属性,为rwx属性值相加的值</span><br><span class="line">  -R：进行递归</span><br></pre></td></tr></table></figure>

<p>文件权限修改有两种方式：使用数字或者符号来进行权限修改。</p>
<ul>
<li><p>数字类型修改文件权限</p>
<p>Linux文件的基本权限有九个，分别是拥有者(owner)，所属群组（group）、其他人（others）三种身份各有自己的读（r）、写（w）、执行（x）权限。</p>
<p>拿上面介绍的文件权限那样，文件权限字符为：【-<strong>rwx</strong> <strong>rwx</strong> <strong>rwx</strong>】九个权限三个一组。</p>
<p>可以使用数字来代表各个组的权限：</p>
<p><strong><code>r</code></strong>：4</p>
<p><strong><code>w</code></strong>：2</p>
<p><strong><code>x</code></strong>：1</p>
<p>三种身份（拥有者(owner)、所属群组(group)、其他人（others））各自的三个权限（r，w，x）数字是需要累加的。例如前面提到的<strong>test.txt</strong>文件如下：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">-rw-r--r--. <span class="number">1</span> root root <span class="number">29</span> Nov <span class="number">18</span> <span class="number">00</span>:<span class="number">00</span> test.txt</span><br></pre></td></tr></table></figure>

<p>权限为：【-rw-r–r–】的数字则是：<strong>644</strong></p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">owner = rw = 4+2 = 6</span><br><span class="line">group = r = 4</span><br><span class="line">others = r = 4</span><br></pre></td></tr></table></figure>

<p>接下来用<strong><code>chmod</code></strong>命令将该文件的是三种身份的权限数字设置为770<br><strong>owner = rwx = 4+2+1 = 7</strong><br><strong>group = rwx = 4+2+1 = 7;</strong><br><strong>others = - - - = 0</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ chmod <span class="number">770</span> test.txt</span><br><span class="line">$ ls -al test.txt</span><br><span class="line">-rwxrwx--- <span class="number">1</span> root root <span class="number">29</span> Nov <span class="number">18</span> <span class="number">00</span>:<span class="number">00</span> test.txt</span><br></pre></td></tr></table></figure>

<p>如果要将文件变成可执行的文件，并且不要让<strong>其他人</strong>修改文件的话，那就需要<strong><code>-rwxr-xr-x</code></strong>这样的权限，此时就要执行 <strong><code>chmod 755 fileName</code></strong>命令。</p>
</li>
<li><p>符号类型修改文件权限</p>
<p>符号类型修改文件权限可以借由(user)<strong><code>u</code></strong>，(group)<strong><code>g</code></strong>，(others)<strong><code>o</code></strong>,来代表三种身份的权限，此外<strong><code>a</code></strong>则代表<strong>all</strong>全部的身份，读写权限可以写成r、w、x</p>
<p><strong><code>chmod [u、g、o、a] [+（加入）、-（移除）、=（设置）] [r、w、x] 文件或目录</code></strong></p>
</li>
</ul>
</li>
</ul>
<p>  例如要把上面的<strong>test.txt</strong>设置成【-rwxr-xr-x】时：</p>
<pre><code><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ ls -al test.txt</span><br><span class="line">-rwxrwx--- <span class="number">1</span> root root <span class="number">0</span> Mar <span class="number">18</span> <span class="number">00</span>:<span class="number">00</span> test.txt</span><br><span class="line">$ chmod u=rwx,go=rx test.txt</span><br><span class="line">$ ls -al</span><br><span class="line">-rwxr-xr-x <span class="number">1</span> root root <span class="number">0</span> Mar <span class="number">18</span> <span class="number">00</span>:<span class="number">00</span> test.txt</span><br></pre></td></tr></table></figure></code></pre><p>  如果想为每身份加入w权限</p>
<pre><code><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ chmod a+w test.txt</span><br><span class="line">$ ls -al test.txt</span><br><span class="line">-rwxrwxrwx <span class="number">1</span> root root <span class="number">0</span> Mar <span class="number">18</span> <span class="number">00</span>:<span class="number">00</span> test.txt</span><br></pre></td></tr></table></figure></code></pre><p>  如果想为每身份移除x权限</p>
<pre><code><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ chmod a-x test.txt</span><br><span class="line">$ ls -al test.txt</span><br><span class="line">-rw-rw-rw- <span class="number">1</span> root root <span class="number">0</span> Mar <span class="number">18</span> <span class="number">01</span>:<span class="number">49</span> test.txt</span><br></pre></td></tr></table></figure></code></pre><h4 id="Linux目录树"><a href="#Linux目录树" class="headerlink" title="Linux目录树"></a>Linux目录树</h4><h5 id="执行文件路径的变量：-PATH"><a href="#执行文件路径的变量：-PATH" class="headerlink" title="执行文件路径的变量：$PATH"></a>执行文件路径的变量：$PATH</h5><p>PATH这个变量的内容是由一堆目录所组成，每个目录中间用冒号（:）来隔开，每个目录有顺序之分。就像下面的格式</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="regexp">/usr/</span>local<span class="regexp">/sbin:/</span>usr<span class="regexp">/local/</span><span class="string">bin:</span><span class="regexp">/usr/</span><span class="string">sbin:</span><span class="regexp">/usr/</span><span class="string">bin:</span><span class="regexp">/root/</span><span class="string">bin:</span><span class="regexp">/usr/</span>local<span class="regexp">/python37/</span>bin</span><br></pre></td></tr></table></figure>

<h5 id="目录树的主要特征："><a href="#目录树的主要特征：" class="headerlink" title="目录树的主要特征："></a>目录树的主要特征：</h5><ul>
<li>目录树的起始点为根目录（/，root）；</li>
<li>每个目录不止能使用本地区分的文件系统，也可以使用网络的文件系统；</li>
<li>用NetWork File System(NFS)服务器挂载某特点的目录</li>
<li>每个文件在此目录树中的文件都是独一无二的；</li>
</ul>
<p>下面是目录树构架示意图（关于目录树更详细的说明，参考《鸟哥的Linux私房菜—基础学习篇（第四版）》第五章5.3节的FHS标准说明）</p>
<p><img src="https://raw.githubusercontent.com/yangshenghua97/Image/master/dirtree.png" alt=""></p>
<h4 id="绝对路径与相对路径"><a href="#绝对路径与相对路径" class="headerlink" title="绝对路径与相对路径"></a>绝对路径与相对路径</h4><p>根据文件名写法的不同，也可将所谓定义为绝对路径与相对路径。这两种文件名路径写法依据如下：</p>
<ul>
<li>绝对路径：由根目录（/）开始写起的文件名或目录名称；</li>
<li>相对路径：相对于目前所处在的目录的文件名写法，例如：../dir1、../dir1/opt等<ul>
<li><strong><code>..</code></strong>代表上一层目录，也可以使用<strong><code>../</code></strong>来代表</li>
<li><strong><code>.</code></strong>代表当前目录，也可以使用<strong><code>./</code></strong>来代表</li>
</ul>
</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<p>《鸟哥的Linux私房菜—基础学习篇（第四版）》 鸟哥著 人民邮电出版社</p>
</blockquote>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>初识Linux</title>
    <url>/2019/03/15/Linux/Linux%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h3 id="什么是Linux"><a href="#什么是Linux" class="headerlink" title="什么是Linux?"></a>什么是Linux?</h3><p>Linux就是一个操作系统(手动狗头)</p>
<h3 id="Linux几个常用的命令"><a href="#Linux几个常用的命令" class="headerlink" title="Linux几个常用的命令"></a>Linux几个常用的命令</h3><ul>
<li><p><strong><code>cd dir</code></strong>：跳转到指定文件夹</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">跳转到root目录</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> ~</span></span><br><span class="line">跳转到之前目录</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> -</span></span><br><span class="line">跳转到上级目录</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> ..</span></span><br></pre></td></tr></table></figure>

<p>cd 后面还可以文件夹绝对路径或相对路径跳转到指定目录</p>
<p>例如跳转到 <strong>/</strong>下的<strong>tmp</strong>目录</p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">cd</span> <span class="string">/tmp</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>pwd</code></strong>：查看当前所处的路径，输入<strong><code>pwd</code></strong>系统会返回当前所处的目录的绝对路径</p>
</li>
<li><p><strong><code>ls -al</code></strong>：列出文件夹下的所有文件，包括隐藏文件</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">ls</span> -<span class="keyword">al</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="操作Linux系统几个重要的热键"><a href="#操作Linux系统几个重要的热键" class="headerlink" title="操作Linux系统几个重要的热键"></a>操作Linux系统几个重要的热键</h3><ul>
<li><h4 id="Tab-按键"><a href="#Tab-按键" class="headerlink" title="[Tab]按键"></a>[Tab]按键</h4><p><strong><code>[Tab]</code></strong>按键就是在切换大小写按键<strong><code>[Casp Lock]</code></strong>上面的那个按键，它具有命令补全与文件补齐的功能。关键是可以避免打错命令或文件名。</p>
<p>这里总结一下</p>
<p><strong>[Tab]接在一串命令的第一个字段后面，则为【命令补全】</strong></p>
<p><strong>[Tab]接在一串命令的第二个字段后面，则为【文件补全】</strong></p>
</li>
<li><h4 id="Ctrl-c-按键"><a href="#Ctrl-c-按键" class="headerlink" title="[Ctrl+c]按键"></a>[Ctrl+c]按键</h4><p>有时候某些命令或程序在系统上一直“跑个不停”，想让命令或程序“停掉”时，可以用这个按键。输入:<strong><code>[Ctrl+c]</code></strong>按键，可以中断目前程序或命令。</p>
</li>
<li><h4 id="Ctrl-d"><a href="#Ctrl-d" class="headerlink" title="[Ctrl+d]"></a>[Ctrl+d]</h4><p>如果想要直接离开命令行模式，可以直接按下<strong><code>[Ctrl+d]</code></strong>就能直接离开（相当于输入exit）</p>
</li>
<li><h4 id="Shift-Page-Up-、-Shift-Page-Down-按键"><a href="#Shift-Page-Up-、-Shift-Page-Down-按键" class="headerlink" title="[Shift]+{Page Up}、[Shift]+{Page Down}按键"></a>[Shift]+{Page Up}、[Shift]+{Page Down}按键</h4><p>使用<strong><code>[Shift]+{Page Up}</code></strong>向前翻页。使用<strong><code>[Shift]+{Page Down}</code></strong>先后翻页</p>
<h3 id="正确的关机方法"><a href="#正确的关机方法" class="headerlink" title="正确的关机方法"></a>正确的关机方法</h3></li>
<li><p>正确的关机命令使用</p>
<ul>
<li><p>几个与关机或重启相关命令</p>
<ul>
<li>将数据同步写入硬盘的命令：<strong><code>sync</code></strong></li>
<li>常用的关机命令：<strong><code>shutdown</code></strong></li>
<li>重启、关机：<strong><code>reboot</code></strong>、<strong><code>halt</code></strong>、<strong><code>poweroff</code></strong></li>
</ul>
</li>
<li><p>数据同步写入磁盘：<strong><code>sync</code></strong></p>
<p>使用<strong><code>sync</code></strong>命令进行数据的写入操作。在命令行下输入<strong>sync</strong>，那么在内存中尚未被更新的数据，就会被写入硬盘中。So 在关机或重启系统之前最好多执行几次</p>
</li>
<li><p>常用的关机命令：<strong><code>shutdown</code></strong></p>
<p>这个是关闭Linux的命令，如果是root管理员可以使用。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="built_in">shutdown</span>语法</span><br><span class="line"><span class="built_in">shutdown</span> -[krhc] [时间] [警告信息]</span><br><span class="line"> 选项与参数</span><br><span class="line">   -k：不是真的关机，只是发送警告信息出去。</span><br><span class="line">   -r：在将系统的服务停掉之后就重新启动（常用）</span><br><span class="line">   -h：将系统的服务停掉后，立即关机（常用）</span><br><span class="line">   -c：取消已经进行的<span class="built_in">shutdown</span>命令内容</span><br><span class="line">   时间：指定系统关机的时间，设置时间的样式如下：</span><br><span class="line"> 	<span class="built_in">shutdown</span> -h <span class="number">13</span>:<span class="number">00</span></span><br><span class="line">	系统将在今天的<span class="number">13</span>:<span class="number">00</span>分关机</span><br><span class="line">	<span class="built_in">shutdown</span> -h now</span><br><span class="line">	系统将立即关机</span><br><span class="line"> 	<span class="built_in">shutdown</span> -r now</span><br><span class="line">	系统会立即重启</span><br></pre></td></tr></table></figure>

<ul>
<li><p>shutdown可以完成如下的工作：</p>
<ul>
<li>可以自由选择关机模式：要是关机或重启均可；</li>
</ul>
</li>
<li><p>可以设置关机时间：可以设置成现在立即关机，也可以设置某一个特定的时间关机；</p>
<ul>
<li>可以自定义关机信息：在关机之前，可以将自己设置的信息发送给在线用户；</li>
</ul>
</li>
<li><p>可以仅发出警告信息：有时有可能要进行一些测试，而不想让其他的用户干扰，或是明白的告诉用户某段时间要注意一下。</p>
</li>
<li><p>重启，关机：<strong><code>reboot</code></strong>、<strong><code>halt</code></strong>，<strong><code>poweroff</code></strong></p>
<p>这三个命令可以进行重启与关机的操作。一般在关机或重启时，都会执行如下命令：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sync</span>;<span class="keyword">sync</span>;<span class="keyword">sync</span>;reboot</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用管理管理工具<strong><code>systemctl</code></strong>关机</p>
<p>在CentOS 7中可以使用<strong><code>systemctl</code></strong>来进行关机，实际上面介绍的关机与重启命令都是调用systemctl这个命令。</p>
<p>这个命令与关机的语法：</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">systemctl [命令]</span><br><span class="line">命令项目有：</span><br><span class="line">halt</span><br><span class="line">poweroff</span><br><span class="line">reboot</span><br><span class="line">suspend <span class="comment">//进入休眠模式</span></span><br><span class="line"># systemctl reboot   #系统重启</span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<p>《鸟哥的Linux私房菜—基础学习篇（第四版）》 鸟哥著 人民邮电出版社</p>
</blockquote>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发基础volatile关键字</title>
    <url>/2018/07/22/java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/volitile%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<h3 id="并发编程的三个重要特性"><a href="#并发编程的三个重要特性" class="headerlink" title="并发编程的三个重要特性"></a>并发编程的三个重要特性</h3><ol>
<li><p><strong>原子性</strong></p>
<p>原子性指在一次的操作或多次的操作中，要么所有操作全部执行且不会受到任何因素的干扰而中断，要么所有操作全部不执行</p>
</li>
<li><p><strong>可见性</strong></p>
<p>当一个线程对共享变量进行修改，另外的线程可以立刻看到修改后的新值。</p>
</li>
<li><p><strong>有序性</strong></p>
<p>有序性是指程序代码在被执行过程中的先后顺序。Java编译器以及运行期的优化，导致代码的执行顺序未必就是在编写代码时的顺序。</p>
</li>
</ol>
<p>关于volatile下面有必要说一下内存与CPU相关的知识</p>
<h3 id="CPU-Cache模型"><a href="#CPU-Cache模型" class="headerlink" title="CPU Cache模型"></a>CPU Cache模型</h3><p>CPU的处理速度和内存访问速度之间差距很大，通过直连内存的方式会导致CPU资源受到限制，为了降低CPU整体的吞吐量，可在CPU和内存之间增加缓存的设计，目前缓存的数量可增加到3级，最靠近CPU的缓存称为L1，依次是L2，L3和主内存。CPU缓存模型如下：</p>
<p><img src="https://raw.githubusercontent.com/yangshenghua97/Image/master/CPUCache.png" alt=""></p>
<p>Cache的出现为了解决CPU直接访问内存效率低下的问题，CPU将运算所需的数据从主内存复制一份到CPU Cache中，CPU在计算时就可以直接对CPU Cache中的数据进行读取和写入，运算结束后，再将CPU Cache中的最新数据刷新回主内存中。</p>
<p><img src="https://raw.githubusercontent.com/yangshenghua97/Image/master/CPUCacheandMemory.png" alt=""></p>
<h3 id="CPU缓存一致性问题"><a href="#CPU缓存一致性问题" class="headerlink" title="CPU缓存一致性问题"></a>CPU缓存一致性问题</h3><p>缓存的出现极大提高CPU的吞吐能力，但也引入了缓存不一致的问题，为了解决缓存不一致性的问题，通常主流的解决方法有两种：</p>
<ul>
<li><p>通过总线加锁的方式</p>
</li>
<li><p>通过缓存一致性协议</p>
<p>缓存一致性协议的大致思想：当CPU在操作Cache中的数据时，如果发现该变量是一个共享变量，在其他CPU Cache中存在一个副本，当进行如下操作时：</p>
<ul>
<li>读取操作：不做任何处理，只将Cache中的数据读取到寄存器中</li>
<li>写入操作：发出信号通知其他CPU将该变量的Cache line置为无效状态，其他CPU进行该变量读取时，必须在主存中再次获取。</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/yangshenghua97/Image/master/CPUCacheconsistency.png" alt=""></p>
<h3 id="关于volatile关键字"><a href="#关于volatile关键字" class="headerlink" title="关于volatile关键字"></a>关于volatile关键字</h3><p>为了确保共享变量能够准确和一致性的更新，线程应该确保通过排他锁单独获取这个变量。Java提供了volatile关键字，如果一个字段被声明为volatile，多线程内存模型确保所有线程看到这个变量的值是一致的。</p>
<h4 id="JMM内存模型"><a href="#JMM内存模型" class="headerlink" title="JMM内存模型"></a>JMM内存模型</h4><p>java内存模型决定了一个线程对共享变量的写入何时对其他线程可见，java内存模型定义了线程和内存之间的抽象关系</p>
<p><img src="https://raw.githubusercontent.com/yangshenghua97/Image/master/JMM.png" alt=""></p>
<ul>
<li>共享变量存储于主内存中，每个线程都可以访问。</li>
<li>每个线程都有私有的工作内存或称为本地内存。</li>
<li>工作内存只存储该线程对共享变量的副本</li>
<li>线程不能直接操作主内存，只有先操作工作内存后才能写入主内存。</li>
<li>工作内存和Java内存模型一样也是一个抽象的概念，其实并不存在，它涵盖了缓存、寄存器、编译器优化以及硬件等。</li>
</ul>
<p>在前面所说的并发编程的三大特性，JMM如何保证这三大特性</p>
<ol>
<li><p><strong>JMM与原子性</strong></p>
<p>先介绍几种简单的赋值操作</p>
<p>(1) x = 1</p>
<p>(2) y = x</p>
<p>(3) y++</p>
<p>(4) z = z+1</p>
<p>在上面的四类赋值操作中，只有第一种赋值操作具有原子性，其余均不具备原子性。可以得出以下结论</p>
<ul>
<li><p>多个原子性的操作在一起就不再是原子性操作</p>
</li>
<li><p>简单的读取与赋值是原子性，将一个变量赋值给另外一个变量的操作就不具备原子性</p>
</li>
<li><p>JMM只保证基本读取和赋值的原子性操作，其余的均不能保证，如果要使某些代码段具备原子性，需要使用关键字synchronized，或JUC中的lock。如果想要使得int等类型自增操作具备原子性封装类型<strong>atomic.*</strong></p>
<p><strong>最后volatile关键字不具备保证原子性的语义</strong></p>
</li>
</ul>
<p>在Java中可以通过锁和循环CAS的方式来实现原子操作</p>
<ul>
<li><p>使用循环<strong><code>CAS</code></strong>实现原子性操作</p>
<p>JVM中的CAS操作利用处理器提供的指令<strong><code>CMPCHG</code></strong>实现，自旋CAS实现的基本思路是循环进行CAS操作直到成功为止。</p>
</li>
<li><p>CAS实现原子类操作的三大问题</p>
<ul>
<li><p><strong>ABA问题</strong></p>
<p>因为CAS需要在操作值的时候，检查值有没有变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查的时候会发现它的值没有发生变化，但是实际发生了变化，ABA问题的解决思路就是使用版本号。在变量前面追加版本号，每次变量更新的时候把版本号加1，JDK中通过使用原子类<strong><code>AtomicStampedReference</code></strong>解决ABA问题</p>
</li>
<li><p><strong>循环时间长开销大</strong></p>
<p>自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。如果JVM能支持处理器提供的<strong><code>pause</code></strong>指令，那么效率在一定程度上提升</p>
</li>
<li><p><strong>只能保证一个共享变量的原子操作</strong></p>
<p>把多个共享变量合并成一个共享变量来操作。</p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line"><span class="attr">i</span> = <span class="number">2</span></span><br><span class="line"><span class="attr">j</span> = a</span><br><span class="line">合并 =&gt; <span class="attr">ij</span> = <span class="number">2</span>a</span><br></pre></td></tr></table></figure>

<p>然后CAS来操作ij，JDK提供了AtomicReference类来保证引用对象之间的原子性，就可以把多个变量放入一个对象里来进行CAS操作</p>
</li>
</ul>
<p><strong>使用锁机制实现原子性操作</strong></p>
<ul>
<li>锁机制保证了只有获得锁的线程才能够操作锁定内存的区域。JVM内部实现了很多锁机制，有偏向锁、轻量锁、互斥锁。JVM实现锁的方式都用了循环CAS，即当一个线程进入同步块的时候使用CAS的方式来获取锁，当它退出同步块的时候使用循环CAS释放锁。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>JMM与可见性</strong></p>
<p>Java通过三种方式来保证可见性</p>
<ul>
<li><p>使用关键字volatile，当一个变量被volatile关键字修饰时，对于共享资源的读操作会直接在主内存中进行（也可能会缓存到工作内存中，当其他线程对该共享资源进行修改，则会导致当前线程在工作内存中的共享资源失效，必须要在主内存中再次获取），对于共享资源的写操作当然是先要修改工作内存，但是修改结束后会立刻将其刷新进主内存中。</p>
</li>
<li><p>通过synchronized关键字能够保证可见性，synchronized关键字能够保证同一时刻只有一个线程获得锁，然后执行同步方法，并且还会确保在锁释放之前，会将对变量的修改刷新到主内存中。</p>
</li>
<li><p>通过JUC提供的显式锁Lock也能保证可见性，Lock的lock方法能够保证在同一时刻只有一个线程获得锁然后执行同步方法，并且会确保在锁释放（Lock的unlock方法）之前会将对变量的修改刷新到主内存中。</p>
<p><strong>volatile关键字具有保证可见性的语义</strong></p>
</li>
</ul>
</li>
<li><p><strong>JMM与有序性</strong></p>
<p>在JMM中允许编译器和处理器对指令进行重排序，在当线程下并不会引起什么问题。在多线程下，重排序会影响到程序的正确运行。</p>
<p>Java提供了三种保证有序性的方式</p>
<ul>
<li>使用volatile关键字来保证有序性。</li>
<li>使用synchronized关键字来保证有序性。</li>
<li>使用显式锁Lock来保证有序性</li>
</ul>
<p>在JMM中具备一些自带的有序性规则，不需要任何同步手段就能够保证有序性，这规则称之为Happens-before原则。</p>
</li>
</ol>
<h4 id="重排序是什么"><a href="#重排序是什么" class="headerlink" title="重排序是什么"></a>重排序是什么</h4><p>   重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段。</p>
<h4 id="三种类型的重排序"><a href="#三种类型的重排序" class="headerlink" title="三种类型的重排序"></a>三种类型的重排序</h4><ul>
<li><p>编译器优化重排序</p>
<p>编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序</p>
</li>
<li><p>指令级并行的重排序</p>
<p>现代处理器采用指令级并行技术来将多条指令重叠执行，如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</p>
</li>
<li><p>内存系统的重排序</p>
<p>由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作来起来可能是在乱序执行</p>
<h4 id="Happens-Before规则"><a href="#Happens-Before规则" class="headerlink" title="Happens-Before规则"></a>Happens-Before规则</h4></li>
<li><p><strong>程序次序规则</strong>：在一个线程内，代码按照编写时的次序执行，编写在后面的操作发生于编写在前面的操作之后。虚拟机还是可能会对程序代码的指令进行重排序，只要确保在一个线程内最终的结果和代码顺序执行的结果一致即可。</p>
</li>
<li><p><strong>锁定规则</strong>：一个unlock操作要先行发生于对同一个锁的lock操作</p>
</li>
<li><p><strong>volatile变量规则</strong>：对一个变量的写操作要早于对这个变量的读操</p>
</li>
<li><p><strong>传递规则</strong>：如果操作A先于操作B，B操作先于C操作，则A操作一定先于C操作，说明Happens-Before</p>
</li>
<li><p>线程启动规则：Thread对象的start()方法先行发生于线程的任何动作，只有start后的线程才能真正运行，否则Thread只是一个对象。</p>
</li>
<li><p>线程中断规则：对线程执行interrupt()方法，肯定要优先于捕获到中断信号。</p>
</li>
<li><p>线程的终结规则：线程中断所有的操作都要先行发生于线程的终止检测，线程的任务执行，逻辑单元执行肯定要发生于线程死亡之前。</p>
</li>
<li><p>对象的终结规则：一个对象初始化的完成先行发生于finalize()方法之前。</p>
</li>
</ul>
<p>   <strong>volatile关键字具有保证顺序性的语义</strong></p>
<h4 id="volatile写读的内存语义"><a href="#volatile写读的内存语义" class="headerlink" title="volatile写读的内存语义"></a>volatile写读的内存语义</h4><ul>
<li><p>volatile写的内存语义</p>
<p>当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存</p>
</li>
<li><p>volatile读的内存语义</p>
<p>当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量</p>
</li>
</ul>
<p>volatile写读的内存语义总结：</p>
<ul>
<li>线程A写一个volatile变量，实质上是线程A向接下来将要读这个volatile变量的某个线程发出消息</li>
<li>线程B读一个volatile变量，实质上是线程B接收了之前某个线程发出的（在写这个volatile变量之前对共享变量所做修改的）消息</li>
<li>线程A写一个volatile变量，随后线程B读这个volatile变量，过程实质上是线程A通过主内存向线程B发送消息</li>
</ul>
<h4 id="volatile关键字语义"><a href="#volatile关键字语义" class="headerlink" title="volatile关键字语义"></a>volatile关键字语义</h4><p>被volatile修饰的实例变量或类变量具备两层语义：</p>
<ol>
<li>保证不同线程之间对共享变量操作时的可见性，也就是说当一个线程修改<strong>volatile</strong>修饰变量，另外一个线程立即可看到新的值。</li>
<li>禁止对指令进行重排序操作。</li>
</ol>
<h4 id="volatile的原理和实现机制"><a href="#volatile的原理和实现机制" class="headerlink" title="volatile的原理和实现机制"></a>volatile的原理和实现机制</h4><p>volatile关键字可以保证可见性以及顺序性，是如何做到的？</p>
<p>观察OpenJDK源码就知道，被volatile修饰的变量存在于一个”lock;”前缀</p>
<p><strong>Lock前缀指令在多核处理器下会引发两件事</strong></p>
<ul>
<li>将当前处理器缓存行的数据写回到系统内存</li>
<li>写回内存操作会使在其他CPU里缓存了该内存地址的数据无效</li>
</ul>
<p>“lock;”前缀实际上相当于一个内存屏障，该屏障会为指令提供几个保障：</p>
<ul>
<li>确保指令重排序时不会将后面的代码排到内存屏障之前</li>
<li>确保指令重排序时不会将其前面的代码排到内存屏障之后</li>
<li>确保在执行到内存屏障修饰的指令时前面的代码全部执行完成</li>
<li>强制在线程工作内存中值的修改刷新至主内存中</li>
<li>如果是写操作，则会导致其他线程工作内存中的缓存数据失效</li>
</ul>
<h4 id="volatile和synchronized的区别"><a href="#volatile和synchronized的区别" class="headerlink" title="volatile和synchronized的区别"></a>volatile和synchronized的区别</h4><ul>
<li><p><strong>使用上的区别</strong></p>
<ul>
<li>volatile关键字只能用于修饰实例变量和类变量，不能用于修饰方法以及方法参数和局部变量，常量等</li>
<li>synchronized关键字不能用于对变量的修饰，只能用于修饰方法或语句块</li>
<li>volatile修饰的变量可以为null，synchronized关键字同步语句块的monitor对象不能为null</li>
</ul>
</li>
<li><p><strong>对原子的保证</strong></p>
<ul>
<li><p>volatile无法保证原子性</p>
</li>
<li><p>由于synchronized是一种排他机制，因此被synchronized关键字修饰的同步代码块是无法被中途打断，因此其能够保证代码的原子性</p>
</li>
</ul>
</li>
<li><p><strong>对可见性的保证</strong></p>
<ul>
<li>俩者均可以保证共享资源在多线程间的可见性，但是实现机制完全不同</li>
<li>synchronized借助JVM指令monitorentry和monitorexit对通过排他的方式使得同步代码块串行化，在monitorexit时所有共享资源都将会被刷新到主内存中。</li>
<li>volatile使用机器指令“lock;”的方式迫使其他线程工作内存中的数据失效，必须到主内存中进行再次加载。</li>
</ul>
</li>
<li><p><strong>对有序性的保证</strong></p>
<ul>
<li>volatile关键字禁止JVM编译器以及处理器对其进行重排序，所以它能够保证有序性</li>
<li>虽然synchronized关键字所修改的同步方法也可以保证顺序性，但是这种顺序性是以程序的串行化执行换来的，在synchronized关键字所修改的代码块中代码指令也会发生指令重排序的情况</li>
</ul>
</li>
<li><p><strong>其他</strong></p>
<ul>
<li>volatile不会使线程陷入阻塞</li>
<li>synchronized关键字会使线程进入阻塞状态</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发编程</title>
    <url>/2018/04/06/java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%801/</url>
    <content><![CDATA[<h4 id="线程生命周期"><a href="#线程生命周期" class="headerlink" title="线程生命周期"></a>线程生命周期</h4><p><img src="https://raw.githubusercontent.com/yangshenghua97/Image/master/Threadlife.png" alt=""></p>
<ul>
<li>NEW – 新建</li>
<li>RUNABLE – 可运行</li>
<li>RUNING – 运行</li>
<li>BLOCKED – 阻塞</li>
<li>TERMINATED – 死亡</li>
</ul>
<p>上面所列的是线程的生命周期</p>
<h4 id="何为上下文切换"><a href="#何为上下文切换" class="headerlink" title="何为上下文切换"></a>何为上下文切换</h4><ul>
<li>CPU通过时间片分配算法来循环执行任务，当前任务执行一个任务时间片后会切换到下一个任务，但是在切换之前将保存上一个任务的状态，以便下次切换回这个任务时，可以在再加载这个任务的状态，所以任务从保存再到加载的过程就是一次上下文切换。上下文切换也会影响多线程的执行速度</li>
</ul>
<p>下面看一段代码：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> ConcurrencyTest &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span>  <span class="keyword">long</span> <span class="keyword">count</span> = <span class="number">10000000000</span>L;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        concurrency();</span><br><span class="line">        serial();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> concurrency() <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> run() &#123;</span><br><span class="line">                <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>;i&lt;<span class="keyword">count</span>;i++)&#123;</span><br><span class="line">                    a +=<span class="number">5</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">int</span> b= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">long</span> i = <span class="number">0</span>;i&lt;<span class="keyword">count</span>;i++)&#123;</span><br><span class="line">            b--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> time = System.currentTimeMillis()-start;</span><br><span class="line">        thread.<span class="keyword">join</span>();</span><br><span class="line">        System.out.<span class="keyword">println</span>(<span class="string">"concurrency:"</span>+time+<span class="string">"ms,b = "</span>+b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> serial()&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>;i&lt;<span class="keyword">count</span>;i++)&#123;</span><br><span class="line">            a+=<span class="number">5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">long</span> i = <span class="number">0</span>;i&lt;<span class="keyword">count</span>;i++)&#123;</span><br><span class="line">            b--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> time = System.currentTimeMillis()-start;</span><br><span class="line">        System.out.<span class="keyword">println</span>(<span class="string">"serial:"</span>+time+<span class="string">"ms,b= "</span>+b+<span class="string">" a= "</span>+a);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码是比较串行与并发时的执行效果；</p>
<p>在测试中可以看到数据量在10万以下，并发的执行速度比串行的执行速度慢；在测试中可以看到数据量在100万以上时，并发的执行速度比串行的执行速度快约2倍。上面的结果是因为线程有创建和上下文切换的开销。</p>
<h4 id="如何减少上下文切换"><a href="#如何减少上下文切换" class="headerlink" title="如何减少上下文切换"></a>如何减少上下文切换</h4><p>减少上下文切换的方法有四种：</p>
<ul>
<li>无锁并发编程：多线程竞争锁时，会引发上下文切换，所以多线程处理数据时，可以使用例如将数据ID按照Hash算法取模分段，不同的线程处理不同段的数据</li>
<li>CAS算法：Java的Atomic包使用CAS算法来更新数据，而不需加锁</li>
<li>使用最少线程：避免创建不需要的线程</li>
<li>协程：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>小杨的简介</title>
    <url>/about/index.html</url>
    <content><![CDATA[<h1 id="个人信息"><a href="#个人信息" class="headerlink" title="个人信息"></a><strong>个人信息</strong></h1><ul>
<li><p><strong>杨生华/男/1997</strong></p>
</li>
<li><p><strong>本科/吉林化⼯学院/外国语学院/⽇语系/</strong></p>
</li>
<li><p><strong>年级：2020年毕业</strong></p>
</li>
<li><p><strong>联系方式：13944680832</strong></p>
</li>
<li><p><strong>微信：</strong></p>
<img src="https://raw.githubusercontent.com/yangshenghua97/Image/master/%E5%BE%AE%E4%BF%A1%E4%BA%8C%E7%BB%B4%E7%A0%81.jpg" style="zoom: 25%;" />
</li>
<li><p><strong>技术博客：<a href="https://yangshenghua97.github.io/" target="_blank" rel="noopener">楊さんノート</a></strong></p>
</li>
<li><p><strong>Github：<a href="https://github.com/yangshenghua97/" target="_blank" rel="noopener">yangshenghua97</a></strong></p>
</li>
<li><p><strong>期望职位：/实习/Java后端开发</strong></p>
</li>
<li><p><strong>期望薪资：税前⽉薪3k-4k</strong></p>
</li>
</ul>
<h1 id="项目和作品"><a href="#项目和作品" class="headerlink" title="项目和作品"></a><strong>项目和作品</strong></h1><h2 id="个人博客后台管理系统"><a href="#个人博客后台管理系统" class="headerlink" title="个人博客后台管理系统"></a><strong>个人博客后台管理系统</strong></h2><h4 id="2019-01-2019-02"><a href="#2019-01-2019-02" class="headerlink" title="2019.01-2019.02"></a><strong>2019.01-2019.02</strong></h4><h3 id="技术运用："><a href="#技术运用：" class="headerlink" title="技术运用："></a>技术运用：</h3><ul>
<li>开发环境：Windows/Linux、IntelliJ IDEA、JDK 1.8、MySQL 5.7、Redis、Tomcat 5. x、Git、Maven;</li>
<li>后端框架：Spring、Spring MVC、Myatis;</li>
<li>前端框架：AdminLTE3,JQuery等前端框架；</li>
</ul>
<h3 id="项目介绍："><a href="#项目介绍：" class="headerlink" title="项目介绍："></a>项目介绍：</h3><ul>
<li>基于Spring+Spring MVC + MyBatis框架的整合运用；</li>
<li>利用 Spring AOP对用户登录进行Token身份验证、Spring 事务隔离对SQL进行验证</li>
<li>MySQL 5.7 数据的基本使用、使用Druid数据库连接池对项目执行的SQL进行监控与优化；</li>
<li>单图/多图上传技术；</li>
<li>文件导入导出功能；</li>
<li>利用Redis缓存数据库对用户Token进行缓存</li>
<li>基于阿里云Linux系统进行部署与发布；</li>
<li>Nginx + Tomcat的集群搭建；</li>
</ul>
<h2 id="微人事人力资源管理系统"><a href="#微人事人力资源管理系统" class="headerlink" title="微人事人力资源管理系统"></a><strong>微人事人力资源管理系统</strong></h2><h3 id="技术运用：-1"><a href="#技术运用：-1" class="headerlink" title="技术运用："></a>技术运用：</h3><ul>
<li>开发环境：Windows/Linux、IntelliJ IDEA、JDK 1.8、MySQL 5.7、Redis、Tomcat 5. x、Git、Maven;</li>
<li>后端框架：Spring Boot、MyBatis；</li>
<li>前端框架：Vue.js+Axios；</li>
</ul>
<h3 id="项目介绍：-1"><a href="#项目介绍：-1" class="headerlink" title="项目介绍："></a>项目介绍：</h3><ul>
<li><p>基于Spring Boot、MyBatis、Spring Security的运用；</p>
</li>
<li><p>项目利用Maven对多模块进行整合，后端权限认证采用Spring Security实现；</p>
</li>
<li><p>数据库访问使用MyBatis，同时使用Redis实现认证信息缓存；</p>
</li>
<li><p>项目实现了邮件发送功能，采用Spring-Boot-Email+Spring Thymeleaf配合Java 多线程来对邮件进行发送；</p>
</li>
</ul>
<h1 id="技能清单"><a href="#技能清单" class="headerlink" title="技能清单"></a><strong>技能清单</strong></h1><ul>
<li><p><strong>Java开发</strong>：熟悉Java开发、 对于Java多线程、I/O操作、反射、Java网络编程等都能其进行简单的应用。<br>熟练使用Java集合，并且简单阅读多ArrayList、LinkedList、HashMap的源码。<br> 了解ConcurrentHashMap的使用场景；</p>
</li>
<li><p>熟练操作<strong>Linux</strong>，掌握Linux常用命令，能够独立编写<strong>Linux Shell</strong>脚本代码，曾在阿里云服务器上发布过个人博客，熟悉Linux系统管理等；</p>
</li>
<li><p>熟练SQL语句编写、使用虚拟机搭建<strong>MySQL</strong>集群进行主从复制，事务隔离，索引优化等</p>
</li>
<li><p>了解<strong>Redis</strong>命令简单使用，使用虚拟机搭建Redis集群进行主从复制</p>
</li>
<li><p>前端框架：了解Vue.js、Node.js构建前端应用框架</p>
</li>
<li><p>版本管理、文档和自动化部署工具：了解<strong>Git</strong>版本控制系统常用命令的使用</p>
</li>
<li><p>开发框架及单元测试：JUnit对项目的各个模块进行单元测试、Spring、<strong>Spring Boot</strong>、Spring MVC、<strong>MyBatis</strong>的简单使用</p>
</li>
</ul>
<h1 id="学校经历"><a href="#学校经历" class="headerlink" title="学校经历"></a><strong>学校经历</strong></h1><p>2018.04-2018.09<br><strong>担任学生会网络部，主要工作是运营学院微信公众号以及组织学院活动；</strong></p>
<p>2018.06-2018.07<br><strong>参加学校互联网+创新创业大赛获得校级团队二等奖；</strong></p>
<h1 id="工作经历"><a href="#工作经历" class="headerlink" title="工作经历"></a>工作经历</h1><h2 id="目前处于待就业实习阶段。2019年8月在吉林市创慧科技有限公司做图片处理工作"><a href="#目前处于待就业实习阶段。2019年8月在吉林市创慧科技有限公司做图片处理工作" class="headerlink" title="  目前处于待就业实习阶段。2019年8月在吉林市创慧科技有限公司做图片处理工作"></a>  <strong>目前处于待就业实习阶段。2019年8月在吉林市创慧科技有限公司做图片处理工作</strong></h2>]]></content>
  </entry>
  <entry>
    <title>Categories</title>
    <url>/categories/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>guestbook</title>
    <url>/guestbook/index.html</url>
    <content><![CDATA[<div class="ds-recent-visitors" data-num-items="28" data-avatar-size="42" id="ds-recent-visitors"></div>]]></content>
  </entry>
  <entry>
    <title>Tags</title>
    <url>/tags/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
</search>
