<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>楊さんノート</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-04-30T11:05:54.716Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>杨生华</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>大数据各组件安装</title>
    <link href="http://yoursite.com/2020/04/30/bigdata/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%90%84%E7%BB%84%E4%BB%B6%E5%AE%89%E8%A3%85/"/>
    <id>http://yoursite.com/2020/04/30/bigdata/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%90%84%E7%BB%84%E4%BB%B6%E5%AE%89%E8%A3%85/</id>
    <published>2020-04-30T10:44:31.000Z</published>
    <updated>2020-04-30T11:05:54.716Z</updated>
    
    <content type="html"><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h2&gt;&lt;blockquote&gt;
&lt;/blockquote&gt;

      
    
    </summary>
    
    
      <category term="大数据" scheme="http://yoursite.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="大数据" scheme="http://yoursite.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="hadoop" scheme="http://yoursite.com/tags/hadoop/"/>
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
      <category term="hive" scheme="http://yoursite.com/tags/hive/"/>
    
      <category term="spark" scheme="http://yoursite.com/tags/spark/"/>
    
      <category term="zookeeper" scheme="http://yoursite.com/tags/zookeeper/"/>
    
      <category term="hbase" scheme="http://yoursite.com/tags/hbase/"/>
    
      <category term="flink" scheme="http://yoursite.com/tags/flink/"/>
    
      <category term="kafka" scheme="http://yoursite.com/tags/kafka/"/>
    
      <category term="flume" scheme="http://yoursite.com/tags/flume/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程之Synchronized</title>
    <link href="http://yoursite.com/2020/04/25/java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BSynchronized/"/>
    <id>http://yoursite.com/2020/04/25/java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BSynchronized/</id>
    <published>2020-04-25T08:07:02.000Z</published>
    <updated>2020-05-06T01:56:55.758Z</updated>
    
    <content type="html"><![CDATA[<h2 id="synchronized的实现原理"><a href="#synchronized的实现原理" class="headerlink" title="synchronized的实现原理"></a>synchronized的实现原理</h2><h3 id="利用synchronized实现同步的基础："><a href="#利用synchronized实现同步的基础：" class="headerlink" title="利用synchronized实现同步的基础："></a>利用synchronized实现同步的基础：</h3><ul><li>对于普通同步方法，锁是当前的实例对象</li><li>对于静态同步方法，锁是当前类的Class对象</li><li>对于同步方法块，锁是Synchronized括号里的配置对象</li></ul><h3 id="Synchronized实现原理："><a href="#Synchronized实现原理：" class="headerlink" title="Synchronized实现原理："></a>Synchronized实现原理：</h3><p>JVM基于进入和退出<strong><code>Monitor</code></strong>对象来实现方法同步和代码块同步，代码块同步使用<strong><code>monitorenter</code></strong>和<strong><code>monitorexit</code></strong>指令实现，monitorenter指令是在编译后插入到同步代码块开始位置，而monitorexit是插入到方法结束和异常处，<strong><code>JVM</code></strong>要保证每个monitorenter必须有对应的monitorexit与之匹配。</p><p>关键字synchronized可以修饰方法或者以同步块的形式来进行使用，它主要确保多个线程在同一时刻，只能有一个线程处于方法或同步块中，他保证了线程对变量访问的可见性和排他性。对于同步块的实现使用monitorenter和monitorexit指令，而同步方法则是依靠方法修饰符上的<strong><code>ACC_SYNCHRONIZED</code></strong>来完成。其本质上是对一个对象的监视器(monitor)进行获取，而这个过程是排他的，也就是在同一时刻只能有一个线程获得synchronized所保护对象的监视器。任意一个对象都拥有自己的监视器，当这个对象有同步块或者这个对象的同步方法调用时，执行方法的线程必须先获取到该对象的监视器才能进入同步块或者同步方法，而没有获取到监视器的线程将会被阻塞在同步块和同步方法的入口处，进入<strong><code>BLOCKED</code></strong>状态。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;synchronized的实现原理&quot;&gt;&lt;a href=&quot;#synchronized的实现原理&quot; class=&quot;headerlink&quot; title=&quot;synchronized的实现原理&quot;&gt;&lt;/a&gt;synchronized的实现原理&lt;/h2&gt;&lt;h3 id=&quot;利用syn
      
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="java并发编程" scheme="http://yoursite.com/tags/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Hadoop基础知识</title>
    <link href="http://yoursite.com/2020/04/01/bigdata/BigData/"/>
    <id>http://yoursite.com/2020/04/01/bigdata/BigData/</id>
    <published>2020-04-01T15:46:11.000Z</published>
    <updated>2020-04-23T05:12:10.698Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h2><ul><li>MapReduce是海量数据的分布式计算框架，这一框架解决了：数据分布式存储，作业调度，容错，机器间通信等复杂问题</li></ul><h3 id="关于MapReduce的两个重要进程"><a href="#关于MapReduce的两个重要进程" class="headerlink" title="关于MapReduce的两个重要进程"></a>关于MapReduce的两个重要进程</h3><ul><li>JobTracker：主进程，负责接收客户作业提交</li><li>TaskTracker：由JobTracker指派任务</li></ul><h3 id="MapReduce执行流程"><a href="#MapReduce执行流程" class="headerlink" title="MapReduce执行流程"></a>MapReduce执行流程</h3><p>文件要存储在HDFS上，每个文件切换成多个一定大小的文件块，存储在多个节点上</p><h3 id="MapReduce的核心思想：分而治之"><a href="#MapReduce的核心思想：分而治之" class="headerlink" title="MapReduce的核心思想：分而治之"></a>MapReduce的核心思想：分而治之</h3><ul><li>分解</li><li>求解</li><li>合并</li></ul><h2 id="Hadoop-2-0"><a href="#Hadoop-2-0" class="headerlink" title="Hadoop 2.0"></a>Hadoop 2.0</h2><p><img src="https://raw.githubusercontent.com/yangshenghua97/Image/master/HDFS2.0.png" alt=""></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;MapReduce&quot;&gt;&lt;a href=&quot;#MapReduce&quot; class=&quot;headerlink&quot; title=&quot;MapReduce&quot;&gt;&lt;/a&gt;MapReduce&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;MapReduce是海量数据的分布式计算框架，这一框架解决了：数据分布式
      
    
    </summary>
    
    
      <category term="大数据" scheme="http://yoursite.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="大数据" scheme="http://yoursite.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="hadoop" scheme="http://yoursite.com/tags/hadoop/"/>
    
  </entry>
  
  <entry>
    <title>TCP/IP协议</title>
    <link href="http://yoursite.com/2020/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TTCP-IP%E5%8D%8F%E8%AE%AE/"/>
    <id>http://yoursite.com/2020/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TTCP-IP%E5%8D%8F%E8%AE%AE/</id>
    <published>2020-03-12T18:19:13.000Z</published>
    <updated>2020-03-15T14:02:04.814Z</updated>
    
    <content type="html"><![CDATA[<h3 id="TCP-IP的标准制定"><a href="#TCP-IP的标准制定" class="headerlink" title="TCP/IP的标准制定"></a>TCP/IP的标准制定</h3><p>由于TCP/IP技术的公开性，他不属于任何一个厂商或者是专业协会所有。TCP/IP的标准大部分都由<strong>RFC</strong>技术报告的形式公开。RCF文件包含了所有TCP/IP的协定标准，以及其最新版本。RFC所涵盖的内容和细节非常广，也可以为新协定的标准和计划，但不能以学术研究论文的方式来编辑。</p><h3 id="TCP-IP的特性"><a href="#TCP-IP的特性" class="headerlink" title="TCP/IP的特性"></a>TCP/IP的特性</h3><ul><li>它是其它网络服务的基础，几乎所有数据包交换网络都提供了这种服务。TCP/IP是根据信息中所含的地址资料来进行资料的传送，他不能确保每个独立路由的数据包是可靠和依序的送达目的地。在每个连线过程中，线路都不是被”独占”的，而是直接映射到硬件地址上，因此特别有效。</li><li>因为数据包交换并不能确保每一个数据包的可靠性，因此我们就需要通讯软件来自动检测和修护传送过程中出现的错误和处理损坏数据包。这种服务就是用来确保电脑程序之间能够连接和传送大量的数据。关键的技术就是数据流进行分割，然后编号传送，然后通过接受的确认来确数据的完整性</li><li>在数据包交换技术中，TCP/IP是独立于硬件之上的。TCP/IP有自己的一套数据包规定和定义,能应用在不同的网络之上</li><li>只要用TCP/IP连接网络，就会获得一个独一无二的识别位址。数据包在交换过程中，是以位址数据为依据，不管数据包所经历的路由如何，数据都会被送到指定的地址。</li><li>TCP/IP 的确认模式是以“端到端”进行的。這样就无需理会数据包交换过程中所参与的其他设备。</li></ul><h3 id="TCP-IP协议分层框架"><a href="#TCP-IP协议分层框架" class="headerlink" title="TCP/IP协议分层框架"></a>TCP/IP协议分层框架</h3><ul><li><p>链路程：链路层以字节位单位0和1分别进行分组，定义数据帧，写入源和目标机器的物理地址，数据，校验位来传输数据。</p><p><img src="https://raw.githubusercontent.com/yangshenghua97/Image/master/linkway.png" alt=""></p><p>链路层报文结构</p></li><li><p>网络层：根据IP定义网络地址，区分网段。子网内根据地址解析协议(ARP)进行MAC寻址，子网外进行路由转发数据包，这个数据包即为IP数据包。</p></li><li><p>传输层：数据包通过网络层发送到目标计算机后，应用程序在传输层定义逻辑端口，确认身份后，将数据包交给应用程序，实现端口到端口间通讯。</p></li><li><p>应用层：传输层的数据到达应用程序时，以某种统一规定的协议格式解读数据。</p></li></ul><p><img src="https://raw.githubusercontent.com/yangshenghua97/Image/master/PTCIP.png" alt=""></p><h3 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h3><p>IP是面向无连接、无状态的，没有额外的机制保证发送的包是否有序到达。IP首先规定出IP地址格式，该地址相当于在逻辑意义上进行了网段的划分，给没台机器额外设置了一个唯一的详细地址。IP地址属于网络层，主要的功能字啊WLAN内进行路由寻址，选择最佳路由。</p><p><img src="https://raw.githubusercontent.com/yangshenghua97/Image/master/IP.png" alt=""></p><h3 id="TCP建立连接"><a href="#TCP建立连接" class="headerlink" title="TCP建立连接"></a>TCP建立连接</h3><p>传输控制协议(TCP)，是一种面向连接、确保数据在端到端间的可靠传输的协议。面向连接是指在发送数据前，需要先建立一条虚拟的链路，然后让数据在这条链路上“流动”传输。每个TCP数据包是封装在IP包中的，每一个IP头的后面紧接的是TCP头。</p><p><img src="https://raw.githubusercontent.com/yangshenghua97/Image/master/TCP.png" alt=""></p><p>协议第一行的两个端口号各个占据两个字节，分别代表源机器与目标机器的端口号。这两个端口号与IP报头格式中的源IP地址和目标IP地址所组成的四元组可唯一标识一条TCP连接。由于TCP是面向连接的，所以有服务器和客户端之分。需要服务端先在相应的端口上进行监听，准备好接收客户端发起的连接请求。在类UNIX系统系统上通过netstat命令列出机器上已建立的连接信息，其中包含唯一标识一条连接的四元组，以及各连接的状态等内容。</p><p>TCP的FLAG位有6个bit组成，分别代表SYN、ACK、FIN、URG、PSH、RST，需要重点关注的是SYN、ACK、FIN。SYN(Synchronize Sequence Numbers)用作建立连接时的同步信号；ACK(Acknowledgement)用于对收到的数据进行确认，所确认的数据由确认序列号表示；FIN(Finish)表示后面没有数据需要发送，通常意味着所建立的连接需要关闭。</p><h4 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h4><p>TCP三次握手是指在建立连接的三个步骤：</p><ul><li><p>A机器发出一个数据包并将SYN置1，表示希望建立连接。这个包中的序列号假设是x。</p></li><li><p>B机器收到A机器发过来的数据包后，通过SYN得知这是一个建立连接的请求，于是发送一个响应包并将SYN和ACK标记都置为1。假设这个包中的序列号是y，而确认序列号的必须是x+1，表示收到了A发过来的SYN。在TCP中，SYN被当作数据中的一个字节。</p></li><li><p>A接收到B的响应后需进行确认，确认包中将ACK置1，并将确认序列号设置为y+1，表示收到了来自B的SYN。</p><p><img src="https://raw.githubusercontent.com/yangshenghua97/Image/master/SANCIWUOSHOU.png" alt=""></p><p>双方只有确认4类信息，才能建立连接。在第二次握手后，从B机器视角看还有连个NO信息无法确认。在第三次握手后，B机器才能确认自己的发报能力是否正常的。</p><p><img src="https://raw.githubusercontent.com/yangshenghua97/Image/master/TCP3.png" alt=""></p></li></ul><p>连接三次握手也是防止出现请求超时导致脏连接。TTL网络报文的生存时间往往都会超过TCP请求时间，如果两次握手就可以创建连接的话，传输数据并释放连接后，第一个超时的连接请求才到达B机器的话，B机器会认为是A创建的连接的请求，然后确认同意创建连接。因为A机器的状态不是SYN_SENT,所以直接丢弃了B的确认数据，以致最后只是B机器单方面创建连接完毕。</p><p><img src="https://raw.githubusercontent.com/yangshenghua97/Image/master/%E8%84%8F%E8%BF%9E%E6%8E%A5.png" alt=""></p><h3 id="TCP断开连接"><a href="#TCP断开连接" class="headerlink" title="TCP断开连接"></a>TCP断开连接</h3><p>TCP是全双工通信，双方都能作为数据的发送方和接收方，但TCP连接也会有断开的时候。A、B机器连接只要三次握手，而断开则需要四次挥手，例如下图：</p><p>A机器想要断开连接，则待本方数据发送完毕后，传递FIN信号给B机器。B机器应答ACK，告诉A机器可以断开，但是需要等B机器处理完成数据，再主动给A机器发送FIN信号。这时A机器处于半关闭状态(FIN-WAIT-2)，无法再发送新的数据。B机器做好连接关闭前的准备工作后，发送FIN给A机器，此时B机器也进入半关闭状态(CLOSE_WAIT)。A机器发送针对B机器FIN的ACK后，进入TIME_WAIT状态，经过2MSL后，没有收到B机器传过来的报文，则确定B机器已经收到A机器最后发送的ACK指令，此时TCP连接正式释放。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;TCP-IP的标准制定&quot;&gt;&lt;a href=&quot;#TCP-IP的标准制定&quot; class=&quot;headerlink&quot; title=&quot;TCP/IP的标准制定&quot;&gt;&lt;/a&gt;TCP/IP的标准制定&lt;/h3&gt;&lt;p&gt;由于TCP/IP技术的公开性，他不属于任何一个厂商或者是专业协会所有
      
    
    </summary>
    
    
      <category term="计算机基础" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>CPU与内存</title>
    <link href="http://yoursite.com/2020/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%9E%84%E6%88%90/CPU%E4%B8%8E%E5%86%85%E5%AD%98/"/>
    <id>http://yoursite.com/2020/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%9E%84%E6%88%90/CPU%E4%B8%8E%E5%86%85%E5%AD%98/</id>
    <published>2020-03-11T14:15:02.000Z</published>
    <updated>2020-03-12T19:34:04.876Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/yangshenghua97/Image/master/CPU.png" alt=""></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yangshenghua97/Image/master/CPU.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerl
      
    
    </summary>
    
    
      <category term="计算机基础" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="计算机基础" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>计算机的0与1</title>
    <link href="http://yoursite.com/2020/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%9E%84%E6%88%90/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%840%E4%B8%8E1/"/>
    <id>http://yoursite.com/2020/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%9E%84%E6%88%90/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%840%E4%B8%8E1/</id>
    <published>2020-03-11T12:53:21.000Z</published>
    <updated>2020-03-11T14:14:08.175Z</updated>
    
    <content type="html"><![CDATA[<p>在计算机中无论是什么设备，归根结底都是0和1的信号处理，设定基数为2，进位的规则是“逢二进一”，称之为二进制，设想有8条电路，每条电路有高电平和低电平两种状态。根据组合排列，有2^8 即256个种不同的信号。这8条电路，最左侧的一条表示正负，0表示正数，1表示负数，不参与数值表示。</p><h3 id="基本编码"><a href="#基本编码" class="headerlink" title="基本编码"></a>基本编码</h3><p>表示数的基本编码方式有原码、反码、补码；</p><p><strong>原码：符号为和数字实际值得结合，正数就是数值本身，符号为0；负数是数值本身，符号位为1，8位的二进制的表示范围是[-127,127]</strong></p><p><strong>反码：正数是本身，符号位为0；负数的数值部分是正数表示的基础上对各个位取反，符号位为1。8位二进制数的表示范围是[-127,127]</strong></p><p><strong>补码：正数是数组的本身，符号位为0，负数的数值部分是在正数表示基础上对各个位取反加1，符号位为1。8位二进制数的表示范围是[-127,127]</strong></p><table><thead><tr><th>正数/负数</th><th>原码</th><th>反码</th><th>补码</th></tr></thead><tbody><tr><td>1</td><td>0000 0001</td><td>0000 0001</td><td>0000 0001</td></tr><tr><td>-1</td><td>1000 0001</td><td>1111 1110</td><td>1111 1111</td></tr><tr><td>2</td><td>0000 0010</td><td>0000 0010</td><td>0000 0010</td></tr><tr><td>-2</td><td>1000 0010</td><td>1111 1101</td><td>1111 1110</td></tr></tbody></table><p>为了加速计算机对加减乘除运算速度，所有产生了反码和补码。例如在进行减法计算时，1-2=-1在计算机运算中可以这样运算：1+（-2）=-1。如果使用原码计算则结果为：1+（-2）= [0000 0001]<del>原</del>+[1000 0010]<del>原</del> = [10000011]<del>原</del> = -3结果是错误的。为了解决这一问题，于是出现了反码，使用反码计算，结果为1-2 = 1+(-2) = [00000001]<del>反</del>+[1111 1101]<del>反</del>=[1111 1110]<del>反</del> = -1。</p><h3 id="计算机存储计量单位"><a href="#计算机存储计量单位" class="headerlink" title="计算机存储计量单位"></a>计算机存储计量单位</h3><p>在上述的一条线路在计算机中表示1位，<strong>即1个bit，8个bit组成一个单位，称为一个字节，即1个Byte，1024个Byte简写为KB，1024个KB简写为MB，1024个MB简写为GB</strong>。</p><h3 id="位移运算"><a href="#位移运算" class="headerlink" title="位移运算"></a>位移运算</h3><p>向右移动一位近似表示除以2，十进制转化为二进制数后，向右移时，最右边的1位将被直接抹去。在左移<strong><code>&lt;&lt;</code></strong>和右移<strong><code>&gt;&gt;</code></strong>这两种运算中符号位均参与移动，除了负数右移时高位补1外，其他情况均在空位处补0</p><p>左移运算由于符号位参与向左移动，在移动后的结果，最左位可能是1或是0，即正数向左移的结果可能负数也可能是正数，负数向左移的结果也是如此。</p><p>对于 <strong><code>&gt;&gt;&gt;</code></strong> 无符号向右移动(不存在&lt;&lt;&lt;位移运算)，当向右移动时，正负数高位均补0，正数不断向右移动的最小值是0，而负数不断向右移动的最小值为1，无需考虑符号位，高位直接补0</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><p>《码出高效 Java开发手册》</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在计算机中无论是什么设备，归根结底都是0和1的信号处理，设定基数为2，进位的规则是“逢二进一”，称之为二进制，设想有8条电路，每条电路有高电平和低电平两种状态。根据组合排列，有2^8 即256个种不同的信号。这8条电路，最左侧的一条表示正负，0表示正数，1表示负数，不参与数
      
    
    </summary>
    
    
      <category term="计算机基础" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="计算机基础" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法概述</title>
    <link href="http://yoursite.com/2020/02/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%A6%82%E8%BF%B0/"/>
    <id>http://yoursite.com/2020/02/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%A6%82%E8%BF%B0/</id>
    <published>2020-02-20T04:54:01.000Z</published>
    <updated>2020-03-16T03:35:35.806Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Git快速入门</title>
    <link href="http://yoursite.com/2020/02/15/git/Git%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2020/02/15/git/Git%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</id>
    <published>2020-02-15T09:56:07.000Z</published>
    <updated>2020-03-27T10:35:41.420Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>Git安装(Windowns系统为例)</p><ul><li><p>下载Git软件:</p><p>点击链接:<a href="https://git-scm.com/" target="_blank" rel="noopener">https://git-scm.com/</a></p><p><img src="https://raw.githubusercontent.com/yangshenghua97/Image/master/git1.png" alt=""></p><p>双击！</p><p>一路Next！</p></li></ul></li><li><h2 id="1-Git命令行"><a href="#1-Git命令行" class="headerlink" title="1 Git命令行"></a>1 Git命令行</h2><p>git简单易用，只要在终端输入$ <code>Git</code>，Git就会不带任何参数输出它的选项和常用的子命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git</span><br><span class="line"><span class="comment">#输入git后会输出一下选项，如果要得到一个完整的git子命令列表，可以输入 git help --all</span></span><br><span class="line">usage: git [--version] [--<span class="built_in">help</span>] [-C &lt;path&gt;] [-c &lt;name&gt;=&lt;value&gt;]</span><br><span class="line">           [--<span class="built_in">exec</span>-path[=&lt;path&gt;]] [--html-path] [--man-path] [--info-path]</span><br><span class="line">           [-p | --paginate | -P | --no-pager] [--no-replace-objects] [--bare]</span><br><span class="line">····················</span><br><span class="line">collaborate (see also: git <span class="built_in">help</span> workflows)</span><br><span class="line">   fetch      Download objects and refs from another repository</span><br><span class="line">   pull       Fetch from and integrate with another repository or a <span class="built_in">local</span> branch</span><br><span class="line">   push       Update remote refs along with associated objects .....</span><br></pre></td></tr></table></figure><ul><li><h2 id="2-Git使用快速入门"><a href="#2-Git使用快速入门" class="headerlink" title="2 Git使用快速入门"></a>2 Git使用快速入门</h2><ul><li><h4 id="2-1创建初始版本库"><a href="#2-1创建初始版本库" class="headerlink" title="2.1创建初始版本库"></a>2.1创建初始版本库</h4><p>首先在git终端下创建一个空文件夹:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建空文件夹 test/</span></span><br><span class="line">$ mkdir -p <span class="built_in">test</span>/</span><br><span class="line"><span class="comment">#进入到test文件夹</span></span><br><span class="line">$ <span class="built_in">cd</span> <span class="built_in">test</span>/</span><br><span class="line"><span class="comment">#执行git init命令</span></span><br><span class="line">$ git init</span><br><span class="line">Initialized empty Git repository <span class="keyword">in</span> /root/<span class="built_in">test</span>/.git/</span><br></pre></td></tr></table></figure><p>Git不会关心文件夹里是否为空，执行<code>git init</code> 命令创建了一个隐藏目录，在项目目录的顶层有个名为 <code>.git</code>文件夹，Git把所有修订的信息都放在这唯一的顶层目录里</p></li><li><h4 id="2-2-将文件添加到版本库中"><a href="#2-2-将文件添加到版本库中" class="headerlink" title="2.2 将文件添加到版本库中"></a>2.2 将文件添加到版本库中</h4><p>执行 git init 命令时，Git版本库都是空的，为了管理内容，需要明确的把内容放入版本库中。</p><p>使用 <code>git add file</code>[^1] 将file添加到版本库中。</p><p>例如:</p><p>在 <code>test</code>目录中创建一个文件<code>index.html</code>并把该文件添加到版本库中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> <span class="built_in">test</span>/</span><br><span class="line">$ touch index.html</span><br><span class="line">$ git add index.html</span><br></pre></td></tr></table></figure><p>[^1 ]: 如果目录中已经有很多的文件，使用<code>git add .</code>命令让Git把当前的目录及子目录中的文件都添加到版本库中</p><p>运行<code>git status</code> 命令显示中间状态的<code>index.html</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">  <span class="comment"># 这个命令显示新文件index.html将在下次提交时添加到版本库中</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure></li></ul></li><li><h4 id="2-3-版本库内文件的删除和重命名"><a href="#2-3-版本库内文件的删除和重命名" class="headerlink" title="2.3 版本库内文件的删除和重命名"></a>2.3 版本库内文件的删除和重命名</h4><ul><li><h5 id="文件删除"><a href="#文件删除" class="headerlink" title="文件删除"></a>文件删除</h5><p>执行命令 <code>git rm</code>可以删除版本库里不需要的文件</p><p>操作如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看版本库中的文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git ls-files</span></span><br><span class="line">index.html</span><br></pre></td></tr></table></figure><h1 id="执行git-rm-index-html即可删除版本库中的index-html文件"><a href="#执行git-rm-index-html即可删除版本库中的index-html文件" class="headerlink" title="执行git rm index.html即可删除版本库中的index.html文件"></a>执行git rm index.html即可删除版本库中的index.html文件</h1><p>$ git rm index.html</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">- ##### 文件重命名</span><br><span class="line">  </span><br><span class="line">      在终端执行``git mv srcfile targetfile``即可以完成文件的重命名</span><br><span class="line">      </span><br><span class="line">      例如：</span><br><span class="line">    </span><br><span class="line">      ```<span class="keyword">shell</span></span><br><span class="line">    # 先查看版本库中的文件</span><br><span class="line">      $ git <span class="keyword">ls</span>-<span class="keyword">files</span></span><br><span class="line">    <span class="built_in">index</span>.html</span><br><span class="line">      # 执行git mv <span class="built_in">index</span>.html foo.html 将<span class="built_in">index</span>.html修改为foo.html</span><br><span class="line">    $ git mv <span class="built_in">index</span>.html foo.html</span><br><span class="line">      # 再次查看版本库文件</span><br><span class="line">    $ git <span class="keyword">ls</span>-<span class="keyword">files</span></span><br><span class="line">      foo.html</span><br></pre></td></tr></table></figure></li></ul><p>​    </p></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;Git安装(Windowns系统为例)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;下载Git软件:&lt;/p&gt;
&lt;p&gt;点击链接:&lt;a href=&quot;https://git-scm.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://g
      
    
    </summary>
    
    
      <category term="版本控制管理" scheme="http://yoursite.com/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Git提交</title>
    <link href="http://yoursite.com/2020/02/15/git/Git%E6%8F%90%E4%BA%A4/"/>
    <id>http://yoursite.com/2020/02/15/git/Git%E6%8F%90%E4%BA%A4/</id>
    <published>2020-02-15T08:54:50.000Z</published>
    <updated>2020-03-27T10:35:07.010Z</updated>
    
    <content type="html"><![CDATA[<h2 id="吧啦吧啦乱七八遭的东西"><a href="#吧啦吧啦乱七八遭的东西" class="headerlink" title="吧啦吧啦乱七八遭的东西"></a>吧啦吧啦乱七八遭的东西</h2><p>在Git中，提交（commit）是用来记录版本库的变更的。当提交时，Git记录索引的快照并把快照放进对象库（简单的介绍）。提交的快照是串联在一起的，每张新的快照指向它的先驱。随着时间的推移，一系列的变更就表示一系列的提交。</p><p>Git提供一种机制来确定相对于另一个引用的提交，通常是分支的头。</p><p>在某些Git应用场景中，可能见过诸如这样的提交形式 master^ 。</p><p>在同一代提交中，插入符号 ^ 是用来选择不同的父提交。给定一个提交C，C^1 是其第一个父提交，C^2 是其第二个父提交，等等，如图:</p><p><img src="https://raw.githubusercontent.com/yangshenghua97/Image/master/commit.jpg" alt=""></p><p><img src="https://raw.githubusercontent.com/yangshenghua97/Image/master/commit1.jpg" alt=""></p><p>通过把引用与^ 和 ~ 组合，就可从引用的提交历史图中选出任意提交</p><h2 id="提交历史记录"><a href="#提交历史记录" class="headerlink" title="提交历史记录"></a>提交历史记录</h2><ul><li><p><strong>查看旧提交</strong> </p><p>显示提交历史记录的主要命令是 <strong><code>git log</code></strong>,在参数形式上，<strong><code>git log</code></strong>跟<strong><code>git log HEAD</code></strong>是一样的，输出每一个可从HEAD找到的历史记录中的提交日志信息。变更从HEAD提交开始显示，并从提交图中回溯。如果使用<strong><code>git log</code></strong></p><p>时提供一个提交名，那么这个日志将从该提交开始回溯输出。例如:<strong><code>git log master</code></strong></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;吧啦吧啦乱七八遭的东西&quot;&gt;&lt;a href=&quot;#吧啦吧啦乱七八遭的东西&quot; class=&quot;headerlink&quot; title=&quot;吧啦吧啦乱七八遭的东西&quot;&gt;&lt;/a&gt;吧啦吧啦乱七八遭的东西&lt;/h2&gt;&lt;p&gt;在Git中，提交（commit）是用来记录版本库的变更的。当提交时，
      
    
    </summary>
    
    
      <category term="版本控制管理" scheme="http://yoursite.com/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>关于Git文件管理</title>
    <link href="http://yoursite.com/2020/02/12/git/%E5%85%B3%E4%BA%8EGit%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2020/02/12/git/%E5%85%B3%E4%BA%8EGit%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/</id>
    <published>2020-02-12T11:25:36.000Z</published>
    <updated>2020-03-27T10:35:50.019Z</updated>
    
    <content type="html"><![CDATA[<h3 id="git中的文件分类"><a href="#git中的文件分类" class="headerlink" title="git中的文件分类"></a>git中的文件分类</h3><p>​    Git将所有文件分为3类：已追踪的、被忽略的以及未追踪的</p><ul><li><p>已追踪的</p><p>已追踪的文件是指已经在版本库中的文件，或者是已暂存到索引中的文件。如果想将新文件<strong><code>newfile</code></strong>添加到已追踪的文件，执行 <strong><code>git add newfile</code></strong>即可</p></li><li><p>被忽略的</p><p>被忽略的文件必须在版本库中明确声明为不可见或被忽略，即使他可能会在工作目录中出现。一个软件项目通常都会有很多被忽略的文件。普通被忽略的文件包括临时文件、个人笔记、编译器输出文件以及构建过程中自动生成的大多数文件。Git维护一个默认的忽略文件列表，也可以配置版本库来识别其他文件。被忽略的文件会在后面介绍。</p></li><li><p>未追踪的</p><p>未追踪的文件是指那些不在版本库中的文件。</p></li></ul><p>下面举一个栗子:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git init</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">查看状态</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> On branch master</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Initial commit</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line">nothing to commit (create/copy files and use "git add" to track)</span><br><span class="line"><span class="meta">#</span><span class="bash">添加一个文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"new Data"</span> &gt;&gt; data</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> On branch master</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Initial commit</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Untracked files:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">"git add &lt;file&gt;..."</span> to include <span class="keyword">in</span> what will be committed)</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash">       data</span></span><br><span class="line">nothing added to commit but untracked files present (use "git add" to track)</span><br></pre></td></tr></table></figure><p>为了让Git忽略目录中的文件，只需将该文件名添加到一个特殊的文件<strong><code>.gitignore</code></strong>中就可以了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> touch main.o</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> On branch master</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Initial commit</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Untracked files:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">"git add &lt;file&gt;..."</span> to include <span class="keyword">in</span> what will be committed)</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash">       data</span></span><br><span class="line"><span class="meta">#</span><span class="bash">       main.o</span></span><br><span class="line">nothing added to commit but untracked files present (use "git add" to track)</span><br><span class="line"><span class="meta">#</span><span class="bash">将 main.o添加到.gitignore中</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> main.o &gt;&gt; .gitignore</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> On branch master</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Initial commit</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Untracked files:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">"git add &lt;file&gt;..."</span> to include <span class="keyword">in</span> what will be committed)</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash">       .gitignore</span></span><br><span class="line"><span class="meta">#</span><span class="bash">       data</span></span><br><span class="line">nothing added to commit but untracked files present (use "git add" to track)</span><br></pre></td></tr></table></figure><p>这样main.o就已经被忽略了，但是<strong><code>git status</code></strong>现在显示一个新的未追踪的文件 .gitignore。</p><h2 id="使用-git-add"><a href="#使用-git-add" class="headerlink" title="使用 git add"></a>使用 git add</h2><p><strong><code>git add</code></strong> 命令将暂存一个文件。就Git文件分类而言，如果一个文件是未追踪的，那么<strong><code>git add</code></strong>就会将文件的状态转化为已追踪的。如果git add作用于一个目录名，那么该目录下的文件以及子目录都会递归暂存起来。</p><p>这里还接着上面的栗子:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> On branch master</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Initial commit</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Untracked files:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">"git add &lt;file&gt;..."</span> to include <span class="keyword">in</span> what will be committed)</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash">       .gitignore</span></span><br><span class="line"><span class="meta">#</span><span class="bash">       data</span></span><br><span class="line">nothing added to commit but untracked files present (use "git add" to track)</span><br><span class="line"><span class="meta">#</span><span class="bash"> 将data、.gitignore两个文件添加至已追踪的分类</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add data .gitignore</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> On branch master</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Initial commit</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Changes to be committed:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">"git rm --cached &lt;file&gt;..."</span> to unstage)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">       new file:   .gitignore</span></span><br><span class="line"><span class="meta">#</span><span class="bash">       new file:   data</span></span><br></pre></td></tr></table></figure><p>在上面的栗子中使用<strong><code>git add</code></strong>后，暂存和追踪data和.gitignore文件，并准备下次提交是时添加到版本库中。</p><p>可以使用<strong><code>git ls-files</code></strong>命令查看隐藏在对象模型下的东西。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git ls-files</span></span><br><span class="line">.gitignore</span><br><span class="line">data</span><br></pre></td></tr></table></figure><p>在任何编辑之后，提交变更之前，请执行一次<strong><code>git add</code></strong>命令。</p><h2 id="使用-git-commit"><a href="#使用-git-commit" class="headerlink" title="使用 git commit"></a>使用 git commit</h2><h3 id="使用-git-commit-–all"><a href="#使用-git-commit-–all" class="headerlink" title="使用 git commit –all"></a>使用 git commit –all</h3><p><strong><code>git commit</code></strong> 的 <strong><code>-a</code></strong>或者 <strong><code>--all</code></strong>选项会导致执行提交之前自动暂存所有未暂存的和未追踪的文件变化，包括从工作副本中删除已追踪的文件</p><p>下面举个栗子:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">pwd</span></span></span><br><span class="line">/tmp/commit-all-example</span><br><span class="line"><span class="meta">#</span><span class="bash">创建测试版本库</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git init</span></span><br><span class="line">Initialized empty Git repository in /tmp/commit-all-example/.git/</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"Testfile1"</span> &gt;&gt; ready</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"Testfile2"</span> &gt;&gt; notyet</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add ready notyet</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">"Setup"</span></span></span><br><span class="line">[master (root-commit) 2b00dbf] Setup</span><br><span class="line"> 2 files changed, 2 insertions(+)</span><br><span class="line"> create mode 100644 notyet</span><br><span class="line"> create mode 100644 ready</span><br></pre></td></tr></table></figure><p>之后再次编辑<strong>ready</strong>文件，并用 <strong><code>git add</code></strong>把它添加到版本库中。然后编辑<strong>notyet</strong>文件保持它是未暂存的。</p><p>在一个子目录下添加一个文件，但是不要对它执行<strong><code>git add</code></strong>命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir subdir</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"Nope"</span> &gt;&gt; subdir/new</span></span><br></pre></td></tr></table></figure><p>当执行 <strong><code>git commit --all</code></strong>命令，Git会递归遍历整个版本库，暂存所有先前通过<strong><code>git add</code></strong>提交的已知的和修改的文件，然后提交它们，由于<strong>subdir/</strong> 一个全新的目录，而且目录下没有任何文件名或路径通过<strong><code>git add</code></strong>和<strong><code>git commit</code></strong>进行操作的，</p><p>So 即使是 –all选项也不能将其提交。</p><h3 id="关于提交日志消息"><a href="#关于提交日志消息" class="headerlink" title="关于提交日志消息"></a>关于提交日志消息</h3><p>​    如果不通过命令行直接提供日志消息（例如:<strong><code>git commit -m &quot;提交日志消息&quot;</code></strong>），Git会启动编辑器，并提示你写一个提交日志。</p><h2 id="使用-git-rm-命令"><a href="#使用-git-rm-命令" class="headerlink" title="使用 git rm 命令"></a>使用 git rm 命令</h2><p>​       git rm命令会在版本库中和目录中同时删除文件。</p><p>接着上面的栗子:</p><p>这里“意外”的添加了一个文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"Random"</span> &gt; oops</span></span><br><span class="line"><span class="meta">#</span><span class="bash">当执行git rm oops时，提示删除失败</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git rm oops</span></span><br><span class="line">fatal: pathspec 'oops' did not match any files</span><br></pre></td></tr></table></figure><p>​    为什么会这样，可以通过<strong><code>git ls-files</code></strong>命令查看版本库中的文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git ls-files</span></span><br><span class="line">notyet</span><br><span class="line">ready</span><br></pre></td></tr></table></figure><p>现在的版本库中没有<strong>oops</strong>这个文件，可通过<strong>git add oops</strong>命令将 oops文件加入到版本库中。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git add oops</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git ls-files</span></span><br><span class="line">notyet</span><br><span class="line">oops</span><br><span class="line">ready</span><br></pre></td></tr></table></figure><p>另外，要将一个文件由已暂存的转化为未暂存的,可以使用<strong><code>git rm --cached</code></strong>命令</p><p>比如要删除oops</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git rm --cached oops</span></span><br><span class="line">rm 'oops'</span><br></pre></td></tr></table></figure><p><strong><code>git rm --cached</code></strong>会删除索引中的文件并它文件保留在工作目录中，而<strong><code>git rm</code></strong>则会将文件从索引和工作目录中都删除。</p><p>如果想要删除一个已经提交的文件，通过简单的<strong><code>git rm filename</code></strong>命令来暂存这一请求</p><blockquote><p>还可以使用 <strong><code>git rm -f</code></strong>来强制删除文件。</p></blockquote><p>如果想保留的文件不小心删除了，可以通过版本控制系统的恢复功能进行恢复</p><p>具体的命令如下:</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 加入不小心删除了oops文件</span></span><br><span class="line"><span class="meta"># 可以是下面的命令进行恢复</span></span><br><span class="line">git checkout HEAD -- oops</span><br></pre></td></tr></table></figure><h2 id="使用-git-mv"><a href="#使用-git-mv" class="headerlink" title="使用 git mv"></a>使用 git mv</h2><p>如果想要给一个文件重命名可以使用<strong><code>git mv srcfile newfile</code></strong>，git mv 命令会将 <strong>srcfile</strong>文件的文件名称改为<strong>newfiles</strong>，Git会在索引中删除<strong>srcfile</strong>文件的路径名，并添加<strong>newfile</strong>的路径名，至于srcfile文件里的内容，Git仍然会保存在对象库中，然后才会将它与newfile重新关联。git mv 还可以移动一个文件到一个目录中：<strong><code>git mv srcfile dir/</code></strong></p><h2 id="gitignore-文件"><a href="#gitignore-文件" class="headerlink" title=".gitignore 文件"></a>.gitignore 文件</h2><p>在前面简单介绍过<strong>.gitignore</strong>文件的作用。可以通过<strong>.gitignore</strong>文件来忽略不相干的文件。Git还支持一种更丰富的机制，一个<strong>.gitignore</strong>文件下可以包含一个文件名模式列表，指定哪些文件需要忽略。<strong>.gitignore</strong> 文件的格式如下。</p><ul><li>空行会被忽略，而以（#）号开头的行可以用于注释。然而，如果#跟在其他文本后面，它就不代表注释了。</li><li>一个简单的字面置文件名匹配任何目录中的同名文件。</li><li>目录名由末尾的（/）标记。这能匹配同名的目录和子目录，但不匹配文件或符号链接。</li><li>包含shell通配符，如（*）号，这种模式可扩展为shell通配模式。正如标准shell通配符一样，因为不能跨目录匹配，所以一个 * 只能匹配一个文件或目录名。</li><li>起始的 ！号会对该行其余部分的模式进行取反。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;git中的文件分类&quot;&gt;&lt;a href=&quot;#git中的文件分类&quot; class=&quot;headerlink&quot; title=&quot;git中的文件分类&quot;&gt;&lt;/a&gt;git中的文件分类&lt;/h3&gt;&lt;p&gt;​    Git将所有文件分为3类：已追踪的、被忽略的以及未追踪的&lt;/p&gt;
&lt;ul&gt;
      
    
    </summary>
    
    
      <category term="版本控制管理" scheme="http://yoursite.com/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Java并发容器和框架</title>
    <link href="http://yoursite.com/2019/05/06/java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E5%92%8C%E6%A1%86%E6%9E%B6/"/>
    <id>http://yoursite.com/2019/05/06/java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E5%92%8C%E6%A1%86%E6%9E%B6/</id>
    <published>2019-05-06T09:02:12.000Z</published>
    <updated>2020-05-06T10:14:13.307Z</updated>
    
    <content type="html"><![CDATA[<p>在多线程环境中，使用HashMap可能会导致程序死循环，使用线程安全的HashTable效率低效，所以便有了<strong>ConcurrentHashMap</strong>。</p><p>ConcurrentHashMap利用锁的分断技术可有效提升并发访问率，在容器里有多把锁，每一把锁用于锁容器其中一部分数据，当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效提升并发访问效率。</p><h3 id="ConcurrentHashMap的结构"><a href="#ConcurrentHashMap的结构" class="headerlink" title="ConcurrentHashMap的结构"></a>ConcurrentHashMap的结构</h3><p>ConcurrentHashMap由Segment数组结构和HashEntry数组结构组成。Segment是一种可重入锁；HashEntry用于存储键值对数据，一个ConcurrentHashMap包含一个Segment数组。Segment数组的结构和HashMap类似，是一种数组和链表结构，一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素，每个Segment守护一个HashEntry数组里的元素，当对HashEntry数组的数据进行修改时，必须先获得与它对应的Segment锁。</p><p><img src="https://raw.githubusercontent.com/yangshenghua97/Image/master/ConcurrentHashMap.png" alt=""></p><h3 id="ConcurrentHashMap初始化"><a href="#ConcurrentHashMap初始化" class="headerlink" title="ConcurrentHashMap初始化"></a>ConcurrentHashMap初始化</h3><h4 id="初始化Segment数组"><a href="#初始化Segment数组" class="headerlink" title="初始化Segment数组"></a>初始化Segment数组</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在多线程环境中，使用HashMap可能会导致程序死循环，使用线程安全的HashTable效率低效，所以便有了&lt;strong&gt;ConcurrentHashMap&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;ConcurrentHashMap利用锁的分断技术可有效提升并发访问率，在容器里
      
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="java并发编程" scheme="http://yoursite.com/tags/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java并发基础Java中的锁</title>
    <link href="http://yoursite.com/2019/04/30/java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80Java%E4%B8%AD%E7%9A%84%E9%94%81/"/>
    <id>http://yoursite.com/2019/04/30/java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80Java%E4%B8%AD%E7%9A%84%E9%94%81/</id>
    <published>2019-04-30T10:40:11.000Z</published>
    <updated>2020-05-06T08:58:29.493Z</updated>
    
    <content type="html"><![CDATA[<p>锁是用来控制多个线程访问共享资源的方式，一个锁能够防止多个线程同时访问共享资源。</p><h3 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h3><p>在<strong><code>Lock</code></strong>接口出现之前，Java通过synchronized关键字实现锁功能，JDK 1.5之后，在并发包中新增了Lock接口来实现锁功能，有与synchronized关键字类似功能，只是在使用时需要显示的获取锁和释放锁，拥有了锁释放和获取的可操作性、可中断性等synchronized关键字不具备的特性。在使用synchronized关键字会隐式的获取锁和释放锁，但锁的获取和释放固化，即先获取后释放。Lock接口的实现基本上是通过聚合一个同步器（<strong><code>AQS</code></strong>）的子类来完成线程访问控制。</p><p>Lock接口的使用方式：</p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Lock</span> <span class="keyword">lock</span> = <span class="keyword">new</span> ReentrantLock()<span class="comment">;</span></span><br><span class="line"><span class="keyword">lock</span>.<span class="keyword">lock</span>()<span class="comment">;</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">&#125;finally&#123;</span><br><span class="line"><span class="keyword">lock</span>.unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码示例中要注意：获取锁的过程不要写在<strong><code>try</code></strong>中，因为在获取锁时发生异常，异常抛出的同时，也会导致锁无故释放。</p><h3 id="重入锁"><a href="#重入锁" class="headerlink" title="重入锁"></a>重入锁</h3><p>重入锁ReentrantLock，支持重进入的锁，表示该锁功能支持一个线程对资源的重复加锁。</p><h4 id="实现重进入"><a href="#实现重进入" class="headerlink" title="实现重进入"></a>实现重进入</h4><p>重进入是指任意线程在获取锁之后能够再次获取该锁而不会被锁所阻塞，这个特性需要解决两个问题：</p><ul><li><strong>线程再次获取锁</strong>：所需要去识别获取锁的线程是否为当前占据锁的线程，如果是则再次成功获取。</li><li><strong>锁的最终释放</strong>：线程重复n次获取锁，随后第n次释放该锁后，其他线程能够获取到该锁。锁的最终释放要求锁对于获取进行计数自增，计数表示当前锁被重复获取的次数，而锁被释放时，计数自减当计数等于0时表示已经释放成功。</li></ul><p>重入锁是通过组合自定义<strong><code>同步器</code></strong>来实现锁的获取和释放。获取同步状态的代码如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">final boolean nonfair<span class="constructor">TryAcquire(<span class="params">int</span> <span class="params">acquires</span>)</span> &#123;</span><br><span class="line">            final Thread current = <span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>;</span><br><span class="line">            <span class="built_in">int</span> c = get<span class="constructor">State()</span>;</span><br><span class="line">            <span class="keyword">if</span> (c<span class="operator"> == </span><span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (compare<span class="constructor">AndSetState(0, <span class="params">acquires</span>)</span>) &#123;</span><br><span class="line">                    set<span class="constructor">ExclusiveOwnerThread(<span class="params">current</span>)</span>;</span><br><span class="line">                    return <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current<span class="operator"> == </span>get<span class="constructor">ExclusiveOwnerThread()</span>) &#123;</span><br><span class="line">                <span class="built_in">int</span> nextc = c + acquires;</span><br><span class="line">                <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                    throw <span class="keyword">new</span> <span class="constructor">Error(<span class="string">"Maximum lock count exceeded"</span>)</span>;</span><br><span class="line">                set<span class="constructor">State(<span class="params">nextc</span>)</span>;</span><br><span class="line">                return <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            return <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>通过判断当前线程是否为获取锁的线程来决定获取操作是否成功，如果是获取锁的线程再次请求，则将同步状态值进行增加并返回true，表示获取同步状态成功。</p><h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p>读写锁维护一对锁，一个读锁和一个写锁，通过分离读锁和写锁使得并发性相比一般的排他锁有了更大的提升，读写锁的性能都会比排它锁好，因为大多数场景读操作对于写操作，在这样的情况下读写锁能够提供排它锁更好的并发性和吞吐量，</p><p><img src="https://raw.githubusercontent.com/yangshenghua97/Image/master/ReadAndWriterLock.png" alt=""></p><h4 id="读写锁的实现"><a href="#读写锁的实现" class="headerlink" title="读写锁的实现"></a>读写锁的实现</h4><ul><li><p>读写状态的设计</p><p>读写锁同样依赖自定义同步器来实现同步功能，而读写状态就是其同步器的同步状态。读写锁的自定义同步器需要在同步同步状态上维护多个读线程和一个写线程的状态，状态的设计成为读写锁实现的关键。</p><p>如果在一个整型变量上维护多种状态，就一定需要“按位切割使用”这个变量，读写锁将变量切分成两个部分，高16为表示读，低16位表示写</p><p><img src="https://raw.githubusercontent.com/yangshenghua97/Image/master/ReadAndWriterStatu.png" alt=""></p></li><li><p>写锁的获取与释放</p><p>写锁是一个支持重进入的排它锁，如果当前线程已经获取了写锁，则增加写状态。如果当前线程在获取写锁时，读锁已经被获取或者该线程不是已经获取写锁的线程，则当前线程进入等待状态。写锁的释放与ReentrantLock的释放过程基本相似，每次释放均减少写状态，当写状态为0时表示写锁已经被释放，从而等待读写线程能够继续访问读写锁，同时前次的写线程的修改对后续读写线程可见。</p></li><li><p>读锁的获取与释放</p><p>读锁是一个支持重进入的共享锁，能够被多个线程同时获取，在没有其他的写线程访问时，读锁总会被成功的获取，而所做的只是增加读状态，如果当前线程已经获取了读锁，则增加读状。如果当前线程在获取读锁时，写锁已被其他线程获取，则进入等待状态。</p></li><li><p>锁降级</p><p>锁降级指的是<strong>写锁降级为读锁</strong>。如果当前线程拥有写锁，然后将其释放，最后在获取读锁，这种分段完成的过程不能称为锁降级。锁降级是指把持住写锁，再获取到读锁，随后释放写锁的过程。锁降级中读锁释放主要是为了保证数据的可见性。</p></li></ul><h3 id="队列同步器"><a href="#队列同步器" class="headerlink" title="队列同步器"></a>队列同步器</h3><p>队列同步器<strong><code>AbstractQueuedSynchronizer</code></strong>，是用来构建锁或者其他同步组件的基本框架，使用一个<strong>int</strong>成员变量表示同步状态，通过内置FIFO队列来完成资源的获取线程的排队工作。</p><p><img src="https://raw.githubusercontent.com/yangshenghua97/Image/master/AQS.png" alt=""></p><p>同步器是实现锁的关键，在锁的实现中聚合同步器，利用同步器实现锁的语义。二者的关系是：锁是面向使用者，定义了使用者与锁交互的接口，隐藏了实现细节；同步器则面向锁的实现者，简化了锁的实现方式，屏蔽了同步状态管理、线程的排队、等待与唤醒等底层操作。同步器的主要使用方式是继承，子类通过继承同步器并实现它的抽象方法来管理同步器状态。</p><h3 id="队列同步器的实现分析"><a href="#队列同步器的实现分析" class="headerlink" title="队列同步器的实现分析"></a>队列同步器的实现分析</h3><h4 id="同步队列"><a href="#同步队列" class="headerlink" title="同步队列"></a>同步队列</h4><p>同步器依赖内部的同步队列来完成同步状态的管理，当前线程获取同步状态失败时，同步器会将当前线程以及等待状态的信息够造成一个节点将其加入到同步队列，同时会阻塞当前线程，当同步状态释放时，会把首节点中的线程唤醒，使其再次尝试获取同步器状态。</p><p>节点是构成同步队列的基础，同步器拥有首节点和尾节点，没有成功获取同步状态的线程会成为节点加入到该队列的尾部。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;锁是用来控制多个线程访问共享资源的方式，一个锁能够防止多个线程同时访问共享资源。&lt;/p&gt;
&lt;h3 id=&quot;Lock&quot;&gt;&lt;a href=&quot;#Lock&quot; class=&quot;headerlink&quot; title=&quot;Lock&quot;&gt;&lt;/a&gt;Lock&lt;/h3&gt;&lt;p&gt;在&lt;strong&gt;&lt;code
      
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="java并发编程" scheme="http://yoursite.com/tags/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java并发基础</title>
    <link href="http://yoursite.com/2019/04/30/java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80Java/"/>
    <id>http://yoursite.com/2019/04/30/java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80Java/</id>
    <published>2019-04-30T10:39:37.000Z</published>
    <updated>2020-05-06T09:01:30.973Z</updated>
    
    <content type="html"><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href=""></a></li><li><a href=""></a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;&quot;&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;&quot;&gt;&lt;/a&gt;&lt;/l
      
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="java并发编程" scheme="http://yoursite.com/tags/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>SQL基础（二）</title>
    <link href="http://yoursite.com/2019/04/05/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/SQL%E5%9F%BA%E7%A1%802/"/>
    <id>http://yoursite.com/2019/04/05/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/SQL%E5%9F%BA%E7%A1%802/</id>
    <published>2019-04-05T09:57:27.000Z</published>
    <updated>2020-04-09T13:52:30.812Z</updated>
    
    <content type="html"><![CDATA[<h2 id="过滤数据"><a href="#过滤数据" class="headerlink" title="过滤数据"></a>过滤数据</h2><h3 id="百分号（-）通配符"><a href="#百分号（-）通配符" class="headerlink" title="百分号（%）通配符"></a>百分号（%）通配符</h3><p><strong><code>%</code></strong>表示任何字符出现任意次数。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_id,prod_name</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_name <span class="keyword">LIKE</span> <span class="string">'jet%'</span>;</span><br></pre></td></tr></table></figure><p>上面的SQL检索任意以jet为开头的词，%告诉MYSQL接受jet之后的任意字符，不论它有多少字符。通配符可在搜索模式中任意位置使用，并且可以使用多个通配符</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_id,prod_name</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_name <span class="keyword">LIKE</span> <span class="string">'%anvil%'</span>;</span><br></pre></td></tr></table></figure><h3 id="下划线（-）通配符"><a href="#下划线（-）通配符" class="headerlink" title="下划线（_）通配符"></a>下划线（_）通配符</h3><p>下划线通配符只匹配单个字符而不是多个字符。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_id,prod_name</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_name <span class="keyword">LIKE</span> <span class="string">'_ ton anvil'</span></span><br></pre></td></tr></table></figure><h3 id="使用通配符的技巧"><a href="#使用通配符的技巧" class="headerlink" title="使用通配符的技巧"></a>使用通配符的技巧</h3><ul><li>不要过度使用通配符，如果其他操作符能达到相同的效果，应该使用其他操作符；</li><li>在确实需要使用通配符时，除非绝对有必要，否则不要把通配符放在搜索模式的开始处。如果把通配符置于开始处，搜索起来很慢；</li><li>仔细注意通配符的位置，如果犯错位置。可能不会得到想要的数据；</li></ul><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p>MySQL中使用<strong><code>REGEXP</code></strong>关键字指定正则表达式的字符匹配。</p><p>正则表达式常用的字符匹配列表</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>^</td><td>匹配文本的开始字符</td></tr><tr><td>$</td><td>匹配文本的结束字符</td></tr><tr><td>.</td><td>匹配任何单一字符</td></tr><tr><td>*</td><td>匹配零个或多个在在它前面的字符</td></tr><tr><td>+</td><td>匹配前面的字符1次或多次</td></tr><tr><td>字符串</td><td>匹配包含指定的字符串的文本</td></tr><tr><td>[字符集合]</td><td>匹配字符集合中的任何一个字符</td></tr><tr><td>[^]</td><td>匹配不在括号中的任何字符</td></tr><tr><td>字符串{n,}</td><td>匹配前面的字符串至少n次</td></tr><tr><td>字符串{n,m}</td><td>匹配前面的字符串至少n次，至多m次。</td></tr><tr><td>|</td><td>进行OR匹配</td></tr></tbody></table><p>正则表达式经典例子：</p><p>基本字符匹配</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_name REGEXP <span class="string">'1000'</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_name;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_name REGEXP <span class="string">'.000'</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_name;</span><br></pre></td></tr></table></figure><p>进行OR匹配</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_name REGEXP <span class="string">'1000|2000'</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_name;</span><br></pre></td></tr></table></figure><p>范围匹配</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_name REGEXP <span class="string">'[1-5] Ton'</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_name;</span><br></pre></td></tr></table></figure><p>匹配特殊字符</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_name</span><br><span class="line"><span class="keyword">FROM</span> vendors</span><br><span class="line"><span class="keyword">WHERE</span> vend_name REGEXP <span class="string">'\\.'</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_name;</span><br></pre></td></tr></table></figure><h2 id="MYSQL函数"><a href="#MYSQL函数" class="headerlink" title="MYSQL函数"></a>MYSQL函数</h2><h3 id="文本处理函数"><a href="#文本处理函数" class="headerlink" title="文本处理函数"></a>文本处理函数</h3><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>Left()</td><td>返回字符串左边的字符</td></tr><tr><td>Length()</td><td>返回字符串的长度</td></tr><tr><td>Locate()</td><td>找出字符串的一个子串</td></tr><tr><td>Lower()</td><td>将字符串转换为小写</td></tr><tr><td>LTrim()</td><td>去掉字符串左边的空格</td></tr><tr><td>Right()</td><td>去掉字符串右边的字符</td></tr><tr><td>RTrim()</td><td>去掉字符串右边的空格</td></tr><tr><td>Upper()</td><td>将字符串转换为大写</td></tr></tbody></table><p>经典例子</p><p>将字符串转换为大写</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_name,<span class="built_in">Upper</span>(vend_name)</span><br><span class="line"><span class="keyword">FROM</span> vendors</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> vend_name;</span><br></pre></td></tr></table></figure><h3 id="日期时间处理函数"><a href="#日期时间处理函数" class="headerlink" title="日期时间处理函数"></a>日期时间处理函数</h3><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>AddDate()</td><td>增加一个日期（天，周等）</td></tr><tr><td>AddTime()</td><td>增加一个时间（时，分等）</td></tr><tr><td>CurDate()</td><td>获取当前日期</td></tr><tr><td>CurTime()</td><td>获取当前时间</td></tr><tr><td>Date()</td><td>返回日期时间的日期部分</td></tr><tr><td>DateDiff()</td><td>计算两个日期之差</td></tr><tr><td>Time()</td><td>返回一个日期时间的时间部分</td></tr><tr><td>Now()</td><td>返回当前日期和时间</td></tr></tbody></table><h3 id="聚集函数"><a href="#聚集函数" class="headerlink" title="聚集函数"></a>聚集函数</h3><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>AVG()</td><td>计算某一列的平均值</td></tr><tr><td>COUNT()</td><td>获取某一列的行数</td></tr><tr><td>MAX()</td><td>获取某一列的最大值</td></tr><tr><td>MIN()</td><td>获取某一列的最小值</td></tr><tr><td>SUM()</td><td>获取某一列值之和</td></tr></tbody></table><h2 id="数据分组"><a href="#数据分组" class="headerlink" title="数据分组"></a>数据分组</h2><h3 id="创建分组"><a href="#创建分组" class="headerlink" title="创建分组"></a>创建分组</h3><p>分组是在SELECT语句的<strong><code>GROUP BY</code></strong>子句中建立的。</p><p>举个例子：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT vend_id,COUNT(*) as num_prods</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line">GROUP BY vend_id;</span><br></pre></td></tr></table></figure><p>使用<strong><code>GROUP BY</code></strong>子句的一些规定</p><ul><li>GROUP BY子句可以包含任意数目的列。使得能够对分组进行嵌套，为数据分组提供更细致的控制。</li><li>如果GROUP BY子句中嵌套了分组，数据将在最后规定的分组上进行汇总。</li><li>GROUP BY子句中列出每个列都必须是检索列或是有效的表达式。如果在SELECT中使用表达式，则必须在GROUP BY子句中指定相同的表达式。不能使用别名。</li><li>除聚集函数语句外，SELECT语句中每个列都必须在GROUP BY子句中给出。</li><li>如果分组列中具有NULL值，则NULL将作为一个分组返回。如果列中有多行NULL值，他们将分为一组。</li><li>GROUP BY子句必须出现在WHERE子句之后，ORDER BY子句之前。</li></ul><h3 id="过滤分组：HAVING"><a href="#过滤分组：HAVING" class="headerlink" title="过滤分组：HAVING"></a>过滤分组：<strong><code>HAVING</code></strong></h3><p>使用<strong><code>HAVING</code></strong>对分组进行过滤，基于分组聚集值进行分组。</p><p>举几个例子</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_id,COUNT<span class="comment">(*) as num_prods</span></span><br><span class="line"><span class="comment">FROM products</span></span><br><span class="line"><span class="comment">GROUP BY vend_id</span></span><br><span class="line"><span class="comment">HAVING COUNT(*)</span>&gt;<span class="number">2</span>;</span><br></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT order_num,SUM(quantity*item_price) as ordertotal</span><br><span class="line"><span class="keyword">FROM</span> orderitems</span><br><span class="line">GROUP BY order_num</span><br><span class="line">HAVING SUM(quantity*item_price) &gt;=50;</span><br></pre></td></tr></table></figure><h3 id="SELECT子句顺序"><a href="#SELECT子句顺序" class="headerlink" title="SELECT子句顺序"></a>SELECT子句顺序</h3><p>以下语句由上至下的顺序</p><p><strong><code>SELECT</code></strong>：要返回的列或表达式</p><p><strong><code>FROM</code></strong>：从中检索数据的表</p><p><strong><code>WHERE</code></strong>：行级过滤</p><p><strong><code>GROUP BY</code></strong>：分组说明</p><p><strong><code>HAVING</code></strong>：组级过滤</p><p><strong><code>ORDER BY</code></strong>：输出排序顺序</p><p><strong><code>LIMIT</code></strong>：遥检索的行数</p><h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><p>子查询就是嵌套在其他查询中的查询。</p><h3 id="利用子查询过滤"><a href="#利用子查询过滤" class="headerlink" title="利用子查询过滤"></a>利用子查询过滤</h3><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">SELECT</span> cust_id</span><br><span class="line"><span class="meta">FROM</span> orders</span><br><span class="line"><span class="meta">WHERE</span> order_num <span class="meta">IN(</span></span><br><span class="line"><span class="meta">SELECT</span> order_num</span><br><span class="line"><span class="meta">FROM</span> orderitems</span><br><span class="line"><span class="meta">WHERE</span> prod_id = <span class="string">'TNT2'</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>上面的<strong>SELECT</strong>语句中子查询总是从内向外处理，上面的SQL语句实际上执行了两个SELECT操作。</p><p>在<strong>WHERE</strong>子句中使用子查询能够编写出功能很强并且很灵活的SQL语句。对于能嵌套的子查询的数目没有限制，但在实际应用中对于性能的要求，不能嵌套太多的子查询。</p><h3 id="用作计算字段使用子查询"><a href="#用作计算字段使用子查询" class="headerlink" title="用作计算字段使用子查询"></a>用作计算字段使用子查询</h3><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_name,cust_state,(</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(*)</span><br><span class="line"><span class="keyword">FROM</span> orders</span><br><span class="line"><span class="keyword">WHERE</span> orders.cust_id = customers.cust_id) <span class="keyword">as</span> orders</span><br><span class="line"><span class="keyword">FROM</span> customers</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> cust_name;</span><br></pre></td></tr></table></figure><h2 id="联结表"><a href="#联结表" class="headerlink" title="联结表"></a>联结表</h2><h3 id="创建联结"><a href="#创建联结" class="headerlink" title="创建联结"></a>创建联结</h3><p>联结的创建非常简单，规定要联结的所有表以及他们如何关联即可。</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_name,prod_name,prod_price</span><br><span class="line"><span class="keyword">FROM</span> vendors <span class="keyword">as</span> vend,products <span class="keyword">as</span> prd</span><br><span class="line"><span class="keyword">WHERE</span> vend.vend_id = prd.vend_id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> vend_name,prod_name;</span><br></pre></td></tr></table></figure><h3 id="内部联结"><a href="#内部联结" class="headerlink" title="内部联结"></a>内部联结</h3><p>基于两个表之间的相等测试，称为内部联结。</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_name,prod_name,prod_price</span><br><span class="line"><span class="keyword">FROM</span> vendors <span class="keyword">as</span> vend,<span class="keyword">INNER</span> <span class="keyword">JOIN</span> products <span class="keyword">as</span> prod</span><br><span class="line"><span class="keyword">ON</span> vend.vend_id = prod.vend_id;</span><br></pre></td></tr></table></figure><p>两个表之间的关系是<strong>FROM</strong>子句的组成部分，以<strong>INNER JOIN</strong>指定，在使用这种语法时，联结条件用特定的<strong>ON</strong>子句而不是WHERE子句给出。传递给ON的实际条件与传递给WHERE的相同。</p><h3 id="自联结"><a href="#自联结" class="headerlink" title="自联结"></a>自联结</h3><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT </span><span class="built_in">p1</span>.prod_id,<span class="built_in">p1</span>.prod_name</span><br><span class="line"><span class="symbol">FROM</span> products as <span class="built_in">p1</span>,products as <span class="built_in">p2</span></span><br><span class="line"><span class="symbol">WHERE</span> <span class="built_in">p1</span>.vend_id = <span class="built_in">p2</span>.vend_id</span><br><span class="line"><span class="keyword">AND</span></span><br><span class="line"><span class="keyword">p2.prod_id </span>= <span class="string">'DTNTR'</span><span class="comment">;</span></span><br></pre></td></tr></table></figure><p>自联结通常作为外部语句用来替代从相同表中检索数据时使用的子查询语句。</p><h3 id="外部联结"><a href="#外部联结" class="headerlink" title="外部联结"></a>外部联结</h3><p>看下面的例子：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> customers.cust_id,orders.order_num</span><br><span class="line"><span class="keyword">FROM</span> customers </span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> </span><br><span class="line">orders</span><br><span class="line"><span class="keyword">ON</span> customers.cust_id = orders.cust_id;</span><br></pre></td></tr></table></figure><p>在使用OUTER JOIN语法时，必须使用RIGHT或LEFT关键字指定包含其所有行的表（RIGHT指出的是OUTER JOIN右边的表，而LEFT指出的是OUTER JOIN左边的表）</p><h3 id="使用联结和联结条件"><a href="#使用联结和联结条件" class="headerlink" title="使用联结和联结条件"></a>使用联结和联结条件</h3><ul><li>注意所使用的联结类型，一般使用内部联结，但使用外部联结也是有效的；</li><li>保证使用正确的联结条件，否则将返回不正确的数据；</li><li>应该总是提供联结条件，否则会得笛卡儿积；</li><li>在一个联结中可以包含多个表，甚至对于每个联结可以采用不同的联结类型。虽然这样做合法的，一般也很有用，但应该在一起测试他们之前，分别测试每个联结，这将是故障排除更为简单；</li></ul><h2 id="组合查询"><a href="#组合查询" class="headerlink" title="组合查询"></a>组合查询</h2><p>组合查询将结果作为单个查询结果集返回。这些组合查询通常称为复合查询。</p><p>下面的情况，需要使用组合查询</p><ul><li>在单个查询浙江哦你从不同的表中返回类型类似结构的数据；</li><li>对单个表执行多个查询，按单个查询返回数据；</li></ul><h3 id="创建组合查询-—-使用UNION"><a href="#创建组合查询-—-使用UNION" class="headerlink" title="创建组合查询 —  使用UNION"></a>创建组合查询 —  使用<strong><code>UNION</code></strong></h3><p><strong><code>UNION</code></strong>的使用很简单，写出每个SELECT语句，在各条语句之间放上关键字</p><p>举个例子：</p><p>第一条select语句</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_id,prod_id,prod_price</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_price &lt;= <span class="number">5</span>;</span><br></pre></td></tr></table></figure><p>第二条select语句</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_id,prod_id,prod_price</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> vend_id <span class="keyword">IN</span>(<span class="number">1001</span>,<span class="number">1002</span>);</span><br></pre></td></tr></table></figure><p>复合两个语句</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_id,prod_id,prod_price</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_price &lt;= <span class="number">5</span>;</span><br><span class="line">UNION</span><br><span class="line"><span class="keyword">SELECT</span> vend_id,prod_id,prod_price</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> vend_id <span class="keyword">IN</span>(<span class="number">1001</span>,<span class="number">1002</span>);</span><br></pre></td></tr></table></figure><h3 id="UNION规则"><a href="#UNION规则" class="headerlink" title="UNION规则"></a>UNION规则</h3><ul><li>UNION必须有<strong>两条或者两条以上</strong>SELECT语句组成，语句之间用关键字UNION分隔；</li><li>UNION中的每个查询<strong>必须包含相同的列，表达式或聚集函数</strong>（不过各个列不需要以相同的次序列出）；</li><li>列数据类型必须兼容：类型不必完全相同，但必须是DBSM可以隐式转换的类型；</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><p>《MySQL必知必会》人民邮电出版社</p><p>《MySQL 从入门到精通》清华大学出版社</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;过滤数据&quot;&gt;&lt;a href=&quot;#过滤数据&quot; class=&quot;headerlink&quot; title=&quot;过滤数据&quot;&gt;&lt;/a&gt;过滤数据&lt;/h2&gt;&lt;h3 id=&quot;百分号（-）通配符&quot;&gt;&lt;a href=&quot;#百分号（-）通配符&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
      <category term="sql" scheme="http://yoursite.com/tags/sql/"/>
    
  </entry>
  
  <entry>
    <title>vim基本命令</title>
    <link href="http://yoursite.com/2019/04/04/%E5%85%B6%E4%BB%96/vim%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2019/04/04/%E5%85%B6%E4%BB%96/vim%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/</id>
    <published>2019-04-04T13:22:53.000Z</published>
    <updated>2020-04-05T10:00:38.854Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th><strong>h或者向左箭头</strong></th><th><strong>光标向左移动一个字符</strong></th></tr></thead><tbody><tr><td><strong>j或者向下箭头</strong></td><td><strong>光标向下移动一个字符</strong></td></tr><tr><td><strong>k或者向上箭头</strong></td><td><strong>光标向上移动一个字符</strong></td></tr><tr><td><strong>l或者向右箭头</strong></td><td><strong>光标向右移动一个字符</strong></td></tr><tr><td><strong>Page Down</strong></td><td><strong>屏幕向下移动一页</strong></td></tr><tr><td><strong>Page Up</strong></td><td><strong>屏幕向上移动一页</strong></td></tr><tr><td><strong>n<space></strong></td><td><strong>n表示数字，按下数字再按空格键，光标会向右移动这一行的n个字符</strong></td></tr><tr><td><strong>功能键[Home]</strong></td><td><strong>移动到这一行的最前面字符处</strong></td></tr><tr><td><strong>功能键[End]</strong></td><td><strong>移动到这一行的最后面字符处</strong></td></tr><tr><td><strong>G</strong></td><td><strong>移动到这个文件的最后一行</strong></td></tr><tr><td><strong>nG</strong></td><td><strong>移动到这个文件的第n行</strong></td></tr><tr><td><strong>n<Enter></strong></td><td><strong>光标向下移动n行</strong></td></tr><tr><td><strong>/word</strong></td><td><strong>向光标之下寻找一个名称为word的字符</strong></td></tr><tr><td><strong>:n1,n2s/word1/word2/g</strong></td><td><strong>在第n1与n2行之间寻找word1这个字符串，并将该字符串替换为word2</strong></td></tr><tr><td><strong>:1,$s/word1/word3/g</strong></td><td><strong>在第1与最后一行之间寻找word1这个字符串，并将该字符串替换为word2</strong></td></tr><tr><td><strong>:1,$s/word1/word4/gc</strong></td><td><strong>在第1与最后一行之间寻找word1这个字符串，并将该字符串替换为word2，且在替换前显示提示字符给用户确认是否需要替换</strong></td></tr><tr><td><strong>x与X</strong></td><td><strong>在一行中x为向后删除一个字符(相当于[del]),X为向前删除一个字符(相当于退格键)</strong></td></tr><tr><td><strong>dd</strong></td><td><strong>删除(剪切)光标所在的那一整行</strong></td></tr><tr><td><strong>ndd</strong></td><td><strong>删除(剪切)光标所在的向下n行</strong></td></tr><tr><td><strong>yy</strong></td><td><strong>复制光标所在的那一行</strong></td></tr><tr><td><strong>nyy</strong></td><td><strong>复制光标所在的向下n行</strong></td></tr><tr><td><strong>p与P</strong></td><td><strong>p为将已复制的数据在光标下一行粘贴，P则为粘贴在光标的上一行。</strong></td></tr><tr><td><strong>u</strong></td><td><strong>恢复前一个操作</strong></td></tr><tr><td><strong>[ctrl]+r</strong></td><td><strong>重做上一个操作</strong></td></tr><tr><td><strong>.</strong></td><td><strong>重复前一个操作</strong></td></tr><tr><td><strong>i、a、o</strong></td><td><strong>进入插入模式</strong></td></tr><tr><td><strong>r或者R</strong></td><td><strong>进入替换模式</strong></td></tr><tr><td><strong>[Esc]</strong></td><td><strong>退出编辑模式</strong></td></tr><tr><td><strong>:w</strong></td><td><strong>将编辑的数据写入硬盘中</strong></td></tr><tr><td><strong>:q</strong></td><td><strong>退出vim</strong></td></tr><tr><td><strong>:wq</strong></td><td><strong>保存后退出</strong></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;h或者向左箭头&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;光标向左移动一个字符&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;j或者向下箭头&lt;/
      
    
    </summary>
    
    
      <category term="其他" scheme="http://yoursite.com/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="工具" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Linux进程管理</title>
    <link href="http://yoursite.com/2019/03/27/Linux/Linux%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2019/03/27/Linux/Linux%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</id>
    <published>2019-03-27T09:09:42.000Z</published>
    <updated>2020-03-28T07:09:59.010Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是进程"><a href="#什么是进程" class="headerlink" title="什么是进程"></a>什么是进程</h1><p>如何产生一个进程？程序一般是放置在物理磁盘中，然后通过用户的执行来触发，触发后会加载内存中成为一个个体，这就是进程，为了让系统可以管理这个进程，进程会给予执行者权限/属性等参数，以及进程所需的脚本或数据，最后在给予一个PID。操作系统通过这个PID来判断该进程是否具有执行权限。过程如下图；</p><p><img src="https://raw.githubusercontent.com/yangshenghua97/Image/master/process.png" alt=""></p><p>举个常见的例子，我们在操作Linux的时候通过登录系统分给我们一个shell(bash)终端，这个shell终端具有一个PID，这个<strong><code>PID</code></strong>就是由UID/GID而来。当这个进程执行其他作业时，那么由这个进程衍生出来的其他进程在一般状态下，会沿用这个进程的相关权限。</p><p><strong>关于程序和进程的总结</strong>：</p><ul><li><strong>程序：通常为二进制程序，放置在存储媒介中，以物理文件的形式存在</strong></li><li><strong>进程：程序被触发后，执行者的权限与属性、程序的代码与所需的数据等都会被加载到内存中，操作系统给予这个内存中的单元一个标识符（PID）所以所进程就是一个正在运行时的程序</strong></li></ul><p><strong>程序调用的流程（fork and exec）</strong>：Linux的程序调用通常称为<strong><code>fork-and-exec</code></strong>的流程。进程都会借由父进程以复制（<strong><code>fork</code></strong>）的方式产生一个一模一样的子进程，然后被复制出来的子进程再以<strong><code>exec</code></strong>方式执行实际要执行的进程，最终就成为一个子进程。</p><p>具体流程就像下面的图片</p><p><img src="https://raw.githubusercontent.com/yangshenghua97/Image/master/forkandexec.png" alt=""></p><p>常驻在内存当中的进程通常都是负责一些系统所提供的功能以服务用户的各项任务，因此这些常驻进程称之为<strong>服务</strong></p><h1 id="任务管理"><a href="#任务管理" class="headerlink" title="任务管理"></a>任务管理</h1><h2 id="什么是任务管理"><a href="#什么是任务管理" class="headerlink" title="什么是任务管理"></a>什么是任务管理</h2><p>任务管理是用在bash环境下的，当登录系统获取 bash shell之后，在单一终端下同时执行多个任务的管理操作，执行任务管理的操作中，每个任务都是目前bash的子进程，彼此之间都是有相关性。</p><ul><li><p>前台与后台</p><p>说到终端，这里说一下前台与后台；</p><p>可以出现提示字符让你操作的环境称为前台，其他任务就可以放入后台去暂停或运行，放入后台的任务是不可以使用【ctrl+c】来终止的</p></li></ul><p>要执行bash的任务管理必须要注意的限制：</p><ul><li>这些任务所触发的进程必须是来自你shell的子进程（只管理自己的bash）；</li><li>前台：可以控制与执行命令的这个环境称为前台任务；</li><li>后台：可以自动执行任务，无法使用【ctrl+c】终止，可使用<strong><code>bg</code></strong>、<strong><code>fg</code></strong>（这两个命名后面会讲解）调用该任务；</li><li>后台中【执行】的进程不能等待或输入；</li></ul><h2 id="任务控制的管理"><a href="#任务控制的管理" class="headerlink" title="任务控制的管理"></a>任务控制的管理</h2><ul><li><p>直接将命令扔到后台去执行的<strong><code>&amp;</code></strong></p><p>如果想要同时执行多个任务，利用<strong><code>&amp;</code></strong>可以将某些任务直接丢到后台环境，这样就可以继续操作前台的工作任务</p><p>例如需要后台执行一个java程序可以这样做：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">java </span>-<span class="keyword">jar </span>xxxx.<span class="keyword">jar </span>&amp;</span><br><span class="line">[<span class="number">1</span>] <span class="number">7851</span></span><br></pre></td></tr></table></figure><p>当命令后面加上<strong><code>&amp;</code></strong>代表着该命令丢到后台执行，此时bash会给予这个命令一个<strong>任务号码【job number】</strong>，就如上面代码的那个【1】。后面的7851则是该命令触发的【PID】。当这个任务执行完毕后bash会返回如下信息，表示[1]这个任务已经执行完毕；</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[1]</span>+ <span class="selector-tag">Done</span> <span class="selector-tag">java</span> <span class="selector-tag">-jar</span> <span class="selector-tag">xxxx</span><span class="selector-class">.jar</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>将目前的任务丢到后台中暂停：【<strong><code>ctrl-z</code></strong>】</p><p>将一个正在执行的任务，扔到后台去暂停，使用【ctrl+c】组合键可以实现，使用【ctrl+c】丢到后台当中的任务都是停止状态</p></li></ul><ul><li><p>查看目前的后台任务状态：<strong><code>jobs</code></strong></p><p>命令格式：<strong><code>jobs [-lrs]</code></strong></p><p>选项与参数：</p><p><strong><code>-l</code></strong>：列出【job number】、【PID】与命令串；</p><p><strong><code>-r</code></strong>：仅列出正在后台运行的任务；</p><p><strong><code>-s</code></strong>：仅列出正在后台停止的任务；</p><p>看一个案例：将vim和vi丢到后台</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ vim &amp;</span><br><span class="line">[<span class="number">1</span>] <span class="number">11439</span></span><br><span class="line">$ vi &amp;</span><br><span class="line">[<span class="number">2</span>] <span class="number">11440</span></span><br><span class="line">$ jobs -l</span><br><span class="line">[<span class="number">1</span>]- <span class="number">11439</span> Stopped (tty output)    vim</span><br><span class="line">[<span class="number">2</span>]+ <span class="number">11440</span> Stopped (tty output)    vi</span><br></pre></td></tr></table></figure><p>在上面输出的案例里，有+，-号，<strong><code>+</code></strong>号代表最近被放到后台的任务号码，<strong><code>-</code></strong>号代表最近第二个被放到后台中的任务号码，而第三个以后的任务，就不会有+-号出现</p></li></ul><ul><li><p>将后台任务拿到前台处理：<strong><code>fg</code></strong></p><p>命令格式：<strong><code>fg %jobnumber</code></strong></p><p>以上面案例基础上将vim和vi放到前台：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">jobs</span> -l</span></span><br><span class="line">[1]- 11439 Stopped (tty output)    vim</span><br><span class="line">[2]+ 11440 Stopped (tty output)    vi</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 将vim放到前台处理</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">fg</span> %1</span></span><br><span class="line">vim</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>让任务在后台下的状态变成运行中：<strong><code>bg %jobnumber</code></strong></p><p>将还在后台停止的vi在后台运行</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ bg %<span class="number">1</span></span><br><span class="line">[<span class="number">1</span>]+ vi &amp;</span><br></pre></td></tr></table></figure><p>就像上面的输出结果那样，命令串后面有一个【&amp;】符号，代表该任务别被启动到后台了</p></li></ul><ul><li><p>管理后台当中的任务：<strong><code>kill</code></strong></p><p>如果想要将该任务直接删除或者重新启动，就可以用<strong><code>kill</code></strong>命令，使用这个命名时需要给这个命令一个信号（signal）</p><p>命令格式：<strong><code>kill -signal %jobnumber</code></strong></p><p>选项与参数：</p><p><strong><code>signal</code></strong>：代表后面的接的任务有什么样的指示，下面列举几个常用的信号</p><p><strong><code>-1</code></strong>：重新读取一次参数的配置文件；</p><p><strong><code>-2</code></strong>：表示有键盘输入【ctrl-c】同样的操作；</p><p><strong><code>-9</code></strong>：立刻强制删除一个任务；</p><p><strong><code>-15</code></strong>：以正常的进程方式终止一项任务；</p><p><strong>-9这信号通常是在【强制删除一个不正常的任务】是使用的，-15则是以正常步骤结束一项任务，这个信号也是默认值；</strong></p></li></ul><ul><li><p>脱机运行</p><p>通常登录系统，系统会给当前的登录账号一个终端进程，在这个终端下运行的进程，如果终端退出则这些进程也会同时退出，所以Linux才有脱机管理。</p><p>如果需要退出系统后让进程继续运行，则需要使用<strong><code>nohup</code></strong>命令</p><p>命令格式：<strong><code>nohup [命令与参数]</code></strong>    在终端前台任务</p><p>​            <strong><code>nohup [命令与参数]</code></strong> &amp; 在终端后台任务</p><p><strong><code>nohup</code></strong>命令并不支持bash内置命令,所以命令只能是外部命令。</p></li></ul><h1 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h1><h2 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h2><ul><li>将某个时间点的进程运行情况截取下来：<strong><code>ps</code></strong><ul><li><strong><code>ps aux</code></strong>：查看系统所有的进程</li></ul></li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><blockquote></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;什么是进程&quot;&gt;&lt;a href=&quot;#什么是进程&quot; class=&quot;headerlink&quot; title=&quot;什么是进程&quot;&gt;&lt;/a&gt;什么是进程&lt;/h1&gt;&lt;p&gt;如何产生一个进程？程序一般是放置在物理磁盘中，然后通过用户的执行来触发，触发后会加载内存中成为一个个体，这就是进程，
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>SQL基础（一）</title>
    <link href="http://yoursite.com/2019/03/27/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/SQL%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2019/03/27/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/SQL%E5%9F%BA%E7%A1%80/</id>
    <published>2019-03-27T05:04:38.000Z</published>
    <updated>2020-04-05T10:12:02.303Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章主要以MySQL数据库进行讲解</p><p>在阅读本文之前假设已经安装MySQL数据库。请先构建好数据源，如果没有安装MYSQL数据库可以通过下面的在线网站构建数据源并练习SQL语句</p><p><strong>SQL在线练习网站：<a href="http://sqlfiddle.com/" target="_blank" rel="noopener">http://sqlfiddle.com/</a></strong></p><p><strong>源数据下载：</strong><a href="https://forta.com/wp-content/uploads/books/0672327120/mysql_scripts.zip" target="_blank" rel="noopener">https://forta.com/wp-content/uploads/books/0672327120/mysql_scripts.zip</a></p><hr><h1 id="SQL语言分类"><a href="#SQL语言分类" class="headerlink" title="SQL语言分类"></a>SQL语言分类</h1><p>SQL语言主要分为三类：</p><ul><li>DML（Data Manipulation Language）：数据操作语言，常用的增删改查就属于DML，操作的对象是数据表中的对象。</li><li>DDL（Data  Definition Language）：数据定义语言。建表，建立数据库就属于DDL</li><li>DCL（Data Control Language）：数据控制语言，提交回滚，数据库安全管理等属于DCL</li></ul><p>本文将逐一介绍这三个SQL语言分类的简单讲解。</p><h1 id="检索数据"><a href="#检索数据" class="headerlink" title="检索数据"></a>检索数据</h1><h2 id="SELECT语句"><a href="#SELECT语句" class="headerlink" title="SELECT语句"></a>SELECT语句</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#建products表并插入数据</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> products</span><br><span class="line">(</span><br><span class="line">  prod_id    <span class="built_in">char</span>(<span class="number">10</span>)      <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  vend_id    <span class="built_in">int</span>           <span class="keyword">NOT</span> <span class="literal">NULL</span> ,</span><br><span class="line">  prod_name  <span class="built_in">char</span>(<span class="number">255</span>)     <span class="keyword">NOT</span> <span class="literal">NULL</span> ,</span><br><span class="line">  prod_price <span class="built_in">decimal</span>(<span class="number">8</span>,<span class="number">2</span>)  <span class="keyword">NOT</span> <span class="literal">NULL</span> ,</span><br><span class="line">  prod_desc  <span class="built_in">text</span>          <span class="literal">NULL</span> ,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span>(prod_id)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> products(prod_id, vend_id, prod_name, prod_price, prod_desc)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">'ANV01'</span>, <span class="number">1001</span>, <span class="string">'.5 ton anvil'</span>, <span class="number">5.99</span>, <span class="string">'.5 ton anvil, black, complete with handy hook'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> products(prod_id, vend_id, prod_name, prod_price, prod_desc)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">'ANV02'</span>, <span class="number">1001</span>, <span class="string">'1 ton anvil'</span>, <span class="number">9.99</span>, <span class="string">'1 ton anvil, black, complete with handy hook and carrying case'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> products(prod_id, vend_id, prod_name, prod_price, prod_desc)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">'OL1'</span>, <span class="number">1002</span>, <span class="string">'Oil can'</span>, <span class="number">8.99</span>, <span class="string">'Oil can, red'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> products(prod_id, vend_id, prod_name, prod_price, prod_desc)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">'FU1'</span>, <span class="number">1002</span>, <span class="string">'Fuses'</span>, <span class="number">3.42</span>, <span class="string">'1 dozen, extra long'</span>);</span><br></pre></td></tr></table></figure><h3 id="检索单个列"><a href="#检索单个列" class="headerlink" title="检索单个列"></a>检索单个列</h3><p>语法：<strong><code>SELECT 列名 FROM 表名</code></strong></p><p>检索prod_name列</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SELECT prod_name FROM products;</span><br><span class="line"><span class="comment">#结果为</span></span><br><span class="line">|<span class="string">    prod_name </span>|</span><br><span class="line">|<span class="string">--------------</span>|</span><br><span class="line">|<span class="string"> .5 ton anvil </span>|</span><br><span class="line">|<span class="string">  1 ton anvil </span>|</span><br><span class="line">|<span class="string">        Fuses </span>|</span><br><span class="line">|<span class="string">      Oil can </span>|</span><br></pre></td></tr></table></figure><ul><li>上面的语句利用SELECT语句从products表中检索一个列为prod_name。所需列名在<strong><code>SELECT</code></strong>关键字后面给出，<strong><code>FROM</code></strong>关键字指定要从哪个表检索数据</li></ul><h3 id="检索多个列"><a href="#检索多个列" class="headerlink" title="检索多个列"></a>检索多个列</h3><p>语法：<strong><code>SELECT 列名1,列名2... FROM 表名</code></strong></p><ul><li>要从一个表中检索多个列，使用SELECT语句，后面键入多个列名，列名之间必须以逗号隔开</li></ul><blockquote><p>当心逗号：在选择多个列时，一定要在列名之间加逗号，最后一个列名之后不用加</p></blockquote><p>还是以上面的数据源为例，检索prod_id、prod_name两列</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SELECT prod_id,prod_name FROM products;</span><br><span class="line"><span class="comment">#其结果如下：</span></span><br><span class="line">|<span class="string"> prod_id </span>|<span class="string">    prod_name </span>|</span><br><span class="line">|<span class="string">---------</span>|<span class="string">--------------</span>|</span><br><span class="line">|<span class="string">   ANV01 </span>|<span class="string"> .5 ton anvil </span>|</span><br><span class="line">|<span class="string">   ANV02 </span>|<span class="string">  1 ton anvil </span>|</span><br><span class="line">|<span class="string">     FU1 </span>|<span class="string">        Fuses </span>|</span><br><span class="line">|<span class="string">     OL1 </span>|<span class="string">      Oil can </span>|</span><br></pre></td></tr></table></figure><h3 id="检索所有列"><a href="#检索所有列" class="headerlink" title="检索所有列"></a>检索所有列</h3><p>语法：<strong><code>SELECT * FROM 表名</code></strong></p><ul><li>检索所有列时，给定一个通配符（<strong><code>*</code></strong>）,则会检索表中的所有列。</li></ul><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM products;</span><br><span class="line">prod_id | <span class="type">vend_id</span> | <span class="type">prod_name</span>  | <span class="type">prod_price</span>  | <span class="type">prod_desc</span></span><br><span class="line">  ANV01|  <span class="type">1001</span>  | <span class="type">.5</span> ton anvil |  <span class="type">5</span><span class="number">.99</span>| <span class="type">.5</span> ton anvil, black</span><br><span class="line">  ANV02|  <span class="type">1001</span>  | <span class="type">1</span> ton anvil |  <span class="type">9</span><span class="number">.99</span>    | <span class="type">1</span> ton anvil, black</span><br></pre></td></tr></table></figure><h3 id="检索不同的行（DISTINCT）"><a href="#检索不同的行（DISTINCT）" class="headerlink" title="检索不同的行（DISTINCT）"></a>检索不同的行（DISTINCT）</h3><p>语法：<strong><code>SELECT DISTINCT 列名 FROM 表名</code></strong></p><p>要检索出有不同值的列表，使用<strong><code>DISTINCT</code></strong>关键字，此关键字必须直接放在列名的前面。此关键字指示MySQL只返回不同的值，这里的DISTINCT不能部分使用，它应用于所有列而不仅是前置它的列。</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT DISTINCT vend_id FROM products;</span><br><span class="line">|<span class="string"> vend_id </span>|</span><br><span class="line">|<span class="string">---------</span>|</span><br><span class="line">|<span class="string">    1001 </span>|</span><br><span class="line">|<span class="string">    1002 </span>|</span><br></pre></td></tr></table></figure><h3 id="限制结果（LIMIT）"><a href="#限制结果（LIMIT）" class="headerlink" title="限制结果（LIMIT）"></a>限制结果（LIMIT）</h3><p>限制返回的行数。可以有两个参数，第一个参数为起始行，从 0 开始；第二个参数为返回的总行数。</p><p>语法：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 列名<span class="number">1</span>,列名<span class="number">2</span>,... </span><br><span class="line"><span class="keyword">FROM</span> 表名</span><br><span class="line"><span class="keyword">LIMIT</span> starts,<span class="built_in">count</span>;</span><br></pre></td></tr></table></figure><ul><li><p><strong><code>count</code></strong>：检索取多少行</p></li><li><p><strong><code>starts</code></strong>：从第几行开始，注意这里的开始行从0开始</p></li></ul><p>返回前五行：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> products <span class="keyword">LIMIT</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> products <span class="keyword">LIMIT</span> <span class="number">0</span>,<span class="number">5</span></span><br></pre></td></tr></table></figure><p>带一个值的<strong><code>LIMIT</code></strong>总是从第一行开始，给出的数为返回的行数。带两个值的<strong><code>LIMIT</code></strong>可以指定从行号为第一个值的位置开始。</p><h1 id="过滤数据"><a href="#过滤数据" class="headerlink" title="过滤数据"></a>过滤数据</h1><h2 id="使用WHERE子句"><a href="#使用WHERE子句" class="headerlink" title="使用WHERE子句"></a>使用WHERE子句</h2><p>在SELECT语句中，数据根据<strong><code>WHERE</code></strong>子句中指定的搜索条件进行过滤。WHERE子句在表名后给出。在同时使用<strong><code>ORDER BY</code></strong>和WHERE子句时，应该让ORDER BY位于WHERE之后</p><h3 id="WHERE子句操作符"><a href="#WHERE子句操作符" class="headerlink" title="WHERE子句操作符"></a>WHERE子句操作符</h3><p>语法：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 列名<span class="number">1</span>,列名<span class="number">2</span>,<span class="params">...</span> </span><br><span class="line">FROM 表名</span><br><span class="line"><span class="keyword">WHERE</span> 条件</span><br></pre></td></tr></table></figure><p>MYSQL支持以下所有条件操作符：</p><table><thead><tr><th>操作符</th><th>说明</th></tr></thead><tbody><tr><td>=</td><td>等于</td></tr><tr><td>&lt;&gt;</td><td>不等于</td></tr><tr><td>!=</td><td>不等于</td></tr><tr><td>&lt;</td><td>小于</td></tr><tr><td>&lt;=</td><td>小于等于</td></tr><tr><td>&gt;</td><td>大于</td></tr><tr><td>&gt;=</td><td>大于等于</td></tr><tr><td>BETWEEN</td><td>在指定的两个值之间</td></tr><tr><td>IS NULL</td><td>为NULL值</td></tr></tbody></table><h3 id="过滤单个值"><a href="#过滤单个值" class="headerlink" title="过滤单个值"></a>过滤单个值</h3><p>过滤prod_name=’fuses’的数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name,prod_price</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_name=<span class="string">'fuses'</span>;</span><br></pre></td></tr></table></figure><p>过滤价格小于10元的数据 </p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name,prod_price</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_price&lt;<span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>过滤价格小于等于10元的数据</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name,prod_price</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_price&lt;=<span class="number">10</span>;</span><br></pre></td></tr></table></figure><h3 id="过滤不匹配"><a href="#过滤不匹配" class="headerlink" title="过滤不匹配"></a>过滤不匹配</h3><p>过滤vend_id不是1002的数据</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name,prod_price</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> vend_id != <span class="number">1002</span>;</span><br></pre></td></tr></table></figure><blockquote><p>如果条件值为字符串类型，则需要引用引号，如果条件值为数值类型，则不需要引用引号</p></blockquote><h3 id="过滤范围值-BETWEEN"><a href="#过滤范围值-BETWEEN" class="headerlink" title="过滤范围值(BETWEEN)"></a>过滤范围值(BETWEEN)</h3><p>如果需要检查某个范围的值，可以使用<strong><code>BETWEEN</code></strong>操作符。其语法与其他WHERE子句的操作符不同。BETWEEN需要两个值，过滤范围的开始值和结束值。在范围使用BETWEEN时，必须指定两个值——所需范围的低端值和高端值。这两个值必须用<strong><code>AND</code></strong>关键字分隔。BETWEEN匹配范围中的所有值，包括指定的开始值和结束值。</p><p>过滤价格在5元和10元之间的所有产品</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name,prod_price</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_price <span class="keyword">BETWEEN</span> <span class="number">5</span> <span class="keyword">AND</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure><h3 id="空值过滤-IS-NULL"><a href="#空值过滤-IS-NULL" class="headerlink" title="空值过滤(IS NULL)"></a>空值过滤(IS NULL)</h3><p>WHERE子句 <strong><code>IS NULL</code></strong>用来检查具有<strong>NULL</strong>值的列。</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_price <span class="keyword">IS</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><h2 id="组合WHERE子句"><a href="#组合WHERE子句" class="headerlink" title="组合WHERE子句"></a>组合WHERE子句</h2><h3 id="AND操作符"><a href="#AND操作符" class="headerlink" title="AND操作符"></a><strong><code>AND</code></strong>操作符</h3><p>为了通过不止一个列在过滤，可使用<strong><code>AND</code></strong>操作符给WHERE子句附加条件，用来指示检索满足所有给定的条件的行。</p><p>案例：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_id,prod_price,prod_name</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> vend_id = <span class="number">1003</span> <span class="keyword">AND</span> prod_price &lt;= <span class="number">10</span>;</span><br></pre></td></tr></table></figure><h3 id="OR操作符："><a href="#OR操作符：" class="headerlink" title="OR操作符："></a><strong><code>OR</code></strong>操作符：</h3><p>用于过滤检索匹配任意一条件的行</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_id,prod_price,prod_name</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> vend_id = <span class="number">1003</span> <span class="keyword">OR</span> prod_price &lt;= <span class="number">10</span>;</span><br></pre></td></tr></table></figure><h3 id="IN操作符"><a href="#IN操作符" class="headerlink" title="IN操作符"></a><strong><code>IN</code></strong>操作符</h3><p><strong><code>IN</code></strong>操作符用于指定条件范围，范围中每个条件都可以进行匹配。<strong>IN</strong>在WHERE中用来指定匹配值的关键字，功能与OR相当</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name,prod_price</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> vend_id <span class="keyword">IN</span>(<span class="number">1002</span>,<span class="number">1003</span>)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_name;</span><br></pre></td></tr></table></figure><p><strong><code>IN</code></strong>操作符的优点如下：</p><ul><li>当需要匹配的值比较多时，IN操作符的语法更清楚且更直观；</li><li><strong>IN</strong>操作符一般比OR操作符执行更快；</li><li>在使用<strong>IN</strong>时，计算的次序更容易管理；</li><li><strong>IN</strong>的一最大优点就是可以包含其他SELECT语句，使得能够更动态地建立WHERE子句；</li></ul><h3 id="NOT操作符："><a href="#NOT操作符：" class="headerlink" title="NOT操作符："></a><strong><code>NOT</code></strong>操作符：</h3><p><strong><code>NOT</code></strong>用在WHERE子句中，用来否定后跟的条件表达式，MYSQL中的NOT，支持NOT对IN，BETWEEN和EXISTS子句取反。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><blockquote><p>《MySQL必知必会》人民邮电出版社</p><p>《MySQL 从入门到精通》清华大学出版社</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这篇文章主要以MySQL数据库进行讲解&lt;/p&gt;
&lt;p&gt;在阅读本文之前假设已经安装MySQL数据库。请先构建好数据源，如果没有安装MYSQL数据库可以通过下面的在线网站构建数据源并练习SQL语句&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SQL在线练习网站：&lt;a href=&quot;http:/
      
    
    </summary>
    
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
      <category term="sql" scheme="http://yoursite.com/tags/sql/"/>
    
  </entry>
  
  <entry>
    <title>Linux账号管理与权限设置</title>
    <link href="http://yoursite.com/2019/03/21/Linux/Linux%E8%B4%A6%E5%8F%B7%E7%AE%A1%E7%90%86%E4%B8%8E%E6%9D%83%E9%99%90%E8%AE%BE%E7%BD%AE/"/>
    <id>http://yoursite.com/2019/03/21/Linux/Linux%E8%B4%A6%E5%8F%B7%E7%AE%A1%E7%90%86%E4%B8%8E%E6%9D%83%E9%99%90%E8%AE%BE%E7%BD%AE/</id>
    <published>2019-03-21T09:47:17.000Z</published>
    <updated>2020-03-21T09:52:13.908Z</updated>
    
    <content type="html"><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h2&gt;&lt;blockquote&gt;
&lt;/blockquote&gt;

      
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>文件与文件系统压缩</title>
    <link href="http://yoursite.com/2019/03/20/Linux/%E6%96%87%E4%BB%B6%E4%B8%8E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%8E%8B%E7%BC%A9/"/>
    <id>http://yoursite.com/2019/03/20/Linux/%E6%96%87%E4%BB%B6%E4%B8%8E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%8E%8B%E7%BC%A9/</id>
    <published>2019-03-20T06:42:11.000Z</published>
    <updated>2020-03-21T09:50:50.125Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Linux系统常见的压缩命令"><a href="#Linux系统常见的压缩命令" class="headerlink" title="Linux系统常见的压缩命令"></a>Linux系统常见的压缩命令</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">*<span class="selector-class">.z</span> <span class="selector-tag">compress</span>程序压缩的文件；</span><br><span class="line">*<span class="selector-class">.zip</span> <span class="selector-tag">zip</span>程序压缩的文件；</span><br><span class="line">*<span class="selector-class">.gz</span> <span class="selector-tag">gzip</span>程序压缩的文件；</span><br><span class="line">*<span class="selector-class">.bz2</span> <span class="selector-tag">bzip2</span>程序压缩的文件；</span><br><span class="line">*<span class="selector-class">.xz</span> <span class="selector-tag">xz</span>程序压缩的文件；</span><br><span class="line">*<span class="selector-class">.tar</span> <span class="selector-tag">tar</span>程序打包的文件，并没有压缩过；</span><br><span class="line">*<span class="selector-class">.tar</span><span class="selector-class">.gz</span> <span class="selector-tag">tar</span>程序打包的文件，并经过<span class="selector-tag">gzip</span>的压缩</span><br><span class="line">*<span class="selector-class">.tar</span><span class="selector-class">.bz2</span> <span class="selector-tag">tar</span>程序打包的文件，并经过<span class="selector-tag">bzip2</span>的压缩</span><br><span class="line">*<span class="selector-class">.tar</span><span class="selector-class">.xz</span> <span class="selector-tag">tar</span>程序打包的文件，并经过<span class="selector-tag">xz</span>的压缩</span><br></pre></td></tr></table></figure><ul><li><p>gzip，zcat</p><p><strong><code>gzip</code></strong>可以说是应用最广泛的压缩命令。下面介绍这些命令;</p><ul><li><p><strong><code>gzip [-cdtv#] 文件名</code></strong></p><p>选项和参数：</p><p><strong><code>-c</code></strong>：将压缩的数据输出到屏幕上，可通过数据流重定向来处理；</p><p><strong><code>-d</code></strong>：解压缩的参数</p><p><strong><code>-t</code></strong>：可以用来检验一个压缩文件的一致性，看看文件是否有误</p><p><strong><code>-#</code></strong>：#表示压缩级别，-1最快，但压缩比最差，-9最慢，压缩比最好，默认为-6</p></li></ul></li><li><p>xz，xzcat</p><p>命令格式</p><p><strong><code>xz [-dtlkc#] 文件名</code></strong></p><p><strong><code>xcat 文件名.xz</code></strong></p><p>选项与参数:</p><p><strong><code>-d</code></strong>：解压缩；</p><p><strong><code>-t</code></strong>：测试压缩文件的完整性；</p><p><strong><code>-l</code></strong>：列出压缩文件的相关信息；</p><p><strong><code>-k</code></strong>：保留原本文件不删除</p><p><strong><code>-c</code></strong>：将数据在屏幕上输出</p><p><strong><code>-#</code></strong>：压缩级别</p></li></ul><h3 id="打包名命名：tar"><a href="#打包名命名：tar" class="headerlink" title="打包名命名：tar"></a>打包名命名：<strong><code>tar</code></strong></h3><p>命名格式：<br><strong><code>tat [-z][-j][-J][cv][-f 待建里的文件名] filename ...</code></strong>：打包与压缩<br><strong><code>tar [-z][-j][-J][tv][-f 既有的tar文件名]</code></strong>：查看文件名<br><strong><code>tar [-z][-j][-J][xv][-f 既有的tar文件名] [-C 目录]</code></strong>：解压缩<br>选项与参数：<br><strong><code>-c</code></strong>：建立打包文件，可搭配-v来查看过程中被打包的文件名；<br><strong><code>-t</code></strong>：查看打包文件的内容含有哪些文件名，重点看文件名；<br><strong><code>-x</code></strong>：解包或解压缩，可以搭配<strong><code>-C</code></strong>在特定目录解压；<br><strong><code>-z</code></strong>：通过gzip的支持进行压缩/解压缩：此时文件名最好为<strong>*.tar.gz</strong>；<br><strong><code>-C 目录</code></strong>：若要在特定目录解压缩，可以使用这个选项；<br><strong><code>-f finame</code></strong>：<strong>-f</strong>后面要立刻接要被处理的文件名<br><strong><code>--exclude=FILE</code></strong>：在压缩过程中，不要将FILE打包<br>注意：<strong><code>-c、-t、-x</code></strong>不可同时出现<br>常使用的命令组合：<br><strong><code>tar -zcvf filename.tar.gz</code></strong>、<strong><code>tar -jcvf filename.tar.bz2</code></strong>：压缩<br><strong><code>tar -ztvf filename.tar.gz</code></strong>、<strong><code>tar -jtvf filename.tar.bz2</code></strong>：查询<br><strong><code>tar -zxvf filename.tar.gz -C 目录</code></strong>、<strong><code>tar -jxvf filename.tar.bz2 -C 目录</code></strong>：解压缩</p><h3 id="常见的压缩与备份工具"><a href="#常见的压缩与备份工具" class="headerlink" title="常见的压缩与备份工具"></a>常见的压缩与备份工具</h3><h4 id="dd"><a href="#dd" class="headerlink" title="dd"></a>dd</h4><p>命令格式：<strong><code>dd if=input_file of=output_file bs=block_size count=number</code></strong></p><p>选项与参数：</p><p><strong><code>if</code></strong>：输如设备</p><p><strong><code>of</code></strong>：输出设备</p><p><strong><code>bs</code></strong>：设置的一个block的大小，若未指定则默认是512Bytes（一个扇区大小）</p><p><strong><code>count</code></strong>：多少个bs</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Linux系统常见的压缩命令&quot;&gt;&lt;a href=&quot;#Linux系统常见的压缩命令&quot; class=&quot;headerlink&quot; title=&quot;Linux系统常见的压缩命令&quot;&gt;&lt;/a&gt;Linux系统常见的压缩命令&lt;/h3&gt;&lt;figure class=&quot;highlight 
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux的文件与目录管理</title>
    <link href="http://yoursite.com/2019/03/18/Linux/Linux%E7%9A%84%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2019/03/18/Linux/Linux%E7%9A%84%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/</id>
    <published>2019-03-18T13:40:17.000Z</published>
    <updated>2020-03-21T06:31:51.518Z</updated>
    
    <content type="html"><![CDATA[<h3 id="目录相关操作"><a href="#目录相关操作" class="headerlink" title="目录相关操作"></a>目录相关操作</h3><p>对于目录相关的命名首先要介绍的一个命令是目录切换命令：<strong><code>cd</code></strong></p><p>还有一些比较特殊的目录：</p><ul><li><strong><code>.</code></strong>：代表此层目录；</li><li><strong><code>..</code></strong>：代表上一层目录；</li><li><strong><code>-</code></strong>：代表前一个工作目录；</li><li><strong><code>~</code></strong>：代表目前使用者身份所在的家目录</li><li><strong><code>~account</code></strong>：代表<strong>account</strong>这个使用者的家目录</li></ul><h4 id="处理目录的命令："><a href="#处理目录的命令：" class="headerlink" title="处理目录的命令："></a>处理目录的命令：</h4><ul><li><p><strong><code>cd（change directory）</code></strong>：切换目录</p><p>命令格式：<strong><code>cd [相对路径或绝对路径]</code></strong></p><p><strong>利用相对路径的写法必须确认的目前的路径才能正确地去到想要的目录</strong></p><p>下面看几个例子</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#切换到tmp目录</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> /tmp</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">pwd</span></span></span><br><span class="line">/tmp</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#回到家目录</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> ~</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">pwd</span></span></span><br><span class="line">/root</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#回到上一次的工作目录</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> -</span></span><br><span class="line">/tmp</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#当前的工作目录在/tmp，回到上一级目录</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> ..</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">pwd</span></span></span><br><span class="line">/</span><br></pre></td></tr></table></figure></li><li><p><strong><code>pwd（显示目前所在的目录）</code></strong></p><p>命令格式：<strong><code>pwd [-p]</code></strong></p><p>​                    选项与参数：-p：显示出真正的目录，而非使用链接路径</p></li><li><p><strong><code>mkdir</code></strong>：建立新目录</p><p>命令格式</p><p><strong><code>mkdir [-mp] 目录名称</code></strong></p><p>选项与参数：</p><p><strong><code>-m</code></strong>：设置文件的权限。直接设置，不需使用默认权限（<strong>umask</strong>）</p><p><strong><code>-p</code></strong>：递归创建子目录</p><p>下面举几个例子：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在当前的工作目录下创建test0目录</span></span><br><span class="line"><span class="string">$</span> <span class="string">mkdir</span> <span class="string">test0</span></span><br><span class="line"><span class="string">drwxr-xr-x</span> <span class="number">2</span> <span class="string">root</span> <span class="string">root</span> <span class="number">4096</span> <span class="string">Mar</span> <span class="number">19</span> <span class="number">16</span><span class="string">:58</span> <span class="string">test0</span></span><br><span class="line"><span class="comment">##在当前的工作目录下递归创建test1/test2/test3这样的多层目录</span></span><br><span class="line"><span class="string">$</span> <span class="string">mkdir</span> <span class="string">-p</span> <span class="string">test1/test2/test3</span></span><br></pre></td></tr></table></figure><p>一般创建目录大都是使用默认权限（umask），mkdir可以在创建目录时可以指定权限，例如：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir -m <span class="number">711</span> test2</span><br><span class="line">drwx--x--x <span class="number">2</span> root root <span class="number">4096</span> Mar <span class="number">19</span> <span class="number">17</span>:<span class="number">07</span> test2</span><br></pre></td></tr></table></figure></li><li><p><strong><code>rmdir</code></strong>：删除“空”目录<br>命令格式：rmdir [-p] 目录名称<br>被删除的目录里不能存在其他的文件和目录，如果想要一次性删除一个目录以及该目录其下的子目录可以使用<strong><code>rm -rf 目录名称</code></strong>,但这样不是太安全，还是使用<strong><code>rmdir</code></strong>比较安全。</p></li></ul><h4 id="文件与目录管理"><a href="#文件与目录管理" class="headerlink" title="文件与目录管理"></a>文件与目录管理</h4><h5 id="文件与目录查看：ls"><a href="#文件与目录查看：ls" class="headerlink" title="文件与目录查看：ls"></a>文件与目录查看：<strong><code>ls</code></strong></h5><p>命名格式：<strong><code>ls [-adlh]</code></strong> 文件名或目录名称</p><p>选项参数：</p><p><strong><code>-a</code></strong>：全部的文件，包括隐藏文件（开头为.的文件）一起列出</p><p><strong><code>-d</code></strong>：仅列出目录本身，而不是列出目录内的文件数据</p><p><strong><code>-h</code></strong>：将文件大小以及人类易读的方式（GB，KB，MB）列出</p><p><strong><code>-l</code></strong>：详细信息显示，包括文件的属性与权限等数据</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">##列出root目录下的所有文件</span><br><span class="line">$ ls -al ~</span><br><span class="line">dr-xr-x---.  <span class="number">9</span> root root <span class="number">4096</span> Mar <span class="number">19</span> <span class="number">17</span>:<span class="number">07</span> .</span><br><span class="line">dr-xr-xr-x. <span class="number">18</span> root root <span class="number">4096</span> Mar <span class="number">14</span> <span class="number">16</span>:<span class="number">57</span> ..</span><br><span class="line">-rw-------   <span class="number">1</span> root root <span class="number">5185</span> Mar <span class="number">18</span> <span class="number">23</span>:<span class="number">42</span> .bash_history</span><br><span class="line">······</span><br><span class="line">drwxr-xr-x   <span class="number">2</span> root root <span class="number">4096</span> Mar <span class="number">19</span> <span class="number">16</span>:<span class="number">58</span> test0</span><br><span class="line">drwxr-xr-x   <span class="number">3</span> root root <span class="number">4096</span> Mar <span class="number">19</span> <span class="number">17</span>:<span class="number">00</span> test1</span><br><span class="line">drwx--x--x   <span class="number">2</span> root root <span class="number">4096</span> Mar <span class="number">19</span> <span class="number">17</span>:<span class="number">07</span> test2</span><br><span class="line">-rw-rw-rw-   <span class="number">1</span> root root    <span class="number">0</span> Mar <span class="number">18</span> <span class="number">01</span>:<span class="number">49</span> test.txt</span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">##列出root目录下的所有文件,以人类易读的方式</span><br><span class="line">$ ls -alh ~</span><br><span class="line">dr-xr-x---.  <span class="number">9</span> root root <span class="number">4.0</span>K Mar <span class="number">19</span> <span class="number">17</span>:<span class="number">07</span> .</span><br><span class="line">dr-xr-xr-x. <span class="number">18</span> root root <span class="number">4.0</span>K Mar <span class="number">14</span> <span class="number">16</span>:<span class="number">57</span> ..</span><br><span class="line">-rw-------   <span class="number">1</span> root root <span class="number">5.1</span>K Mar <span class="number">18</span> <span class="number">23</span>:<span class="number">42</span> .bash_history</span><br><span class="line">······</span><br><span class="line">drwxr-xr-x   <span class="number">2</span> root root <span class="number">4.0</span>K Mar <span class="number">19</span> <span class="number">16</span>:<span class="number">58</span> test0</span><br><span class="line">drwxr-xr-x   <span class="number">3</span> root root <span class="number">4.0</span>K Mar <span class="number">19</span> <span class="number">17</span>:<span class="number">00</span> test1</span><br><span class="line">drwx--x--x   <span class="number">2</span> root root <span class="number">4.0</span>K Mar <span class="number">19</span> <span class="number">17</span>:<span class="number">07</span> test2</span><br><span class="line">-rw-rw-rw-   <span class="number">1</span> root root    <span class="number">0</span> Mar <span class="number">18</span> <span class="number">01</span>:<span class="number">49</span> test.txt</span><br></pre></td></tr></table></figure><h4 id="复制、删除、移动：cp、rm、mv"><a href="#复制、删除、移动：cp、rm、mv" class="headerlink" title="复制、删除、移动：cp、rm、mv"></a>复制、删除、移动：<strong><code>cp</code></strong>、<strong><code>rm</code></strong>、<strong><code>mv</code></strong></h4><ul><li><p><strong><code>cp</code></strong>:复制文件或目录</p><p>命令格式：<strong><code>cp [-ipr] 源文件（source） 目标文件（dest）</code></strong></p><p>选项与参数：</p><p><strong><code>-a</code></strong>：参考下面的<strong><code>-dr</code></strong>选项</p><p><strong><code>-d</code></strong>：若源文件为链接文件属性，则复制链接文件属性而非文件本身</p><p><strong><code>-i</code></strong>：若目标文件已经存在，在覆盖时会先询问操作的进行</p><p><strong><code>-p</code></strong>：连同文件的属性一起复制，不使用默认属性</p><p><strong><code>-r</code></strong>：递归复制，用于目录的复制操作</p><p>在默认的条件中，<strong><code>cp</code></strong>的源文件与目标文件的权限是不同的，目标文件的拥有者通常会是命令操作本身。</p></li><li><p><strong><code>rm</code></strong>（删除文件或目录）</p><p>命令格式：<strong><code>rm [-fir] 文件或目录</code></strong></p><p>选项与参数：</p><p><strong><code>-f</code></strong>：强制的意思</p><p><strong><code>-I</code></strong>：交互模式，在删除之前会询问使用是否操作</p><p><strong><code>-r</code></strong>：递归删除</p><p>通常这个命令在使用时要十分小心，在删除前要认真确定删除的文件或目录是否正确，避免误删除的情况</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#删除test1文件夹</span></span><br><span class="line"><span class="meta">#连同目录下的所有子目录一并强制删除</span></span><br><span class="line">$ rm -rf test1 </span><br><span class="line"><span class="meta">#删除文件也是如此</span></span><br></pre></td></tr></table></figure></li><li><p><strong><code>mv（移动文件与目录或重命名）</code></strong></p><p>命令格式：<strong><code>mv [-fiu] source dest</code></strong></p><p>选项与参数：</p><p><strong><code>-f</code></strong>：强制执行</p><p><strong><code>-i</code></strong>：若目标文件已经存在，会询问是否覆盖</p><p><strong><code>-u</code></strong>：若目标文件已存在，且<strong>source</strong>比较新，才会更新</p><p>这里举几个例子：</p><p>将<strong>test.txt</strong>文件移动到<strong>test0</strong>文件夹中</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mv <span class="keyword">test</span>.txt test0</span><br><span class="line">$ <span class="keyword">ls</span> test0</span><br><span class="line"><span class="keyword">test</span>.txt</span><br></pre></td></tr></table></figure><p>将<strong>test0</strong>文件夹重命名为<strong>test3</strong></p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>mv test0 test4</span><br><span class="line"><span class="variable">$ </span>ls .</span><br><span class="line">test3</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>修改文件时间或创建新文件：<strong><code>touch</code></strong></p><p>命令格式：<strong><code>touch [-acdmt] 文件名</code></strong></p><p>选项与参数：</p><p>​    <strong><code>-a</code></strong>：仅自定义access time；</p><p>​    <strong><code>-c</code></strong>：仅修改文件时间，若该文件不存在则不创建新文件；</p><p>​    <strong><code>-d</code></strong>：后面可以接想要自定义的日期而不用目前的日期；</p><p>​    <strong><code>-m</code></strong>：修改mtime</p><p>​    <strong><code>-t</code></strong>：后面可以接想要自定义的时间而不是使用目前的日期，格式为[YYYYMMDDhhmm]</p><p>touch命令最常用的情况是：</p><ul><li><strong>创建一个空文件</strong></li><li><strong>将某个文件日期自定义为目前</strong></li></ul><p>举几个例子：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#创建一个空文件</span><br><span class="line">$ touch test1</span><br><span class="line">-rw-r--r--  <span class="number">1</span> root root <span class="number">0</span> Mar <span class="number">21</span> <span class="number">12</span>:<span class="number">03</span> test1</span><br><span class="line">#修改日期为：<span class="number">2020</span>/<span class="number">02</span>/<span class="number">21</span> <span class="number">00</span>:<span class="number">00</span></span><br><span class="line">$ touch -t <span class="number">202002210000</span> test1</span><br><span class="line">-rw-r--r--  <span class="number">1</span> root root <span class="number">0</span> Feb <span class="number">21</span> <span class="number">00</span>:<span class="number">00</span> test1</span><br></pre></td></tr></table></figure><h3 id="文件与目录的默认权限与隐藏权限"><a href="#文件与目录的默认权限与隐藏权限" class="headerlink" title="文件与目录的默认权限与隐藏权限"></a>文件与目录的默认权限与隐藏权限</h3><h4 id="文件默认权限：umask"><a href="#文件默认权限：umask" class="headerlink" title="文件默认权限：umask"></a>文件默认权限：<strong><code>umask</code></strong></h4><p>umask是指定目前用户在创建文件或者目录时的权限默认值。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">使用<span class="built_in">umask</span>查看默认权限</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">umask</span></span></span><br><span class="line">0022 //与一般权限有关的是后面三个数字</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">umask</span> -S</span></span><br><span class="line">u=rwx,g=rx,o=rx</span><br></pre></td></tr></table></figure><p>默认情况下：</p><ul><li><p>若用户创建文件则默认没有（x）执行权限，也就是只有<strong><code>rw</code></strong>这两个项目,也就是最大为666，默认权限为：</p><p> <strong><code>-rw-rw-rw-</code></strong></p></li><li><p>若用户创建目录则由于x是与是否可以进入目录有关的，因此默认为所有权限均开放，即777</p><p><strong><code>drwxrwxrwx</code></strong></p></li></ul></li></ul><p><strong>umaks的数字指的是该默认值需要减掉的权限</strong></p><p>通过上面<strong><code>umask=0022</code></strong>进行说明。因为umask=0022，user没有被拿掉任何权限，group与others的权限被拿掉了2（也就是<strong>w</strong>权限）（r、w、x每个权限的数字在《Linux文件权限与目录简介》一篇中介绍过）那么用户：</p><ul><li><strong>创建文件时：（-rw-rw-rw-）-（- - - - - w - - w -）==&gt; - rw-r- -r- - ,最后创建文件时的权限：666-022=644</strong></li><li><strong>创建目录时：（drwxrwxrwx）-（d - - - - w- - w-）==&gt; drwxr-xr-x最后创建目录时的权限：777-022=755</strong></li></ul><p>创建一个文件和一个目录：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ umask</span><br><span class="line"><span class="number">0022</span></span><br><span class="line">$ touch test0</span><br><span class="line"><span class="number">666</span><span class="number">-022</span>=<span class="number">644</span></span><br><span class="line">-rw-r--r--  <span class="number">1</span> root root <span class="number">0</span> Mar <span class="number">21</span> <span class="number">12</span>:<span class="number">49</span> test0</span><br><span class="line"> <span class="number">6</span>  <span class="number">4</span>  <span class="number">4</span></span><br><span class="line">#创建目录</span><br><span class="line">$ mkdir test.d</span><br><span class="line"><span class="number">777</span><span class="number">-022</span>=<span class="number">755</span></span><br><span class="line">drwxr-xr-x  <span class="number">2</span> root roo <span class="number">4096</span> Mar <span class="number">21</span> <span class="number">12</span>:<span class="number">53</span> test.d</span><br><span class="line">  <span class="number">7</span>  <span class="number">5</span>  <span class="number">5</span></span><br></pre></td></tr></table></figure><h4 id="文件隐藏属性"><a href="#文件隐藏属性" class="headerlink" title="文件隐藏属性"></a>文件隐藏属性</h4><ul><li><p>配置文件隐藏属性：<strong><code>chattr [+-=][ASacdistu] 文件或目录名称</code></strong></p><p>常用选项与参数：<br><strong><code>+</code></strong>：增加某个特殊参数，其他原本存在参数不动；<br><strong><code>-</code></strong>：减少某个特殊参数，其他原本存在参数不动；<br><strong><code>=</code></strong>：直接设置参数，且仅有后面接的参数；<br><strong><code>a</code></strong>：当设置这个<strong>a</strong>之后，这个文件将只能增加数据，而不能删除也不能修改数据，只有root才能设置这个属性；<br><strong><code>i</code></strong>：当设置<strong>i</strong>之后，可以让一个文件不能被删除、改名、设置链接也无法写入或新增数据；</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>touch test23</span><br><span class="line"><span class="variable">$ </span>chattr +i test23</span><br><span class="line"><span class="variable">$ </span>rm -rf test23</span><br><span class="line"><span class="comment">#不能删除</span></span><br><span class="line"><span class="symbol">rm:</span> cannot remove test23：Operation <span class="keyword">not</span> permitted</span><br></pre></td></tr></table></figure></li><li><p>显示文件隐藏属性：<strong><code>lsattr [-adR] 文件或目录</code></strong></p><p>选项与参数：</p><p><strong><code>-a</code></strong>：将隐藏文件的属性显示出来</p><p><strong><code>-d</code></strong>：如果接的目录，仅列出目录本身的属性而非目录内的文件名</p><p><strong><code>-R</code></strong>：连同子目录的数据也一并列出来</p><p>接着上面的例子：</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">$</span> <span class="comment">lsattr</span> <span class="literal">-</span><span class="comment">aR</span> <span class="comment">test23</span></span><br><span class="line"><span class="comment"></span>--<span class="literal">-</span><span class="literal">-</span><span class="comment">i</span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">e</span>-- <span class="comment">test23</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="命令与文件的查找"><a href="#命令与文件的查找" class="headerlink" title="命令与文件的查找"></a>命令与文件的查找</h4><h5 id="脚本文件查找"><a href="#脚本文件查找" class="headerlink" title="脚本文件查找"></a>脚本文件查找</h5><ul><li><p>查找执行文件：<strong><code>which [-a] command</code></strong></p><p>选项或参数：</p><p><strong><code>-a</code></strong>：将所有由PATH目录中可以找到的命令均列出，而不止第一个被找到的命令名称</p><p>这个命令是根据【PATH】这个环境变量所规范的路径，去查找执行文件的文件名。</p></li></ul><h5 id="文件查找"><a href="#文件查找" class="headerlink" title="文件查找"></a>文件查找</h5><ul><li><p>由一些特定的目录中查找文件：<strong><code>whereis [-bmsu] 文件或目录</code></strong></p><p>选项与参数：</p><p><strong><code>-l</code></strong>：可以列出whereis会去查询的几个主要目录；</p><p><strong><code>-b</code></strong>：只找binary（二进制）格式文件；</p><p><strong><code>-m</code></strong>：只找在说明文件manual路径下的文件；</p><p><strong><code>-s</code></strong>：只找source源文件；</p><p><strong><code>-u</code></strong>：查找不在上述三个项目当中的其他特殊文件；</p></li><li><p><strong><code>locate [-ir] keyword</code></strong></p><p>选项与参数：</p><p><strong><code>-i</code></strong>：忽略大小写的差异；</p><p><strong><code>-c</code></strong>：不输出文件名，计算找到的文件数量；</p><p><strong><code>-l</code></strong>：仅输出几行的意思；</p><p><strong><code>-S</code></strong>：输出locate所使用的数据库文件的相关信息，包括该数据库记录文件/目录数量等；</p><p><strong><code>-r</code></strong>：后面可接正则表达式的显示方式；</p></li><li><p><strong><code>find [PATH] [option] [action]</code></strong>没事别用这个命令神慢~</p></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><p>《鸟哥的Linux私房菜—基础学习篇（第四版）》 鸟哥著 人民邮电出版社</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;目录相关操作&quot;&gt;&lt;a href=&quot;#目录相关操作&quot; class=&quot;headerlink&quot; title=&quot;目录相关操作&quot;&gt;&lt;/a&gt;目录相关操作&lt;/h3&gt;&lt;p&gt;对于目录相关的命名首先要介绍的一个命令是目录切换命令：&lt;strong&gt;&lt;code&gt;cd&lt;/code&gt;&lt;/st
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
</feed>
