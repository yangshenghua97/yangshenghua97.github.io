<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>楊さんノート</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-06-28T04:01:46.369Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>杨生华</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spark大数据快速分析学习笔记（RDD编程）</title>
    <link href="http://yoursite.com/2020/06/27/Spark%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BF%AB%E9%80%9F%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2020/06/27/Spark%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BF%AB%E9%80%9F%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2020-06-27T15:07:07.000Z</published>
    <updated>2020-06-28T04:01:46.369Z</updated>
    
    <content type="html"><![CDATA[<h3 id="RDD编程基础"><a href="#RDD编程基础" class="headerlink" title="RDD编程基础"></a>RDD编程基础</h3><p>1.何为RDD？RDD的全名叫做<strong>弹性分布式数据集</strong>，其实就是分布式的元素集合。</p><p>RDD支持两种类型的操作：转化操作(<strong><code>Transformation</code></strong>) 和 行为操作(<strong><code>action</code></strong>)。转化操作会由一个RDD生成一个新的RDD。行为操作会对RDD计算出一个结果，并把结果返回到驱动器程序中，或把结果存储到外部的存储系统。</p><h3 id="创建RDD"><a href="#创建RDD" class="headerlink" title="创建RDD"></a>创建RDD</h3><p>创建RDD有两种方式：读取外部数据集、驱动程序中对一个集合进行并行化</p><p>创建RDD最简单的方式是把程序中一个已有的集合传递给SparkContext的parallelize()方法，这种方式不怎么常用，常用的方式是读取外部数据集</p><p>下面的代码就是从外部数据（HDFS）中创建RDD</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> infile = sc.text<span class="constructor">File(<span class="string">"hdfs://master:9000/datafile"</span>)</span></span><br></pre></td></tr></table></figure><p><strong><code>sc.textFile()</code></strong>是一个将文本文件读入为一个存储字符串的RDD方法</p><h3 id="RDD操作"><a href="#RDD操作" class="headerlink" title="RDD操作"></a>RDD操作</h3><ul><li><h4 id="转化操作"><a href="#转化操作" class="headerlink" title="转化操作"></a>转化操作</h4></li><li><h4 id="行为操作"><a href="#行为操作" class="headerlink" title="行为操作"></a>行为操作</h4></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><p>《Spark大数据快速分析》</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;RDD编程基础&quot;&gt;&lt;a href=&quot;#RDD编程基础&quot; class=&quot;headerlink&quot; title=&quot;RDD编程基础&quot;&gt;&lt;/a&gt;RDD编程基础&lt;/h3&gt;&lt;p&gt;1.何为RDD？RDD的全名叫做&lt;strong&gt;弹性分布式数据集&lt;/strong&gt;，其实就是分布式的
      
    
    </summary>
    
    
      <category term="大数据" scheme="http://yoursite.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="spark" scheme="http://yoursite.com/tags/spark/"/>
    
  </entry>
  
  <entry>
    <title>Spark大数据快速分析学习笔记（一）</title>
    <link href="http://yoursite.com/2020/06/26/Spark%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BF%AB%E9%80%9F%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/06/26/Spark%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BF%AB%E9%80%9F%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2020-06-26T14:44:53.000Z</published>
    <updated>2020-06-27T15:09:23.332Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Spark中的Python和Scala的Shell"><a href="#Spark中的Python和Scala的Shell" class="headerlink" title="Spark中的Python和Scala的Shell"></a>Spark中的Python和Scala的Shell</h3><p>Spark自带交互式shell，能够即时数据分析。这里介绍两中语言的shell的使用；</p><ul><li><p>Python</p><p>要打开Python版本的Spark Shell可以在终端中输入命令：</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># pyspark</span></span><br></pre></td></tr></table></figure></li><li><p>Scala</p><p>打开Scala版本的shell</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># spark-shell</span></span><br></pre></td></tr></table></figure></li></ul><p>在打开spark shell时会输出很多的日志信息，可以调整日志的级别来控制输出的信息量。在spark的目录下的conf目录修改<strong>log4j.properties</strong>文件，在文件中修改如下内容：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">log4j.rootCategory</span>=WARN, console</span><br></pre></td></tr></table></figure><p>这样就可以减少大量的日志信息输出</p><h3 id="使用Spark"><a href="#使用Spark" class="headerlink" title="使用Spark"></a>使用Spark</h3><ul><li><p>初始化<strong>SparkContext</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="constructor">SparkConf()</span>.set<span class="constructor">AppName(<span class="string">"App"</span>)</span></span><br><span class="line"><span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="constructor">SparkContext(<span class="params">conf</span>=<span class="params">conf</span>)</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><p>《Spark快速大数据分析》</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Spark中的Python和Scala的Shell&quot;&gt;&lt;a href=&quot;#Spark中的Python和Scala的Shell&quot; class=&quot;headerlink&quot; title=&quot;Spark中的Python和Scala的Shell&quot;&gt;&lt;/a&gt;Spark中的Pyth
      
    
    </summary>
    
    
      <category term="大数据" scheme="http://yoursite.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="spark" scheme="http://yoursite.com/tags/spark/"/>
    
  </entry>
  
  <entry>
    <title>Python数据科学分析笔记</title>
    <link href="http://yoursite.com/2020/06/11/bigdata/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E5%88%86%E6%9E%90%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/06/11/bigdata/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E5%88%86%E6%9E%90%E7%AC%94%E8%AE%B0/</id>
    <published>2020-06-11T03:37:49.000Z</published>
    <updated>2020-06-11T03:37:49.779Z</updated>
    
    <content type="html"><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href=""></a></li><li><a href=""></a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;&quot;&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;&quot;&gt;&lt;/a&gt;&lt;/l
      
    
    </summary>
    
    
      <category term="bigdata" scheme="http://yoursite.com/categories/bigdata/"/>
    
      <category term="数据分析" scheme="http://yoursite.com/categories/bigdata/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
  </entry>
  
  <entry>
    <title>泛读Java集合源码分析</title>
    <link href="http://yoursite.com/2020/06/11/java/java%E5%9F%BA%E7%A1%80/Java%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2020/06/11/java/java%E5%9F%BA%E7%A1%80/Java%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</id>
    <published>2020-06-11T03:31:29.000Z</published>
    <updated>2021-01-17T03:00:10.446Z</updated>
    
    <content type="html"><![CDATA[<h3 id="剖析ArrayList"><a href="#剖析ArrayList" class="headerlink" title="剖析ArrayList"></a>剖析ArrayList</h3><h4 id="ArrayList实现的接口"><a href="#ArrayList实现的接口" class="headerlink" title="ArrayList实现的接口"></a>ArrayList实现的接口</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ArrayList&lt;E&gt;</span> <span class="keyword">extends</span> <span class="title">AbstractList&lt;E&gt;</span></span></span><br><span class="line"><span class="class">        <span class="title">implements</span> <span class="title">List&lt;E&gt;</span>, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span>&#123;</span><br><span class="line">        ....</span><br></pre></td></tr></table></figure><ul><li><p>ArrayList实现了<strong><code>List</code></strong> List是一个数组队列，提供了相关的添加、删除、修改、遍历等功能</p></li><li><p>ArrayList实现了 <strong><code>RandomAccess</code></strong> 接口，为ArrayList提供了随机访问功能，可以通过元素的序号快速获取元素对象。</p></li><li><p>ArrayList还实现<strong><code>Cloneable</code></strong> 接口，覆盖函数<strong><code>clone()</code></strong>，能够被克隆。实现<strong><code>Serializable</code></strong>意味着ArrayList可以被序列化</p></li></ul><p>从java1.5后java加入了泛型的特性，在使用<strong><code>ArrayList</code></strong>时可以实现泛型化</p><p>例如下面的使用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; strlist = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">ArrayList&lt;Integer&gt; intList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br></pre></td></tr></table></figure><h4 id="ArrayList基本原理"><a href="#ArrayList基本原理" class="headerlink" title="ArrayList基本原理"></a>ArrayList基本原理</h4><p>ArrayList的内部有一个elementData数组，一般会有一些预留的空间，有一个整数size记录实际的元素个数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Object[] elementData;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure><p>elementData会随着实际元素个数的增多而重新分配，而size则始终记录实际的元素个数</p><ul><li><p><strong>ArrayList常用方法的实现</strong></p><ul><li><p><strong><code>add()方法</code></strong></p><p>add方法的主要代码为：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        ensureCapacityInternal(<span class="built_in">size</span> + <span class="number">1</span>); <span class="comment">//插入元素，改变元素个数</span></span><br><span class="line">        elementData[<span class="built_in">size</span>++] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>add()方法首先调用 <strong><code>ensureCapacityInternal(size + 1)</code></strong> 以确保数组容量是够的。</p><p>这里以java1.8为例，首先ensureCapacityInternal确保数组容量足够，代码如下：</p><p><strong>ensureCapacityInternal</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> void ensure<span class="constructor">CapacityInternal(<span class="params">int</span> <span class="params">minCapacity</span>)</span> &#123;</span><br><span class="line">        ensure<span class="constructor">ExplicitCapacity(<span class="params">calculateCapacity</span>(<span class="params">elementData</span>,<span class="params">minCapacity</span>)</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>calculateCapacity</strong></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateCapacity</span><span class="params">(Object[] elementData, <span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">            <span class="keyword">return</span> Math.<span class="built_in">max</span>(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minCapacity;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>calculateCapacity</strong> 判断elementData数组是否为空，如果是则将<strong><code>DEFAULT_CAPACITY</code></strong>的容量赋给<strong>minCapacity</strong> ，在这里<strong>DEFAULT_CAPACITY</strong> 大小为10；</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> static <span class="keyword">final</span> <span class="built_in">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>接下来调用<strong>ensureExplicitCapacity</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="built_in">void</span> ensureExplicitCapacity(<span class="built_in">int</span> minCapacity) &#123;</span><br><span class="line">        modCount++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">            grow(minCapacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong><code>modCount</code></strong> 表示内部的增加修改次数，如果需要的长度大于当前的数组长度，则调用<strong><code>grow</code></strong> 方法,grow 的主要代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">        <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>remove()方法</code></strong> </p><p>remove方法源码</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">public</span> E remove(<span class="type">int</span> <span class="keyword">index</span>) &#123;</span><br><span class="line">        range<span class="keyword">Check</span>(<span class="keyword">index</span>);</span><br><span class="line">        modCount++;</span><br><span class="line">        E oldValue = elementData(<span class="keyword">index</span>);</span><br><span class="line">        <span class="type">int</span> numMoved = size - <span class="keyword">index</span> - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">System</span>.arraycopy(elementData, <span class="keyword">index</span>+<span class="number">1</span>, elementData, <span class="keyword">index</span>,</span><br><span class="line">                             numMoved);</span><br><span class="line">        elementData[<span class="comment">--size] = null; </span></span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>get()方法</code></strong></p><p>ArrayList能够支持随机访问，是因为内部的数据结构是数组，数组本身就是支持随机访问。get()方法首先判断输入的<strong><code>index</code></strong> 是否越界，然后将数组的index位置的<strong><code>元素</code></strong>返回即可。</p><p>源代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheck</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= size)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line">        <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="ArrayList的特点"><a href="#ArrayList的特点" class="headerlink" title="ArrayList的特点"></a>ArrayList的特点</h4><p>对于Arraylist，由于内部实现采用动态数组实现，所以具有以下几个特点</p><ul><li><strong>可以随机访问，按照索引位置进行访问效率很高</strong></li><li><strong>除非数组已经排序，否则按照内容查找元素效率比较低下</strong></li><li>添加元素的效率一般，重新分配和复制数组的开销平摊</li><li><strong>插入删除元素效率低下，因为需要移动元素</strong></li><li>ArrayList不是线程安全的，要实现线程安全的方式是使用<strong>Collections</strong>提供的方法修饰ArrayList</li></ul><h3 id="剖析LinkedList"><a href="#剖析LinkedList" class="headerlink" title="剖析LinkedList"></a>剖析LinkedList</h3><p>LinkedList实现了List接口、Deque、Queue接口。其内部实现是双向链表，每个元素在内存中是单独存放的，元素之间通过前驱链接和后继链接将节点连接起来。节点的代码如下：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private static class <span class="keyword">Node</span><span class="title">&lt;E</span>&gt; &#123;</span><br><span class="line">        E item;</span><br><span class="line">        <span class="keyword">Node</span><span class="title">&lt;E</span>&gt; next;</span><br><span class="line">        <span class="keyword">Node</span><span class="title">&lt;E</span>&gt; prev;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">Node</span><span class="title">(Node</span><span class="tag">&lt;E&gt;</span> prev, E element, <span class="keyword">Node</span><span class="title">&lt;E</span>&gt; next) &#123;</span><br><span class="line">            this.item = element;//元素</span><br><span class="line">            this.next = next;//前驱节点</span><br><span class="line">            this.prev = prev;//后继节点</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>LinkedList内部组成就是如下变量</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">transient int size = <span class="number">0</span>;//链表的长度</span><br><span class="line">   transient <span class="keyword">Node</span><span class="title">&lt;E</span>&gt; first;//指向头节点</span><br><span class="line">   transient <span class="keyword">Node</span><span class="title">&lt;E</span>&gt; last;//指向尾节点</span><br></pre></td></tr></table></figure><p>LinkedList常用的方法</p><ul><li><p><strong>add()方法</strong></p><p>该方法是在链表的end添加元素，其调用了自己的方法<strong><code>linkLast(E e)</code></strong>。俩来看看源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法首先将last的Node引用指向了一个新的Node(l)，然后根据l新建了一个<code>newNode</code>，其中的元素就为要添加的e；而后，我们让last指向newNode，接下来是自身进行维护该链表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">        last = newNode;</span><br><span class="line">        <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">            first = newNode;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l.next = newNode;</span><br><span class="line">        size++;</span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>remove()方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">checkElementIndex(index);</span><br><span class="line"><span class="keyword">return</span> unlink(node(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 通过<strong><code>node</code></strong>方法找到节点，调用了unlike方法</p><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">E unlink(Node&lt;E&gt; x) &#123;</span><br><span class="line">        <span class="comment">// assert x != null;</span></span><br><span class="line">        final E element = x.item;</span><br><span class="line">        final Node&lt;E&gt; <span class="built_in">next</span> = x.<span class="built_in">next</span>;</span><br><span class="line">        final Node&lt;E&gt; <span class="built_in">prev</span> = x.<span class="built_in">prev</span>;</span><br><span class="line"></span><br><span class="line">        if (<span class="built_in">prev</span> == <span class="built_in">null</span>) &#123;</span><br><span class="line">            <span class="built_in">first</span> = <span class="built_in">next</span>;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            <span class="built_in">prev</span>.<span class="built_in">next</span> = <span class="built_in">next</span>;</span><br><span class="line">            x.<span class="built_in">prev</span> = <span class="built_in">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (<span class="built_in">next</span> == <span class="built_in">null</span>) &#123;</span><br><span class="line">            last = <span class="built_in">prev</span>;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            <span class="built_in">next</span>.<span class="built_in">prev</span> = <span class="built_in">prev</span>;</span><br><span class="line">            x.<span class="built_in">next</span> = <span class="built_in">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        x.item = <span class="built_in">null</span>;</span><br><span class="line">        size--;</span><br><span class="line">        modCount++;</span><br><span class="line">        return element;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>删除x节点，就是让x的前驱和后继直接链接起来，next是x的后继，prev是x的前驱，分为下面两步：</p><ul><li>让x的前驱的后继指向x的后继。如果没有前驱，说明删除的是头节点，则修改头节点指向x的后继。</li><li>让x的后继的前驱指向x的前驱。如果x没有后继，说明删除的是尾节点，则修改尾节点指向x的前驱。</li></ul></li></ul><p>LinkedList特点</p><p>用法上，LinkedList是一个List，但也实现了Deque接口，可以作为队列、栈。双端队列使用。实现原理上，LinkedList内部是一个双向链表，并维护了长度，头节点、尾节点。</p><ul><li>按需分配空间，不需要预先分配很多的空间</li><li>不可以随机访问，按照索引位置访问效率太低，必须从头到尾顺着链接找</li><li>不管列表是否排序，只要是按照内容查找元素，效率都比较低</li><li>在两端添加、删除元素的效率很高</li><li>在中间插入、删除元素，要先定位，效率比较低，而修改本身的效率很高 </li></ul><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>HashMap实现了Map接口，HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。</p><p><strong>内部组成</strong>：HashMap内部组成主要有如下实例变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Entry&lt;K,V&gt;[]table = (Entry&lt;K,V&gt;[])EMPTY_TABLE;</span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;剖析ArrayList&quot;&gt;&lt;a href=&quot;#剖析ArrayList&quot; class=&quot;headerlink&quot; title=&quot;剖析ArrayList&quot;&gt;&lt;/a&gt;剖析ArrayList&lt;/h3&gt;&lt;h4 id=&quot;ArrayList实现的接口&quot;&gt;&lt;a href=&quot;#Arr
      
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="java中级编程" scheme="http://yoursite.com/tags/java%E4%B8%AD%E7%BA%A7%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java集合框架</title>
    <link href="http://yoursite.com/2020/06/09/java/java%E5%9F%BA%E7%A1%80/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    <id>http://yoursite.com/2020/06/09/java/java%E5%9F%BA%E7%A1%80/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/</id>
    <published>2020-06-09T08:32:12.000Z</published>
    <updated>2021-01-17T02:59:49.568Z</updated>
    
    <content type="html"><![CDATA[<p>在编程时有些场景需要用到Java的集合框架，这篇博文将介绍在Java系统里的集合框架。</p><p><img src="C:%5CUsers%5C%E6%9D%A8%5CDesktop%5C%E8%AF%BB%E4%B9%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5C%E5%AF%BC%E5%87%BA%E5%9B%BE%E7%89%87%5CCollectionAndMap.png" alt=""></p><p>Java提供了大量持有对象的方式：</p><ul><li>数组</li><li><strong><code>Collection</code></strong>保存单一的元素，<strong><code>Map</code></strong>保存相关联的键值对。各种<strong>Collection</strong>和各种<strong>Map</strong>都可以在你向其中添加更多元素时自动调整其尺寸。</li><li>向数组一样，<strong>List</strong>也建立数字索引与对象的关联，因此数组和List都是拍好序的容器。List能自动扩充容量。</li><li>如果要进行大量的随机访问，就使用<strong><code>ArrayList</code></strong>;如果要经常从表中间插入或删除元素，则使用<strong><code>LinkedList</code></strong>.</li><li>各种<strong><code>Queue</code></strong>及栈的行为，优LinkedList提供</li><li><strong><code>Map</code></strong>是一种将对象与对象相关联的设计，<strong>HashMap</strong>设计用来快速访问；<strong>LinkedHashMap</strong>保持元素插入时的顺序，但是也通过散列提供快速访问能力。</li><li><strong><code>Set</code></strong>不接受重复元素。<strong>HashSet</strong>提供最快的查询速度，<strong>LinkedHashSet</strong>以插入顺序保存元素</li></ul><h3 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h3><h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><p>List有两种基本类型：ArrayList和LinkedList</p><h5 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a><strong>ArrayList</strong></h5><p><strong>ArrayList</strong>长于随机访问元素，但是在List的中间插入和移除元素时比较慢。下面来列举几个ArrayList的常用API</p><ul><li>contains()用于确定某个对象是否在列表中。</li><li>remove()方法移除一个对象，将这个对象的引用传递给remove()方法</li><li>indexOf()方法用来获取某个对象在List中的所处位置的索引编号</li><li>subList()方法将从较大的列表中创建出一个片段。</li><li>retailAll()方法时List的交集操作</li></ul><h4 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h4><p><strong>LinkedList</strong>实现基本的<strong>List</strong>接口。下面介绍LinkedList中的一些方法</p><ul><li>getFirst()方法返回列表的头，如果List为空，则抛出异常</li><li>removeFirst()移除并返回列表的头元素，在列表为空时抛出异常</li><li>addList()和addLast()相同，将某个元素插入到列表的头部或尾部</li><li>removeLast()移除并返回列表的最后一个元素</li></ul><h4 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h4><p>Queue是<strong>先进先出</strong>的容器，从容器的一端放入事物，从另一端取出，并且事物放入容器顺序与取出的顺序相同，队列常常被当作一种可靠的将对象从程序的某个区域传输到另一个区域的途径，下面介绍在Queue中的方法：</p><ul><li>offer()方法将一个元素插入到队尾，或者返回false</li><li>peek()和element()都将在不移除的情况下返回对头，peek()方法在队列为空时返回null，element()则会抛出异常信息。</li><li>poll()和remove()方法将移除并返回对头，当队列为空时poll()返回空，而remove()会抛出异常</li></ul><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><p>《Java编程思想》</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在编程时有些场景需要用到Java的集合框架，这篇博文将介绍在Java系统里的集合框架。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;C:%5CUsers%5C%E6%9D%A8%5CDesktop%5C%E8%AF%BB%E4%B9%A6%E5%AD%A6%E4%B9%A0%E7%A
      
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="java中级编程" scheme="http://yoursite.com/tags/java%E4%B8%AD%E7%BA%A7%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Executor框架</title>
    <link href="http://yoursite.com/2020/06/05/java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Executor%E6%A1%86%E6%9E%B6/"/>
    <id>http://yoursite.com/2020/06/05/java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Executor%E6%A1%86%E6%9E%B6/</id>
    <published>2020-06-05T06:13:11.000Z</published>
    <updated>2020-06-06T10:05:32.139Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Executor框架两级调度"><a href="#Executor框架两级调度" class="headerlink" title="Executor框架两级调度"></a>Executor框架两级调度</h3><p><img src="https://raw.githubusercontent.com/yangshenghua97/Image/master/%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E4%B8%A4%E7%BA%A7%E8%B0%83%E5%BA%A6.png" alt=""></p><p>Java线程启动时会创建一个本地操作系统线程，当该Java线程终止时，这个操作系统线程也会被回收。操作系统会调度所有线程并将它们分配给可用CPU。</p><p>在上面的调度模型中：</p><p>在上层，Java多线程程序通常把应用分解为若干任务，然后使用用户级的调度器将这些任务映射为固定数量的线程；在底层，操作系统内核将这些线程映射到硬件处理器上。</p><h3 id="Executor框架结构"><a href="#Executor框架结构" class="headerlink" title="Executor框架结构"></a>Executor框架结构</h3><p>Executor框架由3大部分组成</p><ul><li><p><strong>任务</strong></p><p>包括被执行任务需要的实现接口(Runnable接口或Callable接口)<br>Runnable接口和Callable接口的实现类，可以被ThreadPoolExecutor或者ScheduleThreadPoolExecutor</p></li><li><p><strong>执行的任务</strong></p><p>包括任务执行机制的核心接口<strong><code>Executor</code></strong>以及继承自<strong><code>Executor</code></strong>的<strong><code>ExecutorService</code></strong>接口</p><p>Executor是一个接口，时Executor框架的基础，它将任务的提交与任务的执行分离</p><p>ThreadPoolExecutor是线程池的核心实现类，用来执行被提交的任务</p><p>ScheduleThreadPoolExecutor，可以在给定的延迟后运行命令，或者定期执行命令</p></li><li><p><strong>异步计算的框架</strong><br>包括接口<strong><code>Future</code></strong>和实现Future接口的<strong><code>FutureTask</code></strong>类，代表异步计算的结果</p><p><img src="https://raw.githubusercontent.com/yangshenghua97/Image/master/Executor%E6%A1%86%E6%9E%B6%E7%9A%84Class%E4%B8%8Einterface.png" alt=""></p></li></ul><h3 id="Executor框架成员"><a href="#Executor框架成员" class="headerlink" title="Executor框架成员"></a>Executor框架成员</h3><p>Executor框架主要成员：ThreadPoolExecutor、ScheduledThreadPoolExecutor、Future接口、Runnable接口、Callable接口、Executors。</p><ul><li><p><strong>ThreadPoolExecutor</strong></p><p>ThreadPoolExecutor通常使用工厂类<strong>Executors</strong>来创建，Executors可以创建3种类型的ThreadPoolExecutor；分别是SingleThreadExecutor、FixedThreadPool、CachedThreadPool。ThreadPoolExecutor是Executor框架最核心的类，是实现线程池的类。主要由下列组件构成</p><ul><li>corePool：核心线程池大小</li><li>maximumPool：最大线程池的大小</li><li>BlockingQueue：用来暂时保存任务的工作队列</li></ul></li></ul><p>下面分别介绍3种类型的ThreadPoolExecutor：</p><ul><li><p><strong>SingleThreadExecutor</strong>：</p><p>SingleThreadExecutor适用于需要保证顺序执行各个任务；并且在任意时间点，不会有多个线程是活动的应用场景。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="keyword">new</span><span class="type">SingleThreadExecutor</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">FinalizableDelegatedExecutorService</span></span><br><span class="line"><span class="type"></span>            (<span class="keyword">new</span> <span class="type">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                    <span class="number">0</span>L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> <span class="type">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="keyword">new</span><span class="type">SingleThreadExecutor</span>(ThreadFactory threadFactory) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">FinalizableDelegatedExecutorService</span></span><br><span class="line"><span class="type"></span>            (<span class="keyword">new</span> <span class="type">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                    <span class="number">0</span>L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> <span class="type">LinkedBlockingQueue</span>&lt;Runnable&gt;(),</span><br><span class="line">                                    threadFactory));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，SingleThreadExecutor的corePoolSize和maximumPoolSize被设置为1，SingleThreadExecutor使用无界队列<strong>LinkedQueueBlockingQueue</strong>作为线程池的工作队列（队列的容量为Integer.MAX_VALUE）。SingleThreadExecutor的运行图如下</p><p><img src="https://raw.githubusercontent.com/yangshenghua97/Image/master/SingleThradPoolExecutor.png" alt=""></p><p>下面对上图中的过程进行说明：</p><p>1.如果当前运行的线程少于corePoolSize（线程池中没有运行的线程），则创建一个线程类执行任务</p><p>2.在线程池完成预热之后，将任务加入LinkedBlockingQueue</p><p>3.线程执行完1中的任务后，会在一个无限循环中反复从LinkedBlockingQueue获取任务来执行</p></li><li><p><strong>FixedThreadPool</strong>：</p><p>FixedThreadPool适用于为了满足资源管理的需求，而需要限制当前线程数量的应用场景。适用于负载均衡比较重的服务器</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="keyword">new</span><span class="type">FixedThreadPool</span>(int nThreads) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                      <span class="number">0</span>L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> <span class="type">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="keyword">new</span><span class="type">FixedThreadPool</span>(int nThreads, ThreadFactory threadFactory) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                      <span class="number">0</span>L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> <span class="type">LinkedBlockingQueue</span>&lt;Runnable&gt;(),</span><br><span class="line">                                      threadFactory);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>FixedThreadPool的corePoolSize和maximumPoolSize都被设置为创建FixedThreadPool时指定的参数nThread</p><p>当线程池中的线程数大于corePoolSize时，keepAliveTime为多余的空闲线程等待新任务的最长时间，超过这个时间后多余的线程将被终止。把keepAliveTime设置为0L，说明多余的空闲线程会被立即终止。</p><p><img src="https://raw.githubusercontent.com/yangshenghua97/Image/master/FixedThreadPool.png" alt=""></p><p>1.如果当前运行的线程数少于corePoolSize，则创建线程来执行任务</p><p>2.在线程池完成预热后将任务加入LinkedBlockingQueue</p><p>3.线程执行完成1中的任务后，会在循环中反复从LinkedBlockingQueue获取任务来执行</p><p>FixedThreadPool使用无界队列LinkedBlockingQueue作为线程池的工作队列（队列的容量为Integer.MAX_VALUE）</p></li><li><p><strong>CachedThreadPool</strong></p><p>CachedThreadPool是大小无界的线程池，适用于执行很多短期异步任务的小程序或负载较轻的服务器</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="keyword">new</span><span class="type">CachedThreadPool</span>(ThreadFactory threadFactory) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                      <span class="number">60</span>L, TimeUnit.SECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> <span class="type">SynchronousQueue</span>&lt;Runnable&gt;(),</span><br><span class="line">                                      threadFactory);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>CachedThreadPool的corePoolSize被设置为0，maximumPoolSize被设置为Integer.MAX_VALUE,即maximumPool是无界，把keepAliveTime设置为60L，CachedThreadPool中的空闲线程等待新任务的最长时间为60秒，空闲线程超过60秒后将会终止</p><p><img src="C:%5CUsers%5C%E6%9D%A8%5CDesktop%5C%E8%AF%BB%E4%B9%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5CCachedThreadPool.png" alt=""></p></li></ul><h3 id="ScheduleThreadPoolExecutor"><a href="#ScheduleThreadPoolExecutor" class="headerlink" title="ScheduleThreadPoolExecutor"></a>ScheduleThreadPoolExecutor</h3><p>待续</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Executor框架两级调度&quot;&gt;&lt;a href=&quot;#Executor框架两级调度&quot; class=&quot;headerlink&quot; title=&quot;Executor框架两级调度&quot;&gt;&lt;/a&gt;Executor框架两级调度&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://raw.
      
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="java并发编程" scheme="http://yoursite.com/tags/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>MapReduce&amp;HDFS</title>
    <link href="http://yoursite.com/2020/06/05/bigdata/MapReduce-HDFS/"/>
    <id>http://yoursite.com/2020/06/05/bigdata/MapReduce-HDFS/</id>
    <published>2020-06-05T03:18:43.000Z</published>
    <updated>2020-06-06T10:32:39.137Z</updated>
    
    <content type="html"><![CDATA[<h3 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h3><p><strong>MapReduce编程模型</strong></p><p>整个MapReduce计算过程分为Map阶段和Reduce阶段，也称为映射和缩减阶段，这两个独立的阶段实际上是两个独立的过程，即Map过程和Reduce过程，在Map中进行数据的读取和数据的预处理，之后将预处理的结果发送给Reduce中进行合并。</p><p><strong>MapReduce执行流程</strong></p><ul><li>Hadoop计算流程</li></ul><h3 id="HDFS"><a href="#HDFS" class="headerlink" title="HDFS"></a>HDFS</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;MapReduce&quot;&gt;&lt;a href=&quot;#MapReduce&quot; class=&quot;headerlink&quot; title=&quot;MapReduce&quot;&gt;&lt;/a&gt;MapReduce&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;MapReduce编程模型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;整个Ma
      
    
    </summary>
    
    
      <category term="大数据" scheme="http://yoursite.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="hadoop" scheme="http://yoursite.com/tags/hadoop/"/>
    
  </entry>
  
  <entry>
    <title>队列同步器-AQS</title>
    <link href="http://yoursite.com/2020/05/16/java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/AQS%E5%90%8C%E6%AD%A5%E5%99%A8/"/>
    <id>http://yoursite.com/2020/05/16/java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/AQS%E5%90%8C%E6%AD%A5%E5%99%A8/</id>
    <published>2020-05-16T05:03:22.000Z</published>
    <updated>2020-06-04T05:57:00.150Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是队列同步器"><a href="#什么是队列同步器" class="headerlink" title="什么是队列同步器"></a>什么是队列同步器</h2><p>队列同步器是用来构建锁或者其他同步组件的基础框架，它使用一个int成员变量表示同步状态，通过内置的FIFO队列完成资源获得线程的排队工作。</p><p>同步器是实现锁的关键，在锁的实现中聚合同步器，利用同步器实现锁的语义。</p><p><strong>锁和同步器两者的关系：锁是面向使用者，定义了使用者与锁交互的接口，隐藏实现细节；而同步器面向的是锁的实现者，简化了锁的实现方式，屏蔽了同步状态管理、线程的排队、等待与唤醒等底层操作。</strong></p><p>AQS的主要使用方式是继承，子类通过继承同步器并实现它的抽象方法来管理同步状态，在抽象方法的实现过程中需要对同步状态进行更新，因此就需要使用同步器提供的3个方法来保证状态的改变是安全的。</p><h2 id="队列同步器的实现"><a href="#队列同步器的实现" class="headerlink" title="队列同步器的实现"></a>队列同步器的实现</h2><h3 id="同步队列"><a href="#同步队列" class="headerlink" title="同步队列"></a>同步队列</h3><p>同步队列依赖内部的同步队列完成同步状态的管理，当前线程获得同步状态失败时，同步器会将当前线程以及等待状态等信息构成一个节点将其加入到同步队列中，同时会阻塞当前线程，当同步状态释放时，会将首节点的线程唤醒，使其再次尝试获取同步状态。同步队列中的节点用来保存获取同步状态失败的线程引用、等待状态以及前驱后继节点。</p><table><thead><tr><th>属性类型与名称</th><th>描述</th></tr></thead><tbody><tr><td>int waitStatus</td><td>等待状态</td></tr><tr><td>Node prev</td><td>前驱节点</td></tr><tr><td>Node next</td><td>后继节点</td></tr><tr><td>Node nextWaiter</td><td>等待队列中的后继节点</td></tr><tr><td>Thread thread</td><td>获取同步状态的线程</td></tr></tbody></table><p>上面的<strong><code>waitStatus</code></strong>变量中有这么几个状态，</p><ul><li>CANCELED</li><li>SIGNAL</li><li>CONDITION</li><li>PROPAGATE</li><li>INITIAL</li></ul><p>同步队列的基本结构如下</p><p><img src="https://raw.githubusercontent.com/yangshenghua97/Image/master/AQSLinked.png" alt=""></p><p>同步器提供一个基于CAS的设置尾节点的方法（compareAndSetStatus），通过CAS设置尾节点；</p><p>如下图：</p><p><img src="https://raw.githubusercontent.com/yangshenghua97/Image/master/AQSLinkedCASAddtail.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是队列同步器&quot;&gt;&lt;a href=&quot;#什么是队列同步器&quot; class=&quot;headerlink&quot; title=&quot;什么是队列同步器&quot;&gt;&lt;/a&gt;什么是队列同步器&lt;/h2&gt;&lt;p&gt;队列同步器是用来构建锁或者其他同步组件的基础框架，它使用一个int成员变量表示同步状态，通过
      
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="java并发编程" scheme="http://yoursite.com/tags/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java中的线程池</title>
    <link href="http://yoursite.com/2020/05/04/java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>http://yoursite.com/2020/05/04/java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0/</id>
    <published>2020-05-04T06:29:41.000Z</published>
    <updated>2020-06-04T12:53:06.297Z</updated>
    
    <content type="html"><![CDATA[<h3 id="合理使用线程池的好处"><a href="#合理使用线程池的好处" class="headerlink" title="合理使用线程池的好处"></a>合理使用线程池的好处</h3><ul><li><p>降低资源消耗</p><p>通过重复利用已创建的线程降低线程创建和的销毁造成的消耗</p></li><li><p>提高响应速度</p><p>当任务到达时，任务可以不需要等到线程创建就能立即执行</p></li><li><p>提高线程的可管理性</p><p>线程是稀缺资源，如果无限制创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优、监控</p></li></ul><h3 id="线程池的实现原理"><a href="#线程池的实现原理" class="headerlink" title="线程池的实现原理"></a>线程池的实现原理</h3><p><strong>线程池的处理流程</strong></p><ul><li>线程池判断核心线程池里的线程是否都在执行任务。如果不是，则创建一个新的工作线程来执行任务。如果核心线程池里的线程都在执行任务，则进入下一个流程</li><li>线程池铺垫工作队列是否已满。如果工作队列没有满，则将新提交的任务存储在这个工作队列中。如果工作队列慢了，则进入下一个流程</li><li>线程池判断线程池的线程是否都处于工作状态。如果没有，则创建一个新的工作线程來执行任务。如果已满，则交给饱和策略来处理这个任务</li></ul><p>流程图图如下：</p><p><img src="https://raw.githubusercontent.com/yangshenghua97/Image/master/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.png" alt=""></p><p><strong>ThreadPoolExector执行execute</strong></p><p>ThreadPoolExecutor执行execute方法分为4种情况：</p><ul><li>1 如果当前线程少于<strong><code>corePoolSize</code></strong>，则创建新线程来执行任务</li><li>2 如果运行的线程等于或多于corePoolSize，则将任务加入<strong><code>BlockingQueue</code></strong></li><li>3 如果无法将任务加入BlockingQueue，则创建新的线程来处理任务</li><li>4 如果创建新线程将使当前运行的线程超出maximumPoolSize，任务将被拒绝，并调用异常方法</li></ul><p><img src="https://raw.githubusercontent.com/yangshenghua97/Image/master/ThreadPoolExecutor.png" alt=""></p><p><strong>线程池中的线程执行任务分两种情况</strong></p><ul><li><p>在<strong><code>execute()</code></strong>方法中创建一个线程时，会让这个线程执行当前任务</p></li><li><p>这个线程执行完下图中1的任务后，会反复从BlockingQueue中获取任务来执行</p><p><img src="https://raw.githubusercontent.com/yangshenghua97/Image/master/ThreadPoolExecutor2.png" alt=""></p></li></ul><h3 id="线程池的使用"><a href="#线程池的使用" class="headerlink" title="线程池的使用"></a>线程池的使用</h3><p>  <strong>线程池的创建</strong><br>  通过<strong>ThreadPoolExecutor</strong>来创建一个线程池</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> ThreadPoolExecutor(<span class="keyword">int</span> corePoolSize,</span><br><span class="line">                   <span class="keyword">int</span> maximumPoolSize,</span><br><span class="line">                   <span class="keyword">long</span> keepAliveTime,</span><br><span class="line">                   TimeUnit unit,</span><br><span class="line">                   BlockingQueue&lt;Runnable&gt; workQueue)</span><br></pre></td></tr></table></figure><p>创建一个线程需要输入几个参数</p><ul><li>corePoolSize：线程池的基本大小</li><li>maximumPoolSize：线程池最大数量</li><li>keepAliveTime：线程活动保持时间</li><li>unit：线程活动保持时间单位</li><li>workQueue：任务队列</li></ul><p><strong>向线程池提交任务</strong></p><p>使用两个方法向线程池提交任务</p><ul><li><p><strong><code>execute()</code></strong>方法：</p><p>execute()方法用于提交不需要返回值得任务，所以无法判断任务是否被线程池执行成功</p></li><li><p><strong><code>submit()</code></strong>方法：</p><p>submit()方法用于提交需要返回值的任务。线程池会返回一个future类型的对象，通过这个<strong><code>future</code></strong>对象可以判断任务是否执行成功，并且可以通过future的get()方法来获取返回值，<strong><code>get()</code></strong>方法会阻塞当前线程直到任务完成，<strong>get(long timeout,TimeUnit unit)</strong>方法则会阻塞当前线程一段时间后立即返回，这种情况下有可能任务没有执行完成。</p></li></ul><p><strong>关闭线程池</strong></p><p>通过调用线程池的<strong><code>shutdown</code></strong>或<strong><code>shutdownNow</code></strong>方法关闭线程池。</p><p><strong>shutdownNow</strong>首先将线程池的状态设置成<strong><code>STOP</code></strong>,然后尝试停止所有正在执行或暂停任务的线程，并返回等待执行任务的列表。</p><p><strong>shutdown</strong>只是将线程池的状态设置成SHUTDOWN状态，然后中断所有没有正在执行的任务的线程。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;合理使用线程池的好处&quot;&gt;&lt;a href=&quot;#合理使用线程池的好处&quot; class=&quot;headerlink&quot; title=&quot;合理使用线程池的好处&quot;&gt;&lt;/a&gt;合理使用线程池的好处&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;降低资源消耗&lt;/p&gt;
&lt;p&gt;通过重复利用已创建的线程降低线
      
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="java并发编程" scheme="http://yoursite.com/tags/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程之Synchronized</title>
    <link href="http://yoursite.com/2020/04/25/java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BSynchronized/"/>
    <id>http://yoursite.com/2020/04/25/java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BSynchronized/</id>
    <published>2020-04-25T08:07:02.000Z</published>
    <updated>2020-05-06T01:56:55.758Z</updated>
    
    <content type="html"><![CDATA[<h2 id="synchronized的实现原理"><a href="#synchronized的实现原理" class="headerlink" title="synchronized的实现原理"></a>synchronized的实现原理</h2><h3 id="利用synchronized实现同步的基础："><a href="#利用synchronized实现同步的基础：" class="headerlink" title="利用synchronized实现同步的基础："></a>利用synchronized实现同步的基础：</h3><ul><li>对于普通同步方法，锁是当前的实例对象</li><li>对于静态同步方法，锁是当前类的Class对象</li><li>对于同步方法块，锁是Synchronized括号里的配置对象</li></ul><h3 id="Synchronized实现原理："><a href="#Synchronized实现原理：" class="headerlink" title="Synchronized实现原理："></a>Synchronized实现原理：</h3><p>JVM基于进入和退出<strong><code>Monitor</code></strong>对象来实现方法同步和代码块同步，代码块同步使用<strong><code>monitorenter</code></strong>和<strong><code>monitorexit</code></strong>指令实现，monitorenter指令是在编译后插入到同步代码块开始位置，而monitorexit是插入到方法结束和异常处，<strong><code>JVM</code></strong>要保证每个monitorenter必须有对应的monitorexit与之匹配。</p><p>关键字synchronized可以修饰方法或者以同步块的形式来进行使用，它主要确保多个线程在同一时刻，只能有一个线程处于方法或同步块中，他保证了线程对变量访问的可见性和排他性。对于同步块的实现使用monitorenter和monitorexit指令，而同步方法则是依靠方法修饰符上的<strong><code>ACC_SYNCHRONIZED</code></strong>来完成。其本质上是对一个对象的监视器(monitor)进行获取，而这个过程是排他的，也就是在同一时刻只能有一个线程获得synchronized所保护对象的监视器。任意一个对象都拥有自己的监视器，当这个对象有同步块或者这个对象的同步方法调用时，执行方法的线程必须先获取到该对象的监视器才能进入同步块或者同步方法，而没有获取到监视器的线程将会被阻塞在同步块和同步方法的入口处，进入<strong><code>BLOCKED</code></strong>状态。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;synchronized的实现原理&quot;&gt;&lt;a href=&quot;#synchronized的实现原理&quot; class=&quot;headerlink&quot; title=&quot;synchronized的实现原理&quot;&gt;&lt;/a&gt;synchronized的实现原理&lt;/h2&gt;&lt;h3 id=&quot;利用syn
      
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="java并发编程" scheme="http://yoursite.com/tags/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>TCP/IP协议</title>
    <link href="http://yoursite.com/2020/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TTCP-IP%E5%8D%8F%E8%AE%AE/"/>
    <id>http://yoursite.com/2020/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TTCP-IP%E5%8D%8F%E8%AE%AE/</id>
    <published>2020-03-12T18:19:13.000Z</published>
    <updated>2020-03-15T14:02:04.814Z</updated>
    
    <content type="html"><![CDATA[<h3 id="TCP-IP的标准制定"><a href="#TCP-IP的标准制定" class="headerlink" title="TCP/IP的标准制定"></a>TCP/IP的标准制定</h3><p>由于TCP/IP技术的公开性，他不属于任何一个厂商或者是专业协会所有。TCP/IP的标准大部分都由<strong>RFC</strong>技术报告的形式公开。RCF文件包含了所有TCP/IP的协定标准，以及其最新版本。RFC所涵盖的内容和细节非常广，也可以为新协定的标准和计划，但不能以学术研究论文的方式来编辑。</p><h3 id="TCP-IP的特性"><a href="#TCP-IP的特性" class="headerlink" title="TCP/IP的特性"></a>TCP/IP的特性</h3><ul><li>它是其它网络服务的基础，几乎所有数据包交换网络都提供了这种服务。TCP/IP是根据信息中所含的地址资料来进行资料的传送，他不能确保每个独立路由的数据包是可靠和依序的送达目的地。在每个连线过程中，线路都不是被”独占”的，而是直接映射到硬件地址上，因此特别有效。</li><li>因为数据包交换并不能确保每一个数据包的可靠性，因此我们就需要通讯软件来自动检测和修护传送过程中出现的错误和处理损坏数据包。这种服务就是用来确保电脑程序之间能够连接和传送大量的数据。关键的技术就是数据流进行分割，然后编号传送，然后通过接受的确认来确数据的完整性</li><li>在数据包交换技术中，TCP/IP是独立于硬件之上的。TCP/IP有自己的一套数据包规定和定义,能应用在不同的网络之上</li><li>只要用TCP/IP连接网络，就会获得一个独一无二的识别位址。数据包在交换过程中，是以位址数据为依据，不管数据包所经历的路由如何，数据都会被送到指定的地址。</li><li>TCP/IP 的确认模式是以“端到端”进行的。這样就无需理会数据包交换过程中所参与的其他设备。</li></ul><h3 id="TCP-IP协议分层框架"><a href="#TCP-IP协议分层框架" class="headerlink" title="TCP/IP协议分层框架"></a>TCP/IP协议分层框架</h3><ul><li><p>链路程：链路层以字节位单位0和1分别进行分组，定义数据帧，写入源和目标机器的物理地址，数据，校验位来传输数据。</p><p><img src="https://raw.githubusercontent.com/yangshenghua97/Image/master/linkway.png" alt=""></p><p>链路层报文结构</p></li><li><p>网络层：根据IP定义网络地址，区分网段。子网内根据地址解析协议(ARP)进行MAC寻址，子网外进行路由转发数据包，这个数据包即为IP数据包。</p></li><li><p>传输层：数据包通过网络层发送到目标计算机后，应用程序在传输层定义逻辑端口，确认身份后，将数据包交给应用程序，实现端口到端口间通讯。</p></li><li><p>应用层：传输层的数据到达应用程序时，以某种统一规定的协议格式解读数据。</p></li></ul><p><img src="https://raw.githubusercontent.com/yangshenghua97/Image/master/PTCIP.png" alt=""></p><h3 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h3><p>IP是面向无连接、无状态的，没有额外的机制保证发送的包是否有序到达。IP首先规定出IP地址格式，该地址相当于在逻辑意义上进行了网段的划分，给没台机器额外设置了一个唯一的详细地址。IP地址属于网络层，主要的功能字啊WLAN内进行路由寻址，选择最佳路由。</p><p><img src="https://raw.githubusercontent.com/yangshenghua97/Image/master/IP.png" alt=""></p><h3 id="TCP建立连接"><a href="#TCP建立连接" class="headerlink" title="TCP建立连接"></a>TCP建立连接</h3><p>传输控制协议(TCP)，是一种面向连接、确保数据在端到端间的可靠传输的协议。面向连接是指在发送数据前，需要先建立一条虚拟的链路，然后让数据在这条链路上“流动”传输。每个TCP数据包是封装在IP包中的，每一个IP头的后面紧接的是TCP头。</p><p><img src="https://raw.githubusercontent.com/yangshenghua97/Image/master/TCP.png" alt=""></p><p>协议第一行的两个端口号各个占据两个字节，分别代表源机器与目标机器的端口号。这两个端口号与IP报头格式中的源IP地址和目标IP地址所组成的四元组可唯一标识一条TCP连接。由于TCP是面向连接的，所以有服务器和客户端之分。需要服务端先在相应的端口上进行监听，准备好接收客户端发起的连接请求。在类UNIX系统系统上通过netstat命令列出机器上已建立的连接信息，其中包含唯一标识一条连接的四元组，以及各连接的状态等内容。</p><p>TCP的FLAG位有6个bit组成，分别代表SYN、ACK、FIN、URG、PSH、RST，需要重点关注的是SYN、ACK、FIN。SYN(Synchronize Sequence Numbers)用作建立连接时的同步信号；ACK(Acknowledgement)用于对收到的数据进行确认，所确认的数据由确认序列号表示；FIN(Finish)表示后面没有数据需要发送，通常意味着所建立的连接需要关闭。</p><h4 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h4><p>TCP三次握手是指在建立连接的三个步骤：</p><ul><li><p>A机器发出一个数据包并将SYN置1，表示希望建立连接。这个包中的序列号假设是x。</p></li><li><p>B机器收到A机器发过来的数据包后，通过SYN得知这是一个建立连接的请求，于是发送一个响应包并将SYN和ACK标记都置为1。假设这个包中的序列号是y，而确认序列号的必须是x+1，表示收到了A发过来的SYN。在TCP中，SYN被当作数据中的一个字节。</p></li><li><p>A接收到B的响应后需进行确认，确认包中将ACK置1，并将确认序列号设置为y+1，表示收到了来自B的SYN。</p><p><img src="https://raw.githubusercontent.com/yangshenghua97/Image/master/SANCIWUOSHOU.png" alt=""></p><p>双方只有确认4类信息，才能建立连接。在第二次握手后，从B机器视角看还有连个NO信息无法确认。在第三次握手后，B机器才能确认自己的发报能力是否正常的。</p><p><img src="https://raw.githubusercontent.com/yangshenghua97/Image/master/TCP3.png" alt=""></p></li></ul><p>连接三次握手也是防止出现请求超时导致脏连接。TTL网络报文的生存时间往往都会超过TCP请求时间，如果两次握手就可以创建连接的话，传输数据并释放连接后，第一个超时的连接请求才到达B机器的话，B机器会认为是A创建的连接的请求，然后确认同意创建连接。因为A机器的状态不是SYN_SENT,所以直接丢弃了B的确认数据，以致最后只是B机器单方面创建连接完毕。</p><p><img src="https://raw.githubusercontent.com/yangshenghua97/Image/master/%E8%84%8F%E8%BF%9E%E6%8E%A5.png" alt=""></p><h3 id="TCP断开连接"><a href="#TCP断开连接" class="headerlink" title="TCP断开连接"></a>TCP断开连接</h3><p>TCP是全双工通信，双方都能作为数据的发送方和接收方，但TCP连接也会有断开的时候。A、B机器连接只要三次握手，而断开则需要四次挥手，例如下图：</p><p>A机器想要断开连接，则待本方数据发送完毕后，传递FIN信号给B机器。B机器应答ACK，告诉A机器可以断开，但是需要等B机器处理完成数据，再主动给A机器发送FIN信号。这时A机器处于半关闭状态(FIN-WAIT-2)，无法再发送新的数据。B机器做好连接关闭前的准备工作后，发送FIN给A机器，此时B机器也进入半关闭状态(CLOSE_WAIT)。A机器发送针对B机器FIN的ACK后，进入TIME_WAIT状态，经过2MSL后，没有收到B机器传过来的报文，则确定B机器已经收到A机器最后发送的ACK指令，此时TCP连接正式释放。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;TCP-IP的标准制定&quot;&gt;&lt;a href=&quot;#TCP-IP的标准制定&quot; class=&quot;headerlink&quot; title=&quot;TCP/IP的标准制定&quot;&gt;&lt;/a&gt;TCP/IP的标准制定&lt;/h3&gt;&lt;p&gt;由于TCP/IP技术的公开性，他不属于任何一个厂商或者是专业协会所有
      
    
    </summary>
    
    
      <category term="计算机基础" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>CPU与内存</title>
    <link href="http://yoursite.com/2020/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%9E%84%E6%88%90/CPU%E4%B8%8E%E5%86%85%E5%AD%98/"/>
    <id>http://yoursite.com/2020/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%9E%84%E6%88%90/CPU%E4%B8%8E%E5%86%85%E5%AD%98/</id>
    <published>2020-03-11T14:15:02.000Z</published>
    <updated>2020-03-12T19:34:04.876Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/yangshenghua97/Image/master/CPU.png" alt=""></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yangshenghua97/Image/master/CPU.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerl
      
    
    </summary>
    
    
      <category term="计算机基础" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="计算机基础" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>计算机的0与1</title>
    <link href="http://yoursite.com/2020/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%9E%84%E6%88%90/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%840%E4%B8%8E1/"/>
    <id>http://yoursite.com/2020/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%9E%84%E6%88%90/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%840%E4%B8%8E1/</id>
    <published>2020-03-11T12:53:21.000Z</published>
    <updated>2020-03-11T14:14:08.175Z</updated>
    
    <content type="html"><![CDATA[<p>在计算机中无论是什么设备，归根结底都是0和1的信号处理，设定基数为2，进位的规则是“逢二进一”，称之为二进制，设想有8条电路，每条电路有高电平和低电平两种状态。根据组合排列，有2^8 即256个种不同的信号。这8条电路，最左侧的一条表示正负，0表示正数，1表示负数，不参与数值表示。</p><h3 id="基本编码"><a href="#基本编码" class="headerlink" title="基本编码"></a>基本编码</h3><p>表示数的基本编码方式有原码、反码、补码；</p><p><strong>原码：符号为和数字实际值得结合，正数就是数值本身，符号为0；负数是数值本身，符号位为1，8位的二进制的表示范围是[-127,127]</strong></p><p><strong>反码：正数是本身，符号位为0；负数的数值部分是正数表示的基础上对各个位取反，符号位为1。8位二进制数的表示范围是[-127,127]</strong></p><p><strong>补码：正数是数组的本身，符号位为0，负数的数值部分是在正数表示基础上对各个位取反加1，符号位为1。8位二进制数的表示范围是[-127,127]</strong></p><table><thead><tr><th>正数/负数</th><th>原码</th><th>反码</th><th>补码</th></tr></thead><tbody><tr><td>1</td><td>0000 0001</td><td>0000 0001</td><td>0000 0001</td></tr><tr><td>-1</td><td>1000 0001</td><td>1111 1110</td><td>1111 1111</td></tr><tr><td>2</td><td>0000 0010</td><td>0000 0010</td><td>0000 0010</td></tr><tr><td>-2</td><td>1000 0010</td><td>1111 1101</td><td>1111 1110</td></tr></tbody></table><p>为了加速计算机对加减乘除运算速度，所有产生了反码和补码。例如在进行减法计算时，1-2=-1在计算机运算中可以这样运算：1+（-2）=-1。如果使用原码计算则结果为：1+（-2）= [0000 0001]<del>原</del>+[1000 0010]<del>原</del> = [10000011]<del>原</del> = -3结果是错误的。为了解决这一问题，于是出现了反码，使用反码计算，结果为1-2 = 1+(-2) = [00000001]<del>反</del>+[1111 1101]<del>反</del>=[1111 1110]<del>反</del> = -1。</p><h3 id="计算机存储计量单位"><a href="#计算机存储计量单位" class="headerlink" title="计算机存储计量单位"></a>计算机存储计量单位</h3><p>在上述的一条线路在计算机中表示1位，<strong>即1个bit，8个bit组成一个单位，称为一个字节，即1个Byte，1024个Byte简写为KB，1024个KB简写为MB，1024个MB简写为GB</strong>。</p><h3 id="位移运算"><a href="#位移运算" class="headerlink" title="位移运算"></a>位移运算</h3><p>向右移动一位近似表示除以2，十进制转化为二进制数后，向右移时，最右边的1位将被直接抹去。在左移<strong><code>&lt;&lt;</code></strong>和右移<strong><code>&gt;&gt;</code></strong>这两种运算中符号位均参与移动，除了负数右移时高位补1外，其他情况均在空位处补0</p><p>左移运算由于符号位参与向左移动，在移动后的结果，最左位可能是1或是0，即正数向左移的结果可能负数也可能是正数，负数向左移的结果也是如此。</p><p>对于 <strong><code>&gt;&gt;&gt;</code></strong> 无符号向右移动(不存在&lt;&lt;&lt;位移运算)，当向右移动时，正负数高位均补0，正数不断向右移动的最小值是0，而负数不断向右移动的最小值为1，无需考虑符号位，高位直接补0</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><p>《码出高效 Java开发手册》</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在计算机中无论是什么设备，归根结底都是0和1的信号处理，设定基数为2，进位的规则是“逢二进一”，称之为二进制，设想有8条电路，每条电路有高电平和低电平两种状态。根据组合排列，有2^8 即256个种不同的信号。这8条电路，最左侧的一条表示正负，0表示正数，1表示负数，不参与数
      
    
    </summary>
    
    
      <category term="计算机基础" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="计算机基础" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>浅尝算法</title>
    <link href="http://yoursite.com/2020/02/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2020/02/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</id>
    <published>2020-02-20T12:54:01.000Z</published>
    <updated>2020-12-16T07:12:16.661Z</updated>
    
    <content type="html"><![CDATA[<h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><p>根据时间复杂度的不同，主流的排序算法分为3大类</p><p><strong>时间复杂度为O(n[^^]2)的排序算法</strong></p><ul><li>排序算法</li><li>选择排序</li><li>插入排序</li><li>希尔排序</li></ul><p><strong>时间复杂度为O(nlogn)的排序算法</strong></p><ul><li>快速排序</li><li>归并排序</li><li>堆排序</li></ul><p><strong>时间复杂度为线性的排序算法</strong></p><ul><li>计数排序</li><li>桶排序</li><li>基数排序</li></ul><h3 id="冒泡排序-bubble-sort"><a href="#冒泡排序-bubble-sort" class="headerlink" title="冒泡排序(bubble sort)"></a>冒泡排序(bubble sort)</h3><p>冒泡排序的思想就是把相邻的元素进行两两比较，当一个元素大于右侧相邻的元素时，交换它们的位置；当一个元素小于或等于右侧相邻元素时，位置不变。</p><p>冒泡排序是一种稳定的排序，值相等的元素并不会打乱原本的排序。由于该排序算法的每一轮都会遍历所有元素，总共遍历(元素数量-1)轮，所以平均时间复杂度为O(n[^^]2)。</p><p><code>代码实现</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">bubblesort</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;array.length-i-<span class="number">1</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(array[j]&gt;array[j+<span class="number">1</span>])&#123;</span><br><span class="line">                    tmp = array[j];</span><br><span class="line">                    array[j] = array[j+<span class="number">1</span>];</span><br><span class="line">                    array[j+<span class="number">1</span>] = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">7</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">46</span>,<span class="number">94</span>,<span class="number">84</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">46</span>,<span class="number">5</span>,<span class="number">45</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        sort(array);</span><br><span class="line">        System.out.println(Arrays.toString(array));</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        输出:</span></span><br><span class="line"><span class="comment">        &gt;[3, 4, 5, 5, 6, 7, 8, 45, 46, 46, 84, 94]</span></span><br><span class="line"><span class="comment">        **/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码使用双循环进行排序，外部循环控制所有的回合，内部循环实现每一轮的冒泡处理，进行元素比较，在进行元素排</p><h4 id="算法优化"><a href="#算法优化" class="headerlink" title="算法优化"></a>算法优化</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;排序算法&quot;&gt;&lt;a href=&quot;#排序算法&quot; class=&quot;headerlink&quot; title=&quot;排序算法&quot;&gt;&lt;/a&gt;排序算法&lt;/h2&gt;&lt;p&gt;根据时间复杂度的不同，主流的排序算法分为3大类&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;时间复杂度为O(n[^^]2)的排序算法&lt;/s
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>浅尝算法</title>
    <link href="http://yoursite.com/2020/02/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2020/02/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95/</id>
    <published>2020-02-20T12:54:01.000Z</published>
    <updated>2021-01-17T14:01:37.471Z</updated>
    
    <content type="html"><![CDATA[<h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><p>根据时间复杂度的不同，主流的排序算法分为3大类</p><p><strong>时间复杂度为O(n[^^]2)的排序算法</strong></p><ul><li>排序算法</li><li>选择排序</li><li>插入排序</li><li>希尔排序</li></ul><p><strong>时间复杂度为O(nlogn)的排序算法</strong></p><ul><li>快速排序</li><li>归并排序</li><li>堆排序</li></ul><p><strong>时间复杂度为线性的排序算法</strong></p><ul><li>计数排序</li><li>桶排序</li><li>基数排序</li></ul><h3 id="冒泡排序-bubble-sort"><a href="#冒泡排序-bubble-sort" class="headerlink" title="冒泡排序(bubble sort)"></a>冒泡排序(bubble sort)</h3><p>冒泡排序的思想就是把相邻的元素进行两两比较，当一个元素大于右侧相邻的元素时，交换它们的位置；当一个元素小于或等于右侧相邻元素时，位置不变。</p><p>冒泡排序是一种稳定的排序，值相等的元素并不会打乱原本的排序。由于该排序算法的每一轮都会遍历所有元素，总共遍历(元素数量-1)轮，所以平均时间复杂度为O(n[^^]2)。</p><p><code>代码实现</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">bubblesort</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;array.length-i-<span class="number">1</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(array[j]&gt;array[j+<span class="number">1</span>])&#123;</span><br><span class="line">                    tmp = array[j];</span><br><span class="line">                    array[j] = array[j+<span class="number">1</span>];</span><br><span class="line">                    array[j+<span class="number">1</span>] = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">5</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">7</span>&#125;;</span><br><span class="line">        sort(array);</span><br><span class="line">        System.out.println(Arrays.toString(array));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[3, 4, 5, 5, 6, 7, 8, 45, 46, 46, 84, 94]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>代码使用双循环进行排序，外部循环控制所有的回合，内部循环实现每一轮的冒泡处理，进行元素比较，再进行元素排序。</p><h3 id="冒泡排序的优化"><a href="#冒泡排序的优化" class="headerlink" title="冒泡排序的优化"></a>冒泡排序的优化</h3><p>在刚才描述的排序中，仍以【5,8,6,3,9,2,1,7】为例，当算法分别执行到第6、7轮时，数组状态如下：</p><p>【1，2，3，4，5，6，7，8，9】这是第6轮的。</p><p>第7轮：【1，2，3，4，5，6，7，8，9】。</p><p>在第6轮中整个数组就已经是有序的了，可算法还是执行了第7轮排序。</p><p>如果能够判断出数列已经有序，并做出标记，那么剩下的几轮排序就不必执行，可以提前结束。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> algs;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">bubblesort1</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lastExchangeIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sortBorder = array.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;array.length-<span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">boolean</span> isSorted = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;sortBorder; j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(array[j]&gt;array[j+<span class="number">1</span>])&#123;</span><br><span class="line">                    tmp = array[j];</span><br><span class="line">                    array[j] = array[j+<span class="number">1</span>];</span><br><span class="line">                    array[j+<span class="number">1</span>] = tmp;</span><br><span class="line">                    isSorted = <span class="keyword">false</span>;</span><br><span class="line">                    lastExchangeIndex = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            sortBorder = lastExchangeIndex;</span><br><span class="line">            <span class="keyword">if</span>(isSorted)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">7</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">46</span>,<span class="number">94</span>,<span class="number">84</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">46</span>,<span class="number">5</span>,<span class="number">45</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        sort(array);</span><br><span class="line">        System.out.println(Arrays.toString(array));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[3, 4, 5, 5, 6, 7, 8, 45, 46, 46, 84, 94]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>快速排序在每一轮中挑选一个基准元素，并让其它比它大的元素移动到数列的一边，比它小的元素移动到另一边，从而把数列拆解成两个部分。这叫分而治之。</p><p>每一轮的比较和交换，需要把数组全部元素都遍历一遍，时间复杂度为O(n)，这样下来平均需要logn轮，因此快速排序的总体的平均时间复杂度为O(nlogn)。</p><ul><li><p>基准元素的选择</p><p>基准元素（pivot），在分治过程中，以基准为中心，把其他基准元素移动到它左右两边。</p><p>那如何选择基准元素呢？</p><p>最简单的方式就是选择数列的第一个元素。但是这种方式在一些特殊情况下优点麻烦，所以这种方式还是不好。</p><p>为了尽量避开这种麻烦。在选择基准元素时，可随机选择一个元素作为基准元素，并且让基准元素和数列的首位元素交换位置。</p></li><li><p>元素的交换</p><p>元素的交换方式有两种：</p><p>1.双边循环法</p><p>如下图中数列：要求对其从小到大进行排序</p><p><img src="C:%5CUsers%5C%E6%9D%A8%5CDesktop%5Clist.png" alt=""></p><p><strong>首先，选定基准元素pivot，并且设置两个指针left和right，指向数列的最左和最右两个元素。</strong></p><p><strong>接下来进行第一次循环，从right指针开始，让指针所指向的元素和基准元素做比较。如果大于或等于pivot，则指针向左移动，如果小于pivot，则right指针停止移动，切换到left指针。</strong></p><p><strong>到了left指针移动，让指针所指向的元素和基准元素做比较，如果小于或等于pivot，则指针向右移动，让left和right指针所指向的元素进行交换。如果大于pivot，则left指针停止移动。</strong></p><p><img src="C:%5CUsers%5C%E6%9D%A8%5CDesktop%5C2.jpg" alt=""></p></li></ul><p>  2.单边循环法</p><p>  首先选定基准元素pivot。同时，设置一个mark指针指向数列的起始位置，这个mark指针代表小于基准元素的区域的边界。</p><p>  <img src="C:%5CUsers%5C%E6%9D%A8%5CDesktop%5Clist2.png" alt=""></p><p>  接下来，从基准元素的下一个位置开始遍历数组。</p><p>  如果遍历到的元素大于基准元素，就继续向后遍历。</p><p>  如果遍历到的元素小于基准元素，则需要做两件事：第一，把mark指针右移1位，因为小于pivot的区域边界增大了1，第二，让最新遍历到的元素和mark指针所在的位置的元素交换位置，因为最新遍历的元素归属于小于pivot的区域。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> algs;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">quicksort2</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> startIndex,<span class="keyword">int</span> endIndex)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(startIndex &gt;= endIndex)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> partition = partition(arr,startIndex,endIndex);</span><br><span class="line">        quickSort(arr,startIndex,partition-<span class="number">1</span>);</span><br><span class="line">        quickSort(arr,partition+<span class="number">1</span>,endIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[]arr,<span class="keyword">int</span> startIndex,<span class="keyword">int</span> endIndex)</span></span>&#123;        </span><br><span class="line">        <span class="keyword">int</span> pivot = arr[startIndex];</span><br><span class="line">        <span class="keyword">int</span> mark = startIndex;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = startIndex+<span class="number">1</span>;i&lt;=endIndex;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i]&lt;pivot)&#123;</span><br><span class="line">                mark++;</span><br><span class="line">                <span class="keyword">int</span> tmp = arr[mark];</span><br><span class="line">                arr[mark] = arr[i];</span><br><span class="line">                arr[i] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后把pivot元素交换到mark指针所在位置</span></span><br><span class="line">        arr[startIndex] = arr[mark];</span><br><span class="line">        arr[mark] = pivot;</span><br><span class="line">        <span class="keyword">return</span> mark;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> arr[] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">4</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        quickSort(arr,<span class="number">0</span>,arr.length-<span class="number">1</span>);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <img src="C:%5CUsers%5C%E6%9D%A8%5CDesktop%5Cl.png" alt=""></p><p>  3.非递归实现</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> algs;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">quicksort3</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> startIndex,<span class="keyword">int</span> endIndex)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 用一个集合栈来代替递归函数栈</span></span><br><span class="line">        Stack&lt;Map&lt;String,Integer&gt;&gt; quickSortStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="comment">// 整个数列的起始下标，以哈希的形式入栈</span></span><br><span class="line">        Map&lt;String,Integer&gt; rootparam = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        rootparam.put(<span class="string">"startIndex"</span>,startIndex);</span><br><span class="line">        rootparam.put(<span class="string">"endIndex"</span>,endIndex);</span><br><span class="line">        quickSortStack.push(rootparam);</span><br><span class="line">        <span class="comment">// 循环结束条件：栈为空时</span></span><br><span class="line">        <span class="keyword">while</span>(!quickSortStack.isEmpty())&#123;</span><br><span class="line">            <span class="comment">// 栈顶元素出栈，得到起始下标</span></span><br><span class="line">            Map&lt;String,Integer&gt; param = quickSortStack.pop();</span><br><span class="line">            <span class="comment">// 得到基准元素位置</span></span><br><span class="line">            <span class="keyword">int</span> pivotIndex = partition(arr,param.get(<span class="string">"startIndex"</span>),param.get(<span class="string">"endIndex"</span>));        </span><br><span class="line">            <span class="comment">// 根据基准元素分成两部分，把每个部分的起始下标入栈</span></span><br><span class="line">            <span class="keyword">if</span>(param.get(<span class="string">"startIndex"</span>) &lt; pivotIndex-<span class="number">1</span>)&#123;</span><br><span class="line">                Map&lt;String,Integer&gt; leftparam = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">                leftparam.put(<span class="string">"startIndex"</span>,param.get(<span class="string">"startIndex"</span>));</span><br><span class="line">                leftparam.put(<span class="string">"endIndex"</span>,pivotIndex-<span class="number">1</span>);</span><br><span class="line">                quickSortStack.push(leftparam);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(pivotIndex+<span class="number">1</span> &lt; param.get(<span class="string">"endIndex"</span>))&#123;</span><br><span class="line">                Map&lt;String,Integer&gt; rightParam = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">                rightParam.put(<span class="string">"startIndex"</span>,pivotIndex+<span class="number">1</span>);</span><br><span class="line">                rightParam.put(<span class="string">"endIndex"</span>,param.get(<span class="string">"endIndex"</span>));</span><br><span class="line">                quickSortStack.push(rightParam);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[]arr,<span class="keyword">int</span> startIndex,<span class="keyword">int</span> endIndex)</span></span>&#123;        </span><br><span class="line">        <span class="keyword">int</span> pivot = arr[startIndex];</span><br><span class="line">        <span class="keyword">int</span> mark = startIndex;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = startIndex+<span class="number">1</span>;i&lt;=endIndex;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i]&lt;pivot)&#123;</span><br><span class="line">                mark++;</span><br><span class="line">                <span class="keyword">int</span> tmp = arr[mark];</span><br><span class="line">                arr[mark] = arr[i];</span><br><span class="line">                arr[i] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后把pivot元素交换到mark指针所在位置</span></span><br><span class="line">        arr[startIndex] = arr[mark];</span><br><span class="line">        arr[mark] = pivot;</span><br><span class="line">        <span class="keyword">return</span> mark;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> arr[] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">4</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">68</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">54</span>&#125;;</span><br><span class="line">        quickSort(arr,<span class="number">0</span>,arr.length-<span class="number">1</span>);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[1, 2, 3, 4, 4, 5, 6, 8, 9, 54, 68]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;排序算法&quot;&gt;&lt;a href=&quot;#排序算法&quot; class=&quot;headerlink&quot; title=&quot;排序算法&quot;&gt;&lt;/a&gt;排序算法&lt;/h2&gt;&lt;p&gt;根据时间复杂度的不同，主流的排序算法分为3大类&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;时间复杂度为O(n[^^]2)的排序算法&lt;/s
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构基础</title>
    <link href="http://yoursite.com/2020/02/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2020/02/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/</id>
    <published>2020-02-20T04:54:01.000Z</published>
    <updated>2020-12-08T13:23:54.972Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>  数据结构是算法的基石，是数据的组织、管理、存储形式，请使用的目的是为了访问和修改数据。数据结构的组成形式有：线性结构、树、图、其他数据结构（这个后面会缀述）</p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><ul><li><p>数组是有限个相同类型的变量所组成的有序集合，数组中的每个变量称为元素。</p><h4 id="数组的基本操作"><a href="#数组的基本操作" class="headerlink" title="数组的基本操作"></a>数组的基本操作</h4></li><li><p>读取元素：读取元素，只需要给出一个数组的下标，就可以读取相应的数组元素。这种根据下标读取的元素的方式称为随机读取。</p></li><li><p>更新元素：把一个元素的值替换成为一个新值，利用数组下标，把新值赋给该元素。</p></li><li><p>插入元素：插入数组元素的有三种：尾部插入、中间插入、超范围插入。</p><p>中间插入复杂些，因为数组的每个元素都有固定的下标，所以需要把插入位置及以后的元素向后移动，再把插入的元素放到对应的数组位置上。</p><p>超范围插入：超范围插入涉及到扩容，可以创建一个新数组，长度是旧数组的2倍，再把旧数组中的元素复制给新数组，就是实现了数组的扩容。</p></li><li><p>删除元素：数组的删除操作，如果删除的元素位于数组的中间，其后的元素都需要向前（也就是向左移动一位）</p><h4 id="数组的优点和缺点"><a href="#数组的优点和缺点" class="headerlink" title="数组的优点和缺点"></a>数组的优点和缺点</h4><p>数组的优点是拥有高效的随机访问能力。数组的缺点在插入和删除元素方面，由于数组元素连续紧密的存储在内存中，插入和删除元素会导致大量元素移动。数组适合读多写少的应用场景。</p></li></ul><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>  <strong>链表</strong>是一种在物理上非连续、非顺序的数据结构，由若干节点所组成。单向链表的每个节点包含两部分，一部分是存放数据的变量<strong>data</strong>，一部分是指向下一个节点的指针<strong>next</strong>。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line">Node next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  双向链表比单项链表多了指向前置节点的<strong>prev</strong>指针</p><p>  链表在内存中的存储方式是随机存储</p><h4 id="链表的基本操作"><a href="#链表的基本操作" class="headerlink" title="链表的基本操作"></a>链表的基本操作</h4><ul><li><p>查找节点：</p><p>链表查找节点时只能从头节点开始向后逐个查找。</p></li><li><p>更新节点：</p><p>链表的更新过程会像数组那样，直接把旧数据替换成新数据即可</p></li><li><p>插入节点：</p><p>尾部插入：把最后一个节点的next指针指向新插入的节点即可。</p><p>头部插入：把新节点的next节点的指针原先的头节点，把新节点变成链表的头节点</p><p>中间插入：把新节点的next指针指向插入位置的节点，插入位置前置节点的next指针指向新节点。</p></li><li><p>删除元素：</p><p>尾部删除：把倒数第二个节点的next指针指向空即可</p><p>头部删除：把链表的头节点设为原先头节点的next指针即可</p><p>中间删除：把要删除的节点的前置节点的next指针，指向要删除元素的下一个节点即可</p></li></ul><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLinkedList</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node head;</span><br><span class="line">    <span class="keyword">private</span> Node last;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> data,<span class="keyword">int</span> index)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt; size)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"Index outfound"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Node insertedNode = <span class="keyword">new</span> Node(data);</span><br><span class="line">        <span class="keyword">if</span>(size == <span class="number">0</span>)&#123;</span><br><span class="line">            head = insertedNode;</span><br><span class="line">            last = insertedNode;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(index == <span class="number">0</span>)&#123;</span><br><span class="line">            insertedNode.next = head;</span><br><span class="line">            head = insertedNode;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(size == index)&#123;</span><br><span class="line">            last.next = insertedNode;</span><br><span class="line">            last = insertedNode;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            Node prevNode = get(index-<span class="number">1</span>);</span><br><span class="line">            insertedNode.next = prevNode.next;</span><br><span class="line">            prevNode.next = insertedNode;</span><br><span class="line">        &#125;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt;= size)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"数组越界"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Node temp = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;index;i++)&#123;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">output</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Node temp = head;</span><br><span class="line">        <span class="keyword">while</span>(temp != <span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(temp.data);</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"size："</span>+size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span>|| index &gt;= size)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"下标越界"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Node removeNode = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(index == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 删除头结点</span></span><br><span class="line">            removeNode = head;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(index == size-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">// 删除尾节点</span></span><br><span class="line">            Node prevNode = get(index-<span class="number">1</span>);</span><br><span class="line">            removeNode = prevNode.next;</span><br><span class="line">            prevNode.next = <span class="keyword">null</span>;</span><br><span class="line">            last = prevNode;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 删除中间节点</span></span><br><span class="line">            Node prevNode = get(index-<span class="number">1</span>);</span><br><span class="line">            Node nextNode = prevNode.next.next;</span><br><span class="line">            removeNode = prevNode.next;</span><br><span class="line">            prevNode.next = nextNode;</span><br><span class="line">        &#125;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> removeNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> data;</span><br><span class="line">        Node next;</span><br><span class="line">        Node(<span class="keyword">int</span> data)&#123;</span><br><span class="line">            <span class="keyword">this</span>.data = data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        MyLinkedList myLinkedList = <span class="keyword">new</span> MyLinkedList();</span><br><span class="line">        myLinkedList.insert(<span class="number">3</span>,<span class="number">0</span>);</span><br><span class="line">        myLinkedList.insert(<span class="number">7</span>,<span class="number">1</span>);</span><br><span class="line">        myLinkedList.insert(<span class="number">9</span>,<span class="number">2</span>);</span><br><span class="line">        myLinkedList.insert(<span class="number">5</span>,<span class="number">3</span>);</span><br><span class="line">        myLinkedList.insert(<span class="number">6</span>,<span class="number">1</span>);</span><br><span class="line">        myLinkedList.remove(<span class="number">0</span>);</span><br><span class="line">        myLinkedList.output();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数组和链表的比较：</p><table><thead><tr><th></th><th>查找</th><th>更新</th><th>插入</th><th>删除</th></tr></thead><tbody><tr><td>数组</td><td>O(1)</td><td>O(1)</td><td>O(n)</td><td>O(n)</td></tr><tr><td>链表</td><td>O(n)</td><td>O(1)</td><td>O(1)</td><td>O(1)</td></tr></tbody></table><p>对于读操作多写操作少的应用场景数组适合一些，对于需要频繁插入数据删除数据来说，链表合适一些</p><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>栈是一种线性数据结构，栈中的元素只能先入后出。最早进入的元素存放的位置叫作栈底，最后进入的元素存放的位置叫作栈顶。</p><h4 id="栈的基本操作"><a href="#栈的基本操作" class="headerlink" title="栈的基本操作"></a>栈的基本操作</h4><ul><li><p>入栈(push)</p><p>入栈操作就是把新元素放入栈中，只允许从栈顶一侧放入元素，新元素的位置将会成为新的栈顶</p></li><li><p>出栈(pop)</p><p>出栈操作是把元素从栈中弹出，只有栈顶元素才能允许出栈，出栈元素的前一个元素将会成为新的栈顶。</p></li></ul><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyStack</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] stack;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStack</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.stack = <span class="keyword">new</span> <span class="keyword">int</span>[capacity];</span><br><span class="line">        <span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> elem)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(size &gt; stack.length)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"数组越界"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        stack[size] = elem;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(size &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"栈为空"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> stack[size];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">output</span><span class="params">()</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"栈顶："</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = size-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            System.out.println(pop());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"栈底："</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        MyStack stack = <span class="keyword">new</span> MyStack(<span class="number">5</span>);</span><br><span class="line">        stack.push(<span class="number">5</span>);</span><br><span class="line">        stack.push(<span class="number">6</span>);</span><br><span class="line">        stack.push(<span class="number">52</span>);</span><br><span class="line">        System.out.println(stack.pop());</span><br><span class="line">        <span class="comment">// stack.output();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p><strong>队列</strong>是一种线性数据结构，队列中的元素只能先入后出，对列的出口端叫作<strong>队头</strong>(front)，队列的入口端叫作<strong>队尾</strong>(rear)。</p><h4 id="队列的基本操作"><a href="#队列的基本操作" class="headerlink" title="队列的基本操作"></a>队列的基本操作</h4><ul><li><p>入队（enqueue）</p><p>入队操作（enqueue）就是把新元素放入队列中，只允许在队尾的位置放入元素，新元素的下一个位置将会成为新的对尾。</p></li><li><p>出队（dequeue）</p><p>出队操作就是把元素移出队列，只允许在队头一侧移出元素，出队元素的后一个元素将会成为队头。</p></li></ul><p><strong>循环队列</strong>：在数组不做扩容的前提下，可以利用已出队元素留下的空间，让队尾指针重新指回数组的首位。<strong>一直到(队尾下标+1)%数组长度 = 队头下标，表示此队列已经满</strong>，队尾指针指向的位置永远空出1位，所以队列最大容量比数组长度小1。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] array;</span><br><span class="line">    <span class="comment">// 队头</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> front;</span><br><span class="line">    <span class="comment">// 队尾</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> rear;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.array = <span class="keyword">new</span> <span class="keyword">int</span>[capacity];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    入队操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(<span class="keyword">int</span> elem)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>((rear+<span class="number">1</span>)%array.length == front)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"队列已满"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        array[rear] = elem;</span><br><span class="line">        rear = (rear+<span class="number">1</span>)%array.length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dequeue</span><span class="params">()</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(rear==front)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"队列已空"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> dequeueElem = array[front];</span><br><span class="line">        front = (front+<span class="number">1</span>)%array.length;</span><br><span class="line">        <span class="keyword">return</span> dequeueElem;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">output</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = front;i!=rear;i=(i+<span class="number">1</span>)%array.length)&#123;</span><br><span class="line">            System.out.println(array[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        MyQueue queue = <span class="keyword">new</span> MyQueue(<span class="number">5</span>);</span><br><span class="line">        queue.enqueue(<span class="number">5</span>);</span><br><span class="line">        queue.enqueue(<span class="number">4</span>);</span><br><span class="line">        queue.enqueue(<span class="number">6</span>);</span><br><span class="line">        queue.enqueue(<span class="number">5</span>);</span><br><span class="line">        queue.output();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="栈和队列的应用"><a href="#栈和队列的应用" class="headerlink" title="栈和队列的应用"></a>栈和队列的应用</h3><p>栈的输出顺序和输入顺序相反，所以栈通常用于对“历史”的回溯，也就是逆流而上追溯“历史”。<br>例如实现递归的逻辑，就可以用栈来代替，因为栈可以回溯方法的调用链。</p><p>队列的输出顺序和输入顺序相同，所以队列通常用于对“历史”的回放，也就是按照“历史”顺序，把“历<br>史”重演一遍。<br>例如在多线程中，争夺公平锁的等待队列，就是按照访问顺序来决定线程在队列中的次序的。</p><h3 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h3><p>散列表也叫<strong>哈希表(hash table)</strong>，散列表在本质上也是一个数组。这种数据结构提供了键值对的映射关系。只要给出Key，就可以查找出它所匹配的Value，时间复杂度接近O(1)。</p><h4 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h4><p>在不同的编程语言中，哈希函数的实现也不一样，这里以Java为例，在Java及大多数面向对象编程语言中，每个对象都有自己的hashcode，hashcode是区分不同对象的重要标识，无论对象的自身类型是什么，它们的hashcode都是一个整型变量。最简单的转化方式是按照数组长度进行取模运算。</p><p><strong>index = HashCode(Key)%Array.length</strong></p><p>通过哈希函数，可以把字符串或其他类型的Key转化为数组的下标index。</p><h4 id="散列表的读写操作"><a href="#散列表的读写操作" class="headerlink" title="散列表的读写操作"></a>散列表的读写操作</h4><ul><li><p>写操作（put）</p><p>写操作就是在散列表中插入新的键值对，通过哈希函数，把Key转化为数组下标，如果数组下标没有对应的元素，就把这个Entry填充到数组下标的相应位置。由于数组的长度有限，当插入的Entry越来越多时，不同的Key通过哈希函数获得的下标也有可能相同，所以这就造成了哈希冲突。哈希冲突是无法避免的。解决哈希冲突的方法有两中；一种是开放寻址法，一种是链表法。在Java中开放寻址法用于ThreadLocal。HashMap使用的是链表法解决哈希冲突问题。HashMap数组的每个元素不仅是一个Entry对象，还是一个链表的头节点，每个Entry对象通过next指针指向它的下一个Entry节点。当新来的Entry映射到与之冲突的数组位置时，只需要插入到对应的链表中即可。</p></li><li><p>读操作（get）</p><p>读操作就是通过给定的Key，在散列表中查找对应的Value。通过哈希函数，把Key转化为数组的下标。找到数组下标对应的元素，如果找到了这个元素就返回对应数组的值；如果找不到就顺着这个数组的元素的链表往下找，是否能够找到与之对匹配的节点。</p></li><li><p>扩容（resize）</p><p>当经过多次元素插入，散列表达到一定的饱和时，key映射的位置发生冲突的几率会增加。大量的元素拥挤在相同的数组下标位置下，会形成很长的链表。对于后续的插入操作和查询操作的性能都有很大的影响，这时就需要扩容了。</p><p>散列表的扩容操作</p><ul><li>扩容，创建一个新的Entry空数组，长度为元素的两倍。</li><li>重新hash，遍历原Entry数组，把所有的Entry重新Hash到新数组中，因为长度扩容后，Hash的规则也随之变化。</li></ul><p>用Java中的散列表实现类HashMap为例，影响扩容的因素有两个：</p><p>Capacity：散列表的当前长度</p><p>LoadFactor：散列表的负载因子，默认值为0.75f</p><p>衡量HashMap需要扩容的条件如下：</p><p>HashMap.size &gt;= Capacity*LoadFactor</p></li></ul><h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><p>树（tree）是n（n&gt;=0）个节点的有限集。当n=0时，称为空树。在任意一个非空树中，有下面两个特点。</p><ul><li>有且仅有一个特定的称为根的节点。</li><li>当n&gt;1时，其余的节点可分为m（m&gt;0）个互不相交的有限集，每个集合本身又是一个树，并称为根的子树。</li></ul><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>二叉树是树的一种特殊形式。这种树结构的每个节点最多有2个子节点，也可能只有1个，或者没有孩子节点。二叉树的两个孩子节点，一个称为左孩子节点(left child)，一个称为右孩子节点（right child）,这两个孩子节点的顺序是固定的，不能够颠倒。</p><p>二叉树还有两种特殊的形式，一个叫作满二叉树，一个叫完全二叉树。</p><h4 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h4><p><strong>是一个二叉树的所有非叶子节点都存在左右节点，并且所有叶子节点都在同一层级上，那么这个树就是满二叉树。</strong>也就是说满二叉树的每个分支都是满的。</p><h4 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h4><p><strong>对一个有n个节点的二叉树，按层级顺序编号，则所有节点的编号为从1到n。如果这个树所有节点和同样深度的满二叉树的编号为从1到n的节点位置相同，则这个二叉树为完全二叉树。</strong></p><h4 id="二叉树的物理存储结构"><a href="#二叉树的物理存储结构" class="headerlink" title="二叉树的物理存储结构"></a>二叉树的物理存储结构</h4><ul><li><p>链式存储结构</p><p>链式存储结构的二叉树每个节点包含3部分：存储数据的data变量、指向左孩子的left指针、指向右孩子的right指针。</p></li><li><p>数组</p><p>使用数组存储，会按照层级顺序把二叉树的节点放到数组中对应的位置上。如果某个节点的左孩子或右孩子，则数组的相应位置也空出来。这样就可以更方便地在数组中定位二叉树的孩子节点和父节点。</p><p>假设一个父节点的下标是parent，那么它的左孩子的节点下标就是：<strong>leftchild=2*parent+1</strong>；右孩子节点下标就是：<strong>rightchild=2*parent+2</strong>。</p></li></ul><h4 id="二叉树的应用"><a href="#二叉树的应用" class="headerlink" title="二叉树的应用"></a>二叉树的应用</h4><ul><li><p>查找</p><p>将二叉树用作查找，有一种特殊的二叉树：二叉查找树（binary search tree）这种二叉树主要作用就是进行查找操作。</p><p>二叉查找树在二叉树的基础上增加了一下几个条件：</p><ul><li>如果左子树不为空，则左子树上所有节点的值均小于根节点的值。</li><li>如果右子树不为空，则右子树上所有节点的值均大于根节点的值。</li><li>左，右子树也都是二叉查找树。</li></ul><p>对于一个节点分布相对均衡的二叉查找树来说，如果节点总数是n，那么搜索节点的时间复杂度就是O(logn)，和树的深度一样。</p></li><li><p>维持相对顺序</p><p>二叉查找树要求左子树小于父节点，右子树大于父节点，这样就保证了二叉树的有序性。所有二叉树查找树还有一个名字——二叉排序树</p></li></ul><h4 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h4><p>从宏观的角度看，二叉树的遍历分为两大类：</p><p>深度优先遍历（前序遍历、中序遍历、后序遍历）。</p><ul><li><p>二叉树的遍历方式：二叉树的遍历有4种</p><ul><li><p>前序遍历</p><p>二叉树的前序遍历，输出的顺序是根节点、左子树、右子树。</p></li><li><p>中序遍历</p><p>二叉树的中序遍历，输出的顺序是左子树、根节点、右子树。</p></li><li><p>后序遍历</p><p>二叉树的后序遍历，输出的顺序是左子树、右子树、根节点。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line">  <span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">createBinaryTree</span><span class="params">(LinkedList&lt;Integer&gt; inputList)</span></span>&#123;</span><br><span class="line">          TreeNode node = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(inputList == <span class="keyword">null</span> || inputList.isEmpty())&#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          Integer data = inputList.removeFirst();</span><br><span class="line">          <span class="keyword">if</span>(data != <span class="keyword">null</span>)&#123;</span><br><span class="line">              node = <span class="keyword">new</span> TreeNode(data);</span><br><span class="line">              node.leftchild = createBinaryTree(inputList);</span><br><span class="line">              node.rightchild = createBinaryTree(inputList);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> node;        </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">      二叉树遍历</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">  </span><br><span class="line">      <span class="comment">/**前序遍历 */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrderTraverla</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">          <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          System.out.println(node.data);</span><br><span class="line">          preOrderTraverla(node.leftchild);</span><br><span class="line">          preOrderTraverla(node.rightchild);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/**中序遍历 */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inOrderTraveral</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">          <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          inOrderTraveral(node.leftchild);</span><br><span class="line">          System.out.println(node.data);</span><br><span class="line">          inOrderTraveral(node.rightchild);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/**后序遍历 */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">postOrderTraveral</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">          <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          postOrderTraveral(node.leftchild);</span><br><span class="line">          postOrderTraveral(node.rightchild);</span><br><span class="line">          System.out.println(node.data);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 树节点</span></span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span></span>&#123;</span><br><span class="line">          <span class="keyword">int</span> data;</span><br><span class="line">          TreeNode leftchild;</span><br><span class="line">          TreeNode rightchild;</span><br><span class="line">          TreeNode(<span class="keyword">int</span> data)&#123;</span><br><span class="line">              <span class="keyword">this</span>.data = data;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 利用栈来实现前序遍历</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrderTraverlaWithStack</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">          Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">          TreeNode treeNode = node;</span><br><span class="line">          <span class="keyword">while</span>(treeNode != <span class="keyword">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">              <span class="comment">// 迭代访问节点的左孩子，并入栈</span></span><br><span class="line">              <span class="keyword">while</span>(treeNode != <span class="keyword">null</span>)&#123;</span><br><span class="line">                  System.out.println(treeNode.data);</span><br><span class="line">                  stack.push(treeNode);</span><br><span class="line">                  treeNode = treeNode.leftchild;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">// 如果节点没有左孩纸，这弹出栈顶节点，访问节点右孩子</span></span><br><span class="line">              <span class="keyword">if</span>(!stack.isEmpty())&#123;</span><br><span class="line">                  treeNode = stack.pop();</span><br><span class="line">                  treeNode = treeNode.rightchild;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">          LinkedList&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;(Arrays.asList(<span class="keyword">new</span> Integer[]&#123;<span class="number">32</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="number">10</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="number">8</span>,<span class="keyword">null</span>,<span class="number">4</span>&#125;));</span><br><span class="line">          TreeNode tree = createBinaryTree(list);</span><br><span class="line">          System.out.println(<span class="string">"前序遍历(栈实现)"</span>);</span><br><span class="line">          <span class="comment">// preOrderTraverla(tree);</span></span><br><span class="line">          preOrderTraverlaWithStack(tree);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>广度优先遍历（层序遍历）。</p><ul><li><p>层序遍历</p><p>层序遍历就是按照二叉树从根节点到叶子节点的层次关系，一层一层横向遍历的各个节点。</p></li></ul></li></ul><h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">levelOrderTraversal</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            System.out.println(node.data);</span><br><span class="line">            <span class="keyword">if</span>(node.leftchild != <span class="keyword">null</span>)&#123;</span><br><span class="line">                queue.offer(node.leftchild);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node.rightchild!= <span class="keyword">null</span>)&#123;</span><br><span class="line">                queue.offer(node.rightchild);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></code></pre><h2 id="二叉堆"><a href="#二叉堆" class="headerlink" title="二叉堆"></a>二叉堆</h2><p><strong>二叉堆</strong>本质上就是一种完全二叉树，分为<strong>最大堆</strong>和<strong>最小堆</strong>两类。最大堆的任何一个父节点的值都大于或等于它左右孩子节点的值。最小堆的任何一个父节点的值都小于或等于它左右孩子节点的值。二叉堆的根节点叫作堆顶。最大堆的堆顶是整个堆中的最大的元素；最小堆的堆顶是整个堆中的最小元素。</p><ul><li><p>二叉堆的特性</p><p>最大堆的堆顶是整个堆中的最大元素。</p><p>最小堆的堆顶是整个堆中的最小元素。</p></li></ul><h4 id="二叉堆的自我调整"><a href="#二叉堆的自我调整" class="headerlink" title="二叉堆的自我调整"></a>二叉堆的自我调整</h4><ul><li><p>插入元素</p><p>当二叉堆插入节点时，插入位置是完全二叉树的最后一个位置。</p></li><li><p>删除元素</p><p>二叉堆删除的节点是删除处于堆顶的节点。</p></li><li><p>构建二叉堆</p><p>构建二叉堆，就是把一个无序的完全二叉树调整为二叉堆，本质是让所有非叶子节点依次</p><p>“下沉”</p></li></ul><p>堆的插入、删除、构建操作的时间复杂度：</p><p>堆的插入操作是单一节点的“上浮”，堆的删除操作是单一节点的“下沉”，两个操作是的平均交换次数都是堆高度的一半，时间复杂度是O(logn)，堆的构建，需要所有非叶子节点依次“下沉”，时间复杂度是O(n)</p><h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHeap</span></span>&#123;</span><br><span class="line">    <span class="comment">// “上浮”调整</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">upAdjust</span><span class="params">(<span class="keyword">int</span> [] arr)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 假设找出最后一个元素节点(也就是叶子节点)。用于推导出其父节点</span></span><br><span class="line">        <span class="keyword">int</span> childIndex = arr.length-<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 根据左孩子节点（叶子节点）算出父节点。</span></span><br><span class="line">        <span class="keyword">int</span> parentIndex = (childIndex-<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 设置临时节点，用于保存插入叶子节点值，用于最后的赋值</span></span><br><span class="line">        <span class="keyword">int</span> temp = arr[childIndex];</span><br><span class="line">        <span class="keyword">while</span>(childIndex &gt; <span class="number">0</span> &amp;&amp; temp &lt; arr[parentIndex])&#123;</span><br><span class="line">            arr[childIndex] = arr[parentIndex];</span><br><span class="line">            childIndex = parentIndex;</span><br><span class="line">            parentIndex = (parentIndex-<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[childIndex] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">downAdjust</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">int</span> parentIndex,<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 用于保存父节点的值，最后赋值</span></span><br><span class="line">        <span class="keyword">int</span> temp = array[parentIndex];</span><br><span class="line">        <span class="keyword">int</span> childIndex = (<span class="number">2</span>*parentIndex)+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(childIndex &lt; length)&#123;</span><br><span class="line">            <span class="comment">// 如果有右孩子，且右孩子小于左孩子的值，则定位到右孩子</span></span><br><span class="line">            <span class="keyword">if</span>(childIndex+<span class="number">1</span> &lt; length &amp;&amp; array[childIndex+<span class="number">1</span>] &lt; array[childIndex])&#123;</span><br><span class="line">                childIndex++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果父节点小于任何一个孩子的值，直接跳出</span></span><br><span class="line">            <span class="keyword">if</span>(temp &lt;= array[childIndex])&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            array[parentIndex] = array[childIndex];</span><br><span class="line">            parentIndex = childIndex;</span><br><span class="line">            childIndex = (<span class="number">2</span>*childIndex)+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        array[parentIndex] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildHeap</span><span class="params">(<span class="keyword">int</span>[]array)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 从最后一个非叶子节点开始，依次做“下沉”调整</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = (array.length-<span class="number">2</span>)/<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            downAdjust(array,i,array.length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        upAdjust(array);</span><br><span class="line">        System.out.println(Arrays.toString(array));</span><br><span class="line">        array = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">7</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">10</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">6</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        buildHeap(array);</span><br><span class="line">        System.out.println(Arrays.toString(array));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h2><p>优先队列是基于二叉堆来实现的，优先队列不再遵循先进先出原则，而是分为两种情况：</p><ul><li>最大优先队列，无论入队顺序如何，都是当前最大的元素优先出队</li><li>最小优先队列，无论入队顺序如何，都是当前最小的元素优先出队</li></ul><h4 id="优先队列的实现"><a href="#优先队列的实现" class="headerlink" title="优先队列的实现"></a>优先队列的实现</h4><p>回顾二叉堆的特性可以知道：最大堆的堆顶是整个堆中的最大元素。最小堆的堆顶是整个堆中的最小元素。因此，可以使用最大堆来实现最大优先队列，每一次入队操作都是堆的插入操作，每一次出队操作都是删除堆顶节点。优先队列入队和出队的时间复杂度都是O(logn)。</p><h4 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPriorityQueue</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] array; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyPriorityQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 队列的初始长度是32</span></span><br><span class="line">        array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">32</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 入队</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enQueue</span><span class="params">(<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(size &gt;= array.length)&#123;</span><br><span class="line">            resize();</span><br><span class="line">        &#125;</span><br><span class="line">        array[size++] = key;</span><br><span class="line">        upAdjust();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deQueue</span><span class="params">()</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(size &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"这个队列为空"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 堆顶元素</span></span><br><span class="line">        <span class="keyword">int</span> head = array[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 让最后一个元素移动到堆顶</span></span><br><span class="line">        array[<span class="number">0</span>] = array[--size];</span><br><span class="line">        downAdjust();</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 上浮</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">upAdjust</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> childIndex = size-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> parentIndex = (childIndex-<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> temp = array[childIndex];</span><br><span class="line">        <span class="keyword">while</span>(childIndex &gt; <span class="number">0</span> &amp;&amp; temp &gt; array[parentIndex])&#123;</span><br><span class="line">            array[childIndex] = array[parentIndex];</span><br><span class="line">            childIndex = parentIndex;</span><br><span class="line">            parentIndex = parentIndex/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        array[childIndex] = temp;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 下沉</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">downAdjust</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// temp保存父节点的值，用于最后的赋值</span></span><br><span class="line">        <span class="keyword">int</span> parentIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> temp = array[parentIndex];</span><br><span class="line">        <span class="keyword">int</span> childIndex = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(childIndex &lt; size)&#123;</span><br><span class="line">            <span class="comment">// 如果有右孩子，且右孩子大于左孩子的值，则定位到右孩子</span></span><br><span class="line">            <span class="keyword">if</span>(childIndex+<span class="number">1</span> &lt; size &amp;&amp; array[childIndex+<span class="number">1</span>] &gt; array[childIndex])&#123;</span><br><span class="line">                childIndex++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(temp &gt; array[childIndex])&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            array[parentIndex] = array[childIndex];</span><br><span class="line">            parentIndex = childIndex;</span><br><span class="line">            childIndex = <span class="number">2</span>*childIndex+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        array[parentIndex] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> newSize = <span class="keyword">this</span>.size*<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">this</span>.array = Arrays.copyOf(<span class="keyword">this</span>.array,newSize);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        MyPriorityQueue priorityQueue = <span class="keyword">new</span> MyPriorityQueue();</span><br><span class="line">        priorityQueue.enQueue(<span class="number">3</span>);</span><br><span class="line">        priorityQueue.enQueue(<span class="number">5</span>);</span><br><span class="line">        priorityQueue.enQueue(<span class="number">10</span>);</span><br><span class="line">        priorityQueue.enQueue(<span class="number">2</span>);</span><br><span class="line">        priorityQueue.enQueue(<span class="number">7</span>);</span><br><span class="line">        System.out.println(<span class="string">"出队元素："</span>+priorityQueue.deQueue());</span><br><span class="line">        System.out.println(<span class="string">"出队元素："</span>+priorityQueue.deQueue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;数据结构&quot;&gt;&lt;a href=&quot;#数据结构&quot; class=&quot;headerlink&quot; title=&quot;数据结构&quot;&gt;&lt;/a&gt;数据结构&lt;/h2&gt;&lt;p&gt;  数据结构是算法的基石，是数据的组织、管理、存储形式，请使用的目的是为了访问和修改数据。数据结构的组成形式有：线性结构、树
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Git快速入门</title>
    <link href="http://yoursite.com/2020/02/15/git/Git%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2020/02/15/git/Git%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</id>
    <published>2020-02-15T09:56:07.000Z</published>
    <updated>2020-03-27T10:35:41.420Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>Git安装(Windowns系统为例)</p><ul><li><p>下载Git软件:</p><p>点击链接:<a href="https://git-scm.com/" target="_blank" rel="noopener">https://git-scm.com/</a></p><p><img src="https://raw.githubusercontent.com/yangshenghua97/Image/master/git1.png" alt=""></p><p>双击！</p><p>一路Next！</p></li></ul></li><li><h2 id="1-Git命令行"><a href="#1-Git命令行" class="headerlink" title="1 Git命令行"></a>1 Git命令行</h2><p>git简单易用，只要在终端输入$ <code>Git</code>，Git就会不带任何参数输出它的选项和常用的子命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git</span><br><span class="line"><span class="comment">#输入git后会输出一下选项，如果要得到一个完整的git子命令列表，可以输入 git help --all</span></span><br><span class="line">usage: git [--version] [--<span class="built_in">help</span>] [-C &lt;path&gt;] [-c &lt;name&gt;=&lt;value&gt;]</span><br><span class="line">           [--<span class="built_in">exec</span>-path[=&lt;path&gt;]] [--html-path] [--man-path] [--info-path]</span><br><span class="line">           [-p | --paginate | -P | --no-pager] [--no-replace-objects] [--bare]</span><br><span class="line">····················</span><br><span class="line">collaborate (see also: git <span class="built_in">help</span> workflows)</span><br><span class="line">   fetch      Download objects and refs from another repository</span><br><span class="line">   pull       Fetch from and integrate with another repository or a <span class="built_in">local</span> branch</span><br><span class="line">   push       Update remote refs along with associated objects .....</span><br></pre></td></tr></table></figure><ul><li><h2 id="2-Git使用快速入门"><a href="#2-Git使用快速入门" class="headerlink" title="2 Git使用快速入门"></a>2 Git使用快速入门</h2><ul><li><h4 id="2-1创建初始版本库"><a href="#2-1创建初始版本库" class="headerlink" title="2.1创建初始版本库"></a>2.1创建初始版本库</h4><p>首先在git终端下创建一个空文件夹:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建空文件夹 test/</span></span><br><span class="line">$ mkdir -p <span class="built_in">test</span>/</span><br><span class="line"><span class="comment">#进入到test文件夹</span></span><br><span class="line">$ <span class="built_in">cd</span> <span class="built_in">test</span>/</span><br><span class="line"><span class="comment">#执行git init命令</span></span><br><span class="line">$ git init</span><br><span class="line">Initialized empty Git repository <span class="keyword">in</span> /root/<span class="built_in">test</span>/.git/</span><br></pre></td></tr></table></figure><p>Git不会关心文件夹里是否为空，执行<code>git init</code> 命令创建了一个隐藏目录，在项目目录的顶层有个名为 <code>.git</code>文件夹，Git把所有修订的信息都放在这唯一的顶层目录里</p></li><li><h4 id="2-2-将文件添加到版本库中"><a href="#2-2-将文件添加到版本库中" class="headerlink" title="2.2 将文件添加到版本库中"></a>2.2 将文件添加到版本库中</h4><p>执行 git init 命令时，Git版本库都是空的，为了管理内容，需要明确的把内容放入版本库中。</p><p>使用 <code>git add file</code>[^1] 将file添加到版本库中。</p><p>例如:</p><p>在 <code>test</code>目录中创建一个文件<code>index.html</code>并把该文件添加到版本库中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> <span class="built_in">test</span>/</span><br><span class="line">$ touch index.html</span><br><span class="line">$ git add index.html</span><br></pre></td></tr></table></figure><p>[^1 ]: 如果目录中已经有很多的文件，使用<code>git add .</code>命令让Git把当前的目录及子目录中的文件都添加到版本库中</p><p>运行<code>git status</code> 命令显示中间状态的<code>index.html</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">  <span class="comment"># 这个命令显示新文件index.html将在下次提交时添加到版本库中</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure></li></ul></li><li><h4 id="2-3-版本库内文件的删除和重命名"><a href="#2-3-版本库内文件的删除和重命名" class="headerlink" title="2.3 版本库内文件的删除和重命名"></a>2.3 版本库内文件的删除和重命名</h4><ul><li><h5 id="文件删除"><a href="#文件删除" class="headerlink" title="文件删除"></a>文件删除</h5><p>执行命令 <code>git rm</code>可以删除版本库里不需要的文件</p><p>操作如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看版本库中的文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git ls-files</span></span><br><span class="line">index.html</span><br></pre></td></tr></table></figure><h1 id="执行git-rm-index-html即可删除版本库中的index-html文件"><a href="#执行git-rm-index-html即可删除版本库中的index-html文件" class="headerlink" title="执行git rm index.html即可删除版本库中的index.html文件"></a>执行git rm index.html即可删除版本库中的index.html文件</h1><p>$ git rm index.html</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">- ##### 文件重命名</span><br><span class="line">  </span><br><span class="line">      在终端执行``git mv srcfile targetfile``即可以完成文件的重命名</span><br><span class="line">      </span><br><span class="line">      例如：</span><br><span class="line">    </span><br><span class="line">      ```<span class="keyword">shell</span></span><br><span class="line">    # 先查看版本库中的文件</span><br><span class="line">      $ git <span class="keyword">ls</span>-<span class="keyword">files</span></span><br><span class="line">    <span class="built_in">index</span>.html</span><br><span class="line">      # 执行git mv <span class="built_in">index</span>.html foo.html 将<span class="built_in">index</span>.html修改为foo.html</span><br><span class="line">    $ git mv <span class="built_in">index</span>.html foo.html</span><br><span class="line">      # 再次查看版本库文件</span><br><span class="line">    $ git <span class="keyword">ls</span>-<span class="keyword">files</span></span><br><span class="line">      foo.html</span><br></pre></td></tr></table></figure></li></ul><p>​    </p></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;Git安装(Windowns系统为例)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;下载Git软件:&lt;/p&gt;
&lt;p&gt;点击链接:&lt;a href=&quot;https://git-scm.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://g
      
    
    </summary>
    
    
      <category term="版本控制管理" scheme="http://yoursite.com/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Git提交</title>
    <link href="http://yoursite.com/2020/02/15/git/Git%E6%8F%90%E4%BA%A4/"/>
    <id>http://yoursite.com/2020/02/15/git/Git%E6%8F%90%E4%BA%A4/</id>
    <published>2020-02-15T08:54:50.000Z</published>
    <updated>2020-03-27T10:35:07.010Z</updated>
    
    <content type="html"><![CDATA[<h2 id="吧啦吧啦乱七八遭的东西"><a href="#吧啦吧啦乱七八遭的东西" class="headerlink" title="吧啦吧啦乱七八遭的东西"></a>吧啦吧啦乱七八遭的东西</h2><p>在Git中，提交（commit）是用来记录版本库的变更的。当提交时，Git记录索引的快照并把快照放进对象库（简单的介绍）。提交的快照是串联在一起的，每张新的快照指向它的先驱。随着时间的推移，一系列的变更就表示一系列的提交。</p><p>Git提供一种机制来确定相对于另一个引用的提交，通常是分支的头。</p><p>在某些Git应用场景中，可能见过诸如这样的提交形式 master^ 。</p><p>在同一代提交中，插入符号 ^ 是用来选择不同的父提交。给定一个提交C，C^1 是其第一个父提交，C^2 是其第二个父提交，等等，如图:</p><p><img src="https://raw.githubusercontent.com/yangshenghua97/Image/master/commit.jpg" alt=""></p><p><img src="https://raw.githubusercontent.com/yangshenghua97/Image/master/commit1.jpg" alt=""></p><p>通过把引用与^ 和 ~ 组合，就可从引用的提交历史图中选出任意提交</p><h2 id="提交历史记录"><a href="#提交历史记录" class="headerlink" title="提交历史记录"></a>提交历史记录</h2><ul><li><p><strong>查看旧提交</strong> </p><p>显示提交历史记录的主要命令是 <strong><code>git log</code></strong>,在参数形式上，<strong><code>git log</code></strong>跟<strong><code>git log HEAD</code></strong>是一样的，输出每一个可从HEAD找到的历史记录中的提交日志信息。变更从HEAD提交开始显示，并从提交图中回溯。如果使用<strong><code>git log</code></strong></p><p>时提供一个提交名，那么这个日志将从该提交开始回溯输出。例如:<strong><code>git log master</code></strong></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;吧啦吧啦乱七八遭的东西&quot;&gt;&lt;a href=&quot;#吧啦吧啦乱七八遭的东西&quot; class=&quot;headerlink&quot; title=&quot;吧啦吧啦乱七八遭的东西&quot;&gt;&lt;/a&gt;吧啦吧啦乱七八遭的东西&lt;/h2&gt;&lt;p&gt;在Git中，提交（commit）是用来记录版本库的变更的。当提交时，
      
    
    </summary>
    
    
      <category term="版本控制管理" scheme="http://yoursite.com/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>关于Git文件管理</title>
    <link href="http://yoursite.com/2020/02/12/git/%E5%85%B3%E4%BA%8EGit%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2020/02/12/git/%E5%85%B3%E4%BA%8EGit%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/</id>
    <published>2020-02-12T11:25:36.000Z</published>
    <updated>2020-03-27T10:35:50.019Z</updated>
    
    <content type="html"><![CDATA[<h3 id="git中的文件分类"><a href="#git中的文件分类" class="headerlink" title="git中的文件分类"></a>git中的文件分类</h3><p>​    Git将所有文件分为3类：已追踪的、被忽略的以及未追踪的</p><ul><li><p>已追踪的</p><p>已追踪的文件是指已经在版本库中的文件，或者是已暂存到索引中的文件。如果想将新文件<strong><code>newfile</code></strong>添加到已追踪的文件，执行 <strong><code>git add newfile</code></strong>即可</p></li><li><p>被忽略的</p><p>被忽略的文件必须在版本库中明确声明为不可见或被忽略，即使他可能会在工作目录中出现。一个软件项目通常都会有很多被忽略的文件。普通被忽略的文件包括临时文件、个人笔记、编译器输出文件以及构建过程中自动生成的大多数文件。Git维护一个默认的忽略文件列表，也可以配置版本库来识别其他文件。被忽略的文件会在后面介绍。</p></li><li><p>未追踪的</p><p>未追踪的文件是指那些不在版本库中的文件。</p></li></ul><p>下面举一个栗子:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git init</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">查看状态</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> On branch master</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Initial commit</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line">nothing to commit (create/copy files and use "git add" to track)</span><br><span class="line"><span class="meta">#</span><span class="bash">添加一个文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"new Data"</span> &gt;&gt; data</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> On branch master</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Initial commit</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Untracked files:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">"git add &lt;file&gt;..."</span> to include <span class="keyword">in</span> what will be committed)</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash">       data</span></span><br><span class="line">nothing added to commit but untracked files present (use "git add" to track)</span><br></pre></td></tr></table></figure><p>为了让Git忽略目录中的文件，只需将该文件名添加到一个特殊的文件<strong><code>.gitignore</code></strong>中就可以了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> touch main.o</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> On branch master</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Initial commit</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Untracked files:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">"git add &lt;file&gt;..."</span> to include <span class="keyword">in</span> what will be committed)</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash">       data</span></span><br><span class="line"><span class="meta">#</span><span class="bash">       main.o</span></span><br><span class="line">nothing added to commit but untracked files present (use "git add" to track)</span><br><span class="line"><span class="meta">#</span><span class="bash">将 main.o添加到.gitignore中</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> main.o &gt;&gt; .gitignore</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> On branch master</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Initial commit</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Untracked files:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">"git add &lt;file&gt;..."</span> to include <span class="keyword">in</span> what will be committed)</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash">       .gitignore</span></span><br><span class="line"><span class="meta">#</span><span class="bash">       data</span></span><br><span class="line">nothing added to commit but untracked files present (use "git add" to track)</span><br></pre></td></tr></table></figure><p>这样main.o就已经被忽略了，但是<strong><code>git status</code></strong>现在显示一个新的未追踪的文件 .gitignore。</p><h2 id="使用-git-add"><a href="#使用-git-add" class="headerlink" title="使用 git add"></a>使用 git add</h2><p><strong><code>git add</code></strong> 命令将暂存一个文件。就Git文件分类而言，如果一个文件是未追踪的，那么<strong><code>git add</code></strong>就会将文件的状态转化为已追踪的。如果git add作用于一个目录名，那么该目录下的文件以及子目录都会递归暂存起来。</p><p>这里还接着上面的栗子:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> On branch master</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Initial commit</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Untracked files:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">"git add &lt;file&gt;..."</span> to include <span class="keyword">in</span> what will be committed)</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash">       .gitignore</span></span><br><span class="line"><span class="meta">#</span><span class="bash">       data</span></span><br><span class="line">nothing added to commit but untracked files present (use "git add" to track)</span><br><span class="line"><span class="meta">#</span><span class="bash"> 将data、.gitignore两个文件添加至已追踪的分类</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add data .gitignore</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> On branch master</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Initial commit</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Changes to be committed:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">"git rm --cached &lt;file&gt;..."</span> to unstage)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">       new file:   .gitignore</span></span><br><span class="line"><span class="meta">#</span><span class="bash">       new file:   data</span></span><br></pre></td></tr></table></figure><p>在上面的栗子中使用<strong><code>git add</code></strong>后，暂存和追踪data和.gitignore文件，并准备下次提交是时添加到版本库中。</p><p>可以使用<strong><code>git ls-files</code></strong>命令查看隐藏在对象模型下的东西。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git ls-files</span></span><br><span class="line">.gitignore</span><br><span class="line">data</span><br></pre></td></tr></table></figure><p>在任何编辑之后，提交变更之前，请执行一次<strong><code>git add</code></strong>命令。</p><h2 id="使用-git-commit"><a href="#使用-git-commit" class="headerlink" title="使用 git commit"></a>使用 git commit</h2><h3 id="使用-git-commit-–all"><a href="#使用-git-commit-–all" class="headerlink" title="使用 git commit –all"></a>使用 git commit –all</h3><p><strong><code>git commit</code></strong> 的 <strong><code>-a</code></strong>或者 <strong><code>--all</code></strong>选项会导致执行提交之前自动暂存所有未暂存的和未追踪的文件变化，包括从工作副本中删除已追踪的文件</p><p>下面举个栗子:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">pwd</span></span></span><br><span class="line">/tmp/commit-all-example</span><br><span class="line"><span class="meta">#</span><span class="bash">创建测试版本库</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git init</span></span><br><span class="line">Initialized empty Git repository in /tmp/commit-all-example/.git/</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"Testfile1"</span> &gt;&gt; ready</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"Testfile2"</span> &gt;&gt; notyet</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add ready notyet</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">"Setup"</span></span></span><br><span class="line">[master (root-commit) 2b00dbf] Setup</span><br><span class="line"> 2 files changed, 2 insertions(+)</span><br><span class="line"> create mode 100644 notyet</span><br><span class="line"> create mode 100644 ready</span><br></pre></td></tr></table></figure><p>之后再次编辑<strong>ready</strong>文件，并用 <strong><code>git add</code></strong>把它添加到版本库中。然后编辑<strong>notyet</strong>文件保持它是未暂存的。</p><p>在一个子目录下添加一个文件，但是不要对它执行<strong><code>git add</code></strong>命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir subdir</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"Nope"</span> &gt;&gt; subdir/new</span></span><br></pre></td></tr></table></figure><p>当执行 <strong><code>git commit --all</code></strong>命令，Git会递归遍历整个版本库，暂存所有先前通过<strong><code>git add</code></strong>提交的已知的和修改的文件，然后提交它们，由于<strong>subdir/</strong> 一个全新的目录，而且目录下没有任何文件名或路径通过<strong><code>git add</code></strong>和<strong><code>git commit</code></strong>进行操作的，</p><p>So 即使是 –all选项也不能将其提交。</p><h3 id="关于提交日志消息"><a href="#关于提交日志消息" class="headerlink" title="关于提交日志消息"></a>关于提交日志消息</h3><p>​    如果不通过命令行直接提供日志消息（例如:<strong><code>git commit -m &quot;提交日志消息&quot;</code></strong>），Git会启动编辑器，并提示你写一个提交日志。</p><h2 id="使用-git-rm-命令"><a href="#使用-git-rm-命令" class="headerlink" title="使用 git rm 命令"></a>使用 git rm 命令</h2><p>​       git rm命令会在版本库中和目录中同时删除文件。</p><p>接着上面的栗子:</p><p>这里“意外”的添加了一个文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"Random"</span> &gt; oops</span></span><br><span class="line"><span class="meta">#</span><span class="bash">当执行git rm oops时，提示删除失败</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git rm oops</span></span><br><span class="line">fatal: pathspec 'oops' did not match any files</span><br></pre></td></tr></table></figure><p>​    为什么会这样，可以通过<strong><code>git ls-files</code></strong>命令查看版本库中的文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git ls-files</span></span><br><span class="line">notyet</span><br><span class="line">ready</span><br></pre></td></tr></table></figure><p>现在的版本库中没有<strong>oops</strong>这个文件，可通过<strong>git add oops</strong>命令将 oops文件加入到版本库中。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git add oops</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git ls-files</span></span><br><span class="line">notyet</span><br><span class="line">oops</span><br><span class="line">ready</span><br></pre></td></tr></table></figure><p>另外，要将一个文件由已暂存的转化为未暂存的,可以使用<strong><code>git rm --cached</code></strong>命令</p><p>比如要删除oops</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git rm --cached oops</span></span><br><span class="line">rm 'oops'</span><br></pre></td></tr></table></figure><p><strong><code>git rm --cached</code></strong>会删除索引中的文件并它文件保留在工作目录中，而<strong><code>git rm</code></strong>则会将文件从索引和工作目录中都删除。</p><p>如果想要删除一个已经提交的文件，通过简单的<strong><code>git rm filename</code></strong>命令来暂存这一请求</p><blockquote><p>还可以使用 <strong><code>git rm -f</code></strong>来强制删除文件。</p></blockquote><p>如果想保留的文件不小心删除了，可以通过版本控制系统的恢复功能进行恢复</p><p>具体的命令如下:</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 加入不小心删除了oops文件</span></span><br><span class="line"><span class="meta"># 可以是下面的命令进行恢复</span></span><br><span class="line">git checkout HEAD -- oops</span><br></pre></td></tr></table></figure><h2 id="使用-git-mv"><a href="#使用-git-mv" class="headerlink" title="使用 git mv"></a>使用 git mv</h2><p>如果想要给一个文件重命名可以使用<strong><code>git mv srcfile newfile</code></strong>，git mv 命令会将 <strong>srcfile</strong>文件的文件名称改为<strong>newfiles</strong>，Git会在索引中删除<strong>srcfile</strong>文件的路径名，并添加<strong>newfile</strong>的路径名，至于srcfile文件里的内容，Git仍然会保存在对象库中，然后才会将它与newfile重新关联。git mv 还可以移动一个文件到一个目录中：<strong><code>git mv srcfile dir/</code></strong></p><h2 id="gitignore-文件"><a href="#gitignore-文件" class="headerlink" title=".gitignore 文件"></a>.gitignore 文件</h2><p>在前面简单介绍过<strong>.gitignore</strong>文件的作用。可以通过<strong>.gitignore</strong>文件来忽略不相干的文件。Git还支持一种更丰富的机制，一个<strong>.gitignore</strong>文件下可以包含一个文件名模式列表，指定哪些文件需要忽略。<strong>.gitignore</strong> 文件的格式如下。</p><ul><li>空行会被忽略，而以（#）号开头的行可以用于注释。然而，如果#跟在其他文本后面，它就不代表注释了。</li><li>一个简单的字面置文件名匹配任何目录中的同名文件。</li><li>目录名由末尾的（/）标记。这能匹配同名的目录和子目录，但不匹配文件或符号链接。</li><li>包含shell通配符，如（*）号，这种模式可扩展为shell通配模式。正如标准shell通配符一样，因为不能跨目录匹配，所以一个 * 只能匹配一个文件或目录名。</li><li>起始的 ！号会对该行其余部分的模式进行取反。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;git中的文件分类&quot;&gt;&lt;a href=&quot;#git中的文件分类&quot; class=&quot;headerlink&quot; title=&quot;git中的文件分类&quot;&gt;&lt;/a&gt;git中的文件分类&lt;/h3&gt;&lt;p&gt;​    Git将所有文件分为3类：已追踪的、被忽略的以及未追踪的&lt;/p&gt;
&lt;ul&gt;
      
    
    </summary>
    
    
      <category term="版本控制管理" scheme="http://yoursite.com/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Scala集合</title>
    <link href="http://yoursite.com/2020/01/07/scala/ScalaImpatient/Scala_Set/"/>
    <id>http://yoursite.com/2020/01/07/scala/ScalaImpatient/Scala_Set/</id>
    <published>2020-01-07T14:12:02.000Z</published>
    <updated>2021-03-02T05:29:57.451Z</updated>
    
    <content type="html"><![CDATA[<h3 id="主要的集合特质"><a href="#主要的集合特质" class="headerlink" title="主要的集合特质"></a>主要的集合特质</h3><p><strong><code>Seq</code></strong>是一个有先后次序的值的序列，比如数组和列表。</p><p><strong><code>Set</code></strong>是一组没有先后顺序的值。在SortedSet中，元素以某种排过序的顺序被访问。</p><p><strong><code>Map</code></strong>是一组键值对，SortedMap按照键的排序访问其中的实体。</p><h3 id="可变和不可变集合"><a href="#可变和不可变集合" class="headerlink" title="可变和不可变集合"></a>可变和不可变集合</h3><p>Scala同时支持可变集合和不可变集合。不可变集合从不改变，因此，可以安全的共享其引用，甚至是在一个多线程的应用程序中也没问题。</p><p>Scala优先采用不可变集合。scala.collection包中的伴生对象产生出不可变集合</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;主要的集合特质&quot;&gt;&lt;a href=&quot;#主要的集合特质&quot; class=&quot;headerlink&quot; title=&quot;主要的集合特质&quot;&gt;&lt;/a&gt;主要的集合特质&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;&lt;code&gt;Seq&lt;/code&gt;&lt;/strong&gt;是一个有先后次序的值的序列，比如数
      
    
    </summary>
    
    
      <category term="Scala" scheme="http://yoursite.com/categories/Scala/"/>
    
    
      <category term="Scala基础编程" scheme="http://yoursite.com/tags/Scala%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
</feed>
