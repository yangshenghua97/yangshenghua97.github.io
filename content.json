{"meta":{"title":"楊さんノート","subtitle":"","description":"","author":"杨生华","url":"http://yoursite.com","root":"/"},"pages":[{"title":"Categories","date":"2020-02-09T08:10:17.612Z","updated":"2020-02-09T08:10:17.612Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"小杨的简介","date":"2020-04-08T13:03:17.937Z","updated":"2020-04-08T13:03:17.937Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"个人信息 杨生华/男/1997 本科/吉林化⼯学院/外国语学院/⽇语系/ 年级：2020年毕业 联系方式：13944680832 微信： 技术博客：楊さんノート Github：yangshenghua97 期望职位：/实习/Java后端开发 期望薪资：税前⽉薪3k-4k 项目和作品个人博客后台管理系统2019.01-2019.02技术运用： 开发环境：Windows/Linux、IntelliJ IDEA、JDK 1.8、MySQL 5.7、Redis、Tomcat 5. x、Git、Maven; 后端框架：Spring、Spring MVC、Myatis; 前端框架：AdminLTE3,JQuery等前端框架； 项目介绍： 基于Spring+Spring MVC + MyBatis框架的整合运用； 利用 Spring AOP对用户登录进行Token身份验证、Spring 事务隔离对SQL进行验证 MySQL 5.7 数据的基本使用、使用Druid数据库连接池对项目执行的SQL进行监控与优化； 单图/多图上传技术； 文件导入导出功能； 利用Redis缓存数据库对用户Token进行缓存 基于阿里云Linux系统进行部署与发布； Nginx + Tomcat的集群搭建； 微人事人力资源管理系统技术运用： 开发环境：Windows/Linux、IntelliJ IDEA、JDK 1.8、MySQL 5.7、Redis、Tomcat 5. x、Git、Maven; 后端框架：Spring Boot、MyBatis； 前端框架：Vue.js+Axios； 项目介绍： 基于Spring Boot、MyBatis、Spring Security的运用； 项目利用Maven对多模块进行整合，后端权限认证采用Spring Security实现； 数据库访问使用MyBatis，同时使用Redis实现认证信息缓存； 项目实现了邮件发送功能，采用Spring-Boot-Email+Spring Thymeleaf配合Java 多线程来对邮件进行发送； 技能清单 Java开发：熟悉Java开发、 对于Java多线程、I/O操作、反射、Java网络编程等都能其进行简单的应用。熟练使用Java集合，并且简单阅读多ArrayList、LinkedList、HashMap的源码。 了解ConcurrentHashMap的使用场景； 熟练操作Linux，掌握Linux常用命令，能够独立编写Linux Shell脚本代码，曾在阿里云服务器上发布过个人博客，熟悉Linux系统管理等； 熟练SQL语句编写、使用虚拟机搭建MySQL集群进行主从复制，事务隔离，索引优化等 了解Redis命令简单使用，使用虚拟机搭建Redis集群进行主从复制 前端框架：了解Vue.js、Node.js构建前端应用框架 版本管理、文档和自动化部署工具：了解Git版本控制系统常用命令的使用 开发框架及单元测试：JUnit对项目的各个模块进行单元测试、Spring、Spring Boot、Spring MVC、MyBatis的简单使用 学校经历2018.04-2018.09担任学生会网络部，主要工作是运营学院微信公众号以及组织学院活动； 2018.06-2018.07参加学校互联网+创新创业大赛获得校级团队二等奖； 工作经历 目前处于待就业实习阶段。2019年8月在吉林市创慧科技有限公司做图片处理工作"},{"title":"guestbook","date":"2020-03-31T03:10:00.000Z","updated":"2020-03-31T03:12:08.960Z","comments":true,"path":"guestbook/index.html","permalink":"http://yoursite.com/guestbook/index.html","excerpt":"","text":""},{"title":"Tags","date":"2020-02-09T09:12:40.508Z","updated":"2020-02-09T08:10:17.625Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Spark大数据快速分析学习笔记（RDD编程）","slug":"Spark大数据快速分析学习笔记（二）","date":"2020-06-27T15:07:07.000Z","updated":"2020-06-28T04:01:46.369Z","comments":true,"path":"2020/06/27/Spark大数据快速分析学习笔记（二）/","link":"","permalink":"http://yoursite.com/2020/06/27/Spark%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BF%AB%E9%80%9F%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/","excerpt":"","text":"RDD编程基础1.何为RDD？RDD的全名叫做弹性分布式数据集，其实就是分布式的元素集合。 RDD支持两种类型的操作：转化操作(Transformation) 和 行为操作(action)。转化操作会由一个RDD生成一个新的RDD。行为操作会对RDD计算出一个结果，并把结果返回到驱动器程序中，或把结果存储到外部的存储系统。 创建RDD创建RDD有两种方式：读取外部数据集、驱动程序中对一个集合进行并行化 创建RDD最简单的方式是把程序中一个已有的集合传递给SparkContext的parallelize()方法，这种方式不怎么常用，常用的方式是读取外部数据集 下面的代码就是从外部数据（HDFS）中创建RDD 1val infile = sc.textFile(\"hdfs://master:9000/datafile\") sc.textFile()是一个将文本文件读入为一个存储字符串的RDD方法 RDD操作 转化操作 行为操作 参考资料 《Spark大数据快速分析》","categories":[{"name":"大数据","slug":"大数据","permalink":"http://yoursite.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"}],"tags":[{"name":"spark","slug":"spark","permalink":"http://yoursite.com/tags/spark/"}]},{"title":"Spark大数据快速分析学习笔记（一）","slug":"Spark大数据快速分析学习笔记","date":"2020-06-26T14:44:53.000Z","updated":"2020-06-27T15:09:23.332Z","comments":true,"path":"2020/06/26/Spark大数据快速分析学习笔记/","link":"","permalink":"http://yoursite.com/2020/06/26/Spark%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BF%AB%E9%80%9F%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"Spark中的Python和Scala的ShellSpark自带交互式shell，能够即时数据分析。这里介绍两中语言的shell的使用； Python 要打开Python版本的Spark Shell可以在终端中输入命令： 1# pyspark Scala 打开Scala版本的shell 1# spark-shell 在打开spark shell时会输出很多的日志信息，可以调整日志的级别来控制输出的信息量。在spark的目录下的conf目录修改log4j.properties文件，在文件中修改如下内容： 1log4j.rootCategory=WARN, console 这样就可以减少大量的日志信息输出 使用Spark 初始化SparkContext 12val conf = new SparkConf().setAppName(\"App\")val sc = new SparkContext(conf=conf) 参考资料 《Spark快速大数据分析》","categories":[{"name":"大数据","slug":"大数据","permalink":"http://yoursite.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"}],"tags":[{"name":"spark","slug":"spark","permalink":"http://yoursite.com/tags/spark/"}]},{"title":"Python数据科学分析笔记","slug":"bigdata/数据分析/Python数据科学分析笔记","date":"2020-06-11T03:37:49.000Z","updated":"2020-06-11T03:37:49.779Z","comments":true,"path":"2020/06/11/bigdata/数据分析/Python数据科学分析笔记/","link":"","permalink":"http://yoursite.com/2020/06/11/bigdata/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E5%88%86%E6%9E%90%E7%AC%94%E8%AE%B0/","excerpt":"","text":"参考资料","categories":[{"name":"bigdata","slug":"bigdata","permalink":"http://yoursite.com/categories/bigdata/"},{"name":"数据分析","slug":"bigdata/数据分析","permalink":"http://yoursite.com/categories/bigdata/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"}],"tags":[]},{"title":"泛读Java集合源码分析","slug":"java/java基础/Java集合源码分析","date":"2020-06-11T03:31:29.000Z","updated":"2021-01-17T03:00:10.446Z","comments":true,"path":"2020/06/11/java/java基础/Java集合源码分析/","link":"","permalink":"http://yoursite.com/2020/06/11/java/java%E5%9F%BA%E7%A1%80/Java%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","excerpt":"","text":"剖析ArrayListArrayList实现的接口123public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123; .... ArrayList实现了List List是一个数组队列，提供了相关的添加、删除、修改、遍历等功能 ArrayList实现了 RandomAccess 接口，为ArrayList提供了随机访问功能，可以通过元素的序号快速获取元素对象。 ArrayList还实现Cloneable 接口，覆盖函数clone()，能够被克隆。实现Serializable意味着ArrayList可以被序列化 从java1.5后java加入了泛型的特性，在使用ArrayList时可以实现泛型化 例如下面的使用方法： 12ArrayList&lt;String&gt; strlist = new ArrayList&lt;String&gt;();ArrayList&lt;Integer&gt; intList = new ArrayList&lt;Integer&gt;(); ArrayList基本原理ArrayList的内部有一个elementData数组，一般会有一些预留的空间，有一个整数size记录实际的元素个数 12transient Object[] elementData;private int size; elementData会随着实际元素个数的增多而重新分配，而size则始终记录实际的元素个数 ArrayList常用方法的实现 add()方法 add方法的主要代码为： 12345public boolean add(E e) &#123; ensureCapacityInternal(size + 1); //插入元素，改变元素个数 elementData[size++] = e; return true; &#125; add()方法首先调用 ensureCapacityInternal(size + 1) 以确保数组容量是够的。 这里以java1.8为例，首先ensureCapacityInternal确保数组容量足够，代码如下： ensureCapacityInternal 123private void ensureCapacityInternal(int minCapacity) &#123; ensureExplicitCapacity(calculateCapacity(elementData,minCapacity));&#125; calculateCapacity 123456private static int calculateCapacity(Object[] elementData, int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; return Math.max(DEFAULT_CAPACITY, minCapacity); &#125; return minCapacity; &#125; calculateCapacity 判断elementData数组是否为空，如果是则将DEFAULT_CAPACITY的容量赋给minCapacity ，在这里DEFAULT_CAPACITY 大小为10； 1private static final int DEFAULT_CAPACITY = 10; 接下来调用ensureExplicitCapacity 1234567private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity); &#125; modCount 表示内部的增加修改次数，如果需要的长度大于当前的数组长度，则调用grow 方法,grow 的主要代码： 123456789private void grow(int minCapacity) &#123; int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); elementData = Arrays.copyOf(elementData, newCapacity); &#125; remove()方法 remove方法源码 1234567891011public E remove(int index) &#123; rangeCheck(index); modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; return oldValue; &#125; get()方法 ArrayList能够支持随机访问，是因为内部的数据结构是数组，数组本身就是支持随机访问。get()方法首先判断输入的index 是否越界，然后将数组的index位置的元素返回即可。 源代码如下： 123456789private void rangeCheck(int index) &#123; if (index &gt;= size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index));&#125;public E get(int index) &#123; rangeCheck(index); return elementData(index);&#125; ArrayList的特点对于Arraylist，由于内部实现采用动态数组实现，所以具有以下几个特点 可以随机访问，按照索引位置进行访问效率很高 除非数组已经排序，否则按照内容查找元素效率比较低下 添加元素的效率一般，重新分配和复制数组的开销平摊 插入删除元素效率低下，因为需要移动元素 ArrayList不是线程安全的，要实现线程安全的方式是使用Collections提供的方法修饰ArrayList 剖析LinkedListLinkedList实现了List接口、Deque、Queue接口。其内部实现是双向链表，每个元素在内存中是单独存放的，元素之间通过前驱链接和后继链接将节点连接起来。节点的代码如下： 1234567891011private static class Node&lt;E&gt; &#123; E item; Node&lt;E&gt; next; Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element;//元素 this.next = next;//前驱节点 this.prev = prev;//后继节点 &#125; &#125; LinkedList内部组成就是如下变量 123transient int size = 0;//链表的长度 transient Node&lt;E&gt; first;//指向头节点 transient Node&lt;E&gt; last;//指向尾节点 LinkedList常用的方法 add()方法 该方法是在链表的end添加元素，其调用了自己的方法linkLast(E e)。俩来看看源码 1234public boolean add()&#123; linkLast(e); return true;&#125; 该方法首先将last的Node引用指向了一个新的Node(l)，然后根据l新建了一个newNode，其中的元素就为要添加的e；而后，我们让last指向newNode，接下来是自身进行维护该链表。 1234567891011void linkLast(E e) &#123; final Node&lt;E&gt; l = last; final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); last = newNode; if (l == null) first = newNode; else l.next = newNode; size++; modCount++; &#125; remove()方法 1234public E remove(int index)&#123; checkElementIndex(index); return unlink(node(index));&#125; 通过node方法找到节点，调用了unlike方法 12345678910111213141516171819202122232425E unlink(Node&lt;E&gt; x) &#123; // assert x != null; final E element = x.item; final Node&lt;E&gt; next = x.next; final Node&lt;E&gt; prev = x.prev; if (prev == null) &#123; first = next; &#125; else &#123; prev.next = next; x.prev = null; &#125; if (next == null) &#123; last = prev; &#125; else &#123; next.prev = prev; x.next = null; &#125; x.item = null; size--; modCount++; return element; &#125; 删除x节点，就是让x的前驱和后继直接链接起来，next是x的后继，prev是x的前驱，分为下面两步： 让x的前驱的后继指向x的后继。如果没有前驱，说明删除的是头节点，则修改头节点指向x的后继。 让x的后继的前驱指向x的前驱。如果x没有后继，说明删除的是尾节点，则修改尾节点指向x的前驱。 LinkedList特点 用法上，LinkedList是一个List，但也实现了Deque接口，可以作为队列、栈。双端队列使用。实现原理上，LinkedList内部是一个双向链表，并维护了长度，头节点、尾节点。 按需分配空间，不需要预先分配很多的空间 不可以随机访问，按照索引位置访问效率太低，必须从头到尾顺着链接找 不管列表是否排序，只要是按照内容查找元素，效率都比较低 在两端添加、删除元素的效率很高 在中间插入、删除元素，要先定位，效率比较低，而修改本身的效率很高 HashMapHashMap实现了Map接口，HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。 内部组成：HashMap内部组成主要有如下实例变量 1234transient Entry&lt;K,V&gt;[]table = (Entry&lt;K,V&gt;[])EMPTY_TABLE;transient int size;int threshold;final float loadFactor;","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"java中级编程","slug":"java中级编程","permalink":"http://yoursite.com/tags/java%E4%B8%AD%E7%BA%A7%E7%BC%96%E7%A8%8B/"}]},{"title":"Java集合框架","slug":"java/java基础/Java集合框架","date":"2020-06-09T08:32:12.000Z","updated":"2021-01-17T02:59:49.568Z","comments":true,"path":"2020/06/09/java/java基础/Java集合框架/","link":"","permalink":"http://yoursite.com/2020/06/09/java/java%E5%9F%BA%E7%A1%80/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/","excerpt":"","text":"在编程时有些场景需要用到Java的集合框架，这篇博文将介绍在Java系统里的集合框架。 Java提供了大量持有对象的方式： 数组 Collection保存单一的元素，Map保存相关联的键值对。各种Collection和各种Map都可以在你向其中添加更多元素时自动调整其尺寸。 向数组一样，List也建立数字索引与对象的关联，因此数组和List都是拍好序的容器。List能自动扩充容量。 如果要进行大量的随机访问，就使用ArrayList;如果要经常从表中间插入或删除元素，则使用LinkedList. 各种Queue及栈的行为，优LinkedList提供 Map是一种将对象与对象相关联的设计，HashMap设计用来快速访问；LinkedHashMap保持元素插入时的顺序，但是也通过散列提供快速访问能力。 Set不接受重复元素。HashSet提供最快的查询速度，LinkedHashSet以插入顺序保存元素 CollectionListList有两种基本类型：ArrayList和LinkedList ArrayListArrayList长于随机访问元素，但是在List的中间插入和移除元素时比较慢。下面来列举几个ArrayList的常用API contains()用于确定某个对象是否在列表中。 remove()方法移除一个对象，将这个对象的引用传递给remove()方法 indexOf()方法用来获取某个对象在List中的所处位置的索引编号 subList()方法将从较大的列表中创建出一个片段。 retailAll()方法时List的交集操作 LinkedListLinkedList实现基本的List接口。下面介绍LinkedList中的一些方法 getFirst()方法返回列表的头，如果List为空，则抛出异常 removeFirst()移除并返回列表的头元素，在列表为空时抛出异常 addList()和addLast()相同，将某个元素插入到列表的头部或尾部 removeLast()移除并返回列表的最后一个元素 QueueQueue是先进先出的容器，从容器的一端放入事物，从另一端取出，并且事物放入容器顺序与取出的顺序相同，队列常常被当作一种可靠的将对象从程序的某个区域传输到另一个区域的途径，下面介绍在Queue中的方法： offer()方法将一个元素插入到队尾，或者返回false peek()和element()都将在不移除的情况下返回对头，peek()方法在队列为空时返回null，element()则会抛出异常信息。 poll()和remove()方法将移除并返回对头，当队列为空时poll()返回空，而remove()会抛出异常 Map参考资料 《Java编程思想》","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"java中级编程","slug":"java中级编程","permalink":"http://yoursite.com/tags/java%E4%B8%AD%E7%BA%A7%E7%BC%96%E7%A8%8B/"}]},{"title":"Executor框架","slug":"java/并发编程/Executor框架","date":"2020-06-05T06:13:11.000Z","updated":"2020-06-06T10:05:32.139Z","comments":true,"path":"2020/06/05/java/并发编程/Executor框架/","link":"","permalink":"http://yoursite.com/2020/06/05/java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Executor%E6%A1%86%E6%9E%B6/","excerpt":"","text":"Executor框架两级调度 Java线程启动时会创建一个本地操作系统线程，当该Java线程终止时，这个操作系统线程也会被回收。操作系统会调度所有线程并将它们分配给可用CPU。 在上面的调度模型中： 在上层，Java多线程程序通常把应用分解为若干任务，然后使用用户级的调度器将这些任务映射为固定数量的线程；在底层，操作系统内核将这些线程映射到硬件处理器上。 Executor框架结构Executor框架由3大部分组成 任务 包括被执行任务需要的实现接口(Runnable接口或Callable接口)Runnable接口和Callable接口的实现类，可以被ThreadPoolExecutor或者ScheduleThreadPoolExecutor 执行的任务 包括任务执行机制的核心接口Executor以及继承自Executor的ExecutorService接口 Executor是一个接口，时Executor框架的基础，它将任务的提交与任务的执行分离 ThreadPoolExecutor是线程池的核心实现类，用来执行被提交的任务 ScheduleThreadPoolExecutor，可以在给定的延迟后运行命令，或者定期执行命令 异步计算的框架包括接口Future和实现Future接口的FutureTask类，代表异步计算的结果 Executor框架成员Executor框架主要成员：ThreadPoolExecutor、ScheduledThreadPoolExecutor、Future接口、Runnable接口、Callable接口、Executors。 ThreadPoolExecutor ThreadPoolExecutor通常使用工厂类Executors来创建，Executors可以创建3种类型的ThreadPoolExecutor；分别是SingleThreadExecutor、FixedThreadPool、CachedThreadPool。ThreadPoolExecutor是Executor框架最核心的类，是实现线程池的类。主要由下列组件构成 corePool：核心线程池大小 maximumPool：最大线程池的大小 BlockingQueue：用来暂时保存任务的工作队列 下面分别介绍3种类型的ThreadPoolExecutor： SingleThreadExecutor： SingleThreadExecutor适用于需要保证顺序执行各个任务；并且在任意时间点，不会有多个线程是活动的应用场景。 1234567891011121314public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;())); &#125; public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory) &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(), threadFactory)); &#125; 在上面的代码中，SingleThreadExecutor的corePoolSize和maximumPoolSize被设置为1，SingleThreadExecutor使用无界队列LinkedQueueBlockingQueue作为线程池的工作队列（队列的容量为Integer.MAX_VALUE）。SingleThreadExecutor的运行图如下 下面对上图中的过程进行说明： 1.如果当前运行的线程少于corePoolSize（线程池中没有运行的线程），则创建一个线程类执行任务 2.在线程池完成预热之后，将任务加入LinkedBlockingQueue 3.线程执行完1中的任务后，会在一个无限循环中反复从LinkedBlockingQueue获取任务来执行 FixedThreadPool： FixedThreadPool适用于为了满足资源管理的需求，而需要限制当前线程数量的应用场景。适用于负载均衡比较重的服务器 123456789101112public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()); &#125; public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(), threadFactory); &#125; FixedThreadPool的corePoolSize和maximumPoolSize都被设置为创建FixedThreadPool时指定的参数nThread 当线程池中的线程数大于corePoolSize时，keepAliveTime为多余的空闲线程等待新任务的最长时间，超过这个时间后多余的线程将被终止。把keepAliveTime设置为0L，说明多余的空闲线程会被立即终止。 1.如果当前运行的线程数少于corePoolSize，则创建线程来执行任务 2.在线程池完成预热后将任务加入LinkedBlockingQueue 3.线程执行完成1中的任务后，会在循环中反复从LinkedBlockingQueue获取任务来执行 FixedThreadPool使用无界队列LinkedBlockingQueue作为线程池的工作队列（队列的容量为Integer.MAX_VALUE） CachedThreadPool CachedThreadPool是大小无界的线程池，适用于执行很多短期异步任务的小程序或负载较轻的服务器 123456public static ExecutorService newCachedThreadPool(ThreadFactory threadFactory) &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;(), threadFactory); &#125; CachedThreadPool的corePoolSize被设置为0，maximumPoolSize被设置为Integer.MAX_VALUE,即maximumPool是无界，把keepAliveTime设置为60L，CachedThreadPool中的空闲线程等待新任务的最长时间为60秒，空闲线程超过60秒后将会终止 ScheduleThreadPoolExecutor待续","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"java并发编程","slug":"java并发编程","permalink":"http://yoursite.com/tags/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}]},{"title":"MapReduce&HDFS","slug":"bigdata/MapReduce-HDFS","date":"2020-06-05T03:18:43.000Z","updated":"2020-06-06T10:32:39.137Z","comments":true,"path":"2020/06/05/bigdata/MapReduce-HDFS/","link":"","permalink":"http://yoursite.com/2020/06/05/bigdata/MapReduce-HDFS/","excerpt":"","text":"MapReduceMapReduce编程模型 整个MapReduce计算过程分为Map阶段和Reduce阶段，也称为映射和缩减阶段，这两个独立的阶段实际上是两个独立的过程，即Map过程和Reduce过程，在Map中进行数据的读取和数据的预处理，之后将预处理的结果发送给Reduce中进行合并。 MapReduce执行流程 Hadoop计算流程 HDFS","categories":[{"name":"大数据","slug":"大数据","permalink":"http://yoursite.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"}],"tags":[{"name":"hadoop","slug":"hadoop","permalink":"http://yoursite.com/tags/hadoop/"}]},{"title":"队列同步器-AQS","slug":"java/并发编程/AQS同步器","date":"2020-05-16T05:03:22.000Z","updated":"2020-06-04T05:57:00.150Z","comments":true,"path":"2020/05/16/java/并发编程/AQS同步器/","link":"","permalink":"http://yoursite.com/2020/05/16/java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/AQS%E5%90%8C%E6%AD%A5%E5%99%A8/","excerpt":"","text":"什么是队列同步器队列同步器是用来构建锁或者其他同步组件的基础框架，它使用一个int成员变量表示同步状态，通过内置的FIFO队列完成资源获得线程的排队工作。 同步器是实现锁的关键，在锁的实现中聚合同步器，利用同步器实现锁的语义。 锁和同步器两者的关系：锁是面向使用者，定义了使用者与锁交互的接口，隐藏实现细节；而同步器面向的是锁的实现者，简化了锁的实现方式，屏蔽了同步状态管理、线程的排队、等待与唤醒等底层操作。 AQS的主要使用方式是继承，子类通过继承同步器并实现它的抽象方法来管理同步状态，在抽象方法的实现过程中需要对同步状态进行更新，因此就需要使用同步器提供的3个方法来保证状态的改变是安全的。 队列同步器的实现同步队列同步队列依赖内部的同步队列完成同步状态的管理，当前线程获得同步状态失败时，同步器会将当前线程以及等待状态等信息构成一个节点将其加入到同步队列中，同时会阻塞当前线程，当同步状态释放时，会将首节点的线程唤醒，使其再次尝试获取同步状态。同步队列中的节点用来保存获取同步状态失败的线程引用、等待状态以及前驱后继节点。 属性类型与名称 描述 int waitStatus 等待状态 Node prev 前驱节点 Node next 后继节点 Node nextWaiter 等待队列中的后继节点 Thread thread 获取同步状态的线程 上面的waitStatus变量中有这么几个状态， CANCELED SIGNAL CONDITION PROPAGATE INITIAL 同步队列的基本结构如下 同步器提供一个基于CAS的设置尾节点的方法（compareAndSetStatus），通过CAS设置尾节点； 如下图：","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"java并发编程","slug":"java并发编程","permalink":"http://yoursite.com/tags/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}]},{"title":"Java中的线程池","slug":"java/并发编程/Java中的线程池","date":"2020-05-04T06:29:41.000Z","updated":"2020-06-04T12:53:06.297Z","comments":true,"path":"2020/05/04/java/并发编程/Java中的线程池/","link":"","permalink":"http://yoursite.com/2020/05/04/java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0/","excerpt":"","text":"合理使用线程池的好处 降低资源消耗 通过重复利用已创建的线程降低线程创建和的销毁造成的消耗 提高响应速度 当任务到达时，任务可以不需要等到线程创建就能立即执行 提高线程的可管理性 线程是稀缺资源，如果无限制创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优、监控 线程池的实现原理线程池的处理流程 线程池判断核心线程池里的线程是否都在执行任务。如果不是，则创建一个新的工作线程来执行任务。如果核心线程池里的线程都在执行任务，则进入下一个流程 线程池铺垫工作队列是否已满。如果工作队列没有满，则将新提交的任务存储在这个工作队列中。如果工作队列慢了，则进入下一个流程 线程池判断线程池的线程是否都处于工作状态。如果没有，则创建一个新的工作线程來执行任务。如果已满，则交给饱和策略来处理这个任务 流程图图如下： ThreadPoolExector执行execute ThreadPoolExecutor执行execute方法分为4种情况： 1 如果当前线程少于corePoolSize，则创建新线程来执行任务 2 如果运行的线程等于或多于corePoolSize，则将任务加入BlockingQueue 3 如果无法将任务加入BlockingQueue，则创建新的线程来处理任务 4 如果创建新线程将使当前运行的线程超出maximumPoolSize，任务将被拒绝，并调用异常方法 线程池中的线程执行任务分两种情况 在execute()方法中创建一个线程时，会让这个线程执行当前任务 这个线程执行完下图中1的任务后，会反复从BlockingQueue中获取任务来执行 线程池的使用 线程池的创建 通过ThreadPoolExecutor来创建一个线程池 12345new ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) 创建一个线程需要输入几个参数 corePoolSize：线程池的基本大小 maximumPoolSize：线程池最大数量 keepAliveTime：线程活动保持时间 unit：线程活动保持时间单位 workQueue：任务队列 向线程池提交任务 使用两个方法向线程池提交任务 execute()方法： execute()方法用于提交不需要返回值得任务，所以无法判断任务是否被线程池执行成功 submit()方法： submit()方法用于提交需要返回值的任务。线程池会返回一个future类型的对象，通过这个future对象可以判断任务是否执行成功，并且可以通过future的get()方法来获取返回值，get()方法会阻塞当前线程直到任务完成，get(long timeout,TimeUnit unit)方法则会阻塞当前线程一段时间后立即返回，这种情况下有可能任务没有执行完成。 关闭线程池 通过调用线程池的shutdown或shutdownNow方法关闭线程池。 shutdownNow首先将线程池的状态设置成STOP,然后尝试停止所有正在执行或暂停任务的线程，并返回等待执行任务的列表。 shutdown只是将线程池的状态设置成SHUTDOWN状态，然后中断所有没有正在执行的任务的线程。","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"java并发编程","slug":"java并发编程","permalink":"http://yoursite.com/tags/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}]},{"title":"Java并发编程之Synchronized","slug":"java/并发编程/Java并发编程之Synchronized","date":"2020-04-25T08:07:02.000Z","updated":"2020-05-06T01:56:55.758Z","comments":true,"path":"2020/04/25/java/并发编程/Java并发编程之Synchronized/","link":"","permalink":"http://yoursite.com/2020/04/25/java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BSynchronized/","excerpt":"","text":"synchronized的实现原理利用synchronized实现同步的基础： 对于普通同步方法，锁是当前的实例对象 对于静态同步方法，锁是当前类的Class对象 对于同步方法块，锁是Synchronized括号里的配置对象 Synchronized实现原理：JVM基于进入和退出Monitor对象来实现方法同步和代码块同步，代码块同步使用monitorenter和monitorexit指令实现，monitorenter指令是在编译后插入到同步代码块开始位置，而monitorexit是插入到方法结束和异常处，JVM要保证每个monitorenter必须有对应的monitorexit与之匹配。 关键字synchronized可以修饰方法或者以同步块的形式来进行使用，它主要确保多个线程在同一时刻，只能有一个线程处于方法或同步块中，他保证了线程对变量访问的可见性和排他性。对于同步块的实现使用monitorenter和monitorexit指令，而同步方法则是依靠方法修饰符上的ACC_SYNCHRONIZED来完成。其本质上是对一个对象的监视器(monitor)进行获取，而这个过程是排他的，也就是在同一时刻只能有一个线程获得synchronized所保护对象的监视器。任意一个对象都拥有自己的监视器，当这个对象有同步块或者这个对象的同步方法调用时，执行方法的线程必须先获取到该对象的监视器才能进入同步块或者同步方法，而没有获取到监视器的线程将会被阻塞在同步块和同步方法的入口处，进入BLOCKED状态。 参考资料","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"java并发编程","slug":"java并发编程","permalink":"http://yoursite.com/tags/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}]},{"title":"TCP/IP协议","slug":"计算机基础/计算机网络/TTCP-IP协议","date":"2020-03-12T18:19:13.000Z","updated":"2020-03-15T14:02:04.814Z","comments":true,"path":"2020/03/13/计算机基础/计算机网络/TTCP-IP协议/","link":"","permalink":"http://yoursite.com/2020/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TTCP-IP%E5%8D%8F%E8%AE%AE/","excerpt":"","text":"TCP/IP的标准制定由于TCP/IP技术的公开性，他不属于任何一个厂商或者是专业协会所有。TCP/IP的标准大部分都由RFC技术报告的形式公开。RCF文件包含了所有TCP/IP的协定标准，以及其最新版本。RFC所涵盖的内容和细节非常广，也可以为新协定的标准和计划，但不能以学术研究论文的方式来编辑。 TCP/IP的特性 它是其它网络服务的基础，几乎所有数据包交换网络都提供了这种服务。TCP/IP是根据信息中所含的地址资料来进行资料的传送，他不能确保每个独立路由的数据包是可靠和依序的送达目的地。在每个连线过程中，线路都不是被”独占”的，而是直接映射到硬件地址上，因此特别有效。 因为数据包交换并不能确保每一个数据包的可靠性，因此我们就需要通讯软件来自动检测和修护传送过程中出现的错误和处理损坏数据包。这种服务就是用来确保电脑程序之间能够连接和传送大量的数据。关键的技术就是数据流进行分割，然后编号传送，然后通过接受的确认来确数据的完整性 在数据包交换技术中，TCP/IP是独立于硬件之上的。TCP/IP有自己的一套数据包规定和定义,能应用在不同的网络之上 只要用TCP/IP连接网络，就会获得一个独一无二的识别位址。数据包在交换过程中，是以位址数据为依据，不管数据包所经历的路由如何，数据都会被送到指定的地址。 TCP/IP 的确认模式是以“端到端”进行的。這样就无需理会数据包交换过程中所参与的其他设备。 TCP/IP协议分层框架 链路程：链路层以字节位单位0和1分别进行分组，定义数据帧，写入源和目标机器的物理地址，数据，校验位来传输数据。 链路层报文结构 网络层：根据IP定义网络地址，区分网段。子网内根据地址解析协议(ARP)进行MAC寻址，子网外进行路由转发数据包，这个数据包即为IP数据包。 传输层：数据包通过网络层发送到目标计算机后，应用程序在传输层定义逻辑端口，确认身份后，将数据包交给应用程序，实现端口到端口间通讯。 应用层：传输层的数据到达应用程序时，以某种统一规定的协议格式解读数据。 IP协议IP是面向无连接、无状态的，没有额外的机制保证发送的包是否有序到达。IP首先规定出IP地址格式，该地址相当于在逻辑意义上进行了网段的划分，给没台机器额外设置了一个唯一的详细地址。IP地址属于网络层，主要的功能字啊WLAN内进行路由寻址，选择最佳路由。 TCP建立连接传输控制协议(TCP)，是一种面向连接、确保数据在端到端间的可靠传输的协议。面向连接是指在发送数据前，需要先建立一条虚拟的链路，然后让数据在这条链路上“流动”传输。每个TCP数据包是封装在IP包中的，每一个IP头的后面紧接的是TCP头。 协议第一行的两个端口号各个占据两个字节，分别代表源机器与目标机器的端口号。这两个端口号与IP报头格式中的源IP地址和目标IP地址所组成的四元组可唯一标识一条TCP连接。由于TCP是面向连接的，所以有服务器和客户端之分。需要服务端先在相应的端口上进行监听，准备好接收客户端发起的连接请求。在类UNIX系统系统上通过netstat命令列出机器上已建立的连接信息，其中包含唯一标识一条连接的四元组，以及各连接的状态等内容。 TCP的FLAG位有6个bit组成，分别代表SYN、ACK、FIN、URG、PSH、RST，需要重点关注的是SYN、ACK、FIN。SYN(Synchronize Sequence Numbers)用作建立连接时的同步信号；ACK(Acknowledgement)用于对收到的数据进行确认，所确认的数据由确认序列号表示；FIN(Finish)表示后面没有数据需要发送，通常意味着所建立的连接需要关闭。 TCP三次握手TCP三次握手是指在建立连接的三个步骤： A机器发出一个数据包并将SYN置1，表示希望建立连接。这个包中的序列号假设是x。 B机器收到A机器发过来的数据包后，通过SYN得知这是一个建立连接的请求，于是发送一个响应包并将SYN和ACK标记都置为1。假设这个包中的序列号是y，而确认序列号的必须是x+1，表示收到了A发过来的SYN。在TCP中，SYN被当作数据中的一个字节。 A接收到B的响应后需进行确认，确认包中将ACK置1，并将确认序列号设置为y+1，表示收到了来自B的SYN。 双方只有确认4类信息，才能建立连接。在第二次握手后，从B机器视角看还有连个NO信息无法确认。在第三次握手后，B机器才能确认自己的发报能力是否正常的。 连接三次握手也是防止出现请求超时导致脏连接。TTL网络报文的生存时间往往都会超过TCP请求时间，如果两次握手就可以创建连接的话，传输数据并释放连接后，第一个超时的连接请求才到达B机器的话，B机器会认为是A创建的连接的请求，然后确认同意创建连接。因为A机器的状态不是SYN_SENT,所以直接丢弃了B的确认数据，以致最后只是B机器单方面创建连接完毕。 TCP断开连接TCP是全双工通信，双方都能作为数据的发送方和接收方，但TCP连接也会有断开的时候。A、B机器连接只要三次握手，而断开则需要四次挥手，例如下图： A机器想要断开连接，则待本方数据发送完毕后，传递FIN信号给B机器。B机器应答ACK，告诉A机器可以断开，但是需要等B机器处理完成数据，再主动给A机器发送FIN信号。这时A机器处于半关闭状态(FIN-WAIT-2)，无法再发送新的数据。B机器做好连接关闭前的准备工作后，发送FIN给A机器，此时B机器也进入半关闭状态(CLOSE_WAIT)。A机器发送针对B机器FIN的ACK后，进入TIME_WAIT状态，经过2MSL后，没有收到B机器传过来的报文，则确定B机器已经收到A机器最后发送的ACK指令，此时TCP连接正式释放。","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"CPU与内存","slug":"计算机基础/计算机构成/CPU与内存","date":"2020-03-11T14:15:02.000Z","updated":"2020-03-12T19:34:04.876Z","comments":true,"path":"2020/03/11/计算机基础/计算机构成/CPU与内存/","link":"","permalink":"http://yoursite.com/2020/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%9E%84%E6%88%90/CPU%E4%B8%8E%E5%86%85%E5%AD%98/","excerpt":"","text":"参考资料","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}]},{"title":"计算机的0与1","slug":"计算机基础/计算机构成/计算机的0与1","date":"2020-03-11T12:53:21.000Z","updated":"2020-03-11T14:14:08.175Z","comments":true,"path":"2020/03/11/计算机基础/计算机构成/计算机的0与1/","link":"","permalink":"http://yoursite.com/2020/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%9E%84%E6%88%90/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%840%E4%B8%8E1/","excerpt":"","text":"在计算机中无论是什么设备，归根结底都是0和1的信号处理，设定基数为2，进位的规则是“逢二进一”，称之为二进制，设想有8条电路，每条电路有高电平和低电平两种状态。根据组合排列，有2^8 即256个种不同的信号。这8条电路，最左侧的一条表示正负，0表示正数，1表示负数，不参与数值表示。 基本编码表示数的基本编码方式有原码、反码、补码； 原码：符号为和数字实际值得结合，正数就是数值本身，符号为0；负数是数值本身，符号位为1，8位的二进制的表示范围是[-127,127] 反码：正数是本身，符号位为0；负数的数值部分是正数表示的基础上对各个位取反，符号位为1。8位二进制数的表示范围是[-127,127] 补码：正数是数组的本身，符号位为0，负数的数值部分是在正数表示基础上对各个位取反加1，符号位为1。8位二进制数的表示范围是[-127,127] 正数/负数 原码 反码 补码 1 0000 0001 0000 0001 0000 0001 -1 1000 0001 1111 1110 1111 1111 2 0000 0010 0000 0010 0000 0010 -2 1000 0010 1111 1101 1111 1110 为了加速计算机对加减乘除运算速度，所有产生了反码和补码。例如在进行减法计算时，1-2=-1在计算机运算中可以这样运算：1+（-2）=-1。如果使用原码计算则结果为：1+（-2）= [0000 0001]原+[1000 0010]原 = [10000011]原 = -3结果是错误的。为了解决这一问题，于是出现了反码，使用反码计算，结果为1-2 = 1+(-2) = [00000001]反+[1111 1101]反=[1111 1110]反 = -1。 计算机存储计量单位在上述的一条线路在计算机中表示1位，即1个bit，8个bit组成一个单位，称为一个字节，即1个Byte，1024个Byte简写为KB，1024个KB简写为MB，1024个MB简写为GB。 位移运算向右移动一位近似表示除以2，十进制转化为二进制数后，向右移时，最右边的1位将被直接抹去。在左移&lt;&lt;和右移&gt;&gt;这两种运算中符号位均参与移动，除了负数右移时高位补1外，其他情况均在空位处补0 左移运算由于符号位参与向左移动，在移动后的结果，最左位可能是1或是0，即正数向左移的结果可能负数也可能是正数，负数向左移的结果也是如此。 对于 &gt;&gt;&gt; 无符号向右移动(不存在&lt;&lt;&lt;位移运算)，当向右移动时，正负数高位均补0，正数不断向右移动的最小值是0，而负数不断向右移动的最小值为1，无需考虑符号位，高位直接补0 参考资料 《码出高效 Java开发手册》","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}]},{"title":"浅尝算法","slug":"数据结构与算法/排序算法","date":"2020-02-20T12:54:01.000Z","updated":"2020-12-16T07:12:16.661Z","comments":true,"path":"2020/02/20/数据结构与算法/排序算法/","link":"","permalink":"http://yoursite.com/2020/02/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","excerpt":"","text":"排序算法根据时间复杂度的不同，主流的排序算法分为3大类 时间复杂度为O(n[^^]2)的排序算法 排序算法 选择排序 插入排序 希尔排序 时间复杂度为O(nlogn)的排序算法 快速排序 归并排序 堆排序 时间复杂度为线性的排序算法 计数排序 桶排序 基数排序 冒泡排序(bubble sort)冒泡排序的思想就是把相邻的元素进行两两比较，当一个元素大于右侧相邻的元素时，交换它们的位置；当一个元素小于或等于右侧相邻元素时，位置不变。 冒泡排序是一种稳定的排序，值相等的元素并不会打乱原本的排序。由于该排序算法的每一轮都会遍历所有元素，总共遍历(元素数量-1)轮，所以平均时间复杂度为O(n[^^]2)。 代码实现 123456789101112131415161718192021222324import java.util.Arrays;public class bubblesort&#123; public static void sort(int[] array)&#123; for(int i = 0;i&lt;array.length;i++)&#123; for(int j = 0;j&lt;array.length-i-1;j++)&#123; int tmp = 0; if(array[j]&gt;array[j+1])&#123; tmp = array[j]; array[j] = array[j+1]; array[j+1] = tmp; &#125; &#125; &#125; &#125; public static void main(String[]args)&#123; int[] array = new int[]&#123;7,8,3,46,94,84,5,6,46,5,45,4&#125;; sort(array); System.out.println(Arrays.toString(array)); /** 输出: &gt;[3, 4, 5, 5, 6, 7, 8, 45, 46, 46, 84, 94] **/ &#125;&#125; 代码使用双循环进行排序，外部循环控制所有的回合，内部循环实现每一轮的冒泡处理，进行元素比较，在进行元素排 算法优化","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"浅尝算法","slug":"数据结构与算法/算法","date":"2020-02-20T12:54:01.000Z","updated":"2021-01-17T14:01:37.471Z","comments":true,"path":"2020/02/20/数据结构与算法/算法/","link":"","permalink":"http://yoursite.com/2020/02/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95/","excerpt":"","text":"排序算法根据时间复杂度的不同，主流的排序算法分为3大类 时间复杂度为O(n[^^]2)的排序算法 排序算法 选择排序 插入排序 希尔排序 时间复杂度为O(nlogn)的排序算法 快速排序 归并排序 堆排序 时间复杂度为线性的排序算法 计数排序 桶排序 基数排序 冒泡排序(bubble sort)冒泡排序的思想就是把相邻的元素进行两两比较，当一个元素大于右侧相邻的元素时，交换它们的位置；当一个元素小于或等于右侧相邻元素时，位置不变。 冒泡排序是一种稳定的排序，值相等的元素并不会打乱原本的排序。由于该排序算法的每一轮都会遍历所有元素，总共遍历(元素数量-1)轮，所以平均时间复杂度为O(n[^^]2)。 代码实现 1234567891011121314151617181920212223import java.util.Arrays;public class bubblesort&#123; public static void sort(int[] array)&#123; for(int i = 0;i&lt;array.length;i++)&#123; for(int j = 0;j&lt;array.length-i-1;j++)&#123; int tmp = 0; if(array[j]&gt;array[j+1])&#123; tmp = array[j]; array[j] = array[j+1]; array[j+1] = tmp; &#125; &#125; &#125; &#125; public static void main(String[]args)&#123; int[] array = new int[]&#123;5,8,6,3,9,2,1,7&#125;; sort(array); System.out.println(Arrays.toString(array)); &#125;&#125;/*[3, 4, 5, 5, 6, 7, 8, 45, 46, 46, 84, 94]*/ 代码使用双循环进行排序，外部循环控制所有的回合，内部循环实现每一轮的冒泡处理，进行元素比较，再进行元素排序。 冒泡排序的优化在刚才描述的排序中，仍以【5,8,6,3,9,2,1,7】为例，当算法分别执行到第6、7轮时，数组状态如下： 【1，2，3，4，5，6，7，8，9】这是第6轮的。 第7轮：【1，2，3，4，5，6，7，8，9】。 在第6轮中整个数组就已经是有序的了，可算法还是执行了第7轮排序。 如果能够判断出数列已经有序，并做出标记，那么剩下的几轮排序就不必执行，可以提前结束。 123456789101112131415161718192021222324252627282930313233package algs;import java.util.Arrays;public class bubblesort1&#123; public static void sort(int[] array)&#123; int lastExchangeIndex = 0; int sortBorder = array.length-1; for(int i=0; i&lt;array.length-1; i++)&#123; boolean isSorted = true; for(int j = 0; j&lt;sortBorder; j++)&#123; int tmp = 0; if(array[j]&gt;array[j+1])&#123; tmp = array[j]; array[j] = array[j+1]; array[j+1] = tmp; isSorted = false; lastExchangeIndex = j; &#125; &#125; sortBorder = lastExchangeIndex; if(isSorted)&#123; break; &#125; &#125; &#125; public static void main(String[]args)&#123; int[] array = new int[]&#123;7,8,3,46,94,84,5,6,46,5,45,4&#125;; sort(array); System.out.println(Arrays.toString(array)); &#125;&#125;/*[3, 4, 5, 5, 6, 7, 8, 45, 46, 46, 84, 94]*/ 快速排序快速排序在每一轮中挑选一个基准元素，并让其它比它大的元素移动到数列的一边，比它小的元素移动到另一边，从而把数列拆解成两个部分。这叫分而治之。 每一轮的比较和交换，需要把数组全部元素都遍历一遍，时间复杂度为O(n)，这样下来平均需要logn轮，因此快速排序的总体的平均时间复杂度为O(nlogn)。 基准元素的选择 基准元素（pivot），在分治过程中，以基准为中心，把其他基准元素移动到它左右两边。 那如何选择基准元素呢？ 最简单的方式就是选择数列的第一个元素。但是这种方式在一些特殊情况下优点麻烦，所以这种方式还是不好。 为了尽量避开这种麻烦。在选择基准元素时，可随机选择一个元素作为基准元素，并且让基准元素和数列的首位元素交换位置。 元素的交换 元素的交换方式有两种： 1.双边循环法 如下图中数列：要求对其从小到大进行排序 首先，选定基准元素pivot，并且设置两个指针left和right，指向数列的最左和最右两个元素。 接下来进行第一次循环，从right指针开始，让指针所指向的元素和基准元素做比较。如果大于或等于pivot，则指针向左移动，如果小于pivot，则right指针停止移动，切换到left指针。 到了left指针移动，让指针所指向的元素和基准元素做比较，如果小于或等于pivot，则指针向右移动，让left和right指针所指向的元素进行交换。如果大于pivot，则left指针停止移动。 2.单边循环法 首先选定基准元素pivot。同时，设置一个mark指针指向数列的起始位置，这个mark指针代表小于基准元素的区域的边界。 接下来，从基准元素的下一个位置开始遍历数组。 如果遍历到的元素大于基准元素，就继续向后遍历。 如果遍历到的元素小于基准元素，则需要做两件事：第一，把mark指针右移1位，因为小于pivot的区域边界增大了1，第二，让最新遍历到的元素和mark指针所在的位置的元素交换位置，因为最新遍历的元素归属于小于pivot的区域。 123456789101112131415161718192021222324252627282930313233package algs;import java.util.Arrays;public class quicksort2&#123; public static void quickSort(int[] arr,int startIndex,int endIndex)&#123; if(startIndex &gt;= endIndex)&#123; return; &#125; int partition = partition(arr,startIndex,endIndex); quickSort(arr,startIndex,partition-1); quickSort(arr,partition+1,endIndex); &#125; private static int partition(int[]arr,int startIndex,int endIndex)&#123; int pivot = arr[startIndex]; int mark = startIndex; for(int i = startIndex+1;i&lt;=endIndex;i++)&#123; if(arr[i]&lt;pivot)&#123; mark++; int tmp = arr[mark]; arr[mark] = arr[i]; arr[i] = tmp; &#125; &#125; // 最后把pivot元素交换到mark指针所在位置 arr[startIndex] = arr[mark]; arr[mark] = pivot; return mark; &#125; public static void main(String[]args)&#123; int arr[] = new int[]&#123;4,4,6,5,3,2,8,1&#125;; quickSort(arr,0,arr.length-1); System.out.println(Arrays.toString(arr)); &#125;&#125; 3.非递归实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package algs;import java.util.*;public class quicksort3&#123; public static void quickSort(int[] arr,int startIndex,int endIndex)&#123; // 用一个集合栈来代替递归函数栈 Stack&lt;Map&lt;String,Integer&gt;&gt; quickSortStack = new Stack&lt;&gt;(); // 整个数列的起始下标，以哈希的形式入栈 Map&lt;String,Integer&gt; rootparam = new HashMap&lt;&gt;(); rootparam.put(\"startIndex\",startIndex); rootparam.put(\"endIndex\",endIndex); quickSortStack.push(rootparam); // 循环结束条件：栈为空时 while(!quickSortStack.isEmpty())&#123; // 栈顶元素出栈，得到起始下标 Map&lt;String,Integer&gt; param = quickSortStack.pop(); // 得到基准元素位置 int pivotIndex = partition(arr,param.get(\"startIndex\"),param.get(\"endIndex\")); // 根据基准元素分成两部分，把每个部分的起始下标入栈 if(param.get(\"startIndex\") &lt; pivotIndex-1)&#123; Map&lt;String,Integer&gt; leftparam = new HashMap&lt;&gt;(); leftparam.put(\"startIndex\",param.get(\"startIndex\")); leftparam.put(\"endIndex\",pivotIndex-1); quickSortStack.push(leftparam); &#125; if(pivotIndex+1 &lt; param.get(\"endIndex\"))&#123; Map&lt;String,Integer&gt; rightParam = new HashMap&lt;&gt;(); rightParam.put(\"startIndex\",pivotIndex+1); rightParam.put(\"endIndex\",param.get(\"endIndex\")); quickSortStack.push(rightParam); &#125; &#125; &#125; private static int partition(int[]arr,int startIndex,int endIndex)&#123; int pivot = arr[startIndex]; int mark = startIndex; for(int i = startIndex+1;i&lt;=endIndex;i++)&#123; if(arr[i]&lt;pivot)&#123; mark++; int tmp = arr[mark]; arr[mark] = arr[i]; arr[i] = tmp; &#125; &#125; // 最后把pivot元素交换到mark指针所在位置 arr[startIndex] = arr[mark]; arr[mark] = pivot; return mark; &#125; public static void main(String[]args)&#123; int arr[] = new int[]&#123;4,4,6,5,3,68,2,8,9,1,54&#125;; quickSort(arr,0,arr.length-1); System.out.println(Arrays.toString(arr)); &#125;&#125;/*[1, 2, 3, 4, 4, 5, 6, 8, 9, 54, 68]*/ 堆排序","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"数据结构基础","slug":"数据结构与算法/数据结构基础","date":"2020-02-20T04:54:01.000Z","updated":"2020-12-08T13:23:54.972Z","comments":true,"path":"2020/02/20/数据结构与算法/数据结构基础/","link":"","permalink":"http://yoursite.com/2020/02/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/","excerpt":"","text":"数据结构 数据结构是算法的基石，是数据的组织、管理、存储形式，请使用的目的是为了访问和修改数据。数据结构的组成形式有：线性结构、树、图、其他数据结构（这个后面会缀述） 数组 数组是有限个相同类型的变量所组成的有序集合，数组中的每个变量称为元素。 数组的基本操作 读取元素：读取元素，只需要给出一个数组的下标，就可以读取相应的数组元素。这种根据下标读取的元素的方式称为随机读取。 更新元素：把一个元素的值替换成为一个新值，利用数组下标，把新值赋给该元素。 插入元素：插入数组元素的有三种：尾部插入、中间插入、超范围插入。 中间插入复杂些，因为数组的每个元素都有固定的下标，所以需要把插入位置及以后的元素向后移动，再把插入的元素放到对应的数组位置上。 超范围插入：超范围插入涉及到扩容，可以创建一个新数组，长度是旧数组的2倍，再把旧数组中的元素复制给新数组，就是实现了数组的扩容。 删除元素：数组的删除操作，如果删除的元素位于数组的中间，其后的元素都需要向前（也就是向左移动一位） 数组的优点和缺点数组的优点是拥有高效的随机访问能力。数组的缺点在插入和删除元素方面，由于数组元素连续紧密的存储在内存中，插入和删除元素会导致大量元素移动。数组适合读多写少的应用场景。 链表 链表是一种在物理上非连续、非顺序的数据结构，由若干节点所组成。单向链表的每个节点包含两部分，一部分是存放数据的变量data，一部分是指向下一个节点的指针next。 1234private static class Node&#123; int data; Node next;&#125; 双向链表比单项链表多了指向前置节点的prev指针 链表在内存中的存储方式是随机存储 链表的基本操作 查找节点： 链表查找节点时只能从头节点开始向后逐个查找。 更新节点： 链表的更新过程会像数组那样，直接把旧数据替换成新数据即可 插入节点： 尾部插入：把最后一个节点的next指针指向新插入的节点即可。 头部插入：把新节点的next节点的指针原先的头节点，把新节点变成链表的头节点 中间插入：把新节点的next指针指向插入位置的节点，插入位置前置节点的next指针指向新节点。 删除元素： 尾部删除：把倒数第二个节点的next指针指向空即可 头部删除：把链表的头节点设为原先头节点的next指针即可 中间删除：把要删除的节点的前置节点的next指针，指向要删除元素的下一个节点即可 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687public class MyLinkedList&#123; private Node head; private Node last; private int size; public void insert(int data,int index)throws Exception&#123; if(index &lt; 0 || index &gt; size)&#123; throw new IndexOutOfBoundsException(\"Index outfound\"); &#125; Node insertedNode = new Node(data); if(size == 0)&#123; head = insertedNode; last = insertedNode; &#125;else if(index == 0)&#123; insertedNode.next = head; head = insertedNode; &#125;else if(size == index)&#123; last.next = insertedNode; last = insertedNode; &#125;else&#123; Node prevNode = get(index-1); insertedNode.next = prevNode.next; prevNode.next = insertedNode; &#125; size++; &#125; public Node get(int index)throws Exception&#123; if(index &lt; 0 || index &gt;= size)&#123; throw new IndexOutOfBoundsException(\"数组越界\"); &#125; Node temp = head; for(int i = 0;i&lt;index;i++)&#123; temp = temp.next; &#125; return temp; &#125; public void output()&#123; Node temp = head; while(temp != null)&#123; System.out.println(temp.data); temp = temp.next; &#125; System.out.println(\"size：\"+size); &#125; public Node remove(int index)throws Exception&#123; if(index &lt; 0|| index &gt;= size)&#123; throw new IndexOutOfBoundsException(\"下标越界\"); &#125; Node removeNode = null; if(index == 0)&#123; // 删除头结点 removeNode = head; head = head.next; &#125;else if(index == size-1)&#123; // 删除尾节点 Node prevNode = get(index-1); removeNode = prevNode.next; prevNode.next = null; last = prevNode; &#125;else&#123; // 删除中间节点 Node prevNode = get(index-1); Node nextNode = prevNode.next.next; removeNode = prevNode.next; prevNode.next = nextNode; &#125; size--; return removeNode; &#125; private static class Node&#123; int data; Node next; Node(int data)&#123; this.data = data; &#125; &#125; public static void main(String[] args)throws Exception&#123; MyLinkedList myLinkedList = new MyLinkedList(); myLinkedList.insert(3,0); myLinkedList.insert(7,1); myLinkedList.insert(9,2); myLinkedList.insert(5,3); myLinkedList.insert(6,1); myLinkedList.remove(0); myLinkedList.output(); &#125;&#125; 数组和链表的比较： 查找 更新 插入 删除 数组 O(1) O(1) O(n) O(n) 链表 O(n) O(1) O(1) O(1) 对于读操作多写操作少的应用场景数组适合一些，对于需要频繁插入数据删除数据来说，链表合适一些 栈栈是一种线性数据结构，栈中的元素只能先入后出。最早进入的元素存放的位置叫作栈底，最后进入的元素存放的位置叫作栈顶。 栈的基本操作 入栈(push) 入栈操作就是把新元素放入栈中，只允许从栈顶一侧放入元素，新元素的位置将会成为新的栈顶 出栈(pop) 出栈操作是把元素从栈中弹出，只有栈顶元素才能允许出栈，出栈元素的前一个元素将会成为新的栈顶。 代码实现 12345678910111213141516171819202122232425262728293031323334353637public class MyStack&#123; private int[] stack; private int size; public MyStack(int capacity)&#123; this.stack = new int[capacity]; this.size = 0; &#125; public void push(int elem)throws Exception&#123; if(size &gt; stack.length)&#123; throw new IndexOutOfBoundsException(\"数组越界\"); &#125; stack[size] = elem; size++; &#125; public int pop()throws Exception&#123; if(size &lt; 0)&#123; throw new IndexOutOfBoundsException(\"栈为空\"); &#125; size--; return stack[size]; &#125; public void output()throws Exception&#123; System.out.print(\"栈顶：\"); for(int i = size-1;i&gt;=0;i--)&#123; System.out.println(pop()); &#125; System.out.println(\"栈底：\"); &#125; public static void main(String[] args)throws Exception&#123; MyStack stack = new MyStack(5); stack.push(5); stack.push(6); stack.push(52); System.out.println(stack.pop()); // stack.output(); &#125;&#125; 队列队列是一种线性数据结构，队列中的元素只能先入后出，对列的出口端叫作队头(front)，队列的入口端叫作队尾(rear)。 队列的基本操作 入队（enqueue） 入队操作（enqueue）就是把新元素放入队列中，只允许在队尾的位置放入元素，新元素的下一个位置将会成为新的对尾。 出队（dequeue） 出队操作就是把元素移出队列，只允许在队头一侧移出元素，出队元素的后一个元素将会成为队头。 循环队列：在数组不做扩容的前提下，可以利用已出队元素留下的空间，让队尾指针重新指回数组的首位。一直到(队尾下标+1)%数组长度 = 队头下标，表示此队列已经满，队尾指针指向的位置永远空出1位，所以队列最大容量比数组长度小1。 12345678910111213141516171819202122232425262728293031323334353637383940414243public class MyQueue&#123; private int[] array; // 队头 private int front; // 队尾 private int rear; public MyQueue(int capacity)&#123; this.array = new int[capacity]; &#125; /** 入队操作 */ public void enqueue(int elem)throws Exception&#123; if((rear+1)%array.length == front)&#123; throw new Exception(\"队列已满\"); &#125; array[rear] = elem; rear = (rear+1)%array.length; &#125; /** */ public int dequeue()throws Exception&#123; if(rear==front)&#123; throw new Exception(\"队列已空\"); &#125; int dequeueElem = array[front]; front = (front+1)%array.length; return dequeueElem; &#125; public void output()&#123; for(int i = front;i!=rear;i=(i+1)%array.length)&#123; System.out.println(array[i]); &#125; &#125; public static void main(String[] args)throws Exception&#123; MyQueue queue = new MyQueue(5); queue.enqueue(5); queue.enqueue(4); queue.enqueue(6); queue.enqueue(5); queue.output(); &#125;&#125; 栈和队列的应用栈的输出顺序和输入顺序相反，所以栈通常用于对“历史”的回溯，也就是逆流而上追溯“历史”。例如实现递归的逻辑，就可以用栈来代替，因为栈可以回溯方法的调用链。 队列的输出顺序和输入顺序相同，所以队列通常用于对“历史”的回放，也就是按照“历史”顺序，把“历史”重演一遍。例如在多线程中，争夺公平锁的等待队列，就是按照访问顺序来决定线程在队列中的次序的。 散列表散列表也叫哈希表(hash table)，散列表在本质上也是一个数组。这种数据结构提供了键值对的映射关系。只要给出Key，就可以查找出它所匹配的Value，时间复杂度接近O(1)。 哈希函数在不同的编程语言中，哈希函数的实现也不一样，这里以Java为例，在Java及大多数面向对象编程语言中，每个对象都有自己的hashcode，hashcode是区分不同对象的重要标识，无论对象的自身类型是什么，它们的hashcode都是一个整型变量。最简单的转化方式是按照数组长度进行取模运算。 index = HashCode(Key)%Array.length 通过哈希函数，可以把字符串或其他类型的Key转化为数组的下标index。 散列表的读写操作 写操作（put） 写操作就是在散列表中插入新的键值对，通过哈希函数，把Key转化为数组下标，如果数组下标没有对应的元素，就把这个Entry填充到数组下标的相应位置。由于数组的长度有限，当插入的Entry越来越多时，不同的Key通过哈希函数获得的下标也有可能相同，所以这就造成了哈希冲突。哈希冲突是无法避免的。解决哈希冲突的方法有两中；一种是开放寻址法，一种是链表法。在Java中开放寻址法用于ThreadLocal。HashMap使用的是链表法解决哈希冲突问题。HashMap数组的每个元素不仅是一个Entry对象，还是一个链表的头节点，每个Entry对象通过next指针指向它的下一个Entry节点。当新来的Entry映射到与之冲突的数组位置时，只需要插入到对应的链表中即可。 读操作（get） 读操作就是通过给定的Key，在散列表中查找对应的Value。通过哈希函数，把Key转化为数组的下标。找到数组下标对应的元素，如果找到了这个元素就返回对应数组的值；如果找不到就顺着这个数组的元素的链表往下找，是否能够找到与之对匹配的节点。 扩容（resize） 当经过多次元素插入，散列表达到一定的饱和时，key映射的位置发生冲突的几率会增加。大量的元素拥挤在相同的数组下标位置下，会形成很长的链表。对于后续的插入操作和查询操作的性能都有很大的影响，这时就需要扩容了。 散列表的扩容操作 扩容，创建一个新的Entry空数组，长度为元素的两倍。 重新hash，遍历原Entry数组，把所有的Entry重新Hash到新数组中，因为长度扩容后，Hash的规则也随之变化。 用Java中的散列表实现类HashMap为例，影响扩容的因素有两个： Capacity：散列表的当前长度 LoadFactor：散列表的负载因子，默认值为0.75f 衡量HashMap需要扩容的条件如下： HashMap.size &gt;= Capacity*LoadFactor 树树（tree）是n（n&gt;=0）个节点的有限集。当n=0时，称为空树。在任意一个非空树中，有下面两个特点。 有且仅有一个特定的称为根的节点。 当n&gt;1时，其余的节点可分为m（m&gt;0）个互不相交的有限集，每个集合本身又是一个树，并称为根的子树。 二叉树二叉树是树的一种特殊形式。这种树结构的每个节点最多有2个子节点，也可能只有1个，或者没有孩子节点。二叉树的两个孩子节点，一个称为左孩子节点(left child)，一个称为右孩子节点（right child）,这两个孩子节点的顺序是固定的，不能够颠倒。 二叉树还有两种特殊的形式，一个叫作满二叉树，一个叫完全二叉树。 满二叉树是一个二叉树的所有非叶子节点都存在左右节点，并且所有叶子节点都在同一层级上，那么这个树就是满二叉树。也就是说满二叉树的每个分支都是满的。 完全二叉树对一个有n个节点的二叉树，按层级顺序编号，则所有节点的编号为从1到n。如果这个树所有节点和同样深度的满二叉树的编号为从1到n的节点位置相同，则这个二叉树为完全二叉树。 二叉树的物理存储结构 链式存储结构 链式存储结构的二叉树每个节点包含3部分：存储数据的data变量、指向左孩子的left指针、指向右孩子的right指针。 数组 使用数组存储，会按照层级顺序把二叉树的节点放到数组中对应的位置上。如果某个节点的左孩子或右孩子，则数组的相应位置也空出来。这样就可以更方便地在数组中定位二叉树的孩子节点和父节点。 假设一个父节点的下标是parent，那么它的左孩子的节点下标就是：leftchild=2*parent+1；右孩子节点下标就是：rightchild=2*parent+2。 二叉树的应用 查找 将二叉树用作查找，有一种特殊的二叉树：二叉查找树（binary search tree）这种二叉树主要作用就是进行查找操作。 二叉查找树在二叉树的基础上增加了一下几个条件： 如果左子树不为空，则左子树上所有节点的值均小于根节点的值。 如果右子树不为空，则右子树上所有节点的值均大于根节点的值。 左，右子树也都是二叉查找树。 对于一个节点分布相对均衡的二叉查找树来说，如果节点总数是n，那么搜索节点的时间复杂度就是O(logn)，和树的深度一样。 维持相对顺序 二叉查找树要求左子树小于父节点，右子树大于父节点，这样就保证了二叉树的有序性。所有二叉树查找树还有一个名字——二叉排序树 二叉树遍历从宏观的角度看，二叉树的遍历分为两大类： 深度优先遍历（前序遍历、中序遍历、后序遍历）。 二叉树的遍历方式：二叉树的遍历有4种 前序遍历 二叉树的前序遍历，输出的顺序是根节点、左子树、右子树。 中序遍历 二叉树的中序遍历，输出的顺序是左子树、根节点、右子树。 后序遍历 二叉树的后序遍历，输出的顺序是左子树、右子树、根节点。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283 import java.util.LinkedList; import java.util.Arrays;import java.util.Stack; public class BinaryTree&#123; public static TreeNode createBinaryTree(LinkedList&lt;Integer&gt; inputList)&#123; TreeNode node = null; if(inputList == null || inputList.isEmpty())&#123; return null; &#125; Integer data = inputList.removeFirst(); if(data != null)&#123; node = new TreeNode(data); node.leftchild = createBinaryTree(inputList); node.rightchild = createBinaryTree(inputList); &#125; return node; &#125; /** 二叉树遍历 */ /**前序遍历 */ public static void preOrderTraverla(TreeNode node)&#123; if(node == null)&#123; return; &#125; System.out.println(node.data); preOrderTraverla(node.leftchild); preOrderTraverla(node.rightchild); &#125; /**中序遍历 */ public static void inOrderTraveral(TreeNode node)&#123; if(node == null)&#123; return; &#125; inOrderTraveral(node.leftchild); System.out.println(node.data); inOrderTraveral(node.rightchild); &#125; /**后序遍历 */ public static void postOrderTraveral(TreeNode node)&#123; if(node == null)&#123; return; &#125; postOrderTraveral(node.leftchild); postOrderTraveral(node.rightchild); System.out.println(node.data); &#125; // 树节点 private static class TreeNode&#123; int data; TreeNode leftchild; TreeNode rightchild; TreeNode(int data)&#123; this.data = data; &#125; &#125; // 利用栈来实现前序遍历 public static void preOrderTraverlaWithStack(TreeNode node)&#123; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode treeNode = node; while(treeNode != null || !stack.isEmpty())&#123; // 迭代访问节点的左孩子，并入栈 while(treeNode != null)&#123; System.out.println(treeNode.data); stack.push(treeNode); treeNode = treeNode.leftchild; &#125; // 如果节点没有左孩纸，这弹出栈顶节点，访问节点右孩子 if(!stack.isEmpty())&#123; treeNode = stack.pop(); treeNode = treeNode.rightchild; &#125; &#125; &#125; public static void main(String[]args)&#123; LinkedList&lt;Integer&gt; list = new LinkedList&lt;&gt;(Arrays.asList(new Integer[]&#123;32,null,null,10,null,null,8,null,4&#125;)); TreeNode tree = createBinaryTree(list); System.out.println(\"前序遍历(栈实现)\"); // preOrderTraverla(tree); preOrderTraverlaWithStack(tree); &#125; &#125; 广度优先遍历（层序遍历）。 层序遍历 层序遍历就是按照二叉树从根节点到叶子节点的层次关系，一层一层横向遍历的各个节点。 代码实现1234567891011121314public static void levelOrderTraversal(TreeNode root)&#123; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); while(!queue.isEmpty())&#123; TreeNode node = queue.poll(); System.out.println(node.data); if(node.leftchild != null)&#123; queue.offer(node.leftchild); &#125; if(node.rightchild!= null)&#123; queue.offer(node.rightchild); &#125; &#125; &#125;二叉堆二叉堆本质上就是一种完全二叉树，分为最大堆和最小堆两类。最大堆的任何一个父节点的值都大于或等于它左右孩子节点的值。最小堆的任何一个父节点的值都小于或等于它左右孩子节点的值。二叉堆的根节点叫作堆顶。最大堆的堆顶是整个堆中的最大的元素；最小堆的堆顶是整个堆中的最小元素。 二叉堆的特性 最大堆的堆顶是整个堆中的最大元素。 最小堆的堆顶是整个堆中的最小元素。 二叉堆的自我调整 插入元素 当二叉堆插入节点时，插入位置是完全二叉树的最后一个位置。 删除元素 二叉堆删除的节点是删除处于堆顶的节点。 构建二叉堆 构建二叉堆，就是把一个无序的完全二叉树调整为二叉堆，本质是让所有非叶子节点依次 “下沉” 堆的插入、删除、构建操作的时间复杂度： 堆的插入操作是单一节点的“上浮”，堆的删除操作是单一节点的“下沉”，两个操作是的平均交换次数都是堆高度的一半，时间复杂度是O(logn)，堆的构建，需要所有非叶子节点依次“下沉”，时间复杂度是O(n) 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import java.util.Arrays;public class MyHeap&#123; // “上浮”调整 public static void upAdjust(int [] arr)&#123; // 假设找出最后一个元素节点(也就是叶子节点)。用于推导出其父节点 int childIndex = arr.length-1; // 根据左孩子节点（叶子节点）算出父节点。 int parentIndex = (childIndex-1)/2; // 设置临时节点，用于保存插入叶子节点值，用于最后的赋值 int temp = arr[childIndex]; while(childIndex &gt; 0 &amp;&amp; temp &lt; arr[parentIndex])&#123; arr[childIndex] = arr[parentIndex]; childIndex = parentIndex; parentIndex = (parentIndex-1)/2; &#125; arr[childIndex] = temp; &#125; public static void downAdjust(int[] array,int parentIndex,int length)&#123; // 用于保存父节点的值，最后赋值 int temp = array[parentIndex]; int childIndex = (2*parentIndex)+1; while(childIndex &lt; length)&#123; // 如果有右孩子，且右孩子小于左孩子的值，则定位到右孩子 if(childIndex+1 &lt; length &amp;&amp; array[childIndex+1] &lt; array[childIndex])&#123; childIndex++; &#125; // 如果父节点小于任何一个孩子的值，直接跳出 if(temp &lt;= array[childIndex])&#123; break; &#125; array[parentIndex] = array[childIndex]; parentIndex = childIndex; childIndex = (2*childIndex)+1; &#125; array[parentIndex] = temp; &#125; public static void buildHeap(int[]array)&#123; // 从最后一个非叶子节点开始，依次做“下沉”调整 for(int i = (array.length-2)/2;i&gt;=0;i--)&#123; downAdjust(array,i,array.length); &#125; &#125; public static void main(String[] args)&#123; int[] array = new int[]&#123;1,3,2,6,5,7,8,9,10,0&#125;; upAdjust(array); System.out.println(Arrays.toString(array)); array = new int[]&#123;7,1,3,10,5,2,8,9,6,0&#125;; buildHeap(array); System.out.println(Arrays.toString(array)); &#125;&#125; 优先队列优先队列是基于二叉堆来实现的，优先队列不再遵循先进先出原则，而是分为两种情况： 最大优先队列，无论入队顺序如何，都是当前最大的元素优先出队 最小优先队列，无论入队顺序如何，都是当前最小的元素优先出队 优先队列的实现回顾二叉堆的特性可以知道：最大堆的堆顶是整个堆中的最大元素。最小堆的堆顶是整个堆中的最小元素。因此，可以使用最大堆来实现最大优先队列，每一次入队操作都是堆的插入操作，每一次出队操作都是删除堆顶节点。优先队列入队和出队的时间复杂度都是O(logn)。 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576import java.util.Arrays;public class MyPriorityQueue&#123; private int[] array; private int size; public MyPriorityQueue()&#123; // 队列的初始长度是32 array = new int[32]; &#125; // 入队 public void enQueue(int key)&#123; if(size &gt;= array.length)&#123; resize(); &#125; array[size++] = key; upAdjust(); &#125; public int deQueue()throws Exception&#123; if(size &lt;= 0)&#123; throw new Exception(\"这个队列为空\"); &#125; // 堆顶元素 int head = array[0]; // 让最后一个元素移动到堆顶 array[0] = array[--size]; downAdjust(); return head; &#125; // 上浮 private void upAdjust()&#123; int childIndex = size-1; int parentIndex = (childIndex-1)/2; int temp = array[childIndex]; while(childIndex &gt; 0 &amp;&amp; temp &gt; array[parentIndex])&#123; array[childIndex] = array[parentIndex]; childIndex = parentIndex; parentIndex = parentIndex/2; &#125; array[childIndex] = temp; &#125; // 下沉 private void downAdjust()&#123; // temp保存父节点的值，用于最后的赋值 int parentIndex = 0; int temp = array[parentIndex]; int childIndex = 1; while(childIndex &lt; size)&#123; // 如果有右孩子，且右孩子大于左孩子的值，则定位到右孩子 if(childIndex+1 &lt; size &amp;&amp; array[childIndex+1] &gt; array[childIndex])&#123; childIndex++; &#125; if(temp &gt; array[childIndex])&#123; break; &#125; array[parentIndex] = array[childIndex]; parentIndex = childIndex; childIndex = 2*childIndex+1; &#125; array[parentIndex] = temp; &#125; private void resize()&#123; int newSize = this.size*2; this.array = Arrays.copyOf(this.array,newSize); &#125; public static void main(String[] args)throws Exception&#123; MyPriorityQueue priorityQueue = new MyPriorityQueue(); priorityQueue.enQueue(3); priorityQueue.enQueue(5); priorityQueue.enQueue(10); priorityQueue.enQueue(2); priorityQueue.enQueue(7); System.out.println(\"出队元素：\"+priorityQueue.deQueue()); System.out.println(\"出队元素：\"+priorityQueue.deQueue()); &#125;&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"Git快速入门","slug":"git/Git快速入门","date":"2020-02-15T09:56:07.000Z","updated":"2020-03-27T10:35:41.420Z","comments":true,"path":"2020/02/15/git/Git快速入门/","link":"","permalink":"http://yoursite.com/2020/02/15/git/Git%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/","excerpt":"","text":"Git安装(Windowns系统为例) 下载Git软件: 点击链接:https://git-scm.com/ 双击！ 一路Next！ 1 Git命令行git简单易用，只要在终端输入$ Git，Git就会不带任何参数输出它的选项和常用的子命令。 12345678910$ git#输入git后会输出一下选项，如果要得到一个完整的git子命令列表，可以输入 git help --allusage: git [--version] [--help] [-C &lt;path&gt;] [-c &lt;name&gt;=&lt;value&gt;] [--exec-path[=&lt;path&gt;]] [--html-path] [--man-path] [--info-path] [-p | --paginate | -P | --no-pager] [--no-replace-objects] [--bare]····················collaborate (see also: git help workflows) fetch Download objects and refs from another repository pull Fetch from and integrate with another repository or a local branch push Update remote refs along with associated objects ..... 2 Git使用快速入门 2.1创建初始版本库首先在git终端下创建一个空文件夹: 1234567#创建空文件夹 test/$ mkdir -p test/#进入到test文件夹$ cd test/#执行git init命令$ git initInitialized empty Git repository in /root/test/.git/ Git不会关心文件夹里是否为空，执行git init 命令创建了一个隐藏目录，在项目目录的顶层有个名为 .git文件夹，Git把所有修订的信息都放在这唯一的顶层目录里 2.2 将文件添加到版本库中执行 git init 命令时，Git版本库都是空的，为了管理内容，需要明确的把内容放入版本库中。 使用 git add file[^1] 将file添加到版本库中。 例如: 在 test目录中创建一个文件index.html并把该文件添加到版本库中 123$ cd test/$ touch index.html$ git add index.html [^1 ]: 如果目录中已经有很多的文件，使用git add .命令让Git把当前的目录及子目录中的文件都添加到版本库中 运行git status 命令显示中间状态的index.html 12$ git status # 这个命令显示新文件index.html将在下次提交时添加到版本库中 1 2.3 版本库内文件的删除和重命名 文件删除执行命令 git rm可以删除版本库里不需要的文件 操作如下: 123# 查看版本库中的文件$ git ls-filesindex.html 执行git rm index.html即可删除版本库中的index.html文件$ git rm index.html 12345678910111213141516 - ##### 文件重命名 在终端执行``git mv srcfile targetfile``即可以完成文件的重命名 例如： ```shell # 先查看版本库中的文件 $ git ls-files index.html # 执行git mv index.html foo.html 将index.html修改为foo.html $ git mv index.html foo.html # 再次查看版本库文件 $ git ls-files foo.html ​","categories":[{"name":"版本控制管理","slug":"版本控制管理","permalink":"http://yoursite.com/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%AE%A1%E7%90%86/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"Git提交","slug":"git/Git提交","date":"2020-02-15T08:54:50.000Z","updated":"2020-03-27T10:35:07.010Z","comments":true,"path":"2020/02/15/git/Git提交/","link":"","permalink":"http://yoursite.com/2020/02/15/git/Git%E6%8F%90%E4%BA%A4/","excerpt":"","text":"吧啦吧啦乱七八遭的东西在Git中，提交（commit）是用来记录版本库的变更的。当提交时，Git记录索引的快照并把快照放进对象库（简单的介绍）。提交的快照是串联在一起的，每张新的快照指向它的先驱。随着时间的推移，一系列的变更就表示一系列的提交。 Git提供一种机制来确定相对于另一个引用的提交，通常是分支的头。 在某些Git应用场景中，可能见过诸如这样的提交形式 master^ 。 在同一代提交中，插入符号 ^ 是用来选择不同的父提交。给定一个提交C，C^1 是其第一个父提交，C^2 是其第二个父提交，等等，如图: 通过把引用与^ 和 ~ 组合，就可从引用的提交历史图中选出任意提交 提交历史记录 查看旧提交 显示提交历史记录的主要命令是 git log,在参数形式上，git log跟git log HEAD是一样的，输出每一个可从HEAD找到的历史记录中的提交日志信息。变更从HEAD提交开始显示，并从提交图中回溯。如果使用git log 时提供一个提交名，那么这个日志将从该提交开始回溯输出。例如:git log master","categories":[{"name":"版本控制管理","slug":"版本控制管理","permalink":"http://yoursite.com/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%AE%A1%E7%90%86/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"关于Git文件管理","slug":"git/关于Git文件管理","date":"2020-02-12T11:25:36.000Z","updated":"2020-03-27T10:35:50.019Z","comments":true,"path":"2020/02/12/git/关于Git文件管理/","link":"","permalink":"http://yoursite.com/2020/02/12/git/%E5%85%B3%E4%BA%8EGit%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/","excerpt":"","text":"git中的文件分类​ Git将所有文件分为3类：已追踪的、被忽略的以及未追踪的 已追踪的 已追踪的文件是指已经在版本库中的文件，或者是已暂存到索引中的文件。如果想将新文件newfile添加到已追踪的文件，执行 git add newfile即可 被忽略的 被忽略的文件必须在版本库中明确声明为不可见或被忽略，即使他可能会在工作目录中出现。一个软件项目通常都会有很多被忽略的文件。普通被忽略的文件包括临时文件、个人笔记、编译器输出文件以及构建过程中自动生成的大多数文件。Git维护一个默认的忽略文件列表，也可以配置版本库来识别其他文件。被忽略的文件会在后面介绍。 未追踪的 未追踪的文件是指那些不在版本库中的文件。 下面举一个栗子: 1234567891011121314151617181920$ git init#查看状态$ git status# On branch master## Initial commit#nothing to commit (create/copy files and use \"git add\" to track)#添加一个文件$ echo \"new Data\" &gt;&gt; data# On branch master## Initial commit## Untracked files:# (use \"git add &lt;file&gt;...\" to include in what will be committed)## datanothing added to commit but untracked files present (use \"git add\" to track) 为了让Git忽略目录中的文件，只需将该文件名添加到一个特殊的文件.gitignore中就可以了。 123456789101112131415161718192021222324252627$ touch main.o$ git status# On branch master## Initial commit## Untracked files:# (use \"git add &lt;file&gt;...\" to include in what will be committed)## data# main.onothing added to commit but untracked files present (use \"git add\" to track)#将 main.o添加到.gitignore中$ echo main.o &gt;&gt; .gitignore$ git status# On branch master## Initial commit## Untracked files:# (use \"git add &lt;file&gt;...\" to include in what will be committed)## .gitignore# datanothing added to commit but untracked files present (use \"git add\" to track) 这样main.o就已经被忽略了，但是git status现在显示一个新的未追踪的文件 .gitignore。 使用 git addgit add 命令将暂存一个文件。就Git文件分类而言，如果一个文件是未追踪的，那么git add就会将文件的状态转化为已追踪的。如果git add作用于一个目录名，那么该目录下的文件以及子目录都会递归暂存起来。 这里还接着上面的栗子: 123456789101112131415161718192021$ git status# On branch master## Initial commit## Untracked files:# (use \"git add &lt;file&gt;...\" to include in what will be committed)## .gitignore# datanothing added to commit but untracked files present (use \"git add\" to track)# 将data、.gitignore两个文件添加至已追踪的分类$ git add data .gitignore$ git status# On branch master# Initial commit# Changes to be committed:# (use \"git rm --cached &lt;file&gt;...\" to unstage)# new file: .gitignore# new file: data 在上面的栗子中使用git add后，暂存和追踪data和.gitignore文件，并准备下次提交是时添加到版本库中。 可以使用git ls-files命令查看隐藏在对象模型下的东西。 123$ git ls-files.gitignoredata 在任何编辑之后，提交变更之前，请执行一次git add命令。 使用 git commit使用 git commit –allgit commit 的 -a或者 --all选项会导致执行提交之前自动暂存所有未暂存的和未追踪的文件变化，包括从工作副本中删除已追踪的文件 下面举个栗子: 12345678910111213$ pwd/tmp/commit-all-example#创建测试版本库$ git initInitialized empty Git repository in /tmp/commit-all-example/.git/$ echo \"Testfile1\" &gt;&gt; ready$ echo \"Testfile2\" &gt;&gt; notyet$ git add ready notyet$ git commit -m \"Setup\"[master (root-commit) 2b00dbf] Setup 2 files changed, 2 insertions(+) create mode 100644 notyet create mode 100644 ready 之后再次编辑ready文件，并用 git add把它添加到版本库中。然后编辑notyet文件保持它是未暂存的。 在一个子目录下添加一个文件，但是不要对它执行git add命令 12$ mkdir subdir$ echo \"Nope\" &gt;&gt; subdir/new 当执行 git commit --all命令，Git会递归遍历整个版本库，暂存所有先前通过git add提交的已知的和修改的文件，然后提交它们，由于subdir/ 一个全新的目录，而且目录下没有任何文件名或路径通过git add和git commit进行操作的， So 即使是 –all选项也不能将其提交。 关于提交日志消息​ 如果不通过命令行直接提供日志消息（例如:git commit -m &quot;提交日志消息&quot;），Git会启动编辑器，并提示你写一个提交日志。 使用 git rm 命令​ git rm命令会在版本库中和目录中同时删除文件。 接着上面的栗子: 这里“意外”的添加了一个文件 1234$ echo \"Random\" &gt; oops#当执行git rm oops时，提示删除失败$ git rm oopsfatal: pathspec 'oops' did not match any files ​ 为什么会这样，可以通过git ls-files命令查看版本库中的文件 123$ git ls-filesnotyetready 现在的版本库中没有oops这个文件，可通过git add oops命令将 oops文件加入到版本库中。 12345$ git add oops$ git ls-filesnotyetoopsready 另外，要将一个文件由已暂存的转化为未暂存的,可以使用git rm --cached命令 比如要删除oops 12$ git rm --cached oopsrm 'oops' git rm --cached会删除索引中的文件并它文件保留在工作目录中，而git rm则会将文件从索引和工作目录中都删除。 如果想要删除一个已经提交的文件，通过简单的git rm filename命令来暂存这一请求 还可以使用 git rm -f来强制删除文件。 如果想保留的文件不小心删除了，可以通过版本控制系统的恢复功能进行恢复 具体的命令如下: 123# 加入不小心删除了oops文件# 可以是下面的命令进行恢复git checkout HEAD -- oops 使用 git mv如果想要给一个文件重命名可以使用git mv srcfile newfile，git mv 命令会将 srcfile文件的文件名称改为newfiles，Git会在索引中删除srcfile文件的路径名，并添加newfile的路径名，至于srcfile文件里的内容，Git仍然会保存在对象库中，然后才会将它与newfile重新关联。git mv 还可以移动一个文件到一个目录中：git mv srcfile dir/ .gitignore 文件在前面简单介绍过.gitignore文件的作用。可以通过.gitignore文件来忽略不相干的文件。Git还支持一种更丰富的机制，一个.gitignore文件下可以包含一个文件名模式列表，指定哪些文件需要忽略。.gitignore 文件的格式如下。 空行会被忽略，而以（#）号开头的行可以用于注释。然而，如果#跟在其他文本后面，它就不代表注释了。 一个简单的字面置文件名匹配任何目录中的同名文件。 目录名由末尾的（/）标记。这能匹配同名的目录和子目录，但不匹配文件或符号链接。 包含shell通配符，如（*）号，这种模式可扩展为shell通配模式。正如标准shell通配符一样，因为不能跨目录匹配，所以一个 * 只能匹配一个文件或目录名。 起始的 ！号会对该行其余部分的模式进行取反。","categories":[{"name":"版本控制管理","slug":"版本控制管理","permalink":"http://yoursite.com/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%AE%A1%E7%90%86/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"Java内部类","slug":"java/java基础/【8】Java内部类","date":"2019-12-25T14:12:02.000Z","updated":"2021-01-18T03:52:34.939Z","comments":true,"path":"2019/12/25/java/java基础/【8】Java内部类/","link":"","permalink":"http://yoursite.com/2019/12/25/java/java%E5%9F%BA%E7%A1%80/%E3%80%908%E3%80%91Java%E5%86%85%E9%83%A8%E7%B1%BB/","excerpt":"","text":"创建内部类创建内部类就是在把类的定义置于外围类的里面。 123456789101112131415161718192021222324252627282930package out;public class Parcel1&#123; class Contents&#123; private int i = 11; public int value()&#123; return i; &#125; &#125; class Destination&#123; private String label; public Destination(String whereTo)&#123; label = whereTo; &#125; public String readLable()&#123; return label; &#125; &#125; public void ship(String dest)&#123; Contents c = new Contents(); Destination d = new Destination(dest); System.out.println(d.readLable()); &#125; public static void main(String[]args)&#123; Parcel1 p = new Parcel1(); p.ship(\"Tasmania\"); &#125;&#125;/*Tasmania*/ 如果想从外部类的静态方法之外的任意位置创建某个内部类的对象，那么必须具体地指明这个对象的类型：OuterClassName.InnerClassName 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package out;public class Parcel2&#123; class Contents&#123; private int i = 11; public int value()&#123; return i; &#125; public String toString()&#123; return \"Contents：\"+i; &#125; &#125; class Destination&#123; private String label; public Destination(String whereTo)&#123; label = whereTo; &#125; public String readLable()&#123; return label; &#125; public String toString()&#123; return \"Destination：\"+label; &#125; &#125; public Destination to(String s)&#123; return new Destination(s); &#125; public Contents contents()&#123; return new Contents(); &#125; public void ship(String dest)&#123; Contents c = new Contents(); // System.out.println(c); Destination d = to(dest); // System.out.println(d); System.out.println(d.readLable()); &#125; public static void main(String[]args)&#123; Parcel2 p = new Parcel2(); p.ship(\"Tasmania\"); Parcel2 q = new Parcel2(); Parcel2.Contents c = q.contents(); System.out.println(c); Parcel2.Destination d = q.to(\"TOOOOOOOOOO\"); System.out.println(d); &#125;&#125;/*TasmaniaContents：11Destination：TOOOOOOOOOO*/ 链接到外部类当生成一个内部类的对象时，此对象与制造它的外围对象之间就有了一种联系，所以它能访问其外围对象的所有成员，而不需任何特殊条件。此外，内部类还拥有其外围类的所有元素访问权。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package out;interface Selector&#123; boolean end(); Object current(); void next();&#125;public class Sequence&#123; private Object[]items; private int next=0; public Sequence(int size)&#123; items = new Object[size]; &#125; public void add(Object x)&#123; if(next &lt; items.length)&#123; items[next++] = x; &#125; &#125; private class SequenceSelector implements Selector&#123; private int i = 0; public boolean end()&#123; return i == items.length; &#125; public Object current()&#123; return items[i]; &#125; public void next()&#123; if(i &lt; items.length)&#123; i++; &#125; &#125; &#125; public Selector selector()&#123; return new SequenceSelector(); &#125; public static void main(String[]args)&#123; Sequence sequence = new Sequence(10); for(int i = 0;i&lt;10;i++)&#123; sequence.add(Integer.toString(i)); &#125; Selector s = sequence.selector(); while(!s.end())&#123; System.out.println(s.current()+\" \"); s.next(); &#125; &#125;&#125;/*0123456789*/ 使用.this和.new如果需要生成外部类对象的引用，可以使用外部类的名字后面紧跟.this。这样产生的引用自动的具有正确的类型。 12345678910111213141516171819202122package out;public class Dotthis&#123; public void f()&#123; System.out.println(\"Dotthis.f()\"); &#125; public class Inner&#123; public Dotthis outer()&#123; return Dotthis.this; &#125; &#125; public Inner inner()&#123; return new Inner(); &#125; public static void main(String[]args)&#123; Dotthis dt = new Dotthis(); Dotthis.Inner dti = dt.inner(); dti.outer().f(); &#125;&#125;/*Dotthis.f()*/ 有时可能需要告知某些对象，去创建其某个内部类的对象。要实现这个目的，必须使用new表达式中提供对其他外部类对象的引用，这里使用.new语法： 12345678910111213141516171819package out;public class DotNew&#123; public class Inner&#123; public Inner()&#123; System.out.println(\"Inner()\"); &#125; &#125; public DotNew()&#123; System.out.println(\"DotNew()\"); &#125; public static void main(String[]args)&#123; DotNew dn = new DotNew(); DotNew.Inner dni = dn.new Inner(); &#125;&#125;/*DotNew()Inner()*/ 在拥有外部类对象之前是不能创建内部类对象的。这是因为内部类对象会暗自连接到创建它的外部类对象上，但是，如果创建的嵌套类（静态内部类），那么它就不需要对其外部类对象的引用。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package out;public class Parcel3&#123; class Contents&#123; private int i = 11; public int value()&#123; return i; &#125; public String toString()&#123; return \"Contents：\"+i; &#125; &#125; class Destination&#123; private String label; public Destination(String whereTo)&#123; label = whereTo; &#125; public String readLable()&#123; return label; &#125; public String toString()&#123; return \"Destination：\"+label; &#125; &#125; public Destination to(String s)&#123; return new Destination(s); &#125; public Contents contents()&#123; return new Contents(); &#125; public void ship(String dest)&#123; Contents c = new Contents(); System.out.println(c); Destination d = to(dest); System.out.println(d); System.out.println(d.readLable()); &#125; public static void main(String[]args)&#123; Parcel3 p = new Parcel3(); p.ship(\"Tasmania\"); Parcel3.Contents c = p.new Contents(); System.out.println(c); Parcel3.Destination d = p.new Destination(\"TOOOOOOOOOO\"); System.out.println(d); &#125;&#125;/*Contents：11Destination：TasmaniaTasmaniaContents：11Destination：TOOOOOOOOOO*/ 匿名内部类先来看一段代码： 12345678910package out;public class Content&#123; private int i; public Content(int i)&#123; this.i = i; &#125; public int value()&#123; return i; &#125;&#125; 1234567891011121314151617package out;public class Parce7b&#123; public Content content(int x)&#123; return new Content(x)&#123; public int value()&#123; return super.value()*47; &#125; &#125;; &#125; public static void main(String[]args)&#123; Parce7b p = new Parce7b(); Content c = p.content(10); &#125;&#125;/**/ 在匿名内部类中，使用了默认的构造器来生成Content。如果基类中需要一个有参数的构造器，那么需要","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"java基础编程","slug":"java基础编程","permalink":"http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/"}]},{"title":"Java抽象类和接口","slug":"java/java基础/【7】Java接口","date":"2019-12-23T14:12:02.000Z","updated":"2021-01-18T00:42:49.044Z","comments":true,"path":"2019/12/23/java/java基础/【7】Java接口/","link":"","permalink":"http://yoursite.com/2019/12/23/java/java%E5%9F%BA%E7%A1%80/%E3%80%907%E3%80%91Java%E6%8E%A5%E5%8F%A3/","excerpt":"","text":"抽象类和抽象方法使用abstract关键字来创建抽象类和抽象方法，其语法如下： 123abstract class Test&#123; abstract void f();&#125; 通过创建抽象类是希望通过这个通用接口操纵一系列类，不同的子类可以用不同的方式表示此抽象类。抽象类建立起了一种基本形式，以此表示所有导出类的共同部分。 Java还提供了一个叫抽象方法的机制，这种方法是不完整的，仅有声明而没有方法体。包含抽象方法的类称之为抽象类，如果一个类包含一个或多个抽象方法，那么该类必须被限定为抽象的。由于为抽象类创建对象是不安全的，所以在创建抽象对象时，编译器会报错。这样就保证了抽象类的纯粹性。 如果从一个抽象类继承，并想创建新类的对象，那么就必须为基类的所有方法提供方法定义。如果不这样做，那么导出类便也是抽象类，且编译器会强制我们用abstract关键字类限定这个类。 抽象类的并不需要所有的方法都是抽象的，所以仅需将某些方法声明为抽象的即可 12345678910111213141516171819202122232425262728293031323334353637package interfaces;abstract class Instrument&#123; private int i; public abstract void play(String n); public String what()&#123; return \"Instrument\"; &#125; public abstract void adjust();&#125;class Wind extends Instrument&#123; public void play(String s)&#123; System.out.println(\"Wind.play()\"); &#125; public String what()&#123; return \"Wind\"; &#125; public void adjust()&#123; System.out.println(\"Wind.adjust()\"); &#125;&#125;public class Music4&#123; static void tune(Instrument i,String s)&#123; i.play(s); &#125; static void tuneAll(Instrument[]e)&#123; for(Instrument i:e)&#123; tune(i,\"tune\"); &#125; &#125; public static void main(String[]args)&#123; Instrument i = new Wind(); tune(i,\"gogo\"); &#125;&#125;/*Wind.play()*/ 创建抽象类和抽象方法非常有用，因为它们可以使类的抽象性明确起来，并告诉用户和编译器打算怎样来使用它们。抽象类还是很有用的重构工具，因为它们可以很容易地将公共方法沿着继承层次结构向上移动。 接口interface关键字使抽象的概念更进一步，interface关键字产生一个完完全全抽象的类，它根本就没有任何具体实现。只提供了形式，而未提供任何具体实现。 想要创建一个接口，需要用interface关键字来代替class关键字。可以在interface关键字前面添加public关键字，如果不添加public关键字，则它只具有包访问权限。接口也可以包含域，但这些域隐式地是static和final的。 某个类要实现一个接口，需要使用implements关键字来实现。 可以选择在接口中显式地将方法声明为public的，但即使不这么做，它们也是public的。当要实现一个接口时，在接口中被定义的方法必须被定义为public的；否则，它们将只得到默认的包访问权限，其可访问权限就被降低了。 接口中的域在接口中的任何域都自动是public、static和final的，所以接口就成为了一种便捷的创建常量组的工具。在接口中不能定义为“空final”，也就创建域的时候必须要初始化。 通过继承来扩展接口通过继承，可以很容易地在接口中添加新的方法声明，还可通过继承在新接口中组合数个接口 12345678910111213141516171819202122232425262728293031323334353637383940414243package out;interface Monster&#123; void menace();&#125;interface DangerMonster extends Monster&#123; void destroy();&#125;interface Lethal&#123; void kill();&#125;class DragonZilla implements DangerMonster&#123; public void menace()&#123;&#125; public void destroy()&#123;&#125;&#125;interface Vampire extends DangerMonster,Lethal&#123; void drinkBlood();&#125;class VeryBadVampire implements Vampire&#123; public void menace()&#123;&#125; public void destroy()&#123;&#125; public void kill()&#123;&#125; public void drinkBlood()&#123;&#125;&#125;public class HorrorShow&#123; static void u(Monster m)&#123;m.menace();&#125; static void v(DangerMonster d)&#123; d.menace(); d.destroy(); &#125; static void w(Lethal l)&#123; l.kill(); &#125; public static void main(String[]args)&#123; DangerMonster bancy = new DragonZilla(); u(bancy); v(bancy); Vampire va = new VeryBadVampire(); u(va); v(va); w(va); &#125;&#125;///~","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"java基础编程","slug":"java基础编程","permalink":"http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/"}]},{"title":"Java类的复用","slug":"java/java基础/【6】Java类的复用","date":"2019-12-21T04:32:12.000Z","updated":"2021-01-17T02:53:18.089Z","comments":true,"path":"2019/12/21/java/java基础/【6】Java类的复用/","link":"","permalink":"http://yoursite.com/2019/12/21/java/java%E5%9F%BA%E7%A1%80/%E3%80%906%E3%80%91Java%E7%B1%BB%E7%9A%84%E5%A4%8D%E7%94%A8/","excerpt":"","text":"继承语法继承可以说是所有面向对象编程语言中不可缺少的部分。在Java中，当创建一个类时，总是在继承，除非已明确的指出要从其他类中继承，否则就是在隐式地从Java的标准根类Object进行继承。使用继承时，在类名后面使用extends关键字来实现继承。 1234567891011121314151617181920212223242526272829303132333435363738394041package reusing;class Cleanser&#123; private String s = \"Cleanser\"; public void append(String i)&#123; s += i; &#125; public void dilute()&#123; append(\" dilute() \"); &#125; public void apply()&#123; append(\" apply() \"); &#125; public String toString()&#123; return s; &#125; public static void main(String[]args)&#123; Cleanser c = new Cleanser(); c.dilute(); c.apply(); System.out.println(c); &#125;&#125;public class Detergent extends Cleanser&#123; public void foam()&#123; append(\" foam() \"); &#125; public static void main(String[]args)&#123; Detergent d = new Detergent(); d.dilute(); d.apply(); d.foam(); System.out.println(d); System.out.println(\"Test base class\"); Cleanser.main(args); &#125;&#125;/*Cleanser dilute() apply() foam()Test base classCleanser dilute() apply()*/ 在继承的过程中，并不一定非得使用基类的方法。也可以是在导出类中添加新方法，其添加的方式与类中添加任意方法一样，即对其加以定义即可。 初始化基类初始化基类涉及到基类和导出类，从外部来看，导出类就像是一个与基类具有相同接口的新类。但继承并不只是复制基类的接口。当创建了一个导出类的对象时，该对象包含了一个基类的子对象。这个子对象与使用的基类直接创建的对象是一样的。二者的区别在于，导出类来自于外部，而基类的子对象被包装在导出类对象的内部。 123456789101112131415161718192021222324package reusing;class Art&#123; public Art()&#123; System.out.println(\"Atr Constrcutor\"); &#125;&#125;class Drawing extends Art&#123; public Drawing()&#123; System.out.println(\"Drawing Constrcutor\"); &#125;&#125;public class Cartoon extends Drawing&#123; public Cartoon()&#123; System.out.println(\"Cartoon Constrcutor\"); &#125; public static void main(String[]args)&#123; Cartoon cartoon = new Cartoon(); &#125;&#125;/*Atr ConstrcutorDrawing ConstrcutorCartoon Constrcutor*/ 在上述的代码中可发现，构建过程是从基类“向外”扩展的，所以基类在导出类构造器可以访问它之前就已经做完了初始化。即使不为导出类创建构造器。 带参数的构造器如果在使用继承时，基类中明确的创建了带有参数的构造器，就必须使用关键字super显式地编写调用基类构造器的语句，并且配以适当的参数列表。 12345678910111213141516171819package reusing;class Game&#123; public Game(int i)&#123; System.out.println(\"constructor Args：int i = \"+i); &#125;&#125;public class Chess extends Game&#123; public Chess()&#123; super(2); System.out.println(\"class Chess constructor\"); &#125; public static void main(String[]args)&#123; Chess c = new Chess(); &#125;&#125;/*class Game constructor Args：int i = 2class Chess constructor*/ 调用基类构造器必须是在导出类构造器中要做的第一件事。 名称屏蔽如果Java的基类拥有某个已被多次重载的方法名称，那么在导出类中重新定义该方法名称并不会屏蔽其在基类中任何重载方法的版本。因此，无论是在该层或者是在基类中对方法进行定义，重载机制都可以正常工作。看下代码： 1234567891011121314151617181920212223242526272829303132package reusing;class Homer&#123; public char doh(char c)&#123; System.out.println(\"doh(char): \"+c); return c; &#125; public float doh(float f)&#123; System.out.println(\"doh(float): \"+f); return f; &#125;&#125;class Milhouse&#123;&#125;class Bart extends Homer&#123; public void doh(Milhouse m)&#123; System.out.println(\"doh(Milhouse m)\"); &#125;&#125;public class Hide&#123; public static void main(String[]args)&#123; Bart b = new Bart(); b.doh(1); b.doh('x'); b.doh(1.0f); b.doh(new Milhouse()); &#125;&#125;/*doh(float): 1.0doh(char): xdoh(float): 1.0doh(Milhouse m)*/ 在JavaSE5中增加了@Override注解,当想要覆写某个方法时，可以选择添加这个注解，在不留意重载而并非覆写了该方法时，编译器会生成一条错误消息 向上转型在讲向上转型前先看一段代码 123456789101112131415161718package reusing;class Instrument&#123; public void play()&#123; System.out.println(\"play()\"); &#125; static void tune(Instrument i)&#123; i.play(); &#125;&#125;public class Wind extends Instrument&#123; public static void main(String[]args)&#123; Wind w = new Wind(); Instrument.tune(w); &#125;&#125;/*play()*/ 由于继承可以确保基类中所有的方法在导出类中也同样有效，所以能够向基类发送的所有信息同样也可以向导出类发送。如果Instrument类具有一个play()方法，那么Wind类也将同样具备。也就是说Wind对象也是一种类型的Instrument。 何为向上转型 来看一个UML图吧： 将根置于页面的顶端，然后逐渐向下。由导出类转型为基类，在继承图上是向上移动的，因此称为向上转型。由于向上转型是从一个较专用类型转向较通用类型的转换。所以总是很安全的，也就是说导出类是基类的超集。导出类可能比基类含有更多的方法，但它必须至少具备基类中所含的方法。在向上转型的过程中，类接口中唯一可能发生的就是丢失方法，而不是获取它们。 final关键字可能使用到final关键字的情况：数据、方法、类。 final数据许多编程语言中都会有某种方法，来向编译器告知一块数据是恒定不变的。比如： 一个恒定不变的编译时常量 一个在运行是被初始化，而不希望它被改变的 对于编译期常量的情况，编译器可以将该常量值代入任何用到它的计算中。在Java中，这类常量必须是基本数据类型，并且以关键字final表示，在对这个常量进行定义时，必须对其进行赋值。 一个既是static又是final的域只占据一段不能改变的存储空间。 对于基本类型使用final使数值恒定不变；而用于对象引用，final使引用恒定不变。一旦引用被初始化指向一个对象，就无法在把它指向另一个对象。然而，对象其自身却是可以被修改的，Java并未提供使任何对象恒定不变的途径。这也适用于数组。来看一段代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package reusing;import java.util.Random;class Value&#123; int i; public Value(int i)&#123; this.i = i; &#125;&#125;public class FinalData&#123; private static Random rand = new Random(47); private String id; public FinalData(String id)&#123; this.id = id; &#125; private final int ValueOne = 9; private static final int Value_Two = 99; private static final int Value_THERE = 39; private final int i4 = rand.nextInt(20); static final int INT_5 = rand.nextInt(20); private Value v1 = new Value(11); private final Value v2 = new Value(22); private static final Value VAL_3 = new Value(33); private final int[] a = &#123;1,2,3,4,5,6&#125;; public String toString()&#123; return id+\": \"+\"i4: \"+i4+\" INT_5: \"+INT_5; &#125; public static void main(String[]args)&#123; FinalData f1 = new FinalData(\"f1\"); f1.v2.i++; f1.v1 = new Value(9); for(int i = 0;i&lt;f1.a.length;i++)&#123; f1.a[i]++; &#125; System.out.println(f1); System.out.println(\"Create new FinalData\"); FinalData f2 = new FinalData(\"f2\"); System.out.println(f1); System.out.println(f2); &#125;&#125;/*f1: i4: 15 INT_5: 18Create new FinalDataf1: i4: 15 INT_5: 18f2: i4: 13 INT_5: 18*/ 空白finalJava允许生成一个“空白final”，空白final就是指被声明为final但有未给定初始值的域。无论什么情况，编译器都确保空白final在使用前必须被初始化。但是，空白final在关键final的使用上提供了更大的灵活性，因此，一个类中final域就可以做到根据对象而有所不同，却又保持器恒定不变的特性。 12345678910111213141516171819202122232425262728293031323334353637package reusing;class Poppet&#123; private int i; public Poppet(int i)&#123; this.i = i; &#125; public String toString()&#123; return \"i = \"+i; &#125;&#125;public class BlankFinal&#123; private final int i = 0; private final int j; private final Poppet p; public BlankFinal()&#123; j = 1; p = new Poppet(1); &#125; public BlankFinal(int x)&#123; j = x; p = new Poppet(x); &#125; public String toString()&#123; return \"i = \"+i+\" j = \"+j; &#125; public static void main(String[]aegs)&#123; BlankFinal b1 = new BlankFinal(); BlankFinal b2 = new BlankFinal(47); System.out.println(b1); System.out.println(b2); &#125;&#125;/*i = 0 j = 1i = 0 j = 47*/ 必须在域的定义处或者每个构造器中对final进行赋值，这正是final域在使用前总是被初始化的原因所在。 final参数Java允许在参数列表中以声明的方式将参数指明为final。这意味着无法在方法中更改参数引用所指向的对象。 final方法使用final方法的原因是把方法锁住，以防任何继承类修改它的含义。还有一个原因是考虑到效率，但是在最近的Java版本中，不再需要使用final方法来提升效率了。当只有在想要明确禁止覆盖时，才将方法设置为final。 final和private关键字类中的所有private方法隐式地指定为final的，由于无法取用private方法，所以也就无法覆盖它。可以对private方法添加final修饰词，但是这样做没有什么意义。 final类当将某个类的整体定义为final时，就表明了不打算继承该类。不希望该类有子类。 123456789101112131415161718package reusing;class SmallBrain&#123;&#125;final class Dinosaur&#123; int i = 7; int j = 1; SmallBrain sm = new SmallBrain(); public void f()&#123;&#125;&#125;public class Jurassic&#123; public static void main(String[]args)&#123; Dinosaur n = new Dinosaur(); n.f(); n.i = 40; n.j++; &#125;&#125;/**/ final域可以根据个人的意愿选择是或不是，不论类是否定义为final，同样的这也适用于final域。然而，由于final类禁止继承，所以final类中的所有方法都隐式的指定为final的，因为无法覆盖它们。","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"java基础编程","slug":"java基础编程","permalink":"http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/"}]},{"title":"Java访问权限控制","slug":"java/java基础/【5】Java访问权限控制","date":"2019-12-19T04:32:12.000Z","updated":"2021-01-15T13:53:46.892Z","comments":true,"path":"2019/12/19/java/java基础/【5】Java访问权限控制/","link":"","permalink":"http://yoursite.com/2019/12/19/java/java%E5%9F%BA%E7%A1%80/%E3%80%905%E3%80%91Java%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/","excerpt":"","text":"Java提供了访问权限修饰词，访问权限控制的等级，从最大到最小依次为：public、protected、包访问权限、private。Java使用关键字package来影响访问权限修饰词的使用。 在Java中提供了大量的标准类库，如果想要在自己定义的类文件中使用这些标准的类库，可以使用import关键字来导入想要使用的类库。例如： 123456789101112package access;import java.util.ArrayList;public class SingleImport&#123; public static void main(String[]args)&#123; ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(\"YangAY\"); System.out.println(list.toString()); &#125;&#125;/*[YangAY]*/ 上面的代码中import java.util.ArrayList;将java.util下的ArrayList类导入到类中来使用。 如果SingleImport.java的代码没有使用package来声明一个包，那么Java编译器就会自动将该类声明为默认包。 代码组织当编写一个Java源代码文件时，此代码源文件称为编译单元。每个编译单元都必须有一个后缀名.java，而在编译单元内则可以有一个public类，该类的名称必须和文件名相同，包括大小写（不包括后缀名.java），每个编译单元只能有一个public类，否则编译不通过。 当编译通过一个.java文件时，在.java文件中的每个类都会有一个输出文件，该输出文件的名称和.java文件名相同，只是后缀名为.class。 如果希望一些类从属于一个包中，可以使用package关键字指明，使用package语句，必须是在.java文件中的最开头中声明。在文件中写：package access;就表示在声明编译单元是名为access包的一部分。也就是讲声明的public类名称是位于access名称的包下。如果想要使用该类名称的必须在使用前结合import关键字指定包名.类名。来看一个例子： 123456package access.mypackage;//必须在代码的第一行public class MyClass&#123; public void f()&#123; System.out.println(\"ClassName:MyClass Method:f()\"); &#125;&#125; 12345678910package access;import access.mypackage.MyClass;//导入MyClass;包名.类名public class SingleImport&#123; public static void main(String[]args)&#123; new MyClass().f(); &#125;&#125;/*ClassName:MyClass Method:f()*/ 这个例子中，创建了两个.java文件：MyClass.java和SingleImport.java，在MyClass.java中package access.mypackage;将该编译单元放入ccess.mypackage包中。在SingleImport.java中使用import access.mypackage.MyClass;将access.mypackage.MyClass类导入到SingleImport类中，并调用MyClass中的f()方法。 下面来说说Java的访问权限修饰词 Java访问权限修饰词包访问权限如果不提供任何访问权限修饰词，称之为“包访问权限”；也叫默认访问权限，也就意味着在当前包中的所有其他类对于这个具有默认访问权限的类的成员都具有访问的权利，除非某些成员是使用private修饰的。包访问权限允许将包内的所有相关的类组合起来，以使它们彼此可以轻松的互相作用。 public访问权限使用关键public，就意味着public之后紧跟着的成员的声明自己对于每个人都是有用的。 private访问权限private关键字的意思是，除了包含该成员的类之外，其他任何类都无法访问这个成员。由于处于同一包内的其他类是不能访问private成员的，因此这等于是自己隔离了自己。为此private就允许你随意改变该成员，不需要去考虑这样做是否影响到包内的其他类。 protected访问权限关键字protected处理的是继承的概念，通过继承可以利用一个现有的基类。基类的创建者会希望有个特定的成员，把对它的访问权限赋予派生类而不是所有类。这就需要protected来完成这一工作。protected也提供包访问权限，相同包内的其他类可以访问protected元素。 类的访问权限为了控制某个类的访问权限，访问权限修饰符必须出现于关键字class之前。比如这样写： 1public class MyClass&#123;&#125; 类既不能是private，也不可是protected。对于类的访问权限，仅有两个选择：包访问权限或者是public，如果不希望其他人对该类拥有访问权限，可以将所有构造器都指定为private，从而阻止任何人创建该类对象，如果在该类的static成员内创建，那就另说了。","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"java基础编程","slug":"java基础编程","permalink":"http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/"}]},{"title":"Java类的初始化与清理","slug":"java/java基础/【4】Java类的初始化与清理","date":"2019-12-17T04:32:12.000Z","updated":"2021-01-11T14:18:37.477Z","comments":true,"path":"2019/12/17/java/java基础/【4】Java类的初始化与清理/","link":"","permalink":"http://yoursite.com/2019/12/17/java/java%E5%9F%BA%E7%A1%80/%E3%80%904%E3%80%91Java%E7%B1%BB%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E6%B8%85%E7%90%86/","excerpt":"","text":"在Java中，通过提供构造器，类的设计者可确保每个对象都会得到初始化。创建对象时，如果器类具有构造器，Java就会在用户操作对象之前自动调用相应的构造器，从而确保初始化化的进行。在Java中采取了构造器与类名相同的方案。 1234567891011121314151617package initialization;class Rock&#123; Rock()&#123; System.out.println(\"Rock\"); &#125; public Rock(int i)&#123; System.out.print(\"Rock \"+i+\" \"); &#125;&#125;public class SimpleConstructor&#123; public static void main(String[]args)&#123; Rock r = new Rock(); &#125;&#125;/*Rock*/ 在创建对象时：new Rock();将会为对象分配储存空间，并调用相应的构造器。 不接受任何参数的构造器称为默认构造器,也称为无参构造器，当然了，构造器也能带有形式参数，方便指定如何创建对象。有了构造器的形式参数，就可以在初始化对象过程中提供实际参数。 构造器是一种特殊类型的方法，因为构造器没有返回值，这个与普通方法中的返回值为空（void）不同，构造器不会返回任何东西。 方法重载构造器的名字已经由类名所决定，那就只能有一个构造器名，那想要多种方式创建一个对象怎么怎么办呢？解决方式就是使用方法重载 方法重载就是让方法名相同而形式参数不同，所以在创建构造器是可以使构造器名与类名一致，但是形式参数列表不同即可创建不同的构造器。 1234567891011121314151617181920212223242526272829303132package initialization;class Tree&#123; int h; public Tree()&#123; System.out.println(\"无参构造器\"); &#125; public Tree(int i)&#123; h = i; System.out.println(\"有参构造器\"); &#125; public void info()&#123; System.out.println(\"我叫杨阿阳\"); &#125; public void info(int age)&#123; System.out.println(\"我叫杨阿阳,今年\"+age+\"岁\"); &#125;&#125;public class Overloading&#123; public static void main(String[]args)&#123; // Tree t = new Tree(55); Tree t = new Tree(); t.info(); t.info(23); &#125;&#125;/*//有参构造器无参构造器我叫杨阿阳我叫杨阿阳,今年23岁*/ 区分重载方法 每个重载方法都有独一无二的参数类型列表。甚至参数顺序的不同也可以区分出两个方法。 默认构造器默认构造器也叫无参构造器，是没有形式参数的，它的作用是创建一个“默认对象”。如果在定义的类中没有定义构造器，那么编译器会自动创建一个默认构造器。来看一段代码： 1234567package initialization;class Bird&#123;&#125;public class DefaultConstructor&#123; public static void main(String[]args)&#123; Bird b = new Bird(); &#125;&#125; 上面的代码中创建了一个新对象：Bird b = new Bird();，并调用默认构造器——即使没有创建构造器。但是如果已经定义了一个构造器，编译器就不会帮你自动创建默认构造器。上面的代码再改改： 12345678910111213141516package initialization;class Bird&#123; public Bird(int i)&#123;&#125; public Bird(double d)&#123;&#125; &#125;public class DefaultConstructor&#123; public static void main(String[]args)&#123; Bird b = new Bird(2); /*如果你这样写 Bird b1 = new Bird(); 编译器就会报错 */ &#125;&#125; this关键字有时可能为一个类写了多个构造器，也有可能想在一个构造器中调用另一个构造器，以免代码重复。使用this关键字就可以做到这一点。 通常写this的时候，都是指“这个对象”或者“当前对象”，而且它本身表示对当前对象的引用。在构造器中，如果为this添加参数列表，那么就有了不同的含义。这将产生对符合此参数列表的某个构造器的明确调用；因此，调用其他构造器就有了直接的途径： 1234567891011121314151617181920212223242526272829303132333435package initialization;public class Flower&#123; int petCount = 0; String s = \"initial value\"; public Flower(int petal)&#123; petCount = petal; System.out.println(\"Constructor w/ petCount=\"+petCount); &#125; public Flower(String ss)&#123; System.out.println(\"Constructor w/ s=\"+ss); s = ss; &#125; public Flower(String s,int petals)&#123; this(petals); this.s = s; System.out.println(\"String &amp; int args\"); &#125; public Flower()&#123; this(\"hello\",23); System.out.println(\"default constructor\"); &#125; public void printPetalCount()&#123; System.out.println(\"petalCount = \"+petCount+\" s= \"+s); &#125; public static void main(String[]args)&#123; Flower f = new Flower(); f.printPetalCount(); &#125;&#125;/*Constructor w/ petCount=23String &amp; int argsdefault constructorpetalCount = 23 s= hello*/ 注意上面代码中public Flower(String s,int petals)的声明，尽管可以用this一个构造器，但却不能调用两个。另外，必须将构造器调用置于最起始处，否则编译器会报错。由于参数s的名称和数据成员s的名字相同，所以会产生歧义，使用this.s来代表数据成员就能解决歧义问题。 static关键字用static修饰的方法就没有this关键字。在static方法的内部不能调用非静态方法。而且可以在没有创建任何对象的情况下，仅仅通过类本身来调用static方法。这实际是static方法的主要用途。static方法很像全局方法，虽然Java中禁止使用全局方法，但在类中置入static方法就可以访问其他的static方法和static域。使用static方法时，由于不存在this，所以不是通过“向对象发送消息”的方式来进行的。 成员变量初始化Java尽力的保证所有的变量在使用前都能得到恰当的初始化。对于方法的局部变量，Java以编译时错误的形式来实现这个保证。比如下面的代码就是： 1234void f()&#123; int i; i++;//这是错误的，没有进行初始化&#125; 未初始化的局部变量更有可能是程序员的疏忽大意。所以采取默认值反而会掩盖这种失误。因此强制在编写程序时提供一个初始值，往往能够有助于找出代码中的缺陷。 要是类的数据字段基本类型，不初始化，貌似没有什么问题，因为每个基本类型数据成员保证都会有一个初始值。 比如下面的代码： 12345678910111213141516171819202122package initialization;public class InitialValues&#123; boolean b; int i; char c; long l; public void printlnInitValue()&#123; System.out.println(\"boolean defaultValue \"+b); System.out.println(\"int defaultValue \"+i); System.out.println(\"char defaultValue \"+c); System.out.println(\"long defaultValue \"+l); &#125; public static void main(String[]args)&#123; new InitialValues().printlnInitValue(); &#125;&#125;/*boolean defaultValue falseint defaultValue 0char defaultValuelong defaultValue 0*/ 构造器初始化使用构造器来进行初始化，在运行时，可以调用方法或者执行某些动作确定初始值，这给编程带来了很大的灵活性。 构造器初始化顺序在类的内部，变量定义的顺序的先后确定了初始化的顺序。即便变量的定义散布与方法定义之间，它们仍会在任何方法被调用之前得到初始化。例如： 1234567891011121314151617181920212223242526272829303132package initialization;class Window&#123; public Window(int marker)&#123; System.out.println(\"Window(\"+marker+\")\"); &#125;&#125;class House&#123; Window w1 = new Window(1); public House()&#123; System.out.println(\"House()\"); w3 = new Window(33); &#125; Window w2 = new Window(2); void show()&#123; System.out.println(\"show()\"); &#125; Window w3 = new Window(3);&#125;public class OrderOfInit&#123; public static void main(String[]args)&#123; House h = new House(); h.show(); &#125;&#125;/*Window(1)Window(2)Window(3)House()Window(33)show()*/ 静态数据域初始化static关键字不能应用于局部变量，因此它只能作用于域。如果一个域是静态的基本类型域，且没有对它进行初始化，那么它就会获得基本类型的标准初始值；如果它是一个对象引用，那么它的默认初始值就是null。想要了解静态域何时会初始化，可看看下面的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package initialization;class Bowl&#123; public Bowl(int marker)&#123; System.out.println(\"Bowl(\"+marker+\")\"); &#125; void fc1(int marker)&#123; System.out.println(\"fc1(\"+marker+\")\"); &#125;&#125;class Table&#123; static Bowl bowl1 = new Bowl(1); public Table()&#123; System.out.println(\"Table\"); bowl1.fc1(1); &#125; void fc2(int marker)&#123; System.out.println(\"fc2(\"+marker+\")\"); &#125; static Bowl bowl2 = new Bowl(2);&#125;class Cupbord&#123; Bowl bowl3 = new Bowl(3); static Bowl bowl4 = new Bowl(4); public Cupbord()&#123; System.out.println(\"Cupbord\"); bowl4.fc1(2); &#125; void fc3(int marker)&#123; System.out.println(\"fc3(\"+marker+\")\"); &#125; static Bowl Bowl5 = new Bowl(5);&#125;public class Staticinit&#123; public static void main(String[]args)&#123; System.out.println(\"Create new Cupbord() in main\"); new Cupbord(); System.out.println(\"Create new Cupbord() in main\"); new Cupbord(); table.fc2(1); cupbord.fc3(1); &#125; static Table table = new Table(); static Cupbord cupbord = new Cupbord();&#125;/*Bowl(1)Bowl(2)Tablefc1(1)Bowl(4)Bowl(5)Bowl(3)Cupbordfc1(2)Create new Cupbord() in mainBowl(3)Cupbordfc1(2)Create new Cupbord() in mainBowl(3)Cupbordfc1(2)fc2(1)fc3(1)*/ 【这段代码有点点不容易懂，以后慢慢看吧】 初始化的顺序是先初始化静态对象，而后是非静态对象 这里做一个小小的总结：这里假设用Test类； 即使没有显式的使用static关键字，构造器实际上也是静态方法。因此，当首次创建类型为Test的对象时，或者Test类的静态方法/静态域首次被访问时，Java解释器必须查找类路径，定位Test.class文件。 然后载入Test.class，有关静态初始化的所有动作都会执行，因此，静态初始化只在Class对象首次加载时进行一次。 当用new Test()创建对象的时候，首先将在堆上为Test对象分配足够的存储空间。 这块存储空间会被清零，这就自动的将Test对象中的所有基本类型数据都设置成了默认值，而引用则被设置成null。 执行所有出现于字段定义处的初始化动作。 执行构造器。 显式的静态初始化Java允许将多个静态初始化动作组成一个特殊的“静态子句”，例如下面的代码： 1234567package initialization;public class Spoon&#123; static int i; static&#123; i = 4; &#125;&#125; 上面的代码与其他静态初始化动作一样，这段代码仅执行一次：当首次生成这个类的一个对象时，或者首次访问属于那个类的静态数据成员时。例如下面的代码： 1234567891011121314151617181920212223242526272829303132333435package initialization;class Cup&#123; public Cup(int marke)&#123; System.out.println(\"Cup(\"+marke+\")\"); &#125; public void f(int marke)&#123; System.out.println(\"f(\"+marke+\")\"); &#125;&#125;class Cups&#123; static Cup cup1; static Cup cup2; static&#123; cup1 = new Cup(1); cup2 = new Cup(2); &#125; public Cups()&#123; System.out.println(\"Cups()\"); &#125;&#125;public class ExplicitStatic&#123; public static void main(String[]args)&#123; System.out.println(\"Inside main\"); Cups.cup1.f(9);//[1] &#125; //static Cups cups1 = new Cups();//[2] //static Cups cups2 = new Cups();//[2] &#125;/*Inside mainCup(1)Cup(2)f(9)*/ 无论是通过【1】的那行访问静态的cup1对象，还是把【1】处的代码注释掉，去运行【2】处的代码，Cups的静态初始化动作都会得到执行，如果都把【1】【2】同时注释掉，Cups的静态初始化就不会进行，此外，注释一行还是两行【2】处的代码都没有关系，因为静态初始化只进行一次。 非静态实例初始化Java中有被称为实例初始化的类似语法，用来初始化每个对象的非静态变量。实例初始化块是在构造器之前执行 例如： 1234567891011121314151617181920212223242526272829303132333435363738394041424344package initialization;class Mug&#123; public Mug(int mark)&#123; System.out.println(\"Mug(\"+mark+\")\"); &#125; public void f(int mark)&#123; System.out.println(\"f(\"+mark+\")\"); &#125;&#125;public class Mugs&#123; Mug mug1; Mug mug2; public Mugs()&#123; System.out.println(\"Mugs\"); &#125; &#123; mug1 = new Mug(1); mug2 = new Mug(2); System.out.println(\"mug1 &amp; mug2 init\"); &#125; public Mugs(int mark)&#123; System.out.println(\"Mugs(\"+mark+\")\"); &#125; public static void main(String[]args)&#123; System.out.println(\"Inside main\"); new Mugs(); System.out.println(\"new Mugs() completed\"); new Mugs(1); System.out.println(\"new Mugs(int) completed\"); &#125;&#125;/*Inside mainMug(1)Mug(2)mug1 &amp; mug2 initMugsnew Mugs() completedMug(1)Mug(2)mug1 &amp; mug2 initMugs(1)new Mugs(int) completed*/ 可变参数列表在方法的形式参数里使用...来表示可变参数列表 1234567891011121314151617181920212223242526package initialization;public class OptionalTrainlingArguments&#123; public static void fc(int i,String...argsnuments)&#123; System.out.println(\"i=\"+i+\" \"); for(String s:argsnuments)&#123; System.out.println(s+\" \"); &#125; System.out.println(); &#125; public static void main(String[]args)&#123; fc(0); fc(1,\"yang\"); fc(2,\"yang\",\"a\",\"yang\"); &#125;&#125;/*i=0i=1yangi=2yangayang*/ 在可变参数列表中可以使用任何类型的参数，包括基本类型。","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"java基础编程","slug":"java基础编程","permalink":"http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/"}]},{"title":"Java流程控制","slug":"java/java基础/【3】Java流程控制","date":"2019-12-15T04:32:12.000Z","updated":"2021-01-08T12:41:09.166Z","comments":true,"path":"2019/12/15/java/java基础/【3】Java流程控制/","link":"","permalink":"http://yoursite.com/2019/12/15/java/java%E5%9F%BA%E7%A1%80/%E3%80%903%E3%80%91Java%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/","excerpt":"","text":"if-elseif-else语句是控制程序流程的基本形式。其中的else是可选的。 12345678if(boolean-exp)&#123; statement&#125;if(boolean-exp)&#123; statement&#125;else&#123; statement&#125; 迭代while，do-while和for用来控制循环，语句会重复执行，直到起控制作用的布尔表达式得到假的结果为止。 while循环格式： 123while(boolean-exp)&#123; statement&#125; do-while循环格式： 12345do&#123; statement&#125;while(boolean-exp)&#123; statement&#125; while和do-while的唯一区别就是do-while中的语句至少会执行一次，即便表达式第一次就被计算为false。while比do-while更常用些。 for循环for循环是经常使用的迭代形式，在第一次迭代之前要进行初始化。随后，它会进行条件测试，而在每次迭代结束时，进行某次形式的“进步”。for循环的格式： 123for(inti;boolean-exp;step)&#123; statement&#125; 初始化表达式（init），布尔表达式（boolean-exp），进步（step）运算，都可以为空。每次迭代前会测试布尔表达式，若获得的结果为false，就会执行for语句后面的代码行。每次循环结束，会执行一次进步。 Foreach语法JavaSE5引入一种新的更加简洁的for语法用于数组和容器，即foreach语法，foreach语法不必创建int变量去对由访问项构成的序列进行计数，foreach将自动产生每一项。 1234567891011121314151617181920212223242526package control;import java.util.Random;public class ForeachTest&#123; public static void main(String[]args)&#123; Random rand = new Random(47); float f[] = new float[10]; for(int i = 0;i&lt;10;i++)&#123; f[i] = rand.nextFloat(); &#125; for(float x:f)&#123; System.out.println(x); &#125; &#125;&#125;/*0.727115750.399826350.53094540.05341220.160206560.577997570.188478650.41701370.516602040.73734957*/ return语句return关键词有两方面的用途：一方面指定一个方法返回什么值，另一方面它会导致当前的方法退出，并返回那个值。 如果在返回void方法中没有return语句，那么在该方法的结尾处会有一个隐式的return，因此在方法中并非总是必须要有一个return语句。如果一个方法声明它将返回void之外的其他东西，那么必须确保每条代码路径都会将返回一个值。 break和continue在任何迭代语句的主体部分，都可用break和continue控制循环的流程。break用于强制退出循环，不执行循环中的剩余语句。continue则停止执行当前的迭代，然后退回循环起始处，开始下一次迭代。 123456789101112131415161718192021222324252627package control;public class BreakAndContinue&#123; public static void main(String[]args)&#123; for(int i = 0;i&lt;100;i++)&#123; if(i==47) break; if(i % 9 != 0) continue; System.out.print(i+\" \"); &#125; System.out.println(); int i = 0; while(true)&#123; i++; int j = i*27; if(j == 1269)&#123; break; &#125; if(i%10 != 0)&#123; continue; &#125; System.out.print(i+\" \"); &#125; &#125;&#125;/*0 9 18 27 36 4510 20 30 40*/ switch控制语句switch有时被归为一种选择语句。根据整数表达式的值，switch语句可以从一系列代码中选出一段去执行。 格式如下： 1234567switch(integral-selector)&#123; case integral-value1:statement;break; case integral-value2:statement;break; case integral-value3:statement;break; case integral-value4:statement;break; default:statement;&#125; integral-selector（整数选择因子）是一个能够产生整数值的表达式，switch能够将这个表达式的结果与每个integral-value相比较。若发现相符，就执行对应的语句。若没有发现相符的，就执行default语句。","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"java基础编程","slug":"java基础编程","permalink":"http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/"}]},{"title":"Scala基础知识","slug":"scala/Atomic_Scala/【1】Atomic_Scala_Values","date":"2019-12-11T04:32:12.000Z","updated":"2021-01-07T09:38:29.443Z","comments":true,"path":"2019/12/11/scala/Atomic_Scala/【1】Atomic_Scala_Values/","link":"","permalink":"http://yoursite.com/2019/12/11/scala/Atomic_Scala/%E3%80%901%E3%80%91Atomic_Scala_Values/","excerpt":"","text":"值scala的值保存的是特定类型的信息，可以像下面这样定义一个值： 1val name = initialization val关键字后跟着变量的名字（Scala区分大小写字母）、等号和初始值。 1234567val whole = 11;val fr = 1.4;val words = \"Atomic_Scala\";println(whole,fr,words);/*(11,1.4,Atomic_Scala)*/ 一旦初始化val，就不能再进行修改，因为val的值是常量或不可变量。 变量像值一样，变量保存的也是特定类型的信息。但是在使用变量时，可以修改它的值。 1var name:type = initialization 数据类型在定义值时，scala会基于定义的值的方式来确定其类型，这称之为类型推断。也可以在定义值时直接指定具体类型： 1val name:type = initialization 例如下面的代码： 123456789101112131415val intvalue:Int = 11;val doublevalue:Double = 1.4;val booleanvalue:Boolean = true;val stringValue1:String = \"it is String\";val stringValue2:String = \"\"\"有个年轻人，他叫杨阿阳，他有一些烦恼。现在的年轻人多多少少都有些烦恼。\"\"\"println(intvalue,doublevalue,booleanvalue,stringValue1,stringValue2);/*(11,1.4,true,it is String,有个年轻人，他叫杨阿阳，他有一些烦恼。现在的年轻人多多少少都有些烦恼。)*/","categories":[{"name":"Scala","slug":"Scala","permalink":"http://yoursite.com/categories/Scala/"}],"tags":[{"name":"Scala基础编程","slug":"Scala基础编程","permalink":"http://yoursite.com/tags/Scala%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/"}]},{"title":"Java操作符","slug":"java/java基础/【2】Java操作符","date":"2019-12-11T04:32:12.000Z","updated":"2021-01-07T01:57:39.467Z","comments":true,"path":"2019/12/11/java/java基础/【2】Java操作符/","link":"","permalink":"http://yoursite.com/2019/12/11/java/java%E5%9F%BA%E7%A1%80/%E3%80%902%E3%80%91Java%E6%93%8D%E4%BD%9C%E7%AC%A6/","excerpt":"","text":"使用Java操作符操作符接受一个或多个参数，并生成一个新值。参数的形式与普通的方法调用不同，但是效果是一样的。操作数作用于操作数，并生成一个新值，有些操作数可能会改变操作数自身的值，称之为“副作用”。几乎所有的操作符都只能操作“基本类型”。列外的操作符是“=”、“==”、“!=”，这些操作符能操作所有的对象。此外，String类支持“+”和“+=”操作符。 优先级当一个表达式中存在多个操作符时，操作符的优先级就决定了各部分的计算顺序。Java对计算顺序做了特别的规定。最简单的规则就是先乘除后加减。应给使用括号明确规定计算顺序。 123456789101112package operators;public class Precedence&#123; public static void main(String[]args)&#123; int x = 1,y = 2,z = 3; int a = x + y - 2/2 + z;//(1) int b = x + (y-2)/(2+z);//(2) System.out.println(\"a = \" + a + \" b = \" + b); &#125;&#125;/*outputa = 5 b = 1*/ 语句（1）和语句（2）看上去大体相同，但是输出的结果却截然不同，这就是使用括号与不使用括号的结果。 赋值赋值操作使用操作符“=”。所表达的意思是：取右边的值，把右边的值复制给左边的变量，右值可以是任何常数、变量或者表达式。但左值必须是一个明确的、已经命名了的变量，必须有一个物理空间可以存储等号右边的值。比方说：将一个常数赋值给一个整型变量a： int a = 2; 不能把任何东西赋值给一个常数，常数不能作为左值（不能说4 = a）。 基本类型的赋值比较简单。基本类型存储了实际的数值，而不是指向一个对象的引用（这个后面的内容会介绍）。所以在为其赋值的时候，是直接将一个地方的内容复制到另一个地方。例如基本类型a和b，使用a=b时，是就是把b的值赋值给a变量。如修改a的值，b不会受到影响。 对一个对象进行操作时，真正操作的是对对象的引用。所以将一个对象赋值给另一个对象，实际是将引用从一个地方复制到另一个地方。 1234567891011121314151617181920212223242526272829package operators;class Tank&#123; int level;&#125;public class Assignment&#123; public static void main(String[]args)&#123; Tank t1 = new Tank(); Tank t2 = new Tank(); t1.level = 1; t2.level = 6; System.out.println(\"【1】 t1.level=\"+t1.level+ \",t2.level=\"+t2.level ); t1 = t2; // t1.level = t2.level; System.out.println(\"【2】 t1.level=\"+t1.level+ \",t2.level=\"+t2.level ); t1.level = 30; System.out.println(\"【3】 t1.level=\"+t1.level+ \",t2.level=\"+t2.level ); &#125;&#125;/*output【1】 t1.level=1,t2.level=6【2】 t1.level=6,t2.level=6【3】 t1.level=30,t2.level=30*/ Tank类的两个实例（t1，t2）是在main()里创建的。对每个Tank类的对象level域都赋予不同的值，随后将t2赋值给t1，接着修改t1的level域。在对t1赋值时，这个引用被覆盖，也就是这个引用丢失了，这种现象称之为“别名现象”，如果想避免“别名现象”，就需要写明调用的域；像这样上述代码中的15行所写那样t1.level = t2.level; 基本算术操作符Java的基本算术操作符包含加号（+）、减号（-）、除号（/）、乘号（*）以及取模操作符（%）。说明一下，整数除法会直接去掉结果的小数位，不是四舍五入圆整的结果。 下面展示各种算术操作符的用法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package operators;import java.util.Random;public class MathOps&#123; public static void main(String[]args)&#123; Random r = new Random(50); int i,j,k; j = r.nextInt(100)+1; System.out.println(\"j：\"+j); k = r.nextInt(100)+1; System.out.println(\"k:\"+k); i = j+k; System.out.println(\"+:\"+i); i = j-k; System.out.println(\"-:\"+i); i = j*k; System.out.println(\"*:\"+i); i = j/k; System.out.println(\"/:\"+i); float u,v,w; v = r.nextFloat(); System.out.println(\"v=\"+v); w = r.nextFloat(); System.out.println(\"w=\"+w); u = v+w; System.out.println(\"v+w=\"+u); u = v-w; System.out.println(\"v-w=\"+u); u = v*w; System.out.println(\"v*w=\"+u); u = v/w; System.out.println(\"v/w=\"+u); u+=v; System.out.println(\"u+=v \"+u); u-=v; System.out.println(\"u-=v \"+u); u*=v; System.out.println(\"u*=v \"+u); u/=v; System.out.println(\"u/=v \"+u); &#125;&#125; 一元加、减操作符一元减号用于转变数据的符号，一元加号只是为了与一元减号相对应，一元加号唯一的作用仅仅是将较小类型的操作数提升为int 自动递增和递减递增和递减运算是两种快捷的运算方式，递增操作符是++，表示“增加一个单位”；递减操作符是--，表示“减少一个单位”。递增和递减操作符不仅改变了变量，而且还改变了以变量的值作为生成的结果。 两种操作符各有两种使用方式，通常称为前缀式和后缀式。“前缀式递增”表示“++”操作符位于变量或表达式的前面；而“后缀递增”表示“++”操作符位于变量或表达式的后面。相应的，“前缀式递减”表示“–”操作符位于变量或表达式的前面；而“后缀递减”表示“–”操作符位于变量或表达式的后面。对于前缀式递增和前缀式递减，会先执行运算，再生成值。而对于后缀式递增和后缀式递减，会先生成值，在执行运算。 123456789101112public class AutoInc&#123; public static void main(String[]args)&#123; int i = 1; System.out.println(\"i = \"+i); System.out.println(\"++i = \"+ ++i); System.out.println(\"i++ = \"+ i++); System.out.println(\"i = \"+ i); System.out.println(\"--i = \"+ --i); System.out.println(\"i-- = \"+ i--); System.out.println(\"i = \"+ i); &#125;&#125; 关系操作符关系操作符生成的是一个boolean结果，计算的是操作数的值之间的关系。如果关系是真的关系表达式会生成true；如果关系不真实的则关系表达式生成false。关系操作符包括小于(&lt;)、大于(&gt;)、小于或等于(&lt;=)、大于或等于(&gt;=)、等于(==)以及不等于(!=)。等于或不等于适用于所有的基本数据类型，其他比较符不适用与boolean类型，boolean值只能为true和false，“大于”和“小于”没有实际意义。 测试对象等价性关系操作符==和!=也适用于所有对象，看一个例子： 1234567891011121314package operators;public class Equivalence&#123; public static void main(String[]args)&#123; Integer n1 = new Integer(47); Integer n2 = new Integer(47); System.out.println(n1==n2); System.out.println(n1!=n2); &#125;&#125;/*outputfalsetrue*/ 操作符==和!=比较的是对象的引用。 如果想比较两个对象的实际内容是否相同，必须使用对象都适用的特殊方法equals()。这个方法不适用于“基本类型”，基本类型直接使用==和!=即可。 123456789101112package operators;public class EqualsMethod&#123; public static void main(String[]args)&#123; Integer n1 = new Integer(47); Integer n2 = new Integer(47); System.out.println(n1.equals(n2)); &#125;&#125;/*outputtrue*/ 逻辑操作符逻辑操作符“与”（&amp;&amp;）、“或”（||）、“非”（!）能够根据参数的逻辑关系，生成一个布尔值（true或false） 123456789101112131415161718192021222324252627282930313233343536package operators;import java.util.Random;public class Bool&#123; public static void main(String[]args)&#123; Random r = new Random(52); int i = r.nextInt(100); int j = r.nextInt(100); System.out.println(\"i = \"+i); System.out.println(\"j = \"+j); System.out.println(\"i &gt; j is \"+(i &gt; j)); System.out.println(\"i &lt; j is \"+(i &lt; j)); System.out.println(\"i &gt;= j is \"+(i &gt;= j)); System.out.println(\"i &lt;= j is \"+(i &lt;= j)); // System.out.println(\"i != j is \"+(i != j)); // System.out.println(\"i &amp;&amp; j is \"+(i &amp;&amp; j)); // System.out.println(\"i &amp;&amp; j is \"+(i || j)); // System.out.println(\"!i is \"+ !i); System.out.println( \"(i&lt;10) &amp;&amp; (j&lt;10) is \"+ ((i&lt;10) &amp;&amp; (j&lt;10)) ); System.out.println( \"(i&lt;10) || (j&lt;10) is \"+ ((i&lt;10) || (j&lt;10)) ); &#125;&#125;/*i = 71j = 19i &gt; j is truei &lt; j is falsei &gt;= j is truei &lt;= j is false(i&lt;10) &amp;&amp; (j&lt;10) is false(i&lt;10) || (j&lt;10) is false*/ 短路“短路”现象，即一旦能够明确无误的确定整个表达式的值，就不再计算表达式余下的部分，整个逻辑表达式靠后的部分有可能不会被运算。 123456789101112131415161718192021222324252627282930313233package operators;public class ShortCircuit&#123; public static boolean test1(int v)&#123; System.out.println(\"test1(\"+v+\")\"); System.out.println(\"result：\"+(v&lt;1)); return v&lt;1; &#125; public static boolean test2(int v)&#123; System.out.println(\"test2(\"+v+\")\"); System.out.println(\"result：\"+(v&lt;2)); return v&lt;2; &#125; public static boolean test3(int v)&#123; System.out.println(\"test3(\"+v+\")\"); System.out.println(\"result：\"+(v&lt;3)); return v&lt;3; &#125; public static void main(String[]args)&#123; boolean b = test1(0) &amp;&amp; test2(2) &amp;&amp; test3(2); System.out.println(\"expression is \"+b+\"\\n\"); //没意义 // b = test1(1) || test2(5) || test3(2); // System.out.println(\"expression is \"+b); &#125;&#125;/*outputtest1(0)result：truetest2(2)result：falseexpression is false*/ 直接常量如果在程序中使用直接变量，编译器可以准确地知道生成什么样的类型，但有时候这种情况会变的模棱两可。这时候可以使用与直接量相关的某些字符来额外增加一些信息。 12345678910111213141516171819202122232425262728293031323334package operators;public class Literals&#123; public static void main(String[]args)&#123; int i1 = 0x2f; System.out.println(i1+\" i1：\"+Integer.toBinaryString(i1)); int i2 = 0x2F; System.out.println(i2+\" i2：\"+Integer.toBinaryString(i2)); int i3 = 0177; System.out.println(i3+\" i3：\"+Integer.toBinaryString(i3)); char c = 0xffff; System.out.println(c+\" c：\"+Integer.toBinaryString(c)); byte b = 0x7f; System.out.println(b+\" b：\"+Integer.toBinaryString(b)); short s = 0x7fff; System.out.println(s+\" s：\"+Integer.toBinaryString(s)); float f1 = 1; float f2 = 1f; float f3 = 1F; double d1 = 1d; double d2 = 1D; double d3 = 1; long l1 = 1; long l2 = 1l; long l3 = 1L; &#125;&#125;/*output47 i1：10111147 i2：101111127 i3：1111111? c：1111111111111111127 b：111111132767 s：111111111111111*/ 直接常量后面的后缀字符代表着它的类型。比如；后缀为l或者为L的代表long，后缀为F或者f的代表float。十六进制数适用于所有的整数数据类型，以前缀0x（0X），后面跟随0-9或小写（或大写）a-f来表示。如果试图将一个变量初始化成超出自身表示范围的值，编译器会提示错误信息。在上面的代码中，如果给char、byte以及short所能表示的最大的十六进制值超出表示范围，编译器会将值自动转换为int型，并提示需要对这次赋值进行“窄化转型”。 指数记数法在java中要表示10的2次方，使用1E2来表示。“E”表示以10为底 1234567891011121314151617package operators;public class Exponents&#123; public static void main(String[]args)&#123; double expFloat1 = 1.3e-45d; float expFloat2 = 1.3E-45F; double exp3 = 5E2; System.out.println(expFloat1); System.out.println(expFloat2); System.out.println(exp3); &#125;&#125;/*1.3E-451.4E-45500.0*/ 按位操作符按位操作符用来操作整数基本数据类型中的单个“比特(bit)”，也就是二进制位。按位操作符会对两个参数中对应的位执行布尔代数运算，并最终生成一个结果。 按位操作的规则如下： 如果两个输入位都是1，则按位“与”操作符（&amp;）生成一个输出为1；否则生成一个输出位0。 如果两个输入位里只要有一个是1，则按位“或”操作符（|）生成一个输出位1；只有在两个输入位都是0的情况下，才会生成一个输入位0。 如果输入位的某一位是1，但不全都是1，那么按位“异或”操作符（^）生成一个输出位1。 按位“非”（~）生成与输入位。 1234567891011121314151617181920212223242526272829public class BitwiseOperators&#123; public static void main(String[]args)&#123; int i1 = 0xaaaaaaaa; int i2 = 0x55555555; System.out.println(\"i1 = \"+Integer.toBinaryString(i1)); System.out.println(\"i2 = \"+Integer.toBinaryString(i2)); System.out.println(\"~i1 = \"+Integer.toBinaryString(~i1)); System.out.println(\"~i2 = \"+Integer.toBinaryString(~i2)); System.out.println(\"i1 &amp; i1 = \"+Integer.toBinaryString(i1 &amp; i1)); System.out.println(\"i1 | i1 = \"+Integer.toBinaryString(i1 | i1)); System.out.println(\"i1 ^ i1 = \"+Integer.toBinaryString(i1 ^ i1)); System.out.println(\"i1 &amp; i2 = \"+Integer.toBinaryString(i1 &amp; i2)); System.out.println(\"i1 | i2 = \"+Integer.toBinaryString(i1 | i2)); System.out.println(\"i1 ^ i2 = \"+Integer.toBinaryString(i1 ^ i2)); &#125;&#125;/*i1 = 10101010101010101010101010101010i2 = 1010101010101010101010101010101~i1 = 1010101010101010101010101010101~i2 = 10101010101010101010101010101010i1 &amp; i1 = 10101010101010101010101010101010i1 | i1 = 10101010101010101010101010101010i1 ^ i1 = 0i1 &amp; i2 = 0i1 | i2 = 11111111111111111111111111111111i1 ^ i2 = 11111111111111111111111111111111*/ 按位操作符可与等号（=）联合使用，以便合并运算和赋值：&amp;=、|=、^=都是合法的；但是按位非操作符（~）不能与等号联合使用，因为它是一元操作符 将布尔类型作为一种单比特值对待，可对它执行按位“与”，按位“或”，按位“异或”运算，但是不能对其进行按位“非”运算，对于布尔值，按位操作符具有与逻辑操作符相同的效果，只是按位操作符不会有短路的效果。 移位操作符移位操作符的运算对象也是二进制位。移位操作符只可用于处理整数类型。左移位操作符（&lt;&lt;）能够按照操作符右侧指定的位数将操作符左边的操作数向左移动（在低位补0）。“有符号”右移位操作符（&gt;&gt;）按照操作符右侧指定的位数将操作符左边的操作数向右移动。“有符号”右移位操作符使用“符号扩展”：若符号为正，则在高位插入0；若符号为负，则在高位插入1。Java增加了一种“无符号”右移位操作符（&gt;&gt;&gt;）,使用“零扩展”：无论正负，都在高位插入0。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105import java.util.Random;public class BitManipulation&#123; public static void main(String[]args)&#123; Random rand = new Random(47); int i = rand.nextInt(); int j = rand.nextInt(); printBinaryInt(\"-1\",-1); printBinaryInt(\"+1\",+1); int maxpos = 2147483647; printBinaryInt(\"maxpos\",maxpos); int maxneg = -2147483648; printBinaryInt(\"maxneg\",maxneg); printBinaryInt(\"i\",i); printBinaryInt(\"~i\",~i); printBinaryInt(\"-i\",-i); printBinaryInt(\"j\",j); printBinaryInt(\"i&amp;j\",i&amp;j); printBinaryInt(\"i|j\",i|j); printBinaryInt(\"i^j\",i^j); printBinaryInt(\"i&lt;&lt;5\",i&lt;&lt;5); printBinaryInt(\"i&gt;&gt;5\",i&gt;&gt;5); printBinaryInt(\"(~i)&gt;&gt;5\",(~i)&gt;&gt;5); printBinaryInt(\"i&gt;&gt;&gt;5\",i&gt;&gt;&gt;5); printBinaryInt(\"(~i)&gt;&gt;&gt;5\",(~i)&gt;&gt;&gt;5); long l = rand.nextLong(); long m = rand.nextLong(); printBinaryLong(\"l\",l); printBinaryLong(\"~l\",~l); printBinaryLong(\"-l\",-l); printBinaryLong(\"m\",m); printBinaryLong(\"l&amp;m\",l&amp;m); printBinaryLong(\"l|m\",l|m); printBinaryLong(\"l^m\",l^m); printBinaryLong(\"l&lt;&lt;5\",l&lt;&lt;5); printBinaryLong(\"l&gt;&gt;5\",l&gt;&gt;5); printBinaryLong(\"(~l)&gt;&gt;5\",(~l)&gt;&gt;5); printBinaryLong(\"l&gt;&gt;&gt;5\",l&gt;&gt;&gt;5); printBinaryLong(\"(~l)&gt;&gt;&gt;5\",(~l)&gt;&gt;&gt;5); &#125; public static void printBinaryInt(String s,int i)&#123; System.out.println(s+\",int：\" + i + \", binary：\\n\"+Integer.toBinaryString(i)); &#125; public static void printBinaryLong(String s,long l)&#123; System.out.println(s+\",Long：\"+l+\", binary：\\n\"+Long.toBinaryString(l)); &#125;&#125;/*-1,int：-1, binary：11111111111111111111111111111111+1,int：1, binary：1maxpos,int：2147483647, binary：1111111111111111111111111111111maxneg,int：-2147483648, binary：10000000000000000000000000000000i,int：-1172028779, binary：10111010001001000100001010010101~i,int：1172028778, binary：1000101110110111011110101101010-i,int：1172028779, binary：1000101110110111011110101101011j,int：1717241110, binary：1100110010110110000010100010110i&amp;j,int：570425364, binary：100010000000000000000000010100i|j,int：-25213033, binary：11111110011111110100011110010111i^j,int：-595638397, binary：11011100011111110100011110000011i&lt;&lt;5,int：1149784736, binary：1000100100010000101001010100000i&gt;&gt;5,int：-36625900, binary：11111101110100010010001000010100(~i)&gt;&gt;5,int：36625899, binary：10001011101101110111101011i&gt;&gt;&gt;5,int：97591828, binary：101110100010010001000010100(~i)&gt;&gt;&gt;5,int：36625899, binary：10001011101101110111101011l,Long：-8652529054300476342, binary：1000011111101100000010101010101100001101101011000110110001001010~l,Long：8652529054300476341, binary：111100000010011111101010101010011110010010100111001001110110101-l,Long：8652529054300476342, binary：111100000010011111101010101010011110010010100111001001110110110m,Long：2955289354441303771, binary：10100100000011010011000000001010010011111101111010011011011011l&amp;m,Long：72066398748419146, binary：100000000000010000000001000000001101001000010010001001010l|m,Long：-5769306098607591717, binary：1010111111101111010011101010101110011111111111111110111011011011l^m,Long：-5841372497356010863, binary：1010111011101111010001101010100110011110010110111100101010010001l&lt;&lt;5,Long：-179768631971968704, binary：1111110110000001010101010110000110110101100011011000100101000000l&gt;&gt;5,Long：-270391532946889886, binary：1111110000111111011000000101010101011000011011010110001101100010(~l)&gt;&gt;5,Long：270391532946889885, binary：1111000000100111111010101010100111100100101001110010011101l&gt;&gt;&gt;5,Long：306069219356533602, binary：10000111111011000000101010101011000011011010110001101100010(~l)&gt;&gt;&gt;5,Long：270391532946889885, binary：1111000000100111111010101010100111100100101001110010011101*/ 移位可与等号组合使用（&lt;&lt;=、&gt;&gt;=、&gt;&gt;&gt;=）。操作符左边的值会移动由右边的值指定的位数，再将得到的结果赋值给左边的变量。在进行“无符号”右移位赋值操作时，可能会对遇到一个问题：如果对byte、short值进行“无符号”右移位运算时，得到的结果可能不是正确的结果。它们会先被转换成int类型，在进行右移操作，然后被截断，赋值给原来的类型。 12345678910111213141516171819202122232425262728293031323334353637public class URShift&#123; public static void main(String[]args)&#123; int i = -1; System.out.println(\"i \"+Integer.toBinaryString(i)); i&gt;&gt;&gt;=10; System.out.println(\"i&gt;&gt;&gt;=10 \"+Integer.toBinaryString(i)); long l = -1; System.out.println(\"l \"+Long.toBinaryString(l)); l &gt;&gt;&gt;= 10; System.out.println(\"l &gt;&gt;&gt;= 10 \"+Long.toBinaryString(l)); short s = -1; System.out.println(\"s \"+Integer.toBinaryString(s)); s&gt;&gt;&gt;=10; System.out.println(\"s&gt;&gt;&gt;=10 \"+Integer.toBinaryString(s)); byte b = -1; System.out.println(\"b \"+Integer.toBinaryString(b)); b &gt;&gt;&gt;= 10; System.out.println(\"b&gt;&gt;&gt;=10 \"+Integer.toBinaryString(b)); b = -1; System.out.println(\"b \"+Integer.toBinaryString(b)); // b &gt;&gt;&gt; 10; 编译错误 System.out.println(\"b&gt;&gt;&gt;10 \"+Integer.toBinaryString(b&gt;&gt;&gt;10)); &#125;&#125;/*i 11111111111111111111111111111111i&gt;&gt;&gt;=10 1111111111111111111111l 1111111111111111111111111111111111111111111111111111111111111111l &gt;&gt;&gt;= 10 111111111111111111111111111111111111111111111111111111s 11111111111111111111111111111111s&gt;&gt;&gt;=10 11111111111111111111111111111111b 11111111111111111111111111111111b&gt;&gt;&gt;=10 11111111111111111111111111111111b 11111111111111111111111111111111b&gt;&gt;&gt;10 1111111111111111111111*/ 如果对char、byte或者short类型的数值进行移位操作，那在移位进行之前，它们被转换成int类型，并且得到的结果也是一个int类型的值。只有数值右端的低5位才有用。这样可以防止移位超过int型值所具有的位数。对一个long类型的数值进行移位处理，最后得到的结果也是long，结果只用到了数值右端的低6位，防止移位超过long型数值具有的位数。 三目运算三目运算操作符也称条件操作符，它有三个操作数，其表达式如下： boolean exp?value0:value1 如果boolean-exp（布尔表达式）的结果位true，就计算value0，而且这个计算结果也就是操作符的最终产生的值。如果boolean-exp的结果为false，就计算value1，同样这个计算结果也就成为了操作符最终产生的值。 三目运算也可以使用普通的if-else语句，但是三目运算符更加的简洁。但三目运算操作符与if-else完全不同，因为它会产生一个值。 12345678910111213141516171819202122232425package operators;public class TernaryIfElse&#123; public static int ternary(int i)&#123; return i&lt;10 ? i*100 : i*10; &#125; public static int IfElse(int i)&#123; if(i&lt;10)&#123; return i*10; &#125;else&#123; return i*100; &#125; &#125; public static void main(String[]args)&#123; System.out.println(ternary(11)); System.out.println(ternary(10)); System.out.println(IfElse(9)); System.out.println(IfElse(10)); &#125;&#125;/*110100901000*/ 类型转换操作符类型转换（cast）。在适当的时候，Java会将一种数据类型自动转换为另一种。类型转换运算允许显式的进行这种类型的转换，或者在不能自动进行转换的时候强制进行类型转换。想要执行类型转换，需要将希望得到的数据类型置于括号中，放在要进行类型转换的值的左边。 12345678910package operators;public class Casting&#123; public static void main(String[]args)&#123; int i = 200; long l = (int)i; l = i; long l2 = 200; i = (int)l2; &#125;&#125; 窄化转换在Java中，类型转换是一种比较安全的操作，但如果要执行一种名为窄化转换的操作（将能容纳更多信息的数据类型转换成无法容纳那么多信息的类型），就可能面临信息丢失的风险。 截尾和舍入在执行窄化转换时，必须注意截尾和舍入问题。 123456789101112131415161718192021222324252627package operators;public class CastingNumbers&#123; public static void main(String[]args)&#123; double above = 0.7,below = 0.4; float fabove = 0.7f,fbelow = 0.4f; System.out.println(\"(int)above \"+(int)above); System.out.println(\"(int)below \"+(int)below); System.out.println(\"(int)fabove \"+(int)fabove); System.out.println(\"(int)fbelow \"+(int)fbelow); System.out.println(\"Math.round(above) \"+Math.round(above)); System.out.println(\"Math.round(below) \"+Math.round(below)); System.out.println(\"Math.round(fabove) \"+Math.round(fabove)); System.out.println(\"Math.round(fbelow) \"+Math.round(fbelow)); &#125;&#125;/*(int)above 0(int)below 0(int)fabove 0(int)fbelow 0Math.round(above) 1Math.round(below) 0Math.round(fabove) 1Math.round(fbelow) 0*/ 如果要对结果进行舍入，就需要使用java.lang.Math中的round方法","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"java基础编程","slug":"java基础编程","permalink":"http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/"}]},{"title":"一切皆对象","slug":"java/java基础/【1】万物皆对象","date":"2019-12-09T04:32:12.000Z","updated":"2020-12-30T08:54:05.201Z","comments":true,"path":"2019/12/09/java/java基础/【1】万物皆对象/","link":"","permalink":"http://yoursite.com/2019/12/09/java/java%E5%9F%BA%E7%A1%80/%E3%80%901%E3%80%91%E4%B8%87%E7%89%A9%E7%9A%86%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"引用操作对象每种编程语言都有自己的操作内存中元素的方式。需要注意到将要处理的数据是什么类型。是直接操作元素，还是基于某种特殊的语法间接表示来操作对象呢？ 在Java里将这些做了简化。将一切都视为对象，可采取单一固定的语法。操作的标识符实际上是对象的一个“引用”。拥有一个引用，并不一定需要有一个对象与它关联。所有。如果需要操作一个句子或者词，则可以创建一个String引用，像这样：String s。这只是创建一个引用，并不是对象。一种正确的用法是：创建一个引用的同时便进行初始化：String s = &quot;Object&quot;; 创建所有对象创建了一个引用，希望这个引用能与一个对象相关联。通常用new操作符来实现与此对象相关联。所以上面的例子可以写成：String s = new String(&quot;Object&quot;) 基本类型Java要确定每种基本类型所占据的储存空间大小。每种类型的大小不会像其他语言那样随机器硬件架构的变化而变化。储存空间大小的不变性是Java程序比其他编程语言程序更具可移植性的原因之一。 基本类型 大小 最小值 最大值 包装器类型 boolean - - - Boolean char 16bit Unicode 0 Unicode 2[^^][^ 16]-1 Character byte 8bit -128 +127 Byte short 16bit -2[^^ 15] +12[^^15]-1 Short int 32bit -2[^^31] +2[^^31]-1 Integer long 64bit -2[^^63] +2[^^63]-1 Long float 32bit IEEE754 IEEE754 Float double 64bit IEEE754 IEEE754 Double void - - - Void 所有这些类型都有正负号，因此不需要去寻找它们的无符号数值类型 boolean类型所占据的储存空间大小没有明确规定，仅指定了能够取字面值true和false。自JavaSE5后，上面列举的基本类型，在将其初始化是都能自动拆装为对应的包装类型（自动拆装箱）。基本类型具有的包装器类。使得可以在堆中创建一个非基本对象，用来表示对应的基本类型。 基本类型的默认值 基本类型 默认值 boolean false char ‘\\u0000’ byte (byte)0 short (short)0 int 0 long 0L float 0.0f double 0.0d 若某个基本数据类型没有初始化，Java也会确保它获得一个默认值，如上图 高精度数字Java提供了两个用于高精度计算的类型：BigInteger和BigDecimal。BigInteger可以支持任意精度的整数，BigDecimal支持任何精度的定点数。这两个没有对应的基本类型，即使它们基本上属于“包装器类”的范畴。这两个类包含的方法，提供的操作与基本类型所能执行的操作相似，能够应用于int和float操作，同样可用BigInteger或BigDecimal，只是必须以方法调用的方式取代运算符方式来实现。 Java的作用域在大多数过程型语言中都有作用域(scope)的概念，作用域决定了在其内定义的变量名可见性和生命周期。作用域由花括号{}的位置决定。在作用域里定义的变量只可用与作用域结束之前。 Java对象不具备和基本类型一样的生命周期。当用new创建一个Java对象时，这个对象可以存活于作用域之外。举个例子： 123&#123; String s = new String(\"a string\");&#125;//End of scope 引用s在作用域终点就消失了，但是s指向的String对象仍能继续占据内存空间。在上面的代码段中，无法在这个作用域之外访问这个对象，因为对它的唯一引用已经超过了作用域的范围。 Java中，用new创建的对象，如果需要就会一直保留下去，这就带来了一个问题，如果Java让对象一直保存下去，那么这些对象是不是将填满内存空间？这是C++存在的问题，Java中不会存在。Java有一个叫垃圾回收器的东西，用来监视用new创建的所有对象，并辨别出那些不会再被引用的对象。随后释放这些对象的内存空间，以便供其他新的对象使用。这样消除了内存泄露的问题。 如何定义一个类在大多数面向对象编程的程序语言中使用关键字class来定义一个新的类型。class关键字后紧跟着的是新类型的名称。像这样： 123class ClassName&#123; &#125; 这就给Java引入了一个新的类型。如何可以通过new关键字来创建这个类的对象 1ClassName cn = new ClassName(); 方法、字段、参数和返回值一旦定义了一个类，就可以在类中设置两种类型的元素：字段和方法。字段可以是任意类型的对象，可通过其引用与其进行通信；也可以是基本类型中的一种。如果字段是对某个对象的引用，那么必须初始化该引用，以便使其与实际对象相关联。每个对象都有用来存储器字段的空间；普通字段不能在对象间共享。 Java的方法决定了一个对象能够接收什么样的消息。方法的基本组成部分包括：名称、参数列表、返回值、方法体。 123ReturnType methodName(Argument list)&#123; //Method body&#125; 返回类型描述的是调用方法之后从方法返回的值。参数列表给出了要传给方法的信息的类型和名称。方法名和参数列表(合称“方法签名”)唯一的标识出某个方法。 参数列表方法的参数列表指定要传递给方法什么信息。假设某个方法接受String为参数，其定义如下： 123int storage(String s)&#123; return s.length()*2;&#125; 这个方法中可以了解到return关键字的用法,它包含两方面：代表此方法已经执行结束，离开此方法。如果此方法产生一个值，这个值要放在return关键字后面。 如果返回类型是void，return关键字的作用只是用来退出方法，所以，没有必要到方法结束时才离开，可以在任何地方返回。但如果返回类型不是void，那么无论何处返回，编译器都会强制返回一个正确类型的返回值。 创建一个Java程序Objects/HelloDate.java 12345678910package objects;import java.util.Date;public class HelloDate&#123; public static void main(String[]args)&#123; System.out.println(\"Hello World\"); System.out.println(new Date()); &#125;&#125; 上面的HelloDateJava程序，类的名称和文件名必须要相同，如果创建一个独立的运行程序，那么文件中必须存在某个类的类名与该文件同名，并且那个类必须包含一个名为main()的方法。 使用关键字import关键字准确的告诉编译器需要的类是什么，import指示编译器导入一个包，也就是一个类库。 当什么一个事物是static时，就意味着这个域或者方法不会包含它的那个类的任何对象实例关联在一起。所以即使从未创建某个类的任何对象，也可以调用其static方法或访问static域。将static关键字放在定义之前，就可以将字段或方法设定为static。使用类名使用static变量的首选方式，这样不仅可以强调变量是static结构，而且在某些情况下还为编译器进行优化提供机会。static方法的一个重要用法是在不创建任何对象的前提下就可以调用它。 编译和运行Java程序程序代码编写完成后接下来就是对代码进行编译会运行： 这个过程要确保机器安装好了JDK环境，同时还要设定好路径，方便机器能够找到javac和java这两个文件。 编译前面的代码：Objects/HelloDate.java。 键入javac -d . -encoding utf-8 HelloDate.java。这条命令表示编译HelloDate.java文件，使用的是utf-8编码，并自动在当前目录下创建objects文件夹，在objects文件夹下生成HelloDate.class文件。如果这个过程顺利完成，则不会有任何输出信息，说明一切都正常。 编译好代码后，运行HelloDate的java程序 键入java -cp ./ objects.HelloDate即可运行这个Java程序。","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"java基础编程","slug":"java基础编程","permalink":"http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/"}]},{"title":"Java枚举类型","slug":"java/java基础/【19】Java枚举类型","date":"2019-12-07T14:12:02.000Z","updated":"2021-01-11T14:25:26.071Z","comments":true,"path":"2019/12/07/java/java基础/【19】Java枚举类型/","link":"","permalink":"http://yoursite.com/2019/12/07/java/java%E5%9F%BA%E7%A1%80/%E3%80%9019%E3%80%91Java%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"Enum关键字enum关键字，在需要群组并使用枚举类型集合时，可以很方便的处理。由于枚举类型的实例是常量，因此命名时大都使用大写。在创建enum时，编译器会自动添加一些有用的特性，,比如会创建toString()方法，便于显示某个enum实例的名字。编译器还会创建ordinal()方法，用来表示某个特定enum常量的声明顺序。static values()方法产生常量值构成的数组,还会生成一个相关的类，这个类继承自java.lang.Enum 下面看代码实例： 1234567public static void main(String[] args) &#123; //values()方法用于产生常量值构成的数组 for(Spiciness s:Spiciness.values()) &#123; //ordinal()方法，用来表示某个特定**enum常量**的声明顺序 System.out.println(s+\" ,\"+s.ordinal()); &#125; &#125; 12345678910111213public enum Spiciness &#123;//声明enum常量时通常使用大写字母 NOT, MILD, MEDIUM, HOT&#125;public class SimpleEnumeUse &#123; public static void main(String[] args) &#123; Spiciness howhot = Spiciness.MILD; System.out.println(howhot); &#125;&#125; enum还有一个实用的特性，可以在switch语句块中使用 1234567891011121314151617181920212223242526272829import static EnumType.demo1.Spiciness.*;public class Burrito &#123; Spiciness deg; public Burrito(Spiciness s)&#123; this.deg = s; &#125; public void describe()&#123; System.out.println(\"This Burrito\"); switch (deg) &#123; case NOT: System.out.println(\"not\"); break; case MILD: System.out.println(\"this MILD\"); break; case MEDIUM: System.out.println(\"a little hot\"); break; case HOT: System.out.println(\"this is HOT\"); break; &#125; &#125; public static void main(String[] args) &#123; Burrito plain = new Burrito(HOT); plain.describe(); &#125;&#125; 由于switch是要在有限的可能值集合中进行选择，因此与enum能很好的进行组合。 将静态导入应用于enum使用static import能够将enum实例的标识符带入当前的命名空间，所以无需再用enum类型来修饰enum实例 12345678910111213public enum Spiciness &#123; NOT, MILD, MEDIUM, HOT&#125;//static import导入Spicinessimport static EnumType.demo1.Spiciness.*;public class ImportEnum &#123; public static void main(String[] args) &#123; System.out.println(HOT); &#125;&#125; 向enum中添加新方法如果希望每个枚举能够返回对自身的描述，而不是使用toString实现，这只能返回枚举实例的名字。为此，需要提供一个构造器，专门负责处理这个额外的信息，然后添加一个方法，返回这个描述信息。 123456789101112131415161718192021public enum EnumFunction &#123; NAME(\"我是杨阿阳\"), AGE(\"23\"); private String decript; EnumFunction(String decript)&#123; this.decript = decript; &#125; public String getDecript() &#123; return decript; &#125; public static void main(String[] args) &#123; for(EnumFunction e:EnumFunction.values()) &#123; System.out.println(e+\": \"+e.getDecript()); &#125; System.out.println(EnumFunction.AGE.getDecript()); &#125;&#125;//outinfo~NAME: 我是杨阿阳AGE: 2323 在定义enum方法时，必须在enum实例序列的最后添加一个分号。同时必须先定义enum实例。如果在定义enum实例前定义任何方法或属性，那么编译时就会报错。在定义enum时将enum的构造器修饰为private 常量相关的方法在enum中可以声明常量方法，从而为每个enum实例赋予各自不同的行为。如果要实现常量相关的方法，需要为enum定义一个或多个abstract方法，然后为每个enum实例实现该抽象方法。 1234567891011121314151617public enum ConstantSpecificMethod &#123; DATA_TIME&#123; String getinfo() &#123; return \"getinfo1\"; &#125; &#125;, ClassPath&#123; String getinfo() &#123; return \"getinfo2\"; &#125; &#125;; abstract String getinfo(); public static void main(String[] args) &#123; ConstantSpecificMethod s = ConstantSpecificMethod.ClassPath; System.out.println(s.getinfo()); &#125;&#125; 通过相应的enum实例，可以调用其上的方法，上面的代码也称为表驱动的代码，这跟设计模式里的命令模式有些相似","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"java基础编程","slug":"java基础编程","permalink":"http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/"}]},{"title":"Java并发基础Java中的锁","slug":"java/并发编程/Java并发基础Java中的锁","date":"2019-04-30T10:40:11.000Z","updated":"2020-06-04T06:03:26.423Z","comments":true,"path":"2019/04/30/java/并发编程/Java并发基础Java中的锁/","link":"","permalink":"http://yoursite.com/2019/04/30/java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80Java%E4%B8%AD%E7%9A%84%E9%94%81/","excerpt":"","text":"锁是用来控制多个线程访问共享资源的方式，一个锁能够防止多个线程同时访问共享资源。 Lock在Lock接口出现之前，Java通过synchronized关键字实现锁功能，JDK 1.5之后，在并发包中新增了Lock接口来实现锁功能，有与synchronized关键字类似功能，只是在使用时需要显示的获取锁和释放锁，拥有了锁释放和获取的可操作性、可中断性等synchronized关键字不具备的特性。在使用synchronized关键字会隐式的获取锁和释放锁，但锁的获取和释放固化，即先获取后释放。Lock接口的实现基本上是通过聚合一个同步器（AQS）的子类来完成线程访问控制。 Lock接口的使用方式： 123456Lock lock = new ReentrantLock();lock.lock();try&#123;&#125;finally&#123; lock.unlock()&#125; 上面的代码示例中要注意：获取锁的过程不要写在try中，因为在获取锁时发生异常，异常抛出的同时，也会导致锁无故释放。 比较synchronized和ReentrantLock 锁的实现 synchronized是JVM实现的，而ReentrantLock是JDK实现 性能新版Java对synchronized进行了很多的优化，synchronized与ReentrantLock大致相同。 等待可中断 当持有锁的线程长期不释放锁，正在等待的线程可以选择放弃等待，改为处理其他事情。ReentrantLock可以中断，而synchronized不可以中断 公平锁 公平锁是指多个线程在等待同一锁时，必须按照申请的时间顺序来依次获得锁。synchronized中的锁是非公平的，ReentrantLock默认也是非公平，但也是可以公平的 锁绑定多个条件 一个ReentrantLock可以同时绑定多个Condition对象 如何选择呢？优先使用synchronized，除非需要使用ReentrantLock的高级功能，因为synchronized是JVM实现的一种锁机制，JVM原生的支持，而ReentrantLock不是所有的JDK都支持，synchronized不用担心没有锁而造成死锁问题，JVM会确保锁的释放。 重入锁重入锁ReentrantLock，支持重进入的锁，表示该锁功能支持一个线程对资源的重复加锁。 实现重进入重进入是指任意线程在获取锁之后能够再次获取该锁而不会被锁所阻塞，这个特性需要解决两个问题： 线程再次获取锁：所需要去识别获取锁的线程是否为当前占据锁的线程，如果是则再次成功获取。 锁的最终释放：线程重复n次获取锁，随后第n次释放该锁后，其他线程能够获取到该锁。锁的最终释放要求锁对于获取进行计数自增，计数表示当前锁被重复获取的次数，而锁被释放时，计数自减当计数等于0时表示已经释放成功。 重入锁是通过组合自定义同步器来实现锁的获取和释放。获取同步状态的代码如下： 123456789101112131415161718final boolean nonfairTryAcquire(int acquires) &#123; final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) &#123; if (compareAndSetState(0, acquires)) &#123; setExclusiveOwnerThread(current); return true; &#125; &#125; else if (current == getExclusiveOwnerThread()) &#123; int nextc = c + acquires; if (nextc &lt; 0) // overflow throw new Error(\"Maximum lock count exceeded\"); setState(nextc); return true; &#125; return false; &#125; 通过判断当前线程是否为获取锁的线程来决定获取操作是否成功，如果是获取锁的线程再次请求，则将同步状态值进行增加并返回true，表示获取同步状态成功。 读写锁读写锁维护一对锁，一个读锁和一个写锁，通过分离读锁和写锁使得并发性相比一般的排他锁有了更大的提升，读写锁的性能都会比排它锁好，因为大多数场景读操作对于写操作，在这样的情况下读写锁能够提供排它锁更好的并发性和吞吐量， 读写锁的实现 读写状态的设计 读写锁同样依赖自定义同步器来实现同步功能，而读写状态就是其同步器的同步状态。读写锁的自定义同步器需要在同步同步状态上维护多个读线程和一个写线程的状态，状态的设计成为读写锁实现的关键。 如果在一个整型变量上维护多种状态，就一定需要“按位切割使用”这个变量，读写锁将变量切分成两个部分，高16为表示读，低16位表示写 写锁的获取与释放 写锁是一个支持重进入的排它锁，如果当前线程已经获取了写锁，则增加写状态。如果当前线程在获取写锁时，读锁已经被获取或者该线程不是已经获取写锁的线程，则当前线程进入等待状态。写锁的释放与ReentrantLock的释放过程基本相似，每次释放均减少写状态，当写状态为0时表示写锁已经被释放，从而等待读写线程能够继续访问读写锁，同时前次的写线程的修改对后续读写线程可见。 读锁的获取与释放 读锁是一个支持重进入的共享锁，能够被多个线程同时获取，在没有其他的写线程访问时，读锁总会被成功的获取，而所做的只是增加读状态，如果当前线程已经获取了读锁，则增加读状。如果当前线程在获取读锁时，写锁已被其他线程获取，则进入等待状态。 锁降级 锁降级指的是写锁降级为读锁。如果当前线程拥有写锁，然后将其释放，最后在获取读锁，这种分段完成的过程不能称为锁降级。锁降级是指把持住写锁，再获取到读锁，随后释放写锁的过程。锁降级中读锁释放主要是为了保证数据的可见性。 队列同步器队列同步器AbstractQueuedSynchronizer，是用来构建锁或者其他同步组件的基本框架，使用一个int成员变量表示同步状态，通过内置FIFO队列来完成资源的获取线程的排队工作。 同步器是实现锁的关键，在锁的实现中聚合同步器，利用同步器实现锁的语义。二者的关系是：锁是面向使用者，定义了使用者与锁交互的接口，隐藏了实现细节；同步器则面向锁的实现者，简化了锁的实现方式，屏蔽了同步状态管理、线程的排队、等待与唤醒等底层操作。同步器的主要使用方式是继承，子类通过继承同步器并实现它的抽象方法来管理同步器状态。 队列同步器的实现分析同步队列同步器依赖内部的同步队列来完成同步状态的管理，当前线程获取同步状态失败时，同步器会将当前线程以及等待状态的信息够造成一个节点将其加入到同步队列，同时会阻塞当前线程，当同步状态释放时，会把首节点中的线程唤醒，使其再次尝试获取同步器状态。 节点是构成同步队列的基础，同步器拥有首节点和尾节点，没有成功获取同步状态的线程会成为节点加入到该队列的尾部。","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"java并发编程","slug":"java并发编程","permalink":"http://yoursite.com/tags/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}]},{"title":"Java并发基础","slug":"java/并发编程/Java并发基础Java","date":"2019-04-30T10:39:37.000Z","updated":"2020-05-06T09:01:30.973Z","comments":true,"path":"2019/04/30/java/并发编程/Java并发基础Java/","link":"","permalink":"http://yoursite.com/2019/04/30/java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80Java/","excerpt":"","text":"参考资料","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"java并发编程","slug":"java并发编程","permalink":"http://yoursite.com/tags/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}]},{"title":"Java并发容器和框架","slug":"java/并发编程/Java并发容器和框架","date":"2019-04-25T08:07:02.000Z","updated":"2020-05-09T08:53:21.771Z","comments":true,"path":"2019/04/25/java/并发编程/Java并发容器和框架/","link":"","permalink":"http://yoursite.com/2019/04/25/java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E5%92%8C%E6%A1%86%E6%9E%B6/","excerpt":"","text":"ConcurrentHashMap ​ 在多线程环境中，使用HashMap可能会导致程序死循环，使用线程安全的HashTable效率低效，所以便有了 ConcurrentHashMap。 ConcurrentHashMap利用锁的分断技术可有效提升并发访问率，在容器里有多把锁，每一把锁用于锁容器其中一部分数据，当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效提升并发访问效率。容器中有多把锁，每把锁用于锁容器其中的一部分数据，那么当多线程访问容器里不同的数据段时，线程之间就不会存在锁竞争，从而提高并发访问效率。 ConcurrentHashMap的结构ConcurrentHashMap由Segment数组结构和HashEntry数组结构组成。Segment是一种可重入锁；HashEntry用于存储键值对数据，一个ConcurrentHashMap包含一个Segment数组。Segment数组的结构和HashMap类似，是一种数组和链表结构，一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素，每个Segment守护一个HashEntry数组里的元素，当对HashEntry数组的数据进行修改时，必须先获得与它对应的Segment锁。 ConcurrentHashMap初始化初始化Segment数组segments数组的长度ssize是通过ConcurrencyLevel计算得出，为了可以通过按位与的散列算法定位Segments数组的索引，必须保证segments数组的长度是2的N次方，所以必须计算出一个大于或等于concurrencyLevel的最小的2的N次方值来作为segments数组的长度。下面是segments数组的源代码 123456789101112if(concurrencyLevel &gt; MAX_SEGMENTS)&#123; concurrencyLevel = MAX_SEGMENTS; int sshift = 0; int ssize = 1; while(ssize &lt; concurrencyLevel)&#123; ++sshift; ssize &lt;&lt;= 1; &#125; segmentShift = 32 - sshift; segmentMask = ssize -1; this.segments = Segment.newArray(ssize);&#125; concurrencyLevel的最大值是65535，Segments数组的长度最大为65536对应的二进制数组 初始化segmentShift和segmentMask这两个全局变量需要定位segments的散列算法里使用，sshift等于ssize从1向左移位的次数，在默认情况下concurrencyLevel等于161需要向左移位移动4次，所以sshift等于4segmentShift用于定位参与散列运算的位数，segmentShift等于32减sshift，所以等于28。 定位SegmentConcurrentHashMap使用分段锁Segment保护不同的数据，在插入和获取元素的时候，必须通过散列算法定位到Segment，然后在进行再散列，减少散列冲突，使元素能够均匀地分布在不同的Segment上，提高容器的存取效率。 散列算法如下： 1234final Segment&lt;K,V&gt; segmentFor(int hash)&#123; //segmentShift默认为28，SegmentMask为15 return segments[(hash&gt;&gt;&gt;segmentShift)&amp;segmentMask];&#125; 初始化每个segment输入参数initialCapacity是ConcurrentHashMap的初始化容量，loadfactor是每个segment的负载因子，在构造方法中需要通过这两个参数来初始化数组中的每个segment。 1234567891011121314if(initialCapacity &gt;MAXIMUM_CAPACITY)&#123; initialCapacity = MAXIMUM_CAPACITY; int c = initialCapacity/ssize; if(c * ssize &lt; initialCapacity)&#123; ++c; &#125; int cap = 1; while(cap &lt; c)&#123; cap &lt;&lt;= 1; &#125; for(int i = 0;i&lt;this.segments.length;i++)&#123; this.segments[i] = new Segment&lt;K,V&gt;(cap,loadFactor); &#125;&#125; ConcurrentHashMap的操作 get操作get操作先经过一次再散列，然后使用这个散列值通过散列运算定位到Segment，在通过散列算法定位到元素。 1234public V get(Object key)&#123; int hash = hash(key.hashCode()); return segmentFor(hash).get(key,hash);&#125; get操作之所以高效是因为整个get过程不需要加锁，除非读到的值是空才会加锁重读。get方法里面将要使用的共享变量都定义为volatile,定义成volatile的变量，能够在线程之间保持可见性，能够被多线程同时读，并且保证不会读到过期的值，在get操作里只需要读不需要写共享变量count和value，所以不需要加锁。不会读到过期的值，是因为根据Java内存模型Happen-before原则，对volatile字段的写入优先于读操作，即使两个线程同时修改和获取volatile变量，get操作也能够拿到最新的值。 put操作由于put操作需要对共享变量进行写入操作，为了线程安全，在操作共享变量是必须加锁。插入操作需经历两步：（1）判断是否需要对Segment数组里的HashEntry数组进行扩容；（2）定位添加元素的为位置，然后将其放在HashEntry数组中。根据上面的两个步骤这里又抛出两个问题：是否需要扩容、如何扩容。 是否需要扩容：在插入元素前会先判断Segment里的HashEntry数组是否超过容量，如果超过阈值，则对数组进行扩容（Segment的扩容判断比HashMap更恰当，因为HashMap是在插入元素后判断元素是否已经达到容量，如果达到了就进行扩容）， 如果扩容：在扩容的时候，为了高效ConcurrentHashMap不会对整个容器进行扩容，而只是对某个Segment数组进行扩容 size操作在统计size的时候会把所有Segment的put、remove、clean方法全部加锁，这种做法会变得非常低效，ConcurrentHashMap先尝试通过两次不加锁Segment的方式来统计各个Segment大小，通过过程中容器的count发生了变化，则再采用加锁的方式来统计所有Segment的大小，那么ConcurrentHashMap如何判断容器是否发生变化？使用modCount变量，在put、remove、clean方法里操作元素前都会将变量modCount进行加一操作，那么在统计size前后比较modCount是否发生变化，从而知道容器大小是否发生变化。 ConcurrentLinkedQueueConcurrentLinkedQueue是个基于链表节点的无界线程安全队列，采用先进先出的规则对节点进行排序，当添加一个元素时，会添加到队列的尾部；当获取一个元素时会返回队列的头元素。采用CAS算法实现。 ConcurrentLinkedQueue的入队列入队列过程入队列就是将入队节点添加到队列的尾部，在单线程下入队列比较简单，但在多线程同时进行入对的时候就复杂了许多，这个过程可能会有其他线程入队的情况，如果有个线程正在入队，那么这个线程就必须获取尾节点，然后设置尾结点的下一个节点为入队节点，要是这时有另一个线程插队，那么队列的尾节点就会发生变化，当前线程停止入队操作。这里就需要用到CAS算法 出队列过程出队列就是从队列里返回一个节点元素，并清空该节点对元素的引用。首先获取头节点的元素，然后判断头节点元素是否为空，如果为空，表示另外一个线程已经进行了一次出队操作将该节点的元素取走，如果不为空，则使用CAS的方式将头节点的引用设置为null，如果CAS成功，则直接返回头节点的元素，如果不为空表示另外一个线程已经进行了一次出队操作更新过了head头节点，导致元素发生变化，需要重新获取头节点。 Java中的阻塞队列什么是阻塞队列：阻塞队列是个支持阻塞的插入方法和阻塞的移除方法的队列； 支持阻塞的插入方法：当队列满时，队列会阻塞插入元素的线程直到队列不满。 支持阻塞的移除方法：当队列空时，获取元素的线程会等待队列变为非空 阻塞队列的实现原理 使用通知模式实现：通知模式就是当生产者往满的队列里添加元素时会阻塞生产者，当消费者消费了一个队列中的元素后，会通知生产者当前队列可用。","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"java并发编程","slug":"java并发编程","permalink":"http://yoursite.com/tags/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}]},{"title":"SQL基础（二）","slug":"数据库/mysql/SQL基础2","date":"2019-04-05T09:57:27.000Z","updated":"2020-04-09T13:52:30.812Z","comments":true,"path":"2019/04/05/数据库/mysql/SQL基础2/","link":"","permalink":"http://yoursite.com/2019/04/05/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/SQL%E5%9F%BA%E7%A1%802/","excerpt":"","text":"过滤数据百分号（%）通配符%表示任何字符出现任意次数。 123SELECT prod_id,prod_nameFROM productsWHERE prod_name LIKE 'jet%'; 上面的SQL检索任意以jet为开头的词，%告诉MYSQL接受jet之后的任意字符，不论它有多少字符。通配符可在搜索模式中任意位置使用，并且可以使用多个通配符 123SELECT prod_id,prod_nameFROM productsWHERE prod_name LIKE '%anvil%'; 下划线（_）通配符下划线通配符只匹配单个字符而不是多个字符。 123SELECT prod_id,prod_nameFROM productsWHERE prod_name LIKE '_ ton anvil' 使用通配符的技巧 不要过度使用通配符，如果其他操作符能达到相同的效果，应该使用其他操作符； 在确实需要使用通配符时，除非绝对有必要，否则不要把通配符放在搜索模式的开始处。如果把通配符置于开始处，搜索起来很慢； 仔细注意通配符的位置，如果犯错位置。可能不会得到想要的数据； 正则表达式MySQL中使用REGEXP关键字指定正则表达式的字符匹配。 正则表达式常用的字符匹配列表 选项 说明 ^ 匹配文本的开始字符 $ 匹配文本的结束字符 . 匹配任何单一字符 * 匹配零个或多个在在它前面的字符 + 匹配前面的字符1次或多次 字符串 匹配包含指定的字符串的文本 [字符集合] 匹配字符集合中的任何一个字符 [^] 匹配不在括号中的任何字符 字符串{n,} 匹配前面的字符串至少n次 字符串{n,m} 匹配前面的字符串至少n次，至多m次。 | 进行OR匹配 正则表达式经典例子： 基本字符匹配 1234SELECT prod_nameFROM productsWHERE prod_name REGEXP '1000'ORDER BY prod_name; 1234SELECT prod_nameFROM productsWHERE prod_name REGEXP '.000'ORDER BY prod_name; 进行OR匹配 1234SELECT prod_nameFROM productsWHERE prod_name REGEXP '1000|2000'ORDER BY prod_name; 范围匹配 1234SELECT prod_nameFROM productsWHERE prod_name REGEXP '[1-5] Ton'ORDER BY prod_name; 匹配特殊字符 1234SELECT vend_nameFROM vendorsWHERE vend_name REGEXP '\\\\.'ORDER BY prod_name; MYSQL函数文本处理函数 函数 说明 Left() 返回字符串左边的字符 Length() 返回字符串的长度 Locate() 找出字符串的一个子串 Lower() 将字符串转换为小写 LTrim() 去掉字符串左边的空格 Right() 去掉字符串右边的字符 RTrim() 去掉字符串右边的空格 Upper() 将字符串转换为大写 经典例子 将字符串转换为大写 123SELECT vend_name,Upper(vend_name)FROM vendorsORDER BY vend_name; 日期时间处理函数 函数 说明 AddDate() 增加一个日期（天，周等） AddTime() 增加一个时间（时，分等） CurDate() 获取当前日期 CurTime() 获取当前时间 Date() 返回日期时间的日期部分 DateDiff() 计算两个日期之差 Time() 返回一个日期时间的时间部分 Now() 返回当前日期和时间 聚集函数 函数 说明 AVG() 计算某一列的平均值 COUNT() 获取某一列的行数 MAX() 获取某一列的最大值 MIN() 获取某一列的最小值 SUM() 获取某一列值之和 数据分组创建分组分组是在SELECT语句的GROUP BY子句中建立的。 举个例子： 123SELECT vend_id,COUNT(*) as num_prodsFROM productsGROUP BY vend_id; 使用GROUP BY子句的一些规定 GROUP BY子句可以包含任意数目的列。使得能够对分组进行嵌套，为数据分组提供更细致的控制。 如果GROUP BY子句中嵌套了分组，数据将在最后规定的分组上进行汇总。 GROUP BY子句中列出每个列都必须是检索列或是有效的表达式。如果在SELECT中使用表达式，则必须在GROUP BY子句中指定相同的表达式。不能使用别名。 除聚集函数语句外，SELECT语句中每个列都必须在GROUP BY子句中给出。 如果分组列中具有NULL值，则NULL将作为一个分组返回。如果列中有多行NULL值，他们将分为一组。 GROUP BY子句必须出现在WHERE子句之后，ORDER BY子句之前。 过滤分组：HAVING使用HAVING对分组进行过滤，基于分组聚集值进行分组。 举几个例子 1234SELECT vend_id,COUNT(*) as num_prodsFROM productsGROUP BY vend_idHAVING COUNT(*)&gt;2; 1234SELECT order_num,SUM(quantity*item_price) as ordertotalFROM orderitemsGROUP BY order_numHAVING SUM(quantity*item_price) &gt;=50; SELECT子句顺序以下语句由上至下的顺序 SELECT：要返回的列或表达式 FROM：从中检索数据的表 WHERE：行级过滤 GROUP BY：分组说明 HAVING：组级过滤 ORDER BY：输出排序顺序 LIMIT：遥检索的行数 子查询子查询就是嵌套在其他查询中的查询。 利用子查询过滤1234567SELECT cust_idFROM ordersWHERE order_num IN(SELECT order_numFROM orderitemsWHERE prod_id = 'TNT2'); 上面的SELECT语句中子查询总是从内向外处理，上面的SQL语句实际上执行了两个SELECT操作。 在WHERE子句中使用子查询能够编写出功能很强并且很灵活的SQL语句。对于能嵌套的子查询的数目没有限制，但在实际应用中对于性能的要求，不能嵌套太多的子查询。 用作计算字段使用子查询123456SELECT cust_name,cust_state,(SELECT COUNT(*)FROM ordersWHERE orders.cust_id = customers.cust_id) as ordersFROM customersORDER BY cust_name; 联结表创建联结联结的创建非常简单，规定要联结的所有表以及他们如何关联即可。 1234SELECT vend_name,prod_name,prod_priceFROM vendors as vend,products as prdWHERE vend.vend_id = prd.vend_idORDER BY vend_name,prod_name; 内部联结基于两个表之间的相等测试，称为内部联结。 123SELECT vend_name,prod_name,prod_priceFROM vendors as vend,INNER JOIN products as prodON vend.vend_id = prod.vend_id; 两个表之间的关系是FROM子句的组成部分，以INNER JOIN指定，在使用这种语法时，联结条件用特定的ON子句而不是WHERE子句给出。传递给ON的实际条件与传递给WHERE的相同。 自联结12345SELECT p1.prod_id,p1.prod_nameFROM products as p1,products as p2WHERE p1.vend_id = p2.vend_idANDp2.prod_id = 'DTNTR'; 自联结通常作为外部语句用来替代从相同表中检索数据时使用的子查询语句。 外部联结看下面的例子： 12345SELECT customers.cust_id,orders.order_numFROM customers LEFT OUTER JOIN ordersON customers.cust_id = orders.cust_id; 在使用OUTER JOIN语法时，必须使用RIGHT或LEFT关键字指定包含其所有行的表（RIGHT指出的是OUTER JOIN右边的表，而LEFT指出的是OUTER JOIN左边的表） 使用联结和联结条件 注意所使用的联结类型，一般使用内部联结，但使用外部联结也是有效的； 保证使用正确的联结条件，否则将返回不正确的数据； 应该总是提供联结条件，否则会得笛卡儿积； 在一个联结中可以包含多个表，甚至对于每个联结可以采用不同的联结类型。虽然这样做合法的，一般也很有用，但应该在一起测试他们之前，分别测试每个联结，这将是故障排除更为简单； 组合查询组合查询将结果作为单个查询结果集返回。这些组合查询通常称为复合查询。 下面的情况，需要使用组合查询 在单个查询浙江哦你从不同的表中返回类型类似结构的数据； 对单个表执行多个查询，按单个查询返回数据； 创建组合查询 — 使用UNIONUNION的使用很简单，写出每个SELECT语句，在各条语句之间放上关键字 举个例子： 第一条select语句 123SELECT vend_id,prod_id,prod_priceFROM productsWHERE prod_price &lt;= 5; 第二条select语句 123SELECT vend_id,prod_id,prod_priceFROM productsWHERE vend_id IN(1001,1002); 复合两个语句 1234567SELECT vend_id,prod_id,prod_priceFROM productsWHERE prod_price &lt;= 5;UNIONSELECT vend_id,prod_id,prod_priceFROM productsWHERE vend_id IN(1001,1002); UNION规则 UNION必须有两条或者两条以上SELECT语句组成，语句之间用关键字UNION分隔； UNION中的每个查询必须包含相同的列，表达式或聚集函数（不过各个列不需要以相同的次序列出）； 列数据类型必须兼容：类型不必完全相同，但必须是DBSM可以隐式转换的类型； 参考资料 《MySQL必知必会》人民邮电出版社 《MySQL 从入门到精通》清华大学出版社","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"},{"name":"sql","slug":"sql","permalink":"http://yoursite.com/tags/sql/"}]},{"title":"vim基本命令","slug":"其他/vim基本命令","date":"2019-04-04T13:22:53.000Z","updated":"2020-04-05T10:00:38.854Z","comments":true,"path":"2019/04/04/其他/vim基本命令/","link":"","permalink":"http://yoursite.com/2019/04/04/%E5%85%B6%E4%BB%96/vim%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/","excerpt":"","text":"h或者向左箭头 光标向左移动一个字符 j或者向下箭头 光标向下移动一个字符 k或者向上箭头 光标向上移动一个字符 l或者向右箭头 光标向右移动一个字符 Page Down 屏幕向下移动一页 Page Up 屏幕向上移动一页 n n表示数字，按下数字再按空格键，光标会向右移动这一行的n个字符 功能键[Home] 移动到这一行的最前面字符处 功能键[End] 移动到这一行的最后面字符处 G 移动到这个文件的最后一行 nG 移动到这个文件的第n行 n 光标向下移动n行 /word 向光标之下寻找一个名称为word的字符 :n1,n2s/word1/word2/g 在第n1与n2行之间寻找word1这个字符串，并将该字符串替换为word2 :1,$s/word1/word3/g 在第1与最后一行之间寻找word1这个字符串，并将该字符串替换为word2 :1,$s/word1/word4/gc 在第1与最后一行之间寻找word1这个字符串，并将该字符串替换为word2，且在替换前显示提示字符给用户确认是否需要替换 x与X 在一行中x为向后删除一个字符(相当于[del]),X为向前删除一个字符(相当于退格键) dd 删除(剪切)光标所在的那一整行 ndd 删除(剪切)光标所在的向下n行 yy 复制光标所在的那一行 nyy 复制光标所在的向下n行 p与P p为将已复制的数据在光标下一行粘贴，P则为粘贴在光标的上一行。 u 恢复前一个操作 [ctrl]+r 重做上一个操作 . 重复前一个操作 i、a、o 进入插入模式 r或者R 进入替换模式 [Esc] 退出编辑模式 :w 将编辑的数据写入硬盘中 :q 退出vim :wq 保存后退出","categories":[{"name":"其他","slug":"其他","permalink":"http://yoursite.com/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"Linux进程管理","slug":"Linux/Linux进程管理","date":"2019-03-27T09:09:42.000Z","updated":"2020-03-28T07:09:59.010Z","comments":true,"path":"2019/03/27/Linux/Linux进程管理/","link":"","permalink":"http://yoursite.com/2019/03/27/Linux/Linux%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/","excerpt":"","text":"什么是进程如何产生一个进程？程序一般是放置在物理磁盘中，然后通过用户的执行来触发，触发后会加载内存中成为一个个体，这就是进程，为了让系统可以管理这个进程，进程会给予执行者权限/属性等参数，以及进程所需的脚本或数据，最后在给予一个PID。操作系统通过这个PID来判断该进程是否具有执行权限。过程如下图； 举个常见的例子，我们在操作Linux的时候通过登录系统分给我们一个shell(bash)终端，这个shell终端具有一个PID，这个PID就是由UID/GID而来。当这个进程执行其他作业时，那么由这个进程衍生出来的其他进程在一般状态下，会沿用这个进程的相关权限。 关于程序和进程的总结： 程序：通常为二进制程序，放置在存储媒介中，以物理文件的形式存在 进程：程序被触发后，执行者的权限与属性、程序的代码与所需的数据等都会被加载到内存中，操作系统给予这个内存中的单元一个标识符（PID）所以所进程就是一个正在运行时的程序 程序调用的流程（fork and exec）：Linux的程序调用通常称为fork-and-exec的流程。进程都会借由父进程以复制（fork）的方式产生一个一模一样的子进程，然后被复制出来的子进程再以exec方式执行实际要执行的进程，最终就成为一个子进程。 具体流程就像下面的图片 常驻在内存当中的进程通常都是负责一些系统所提供的功能以服务用户的各项任务，因此这些常驻进程称之为服务 任务管理什么是任务管理任务管理是用在bash环境下的，当登录系统获取 bash shell之后，在单一终端下同时执行多个任务的管理操作，执行任务管理的操作中，每个任务都是目前bash的子进程，彼此之间都是有相关性。 前台与后台 说到终端，这里说一下前台与后台； 可以出现提示字符让你操作的环境称为前台，其他任务就可以放入后台去暂停或运行，放入后台的任务是不可以使用【ctrl+c】来终止的 要执行bash的任务管理必须要注意的限制： 这些任务所触发的进程必须是来自你shell的子进程（只管理自己的bash）； 前台：可以控制与执行命令的这个环境称为前台任务； 后台：可以自动执行任务，无法使用【ctrl+c】终止，可使用bg、fg（这两个命名后面会讲解）调用该任务； 后台中【执行】的进程不能等待或输入； 任务控制的管理 直接将命令扔到后台去执行的&amp; 如果想要同时执行多个任务，利用&amp;可以将某些任务直接丢到后台环境，这样就可以继续操作前台的工作任务 例如需要后台执行一个java程序可以这样做： 12$ java -jar xxxx.jar &amp;[1] 7851 当命令后面加上&amp;代表着该命令丢到后台执行，此时bash会给予这个命令一个任务号码【job number】，就如上面代码的那个【1】。后面的7851则是该命令触发的【PID】。当这个任务执行完毕后bash会返回如下信息，表示[1]这个任务已经执行完毕； 1[1]+ Done java -jar xxxx.jar 将目前的任务丢到后台中暂停：【ctrl-z】 将一个正在执行的任务，扔到后台去暂停，使用【ctrl+c】组合键可以实现，使用【ctrl+c】丢到后台当中的任务都是停止状态 查看目前的后台任务状态：jobs 命令格式：jobs [-lrs] 选项与参数： -l：列出【job number】、【PID】与命令串； -r：仅列出正在后台运行的任务； -s：仅列出正在后台停止的任务； 看一个案例：将vim和vi丢到后台 1234567$ vim &amp;[1] 11439$ vi &amp;[2] 11440$ jobs -l[1]- 11439 Stopped (tty output) vim[2]+ 11440 Stopped (tty output) vi 在上面输出的案例里，有+，-号，+号代表最近被放到后台的任务号码，-号代表最近第二个被放到后台中的任务号码，而第三个以后的任务，就不会有+-号出现 将后台任务拿到前台处理：fg 命令格式：fg %jobnumber 以上面案例基础上将vim和vi放到前台： 1234567$ jobs -l[1]- 11439 Stopped (tty output) vim[2]+ 11440 Stopped (tty output) vi## 将vim放到前台处理$ fg %1vim... 让任务在后台下的状态变成运行中：bg %jobnumber 将还在后台停止的vi在后台运行 12$ bg %1[1]+ vi &amp; 就像上面的输出结果那样，命令串后面有一个【&amp;】符号，代表该任务别被启动到后台了 管理后台当中的任务：kill 如果想要将该任务直接删除或者重新启动，就可以用kill命令，使用这个命名时需要给这个命令一个信号（signal） 命令格式：kill -signal %jobnumber 选项与参数： signal：代表后面的接的任务有什么样的指示，下面列举几个常用的信号 -1：重新读取一次参数的配置文件； -2：表示有键盘输入【ctrl-c】同样的操作； -9：立刻强制删除一个任务； -15：以正常的进程方式终止一项任务； -9这信号通常是在【强制删除一个不正常的任务】是使用的，-15则是以正常步骤结束一项任务，这个信号也是默认值； 脱机运行 通常登录系统，系统会给当前的登录账号一个终端进程，在这个终端下运行的进程，如果终端退出则这些进程也会同时退出，所以Linux才有脱机管理。 如果需要退出系统后让进程继续运行，则需要使用nohup命令 命令格式：nohup [命令与参数] 在终端前台任务 ​ nohup [命令与参数] &amp; 在终端后台任务 nohup命令并不支持bash内置命令,所以命令只能是外部命令。 进程管理查看进程 将某个时间点的进程运行情况截取下来：ps ps aux：查看系统所有的进程 参考资料","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"SQL基础（一）","slug":"数据库/mysql/SQL基础","date":"2019-03-27T05:04:38.000Z","updated":"2020-05-11T08:49:10.687Z","comments":true,"path":"2019/03/27/数据库/mysql/SQL基础/","link":"","permalink":"http://yoursite.com/2019/03/27/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/SQL%E5%9F%BA%E7%A1%80/","excerpt":"","text":"这篇文章主要以MySQL数据库进行讲解 在阅读本文之前假设已经安装MySQL数据库。请先构建好数据源，如果没有安装MYSQL数据库可以通过下面的在线网站构建数据源并练习SQL语句 SQL在线练习网站：http://sqlfiddle.com/ 源数据下载：https://forta.com/wp-content/uploads/books/0672327120/mysql_scripts.zip SQL语言分类SQL语言主要分为三类： DML（Data Manipulation Language）：数据操作语言，常用的增删改查就属于DML，操作的对象是数据表中的对象。 DDL（Data Definition Language）：数据定义语言。建表，建立数据库就属于DDL DCL（Data Control Language）：数据控制语言，提交回滚，数据库安全管理等属于DCL 本文将逐一介绍这三个SQL语言分类的简单讲解。 检索数据SELECT语句123456789101112131415161718#建products表并插入数据CREATE TABLE products( prod_id char(10) NOT NULL, vend_id int NOT NULL , prod_name char(255) NOT NULL , prod_price decimal(8,2) NOT NULL , prod_desc text NULL , PRIMARY KEY(prod_id)) ENGINE=InnoDB;INSERT INTO products(prod_id, vend_id, prod_name, prod_price, prod_desc)VALUES('ANV01', 1001, '.5 ton anvil', 5.99, '.5 ton anvil, black, complete with handy hook');INSERT INTO products(prod_id, vend_id, prod_name, prod_price, prod_desc)VALUES('ANV02', 1001, '1 ton anvil', 9.99, '1 ton anvil, black, complete with handy hook and carrying case');INSERT INTO products(prod_id, vend_id, prod_name, prod_price, prod_desc)VALUES('OL1', 1002, 'Oil can', 8.99, 'Oil can, red');INSERT INTO products(prod_id, vend_id, prod_name, prod_price, prod_desc)VALUES('FU1', 1002, 'Fuses', 3.42, '1 dozen, extra long'); 检索单个列语法：SELECT 列名 FROM 表名 检索prod_name列 12345678SELECT prod_name FROM products;#结果为| prod_name ||--------------|| .5 ton anvil || 1 ton anvil || Fuses || Oil can | 上面的语句利用SELECT语句从products表中检索一个列为prod_name。所需列名在SELECT关键字后面给出，FROM关键字指定要从哪个表检索数据 检索多个列语法：SELECT 列名1,列名2... FROM 表名 要从一个表中检索多个列，使用SELECT语句，后面键入多个列名，列名之间必须以逗号隔开 当心逗号：在选择多个列时，一定要在列名之间加逗号，最后一个列名之后不用加 还是以上面的数据源为例，检索prod_id、prod_name两列 12345678SELECT prod_id,prod_name FROM products;#其结果如下：| prod_id | prod_name ||---------|--------------|| ANV01 | .5 ton anvil || ANV02 | 1 ton anvil || FU1 | Fuses || OL1 | Oil can | 检索所有列语法：SELECT * FROM 表名 检索所有列时，给定一个通配符（*）,则会检索表中的所有列。 1234SELECT * FROM products;prod_id | vend_id | prod_name | prod_price | prod_desc ANV01 | 1001 | .5 ton anvil | 5.99 | .5 ton anvil, black ANV02 | 1001 | 1 ton anvil | 9.99 | 1 ton anvil, black 检索不同的行（DISTINCT）语法：SELECT DISTINCT 列名 FROM 表名 要检索出有不同值的列表，使用DISTINCT关键字，此关键字必须直接放在列名的前面。此关键字指示MySQL只返回不同的值，这里的DISTINCT不能部分使用，它应用于所有列而不仅是前置它的列。 12345SELECT DISTINCT vend_id FROM products;| vend_id ||---------|| 1001 || 1002 | 限制结果（LIMIT）限制返回的行数。可以有两个参数，第一个参数为起始行，从 0 开始；第二个参数为返回的总行数。 语法： 123SELECT 列名1,列名2,... FROM 表名LIMIT starts,count; count：检索取多少行 starts：从第几行开始，注意这里的开始行从0开始 返回前五行： 1SELECT * FROM products LIMIT 5; 1SELECT * FROM products LIMIT 0,5 带一个值的LIMIT总是从第一行开始，给出的数为返回的行数。带两个值的LIMIT可以指定从行号为第一个值的位置开始。 过滤数据使用WHERE子句在SELECT语句中，数据根据WHERE子句中指定的搜索条件进行过滤。WHERE子句在表名后给出。在同时使用ORDER BY和WHERE子句时，应该让ORDER BY位于WHERE之后 WHERE子句操作符语法： 123SELECT 列名1,列名2,... FROM 表名WHERE 条件 MYSQL支持以下所有条件操作符： 操作符 说明 = 等于 &lt;&gt; 不等于 != 不等于 &lt; 小于 &lt;= 小于等于 &gt; 大于 &gt;= 大于等于 BETWEEN 在指定的两个值之间 IS NULL 为NULL值 过滤单个值过滤prod_name=’fuses’的数据 123SELECT prod_name,prod_priceFROM productsWHERE prod_name='fuses'; 过滤价格小于10元的数据 123SELECT prod_name,prod_priceFROM productsWHERE prod_price&lt;10; 过滤价格小于等于10元的数据 123SELECT prod_name,prod_priceFROM productsWHERE prod_price&lt;=10; 过滤不匹配过滤vend_id不是1002的数据 123SELECT prod_name,prod_priceFROM productsWHERE vend_id != 1002; 如果条件值为字符串类型，则需要引用引号，如果条件值为数值类型，则不需要引用引号 过滤范围值(BETWEEN)如果需要检查某个范围的值，可以使用BETWEEN操作符。其语法与其他WHERE子句的操作符不同。BETWEEN需要两个值，过滤范围的开始值和结束值。在范围使用BETWEEN时，必须指定两个值——所需范围的低端值和高端值。这两个值必须用AND关键字分隔。BETWEEN匹配范围中的所有值，包括指定的开始值和结束值。 过滤价格在5元和10元之间的所有产品 123SELECT prod_name,prod_priceFROM productsWHERE prod_price BETWEEN 5 AND 10; 空值过滤(IS NULL)WHERE子句 IS NULL用来检查具有NULL值的列。 123SELECT prod_nameFROM productsWHERE prod_price IS NULL; 组合WHERE子句AND操作符为了通过不止一个列在过滤，可使用AND操作符给WHERE子句附加条件，用来指示检索满足所有给定的条件的行。 案例： 123SELECT prod_id,prod_price,prod_nameFROM productsWHERE vend_id = 1003 AND prod_price &lt;= 10; OR操作符：用于过滤检索匹配任意一条件的行 123SELECT prod_id,prod_price,prod_nameFROM productsWHERE vend_id = 1003 OR prod_price &lt;= 10; IN操作符IN操作符用于指定条件范围，范围中每个条件都可以进行匹配。IN在WHERE中用来指定匹配值的关键字，功能与OR相当 1234SELECT prod_name,prod_priceFROM productsWHERE vend_id IN(1002,1003)ORDER BY prod_name; IN操作符的优点如下： 当需要匹配的值比较多时，IN操作符的语法更清楚且更直观； IN操作符一般比OR操作符执行更快； 在使用IN时，计算的次序更容易管理； IN的一最大优点就是可以包含其他SELECT语句，使得能够更动态地建立WHERE子句； NOT操作符：NOT用在WHERE子句中，用来否定后跟的条件表达式，MYSQL中的NOT，支持NOT对IN，BETWEEN和EXISTS子句取反。 参考资料 《MySQL必知必会》人民邮电出版社 《MySQL 从入门到精通》清华大学出版社","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"},{"name":"sql","slug":"sql","permalink":"http://yoursite.com/tags/sql/"}]},{"title":"Linux账号管理与权限设置","slug":"Linux/Linux账号管理与权限设置","date":"2019-03-21T09:47:17.000Z","updated":"2020-03-21T09:52:13.908Z","comments":true,"path":"2019/03/21/Linux/Linux账号管理与权限设置/","link":"","permalink":"http://yoursite.com/2019/03/21/Linux/Linux%E8%B4%A6%E5%8F%B7%E7%AE%A1%E7%90%86%E4%B8%8E%E6%9D%83%E9%99%90%E8%AE%BE%E7%BD%AE/","excerpt":"","text":"参考资料","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"文件与文件系统压缩","slug":"Linux/文件与文件系统压缩","date":"2019-03-20T06:42:11.000Z","updated":"2020-03-21T09:50:50.125Z","comments":true,"path":"2019/03/20/Linux/文件与文件系统压缩/","link":"","permalink":"http://yoursite.com/2019/03/20/Linux/%E6%96%87%E4%BB%B6%E4%B8%8E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%8E%8B%E7%BC%A9/","excerpt":"","text":"Linux系统常见的压缩命令123456789*.z compress程序压缩的文件；*.zip zip程序压缩的文件；*.gz gzip程序压缩的文件；*.bz2 bzip2程序压缩的文件；*.xz xz程序压缩的文件；*.tar tar程序打包的文件，并没有压缩过；*.tar.gz tar程序打包的文件，并经过gzip的压缩*.tar.bz2 tar程序打包的文件，并经过bzip2的压缩*.tar.xz tar程序打包的文件，并经过xz的压缩 gzip，zcat gzip可以说是应用最广泛的压缩命令。下面介绍这些命令; gzip [-cdtv#] 文件名 选项和参数： -c：将压缩的数据输出到屏幕上，可通过数据流重定向来处理； -d：解压缩的参数 -t：可以用来检验一个压缩文件的一致性，看看文件是否有误 -#：#表示压缩级别，-1最快，但压缩比最差，-9最慢，压缩比最好，默认为-6 xz，xzcat 命令格式 xz [-dtlkc#] 文件名 xcat 文件名.xz 选项与参数: -d：解压缩； -t：测试压缩文件的完整性； -l：列出压缩文件的相关信息； -k：保留原本文件不删除 -c：将数据在屏幕上输出 -#：压缩级别 打包名命名：tar命名格式：tat [-z][-j][-J][cv][-f 待建里的文件名] filename ...：打包与压缩tar [-z][-j][-J][tv][-f 既有的tar文件名]：查看文件名tar [-z][-j][-J][xv][-f 既有的tar文件名] [-C 目录]：解压缩选项与参数：-c：建立打包文件，可搭配-v来查看过程中被打包的文件名；-t：查看打包文件的内容含有哪些文件名，重点看文件名；-x：解包或解压缩，可以搭配-C在特定目录解压；-z：通过gzip的支持进行压缩/解压缩：此时文件名最好为*.tar.gz；-C 目录：若要在特定目录解压缩，可以使用这个选项；-f finame：-f后面要立刻接要被处理的文件名--exclude=FILE：在压缩过程中，不要将FILE打包注意：-c、-t、-x不可同时出现常使用的命令组合：tar -zcvf filename.tar.gz、tar -jcvf filename.tar.bz2：压缩tar -ztvf filename.tar.gz、tar -jtvf filename.tar.bz2：查询tar -zxvf filename.tar.gz -C 目录、tar -jxvf filename.tar.bz2 -C 目录：解压缩 常见的压缩与备份工具dd命令格式：dd if=input_file of=output_file bs=block_size count=number 选项与参数： if：输如设备 of：输出设备 bs：设置的一个block的大小，若未指定则默认是512Bytes（一个扇区大小） count：多少个bs 参考资料","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"Linux的文件与目录管理","slug":"Linux/Linux的文件与目录管理","date":"2019-03-18T13:40:17.000Z","updated":"2020-03-21T06:31:51.518Z","comments":true,"path":"2019/03/18/Linux/Linux的文件与目录管理/","link":"","permalink":"http://yoursite.com/2019/03/18/Linux/Linux%E7%9A%84%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/","excerpt":"","text":"目录相关操作对于目录相关的命名首先要介绍的一个命令是目录切换命令：cd 还有一些比较特殊的目录： .：代表此层目录； ..：代表上一层目录； -：代表前一个工作目录； ~：代表目前使用者身份所在的家目录 ~account：代表account这个使用者的家目录 处理目录的命令： cd（change directory）：切换目录 命令格式：cd [相对路径或绝对路径] 利用相对路径的写法必须确认的目前的路径才能正确地去到想要的目录 下面看几个例子 123456789101112131415##切换到tmp目录$ cd /tmp$ pwd/tmp##回到家目录$ cd ~$ pwd/root##回到上一次的工作目录$ cd -/tmp##当前的工作目录在/tmp，回到上一级目录$ cd ..$ pwd/ pwd（显示目前所在的目录） 命令格式：pwd [-p] ​ 选项与参数：-p：显示出真正的目录，而非使用链接路径 mkdir：建立新目录 命令格式 mkdir [-mp] 目录名称 选项与参数： -m：设置文件的权限。直接设置，不需使用默认权限（umask） -p：递归创建子目录 下面举几个例子： 12345#在当前的工作目录下创建test0目录$ mkdir test0drwxr-xr-x 2 root root 4096 Mar 19 16:58 test0##在当前的工作目录下递归创建test1/test2/test3这样的多层目录$ mkdir -p test1/test2/test3 一般创建目录大都是使用默认权限（umask），mkdir可以在创建目录时可以指定权限，例如： 12$ mkdir -m 711 test2drwx--x--x 2 root root 4096 Mar 19 17:07 test2 rmdir：删除“空”目录命令格式：rmdir [-p] 目录名称被删除的目录里不能存在其他的文件和目录，如果想要一次性删除一个目录以及该目录其下的子目录可以使用rm -rf 目录名称,但这样不是太安全，还是使用rmdir比较安全。 文件与目录管理文件与目录查看：ls命名格式：ls [-adlh] 文件名或目录名称 选项参数： -a：全部的文件，包括隐藏文件（开头为.的文件）一起列出 -d：仅列出目录本身，而不是列出目录内的文件数据 -h：将文件大小以及人类易读的方式（GB，KB，MB）列出 -l：详细信息显示，包括文件的属性与权限等数据 12345678910##列出root目录下的所有文件$ ls -al ~dr-xr-x---. 9 root root 4096 Mar 19 17:07 .dr-xr-xr-x. 18 root root 4096 Mar 14 16:57 ..-rw------- 1 root root 5185 Mar 18 23:42 .bash_history······drwxr-xr-x 2 root root 4096 Mar 19 16:58 test0drwxr-xr-x 3 root root 4096 Mar 19 17:00 test1drwx--x--x 2 root root 4096 Mar 19 17:07 test2-rw-rw-rw- 1 root root 0 Mar 18 01:49 test.txt 12345678910##列出root目录下的所有文件,以人类易读的方式$ ls -alh ~dr-xr-x---. 9 root root 4.0K Mar 19 17:07 .dr-xr-xr-x. 18 root root 4.0K Mar 14 16:57 ..-rw------- 1 root root 5.1K Mar 18 23:42 .bash_history······drwxr-xr-x 2 root root 4.0K Mar 19 16:58 test0drwxr-xr-x 3 root root 4.0K Mar 19 17:00 test1drwx--x--x 2 root root 4.0K Mar 19 17:07 test2-rw-rw-rw- 1 root root 0 Mar 18 01:49 test.txt 复制、删除、移动：cp、rm、mv cp:复制文件或目录 命令格式：cp [-ipr] 源文件（source） 目标文件（dest） 选项与参数： -a：参考下面的-dr选项 -d：若源文件为链接文件属性，则复制链接文件属性而非文件本身 -i：若目标文件已经存在，在覆盖时会先询问操作的进行 -p：连同文件的属性一起复制，不使用默认属性 -r：递归复制，用于目录的复制操作 在默认的条件中，cp的源文件与目标文件的权限是不同的，目标文件的拥有者通常会是命令操作本身。 rm（删除文件或目录） 命令格式：rm [-fir] 文件或目录 选项与参数： -f：强制的意思 -I：交互模式，在删除之前会询问使用是否操作 -r：递归删除 通常这个命令在使用时要十分小心，在删除前要认真确定删除的文件或目录是否正确，避免误删除的情况 1234#删除test1文件夹#连同目录下的所有子目录一并强制删除$ rm -rf test1 #删除文件也是如此 mv（移动文件与目录或重命名） 命令格式：mv [-fiu] source dest 选项与参数： -f：强制执行 -i：若目标文件已经存在，会询问是否覆盖 -u：若目标文件已存在，且source比较新，才会更新 这里举几个例子： 将test.txt文件移动到test0文件夹中 123$ mv test.txt test0$ ls test0test.txt 将test0文件夹重命名为test3 123$ mv test0 test4$ ls .test3 修改文件时间或创建新文件：touch 命令格式：touch [-acdmt] 文件名 选项与参数： ​ -a：仅自定义access time； ​ -c：仅修改文件时间，若该文件不存在则不创建新文件； ​ -d：后面可以接想要自定义的日期而不用目前的日期； ​ -m：修改mtime ​ -t：后面可以接想要自定义的时间而不是使用目前的日期，格式为[YYYYMMDDhhmm] touch命令最常用的情况是： 创建一个空文件 将某个文件日期自定义为目前 举几个例子： 123456#创建一个空文件$ touch test1-rw-r--r-- 1 root root 0 Mar 21 12:03 test1#修改日期为：2020/02/21 00:00$ touch -t 202002210000 test1-rw-r--r-- 1 root root 0 Feb 21 00:00 test1 文件与目录的默认权限与隐藏权限文件默认权限：umaskumask是指定目前用户在创建文件或者目录时的权限默认值。 12345#使用umask查看默认权限$ umask0022 //与一般权限有关的是后面三个数字$ umask -Su=rwx,g=rx,o=rx 默认情况下： 若用户创建文件则默认没有（x）执行权限，也就是只有rw这两个项目,也就是最大为666，默认权限为： -rw-rw-rw- 若用户创建目录则由于x是与是否可以进入目录有关的，因此默认为所有权限均开放，即777 drwxrwxrwx umaks的数字指的是该默认值需要减掉的权限 通过上面umask=0022进行说明。因为umask=0022，user没有被拿掉任何权限，group与others的权限被拿掉了2（也就是w权限）（r、w、x每个权限的数字在《Linux文件权限与目录简介》一篇中介绍过）那么用户： 创建文件时：（-rw-rw-rw-）-（- - - - - w - - w -）==&gt; - rw-r- -r- - ,最后创建文件时的权限：666-022=644 创建目录时：（drwxrwxrwx）-（d - - - - w- - w-）==&gt; drwxr-xr-x最后创建目录时的权限：777-022=755 创建一个文件和一个目录： 1234567891011$ umask0022$ touch test0666-022=644-rw-r--r-- 1 root root 0 Mar 21 12:49 test0 6 4 4#创建目录$ mkdir test.d777-022=755drwxr-xr-x 2 root roo 4096 Mar 21 12:53 test.d 7 5 5 文件隐藏属性 配置文件隐藏属性：chattr [+-=][ASacdistu] 文件或目录名称 常用选项与参数：+：增加某个特殊参数，其他原本存在参数不动；-：减少某个特殊参数，其他原本存在参数不动；=：直接设置参数，且仅有后面接的参数；a：当设置这个a之后，这个文件将只能增加数据，而不能删除也不能修改数据，只有root才能设置这个属性；i：当设置i之后，可以让一个文件不能被删除、改名、设置链接也无法写入或新增数据； 12345$ touch test23$ chattr +i test23$ rm -rf test23#不能删除rm: cannot remove test23：Operation not permitted 显示文件隐藏属性：lsattr [-adR] 文件或目录 选项与参数： -a：将隐藏文件的属性显示出来 -d：如果接的目录，仅列出目录本身的属性而非目录内的文件名 -R：连同子目录的数据也一并列出来 接着上面的例子： 12$ lsattr -aR test23----i--------e-- test23 命令与文件的查找脚本文件查找 查找执行文件：which [-a] command 选项或参数： -a：将所有由PATH目录中可以找到的命令均列出，而不止第一个被找到的命令名称 这个命令是根据【PATH】这个环境变量所规范的路径，去查找执行文件的文件名。 文件查找 由一些特定的目录中查找文件：whereis [-bmsu] 文件或目录 选项与参数： -l：可以列出whereis会去查询的几个主要目录； -b：只找binary（二进制）格式文件； -m：只找在说明文件manual路径下的文件； -s：只找source源文件； -u：查找不在上述三个项目当中的其他特殊文件； locate [-ir] keyword 选项与参数： -i：忽略大小写的差异； -c：不输出文件名，计算找到的文件数量； -l：仅输出几行的意思； -S：输出locate所使用的数据库文件的相关信息，包括该数据库记录文件/目录数量等； -r：后面可接正则表达式的显示方式； find [PATH] [option] [action]没事别用这个命令神慢~ 参考资料 《鸟哥的Linux私房菜—基础学习篇（第四版）》 鸟哥著 人民邮电出版社","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"Linux文件权限与目录简介","slug":"Linux/Linux文件权限与目录简介","date":"2019-03-16T09:52:07.000Z","updated":"2020-03-21T03:49:47.441Z","comments":true,"path":"2019/03/16/Linux/Linux文件权限与目录简介/","link":"","permalink":"http://yoursite.com/2019/03/16/Linux/Linux%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E4%B8%8E%E7%9B%AE%E5%BD%95%E7%AE%80%E4%BB%8B/","excerpt":"","text":"Linux文件权限与文件属性Linux文件属性先来看下面的Linux文件属性信息: 12-rw-r--r--. 1 root root 29 Nov 18 00:00 test.txtdrwxr-xr-x. 4 root root 39 Oct 8 14:39 opt 第一栏代表这个文件的类型与权限 第一个字符代表这个文件是目录、文件或是链接文件等 当为[d]则为目录，例如像上面的文件名【opt】就是一个目录 当为[-]则是文件，例如像上面的文件名【test.txt】就是一个文件 当为[l]则是链接文件 当为[b]则是设备文件里面的可供存储的周边设备 当为[c]则是设备文件里面的串行端口设备 上面图片中后面的三个组表示文件拥有者、文件所属用户组、其他人的文件权限 1234r 可读w 可写x 可执行- 无权限 第一组为文件拥有者可具备的权限。 第二组为加入此用户组的账号的权限 第三组为非本人且没有加入本用户组的其他账号的权限 第二栏表示多少文件名链接到此节点 第三栏表示这个文件或目录的拥有者账号 第四栏表示这个文件的所属用户组 第五栏为这个文件的容量大小，默认单位为Bytes，如果想看更人性化的可以输入ls -alh 第六栏为这个文件创建日期或是最近修该日期 第七栏为文件名，如果文件名之前多一个.,则代表这个文件为隐藏文件。 如何修改文件属性与权限 几个修改用户组、拥有者、各种身份的权限命令 chgrp：修改文件所属用户组 chown：修改文件拥有者 chmod：修改文件的权限，SUID、SGID、SBIT等的特性 修改所属用户组：chgrp修改一个文件的用户组直接使用chgrp命令修改即可，这个命令就是change group的缩写 命令格式： 12chgrp [-R] [系统用户] dirname/filename ... -R：进行递归修改， 现在系统中有yang这个用户，将test.txt文件的用户组修改为yang 12345$ -rw-r--r--. 1 root root 29 Nov 18 00:00 test.txt$ chgrp yang test.txt$ ls -al#已经将test.txt文件的所属用户组修改为yang$ -rw-r--r--. 1 root yang 29 Nov 18 00:00 test.txt 修改文件拥有者：chown要修改文件为指定的用户，系统里必须有这个指定用户账号 命名格式： 123chown [-R] 账号名称 文件或目录chown [-R] 账号名称:用户组名称 文件或目录-R：进行递归修改，如果要连目录下的所有子目录或文件同时更改文件拥有者的话，加上-R选项即可 还是上面的那个test.txt文件，将其的文件拥有者修改为yang 1234567$ -rw-r--r--. 1 root yang 29 Nov 18 00:00 test.txt$ chown yang test.txt$ ls -al$ -rw-r--r--. 1 yang yang 29 Nov 18 00:00 test.txt#将test.txt的拥有者和用户组修改回root$ chown root:root test.txt$ -rw-r--r--. 1 root root 29 Nov 18 00:00 test.txt chown也可以使用【chown user.group file】,在拥有者与用户组间加上【.】也可以修改。 目录与文件权限的意义 权限对文件的重要性权限对于文件来说，意义是这样的： r（read）：可读取此文件的实际内容 w（write）：可以编辑、新增或是修改该文件的内容（但不可以删除该文件哦） x（eXecute）：该文件具有可以被系统执行的权限 在Linux下面，文件是否有执行能力，是根据是否具有【x】这个权限来决定的，和文件名没有绝对的关系 权限对目录的重要性目录的主要内容在记录文件名列表，文件名与目录有强烈的关联。对于目录，r、w、x的意义如下： r：表示具有读取目录结构列表的权限，所有当具有读取一个目录的权限（r）时，表示可以查询该目录下的文件名的数据。 w：这个是对于目录的可写入权限，表示用户具有改动改目录结构列表的权限。也就是下面这些权限： 建立新的文件与目录 删除已经存在的文件与目录 将已存在的文件或目录进行更名 移动该目录内的文件、目录位置 x： 目录的x表示的是当前用户能否进入该目录成工作目录。就是说可以通过cd命令切换到改目录下。如果当前用户在某目录下不具有x的权限，那么就无法切换到改目录下，也就无法在改目录下进行任何操作，即使有该目录的r和w权限也不好使。 注意：要开放目录给任何人浏览时，应该至少也要给予r及x权限 修改文件权限：chmod命名格式语法： 123chmod [-R] xyz 文件或目录 xyz：数字类型的权限属性,为rwx属性值相加的值 -R：进行递归 文件权限修改有两种方式：使用数字或者符号来进行权限修改。 数字类型修改文件权限 Linux文件的基本权限有九个，分别是拥有者(owner)，所属群组（group）、其他人（others）三种身份各有自己的读（r）、写（w）、执行（x）权限。 拿上面介绍的文件权限那样，文件权限字符为：【-rwx rwx rwx】九个权限三个一组。 可以使用数字来代表各个组的权限： r：4 w：2 x：1 三种身份（拥有者(owner)、所属群组(group)、其他人（others））各自的三个权限（r，w，x）数字是需要累加的。例如前面提到的test.txt文件如下： 1-rw-r--r--. 1 root root 29 Nov 18 00:00 test.txt 权限为：【-rw-r–r–】的数字则是：644 123owner = rw = 4+2 = 6group = r = 4others = r = 4 接下来用chmod命令将该文件的是三种身份的权限数字设置为770owner = rwx = 4+2+1 = 7group = rwx = 4+2+1 = 7;others = - - - = 0 123$ chmod 770 test.txt$ ls -al test.txt-rwxrwx--- 1 root root 29 Nov 18 00:00 test.txt 如果要将文件变成可执行的文件，并且不要让其他人修改文件的话，那就需要-rwxr-xr-x这样的权限，此时就要执行 chmod 755 fileName命令。 符号类型修改文件权限 符号类型修改文件权限可以借由(user)u，(group)g，(others)o,来代表三种身份的权限，此外a则代表all全部的身份，读写权限可以写成r、w、x chmod [u、g、o、a] [+（加入）、-（移除）、=（设置）] [r、w、x] 文件或目录 例如要把上面的test.txt设置成【-rwxr-xr-x】时： 12345$ ls -al test.txt-rwxrwx--- 1 root root 0 Mar 18 00:00 test.txt$ chmod u=rwx,go=rx test.txt$ ls -al-rwxr-xr-x 1 root root 0 Mar 18 00:00 test.txt 如果想为每身份加入w权限 123$ chmod a+w test.txt$ ls -al test.txt-rwxrwxrwx 1 root root 0 Mar 18 00:00 test.txt 如果想为每身份移除x权限 123$ chmod a-x test.txt$ ls -al test.txt-rw-rw-rw- 1 root root 0 Mar 18 01:49 test.txtLinux目录树执行文件路径的变量：$PATHPATH这个变量的内容是由一堆目录所组成，每个目录中间用冒号（:）来隔开，每个目录有顺序之分。就像下面的格式 1/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin:/usr/local/python37/bin 目录树的主要特征： 目录树的起始点为根目录（/，root）； 每个目录不止能使用本地区分的文件系统，也可以使用网络的文件系统； 用NetWork File System(NFS)服务器挂载某特点的目录 每个文件在此目录树中的文件都是独一无二的； 下面是目录树构架示意图（关于目录树更详细的说明，参考《鸟哥的Linux私房菜—基础学习篇（第四版）》第五章5.3节的FHS标准说明） 绝对路径与相对路径根据文件名写法的不同，也可将所谓定义为绝对路径与相对路径。这两种文件名路径写法依据如下： 绝对路径：由根目录（/）开始写起的文件名或目录名称； 相对路径：相对于目前所处在的目录的文件名写法，例如：../dir1、../dir1/opt等 ..代表上一层目录，也可以使用../来代表 .代表当前目录，也可以使用./来代表 参考资料 《鸟哥的Linux私房菜—基础学习篇（第四版）》 鸟哥著 人民邮电出版社","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"初识Linux","slug":"Linux/Linux基础","date":"2019-03-15T14:20:39.000Z","updated":"2020-05-06T06:30:21.139Z","comments":true,"path":"2019/03/15/Linux/Linux基础/","link":"","permalink":"http://yoursite.com/2019/03/15/Linux/Linux%E5%9F%BA%E7%A1%80/","excerpt":"","text":"什么是Linux?Linux就是一个操作系统(手动狗头) Linux几个常用的命令 cd dir：跳转到指定文件夹 123456跳转到root目录$ cd ~跳转到之前目录$ cd -跳转到上级目录$ cd .. cd 后面还可以文件夹绝对路径或相对路径跳转到指定目录 例如跳转到 /下的tmp目录 1$ cd /tmp pwd：查看当前所处的路径，输入pwd系统会返回当前所处的目录的绝对路径 ls -al：列出文件夹下的所有文件，包括隐藏文件 1$ ls -al 操作Linux系统几个重要的热键 [Tab]按键[Tab]按键就是在切换大小写按键[Casp Lock]上面的那个按键，它具有命令补全与文件补齐的功能。关键是可以避免打错命令或文件名。 这里总结一下 [Tab]接在一串命令的第一个字段后面，则为【命令补全】 [Tab]接在一串命令的第二个字段后面，则为【文件补全】 [Ctrl+c]按键有时候某些命令或程序在系统上一直“跑个不停”，想让命令或程序“停掉”时，可以用这个按键。输入:[Ctrl+c]按键，可以中断目前程序或命令。 [Ctrl+d]如果想要直接离开命令行模式，可以直接按下[Ctrl+d]就能直接离开（相当于输入exit） [Shift]+{Page Up}、[Shift]+{Page Down}按键使用[Shift]+{Page Up}向前翻页。使用[Shift]+{Page Down}先后翻页 正确的关机方法 正确的关机命令使用 几个与关机或重启相关命令 将数据同步写入硬盘的命令：sync 常用的关机命令：shutdown 重启、关机：reboot、halt、poweroff 数据同步写入磁盘：sync 使用sync命令进行数据的写入操作。在命令行下输入sync，那么在内存中尚未被更新的数据，就会被写入硬盘中。So 在关机或重启系统之前最好多执行几次 常用的关机命令：shutdown 这个是关闭Linux的命令，如果是root管理员可以使用。 1234567891011121314shutdown语法shutdown -[krhc] [时间] [警告信息] 选项与参数 -k：不是真的关机，只是发送警告信息出去。 -r：在将系统的服务停掉之后就重新启动（常用） -h：将系统的服务停掉后，立即关机（常用） -c：取消已经进行的shutdown命令内容 时间：指定系统关机的时间，设置时间的样式如下： shutdown -h 13:00 系统将在今天的13:00分关机 shutdown -h now 系统将立即关机 shutdown -r now 系统会立即重启 shutdown可以完成如下的工作： 可以自由选择关机模式：要是关机或重启均可； 可以设置关机时间：可以设置成现在立即关机，也可以设置某一个特定的时间关机； 可以自定义关机信息：在关机之前，可以将自己设置的信息发送给在线用户； 可以仅发出警告信息：有时有可能要进行一些测试，而不想让其他的用户干扰，或是明白的告诉用户某段时间要注意一下。 重启，关机：reboot、halt，poweroff 这三个命令可以进行重启与关机的操作。一般在关机或重启时，都会执行如下命令： 1sync;sync;sync;reboot 使用管理管理工具systemctl关机 在CentOS 7中可以使用systemctl来进行关机，实际上面介绍的关机与重启命令都是调用systemctl这个命令。 这个命令与关机的语法： 1234567systemctl [命令]命令项目有：haltpoweroffrebootsuspend //进入休眠模式# systemctl reboot #系统重启 参考资料 《鸟哥的Linux私房菜—基础学习篇（第四版）》 鸟哥著 人民邮电出版社","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"Java并发基础volatile关键字","slug":"java/并发编程/volitile关键字","date":"2018-07-22T11:16:24.000Z","updated":"2020-05-06T01:42:50.060Z","comments":true,"path":"2018/07/22/java/并发编程/volitile关键字/","link":"","permalink":"http://yoursite.com/2018/07/22/java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/volitile%E5%85%B3%E9%94%AE%E5%AD%97/","excerpt":"","text":"并发编程的三个重要特性 原子性 原子性指在一次的操作或多次的操作中，要么所有操作全部执行且不会受到任何因素的干扰而中断，要么所有操作全部不执行 可见性 当一个线程对共享变量进行修改，另外的线程可以立刻看到修改后的新值。 有序性 有序性是指程序代码在被执行过程中的先后顺序。Java编译器以及运行期的优化，导致代码的执行顺序未必就是在编写代码时的顺序。 关于volatile下面有必要说一下内存与CPU相关的知识 CPU Cache模型CPU的处理速度和内存访问速度之间差距很大，通过直连内存的方式会导致CPU资源受到限制，为了降低CPU整体的吞吐量，可在CPU和内存之间增加缓存的设计，目前缓存的数量可增加到3级，最靠近CPU的缓存称为L1，依次是L2，L3和主内存。CPU缓存模型如下： Cache的出现为了解决CPU直接访问内存效率低下的问题，CPU将运算所需的数据从主内存复制一份到CPU Cache中，CPU在计算时就可以直接对CPU Cache中的数据进行读取和写入，运算结束后，再将CPU Cache中的最新数据刷新回主内存中。 CPU缓存一致性问题缓存的出现极大提高CPU的吞吐能力，但也引入了缓存不一致的问题，为了解决缓存不一致性的问题，通常主流的解决方法有两种： 通过总线加锁的方式 通过缓存一致性协议 缓存一致性协议的大致思想：当CPU在操作Cache中的数据时，如果发现该变量是一个共享变量，在其他CPU Cache中存在一个副本，当进行如下操作时： 读取操作：不做任何处理，只将Cache中的数据读取到寄存器中 写入操作：发出信号通知其他CPU将该变量的Cache line置为无效状态，其他CPU进行该变量读取时，必须在主存中再次获取。 关于volatile关键字为了确保共享变量能够准确和一致性的更新，线程应该确保通过排他锁单独获取这个变量。Java提供了volatile关键字，如果一个字段被声明为volatile，多线程内存模型确保所有线程看到这个变量的值是一致的。 JMM内存模型java内存模型决定了一个线程对共享变量的写入何时对其他线程可见，java内存模型定义了线程和内存之间的抽象关系 共享变量存储于主内存中，每个线程都可以访问。 每个线程都有私有的工作内存或称为本地内存。 工作内存只存储该线程对共享变量的副本 线程不能直接操作主内存，只有先操作工作内存后才能写入主内存。 工作内存和Java内存模型一样也是一个抽象的概念，其实并不存在，它涵盖了缓存、寄存器、编译器优化以及硬件等。 在前面所说的并发编程的三大特性，JMM如何保证这三大特性 JMM与原子性 先介绍几种简单的赋值操作 (1) x = 1 (2) y = x (3) y++ (4) z = z+1 在上面的四类赋值操作中，只有第一种赋值操作具有原子性，其余均不具备原子性。可以得出以下结论 多个原子性的操作在一起就不再是原子性操作 简单的读取与赋值是原子性，将一个变量赋值给另外一个变量的操作就不具备原子性 JMM只保证基本读取和赋值的原子性操作，其余的均不能保证，如果要使某些代码段具备原子性，需要使用关键字synchronized，或JUC中的lock。如果想要使得int等类型自增操作具备原子性封装类型atomic.* 最后volatile关键字不具备保证原子性的语义 在Java中可以通过锁和循环CAS的方式来实现原子操作 使用循环CAS实现原子性操作 JVM中的CAS操作利用处理器提供的指令CMPCHG实现，自旋CAS实现的基本思路是循环进行CAS操作直到成功为止。 CAS实现原子类操作的三大问题 ABA问题 因为CAS需要在操作值的时候，检查值有没有变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查的时候会发现它的值没有发生变化，但是实际发生了变化，ABA问题的解决思路就是使用版本号。在变量前面追加版本号，每次变量更新的时候把版本号加1，JDK中通过使用原子类AtomicStampedReference解决ABA问题 循环时间长开销大 自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。如果JVM能支持处理器提供的pause指令，那么效率在一定程度上提升 只能保证一个共享变量的原子操作 把多个共享变量合并成一个共享变量来操作。 123i = 2j = a合并 =&gt; ij = 2a 然后CAS来操作ij，JDK提供了AtomicReference类来保证引用对象之间的原子性，就可以把多个变量放入一个对象里来进行CAS操作 使用锁机制实现原子性操作 锁机制保证了只有获得锁的线程才能够操作锁定内存的区域。JVM内部实现了很多锁机制，有偏向锁、轻量锁、互斥锁。JVM实现锁的方式都用了循环CAS，即当一个线程进入同步块的时候使用CAS的方式来获取锁，当它退出同步块的时候使用循环CAS释放锁。 JMM与可见性 Java通过三种方式来保证可见性 使用关键字volatile，当一个变量被volatile关键字修饰时，对于共享资源的读操作会直接在主内存中进行（也可能会缓存到工作内存中，当其他线程对该共享资源进行修改，则会导致当前线程在工作内存中的共享资源失效，必须要在主内存中再次获取），对于共享资源的写操作当然是先要修改工作内存，但是修改结束后会立刻将其刷新进主内存中。 通过synchronized关键字能够保证可见性，synchronized关键字能够保证同一时刻只有一个线程获得锁，然后执行同步方法，并且还会确保在锁释放之前，会将对变量的修改刷新到主内存中。 通过JUC提供的显式锁Lock也能保证可见性，Lock的lock方法能够保证在同一时刻只有一个线程获得锁然后执行同步方法，并且会确保在锁释放（Lock的unlock方法）之前会将对变量的修改刷新到主内存中。 volatile关键字具有保证可见性的语义 JMM与有序性 在JMM中允许编译器和处理器对指令进行重排序，在当线程下并不会引起什么问题。在多线程下，重排序会影响到程序的正确运行。 Java提供了三种保证有序性的方式 使用volatile关键字来保证有序性。 使用synchronized关键字来保证有序性。 使用显式锁Lock来保证有序性 在JMM中具备一些自带的有序性规则，不需要任何同步手段就能够保证有序性，这规则称之为Happens-before原则。 重排序是什么 重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段。 三种类型的重排序 编译器优化重排序 编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序 指令级并行的重排序 现代处理器采用指令级并行技术来将多条指令重叠执行，如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。 内存系统的重排序 由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作来起来可能是在乱序执行 Happens-Before规则 程序次序规则：在一个线程内，代码按照编写时的次序执行，编写在后面的操作发生于编写在前面的操作之后。虚拟机还是可能会对程序代码的指令进行重排序，只要确保在一个线程内最终的结果和代码顺序执行的结果一致即可。 锁定规则：一个unlock操作要先行发生于对同一个锁的lock操作 volatile变量规则：对一个变量的写操作要早于对这个变量的读操 传递规则：如果操作A先于操作B，B操作先于C操作，则A操作一定先于C操作，说明Happens-Before 线程启动规则：Thread对象的start()方法先行发生于线程的任何动作，只有start后的线程才能真正运行，否则Thread只是一个对象。 线程中断规则：对线程执行interrupt()方法，肯定要优先于捕获到中断信号。 线程的终结规则：线程中断所有的操作都要先行发生于线程的终止检测，线程的任务执行，逻辑单元执行肯定要发生于线程死亡之前。 对象的终结规则：一个对象初始化的完成先行发生于finalize()方法之前。 volatile关键字具有保证顺序性的语义 volatile写读的内存语义 volatile写的内存语义 当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存 volatile读的内存语义 当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量 volatile写读的内存语义总结： 线程A写一个volatile变量，实质上是线程A向接下来将要读这个volatile变量的某个线程发出消息 线程B读一个volatile变量，实质上是线程B接收了之前某个线程发出的（在写这个volatile变量之前对共享变量所做修改的）消息 线程A写一个volatile变量，随后线程B读这个volatile变量，过程实质上是线程A通过主内存向线程B发送消息 volatile关键字语义被volatile修饰的实例变量或类变量具备两层语义： 保证不同线程之间对共享变量操作时的可见性，也就是说当一个线程修改volatile修饰变量，另外一个线程立即可看到新的值。 禁止对指令进行重排序操作。 volatile的原理和实现机制volatile关键字可以保证可见性以及顺序性，是如何做到的？ 观察OpenJDK源码就知道，被volatile修饰的变量存在于一个”lock;”前缀 Lock前缀指令在多核处理器下会引发两件事 将当前处理器缓存行的数据写回到系统内存 写回内存操作会使在其他CPU里缓存了该内存地址的数据无效 “lock;”前缀实际上相当于一个内存屏障，该屏障会为指令提供几个保障： 确保指令重排序时不会将后面的代码排到内存屏障之前 确保指令重排序时不会将其前面的代码排到内存屏障之后 确保在执行到内存屏障修饰的指令时前面的代码全部执行完成 强制在线程工作内存中值的修改刷新至主内存中 如果是写操作，则会导致其他线程工作内存中的缓存数据失效 volatile和synchronized的区别 使用上的区别 volatile关键字只能用于修饰实例变量和类变量，不能用于修饰方法以及方法参数和局部变量，常量等 synchronized关键字不能用于对变量的修饰，只能用于修饰方法或语句块 volatile修饰的变量可以为null，synchronized关键字同步语句块的monitor对象不能为null 对原子的保证 volatile无法保证原子性 由于synchronized是一种排他机制，因此被synchronized关键字修饰的同步代码块是无法被中途打断，因此其能够保证代码的原子性 对可见性的保证 俩者均可以保证共享资源在多线程间的可见性，但是实现机制完全不同 synchronized借助JVM指令monitorentry和monitorexit对通过排他的方式使得同步代码块串行化，在monitorexit时所有共享资源都将会被刷新到主内存中。 volatile使用机器指令“lock;”的方式迫使其他线程工作内存中的数据失效，必须到主内存中进行再次加载。 对有序性的保证 volatile关键字禁止JVM编译器以及处理器对其进行重排序，所以它能够保证有序性 虽然synchronized关键字所修改的同步方法也可以保证顺序性，但是这种顺序性是以程序的串行化执行换来的，在synchronized关键字所修改的代码块中代码指令也会发生指令重排序的情况 其他 volatile不会使线程陷入阻塞 synchronized关键字会使线程进入阻塞状态","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"java并发编程","slug":"java并发编程","permalink":"http://yoursite.com/tags/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}]},{"title":"Java并发编程","slug":"java/并发编程/Java并发基础1","date":"2018-04-06T10:39:51.000Z","updated":"2020-05-11T07:20:26.025Z","comments":true,"path":"2018/04/06/java/并发编程/Java并发基础1/","link":"","permalink":"http://yoursite.com/2018/04/06/java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%801/","excerpt":"","text":"线程生命周期 NEW – 新建 RUNABLE – 可运行 RUNING – 运行 BLOCKED – 阻塞 TERMINATED – 死亡 上面所列的是线程的生命周期 何为上下文切换 CPU通过时间片分配算法来循环执行任务，当前任务执行一个任务时间片后会切换到下一个任务，但是在切换之前将保存上一个任务的状态，以便下次切换回这个任务时，可以在再加载这个任务的状态，所以任务从保存再到加载的过程就是一次上下文切换。上下文切换也会影响多线程的执行速度 下面看一段代码： 1234567891011121314151617181920212223242526272829303132333435363738394041public class ConcurrencyTest &#123; private static final long count = 10000000000L; public static void main(String[] args) throws InterruptedException &#123; concurrency(); serial(); &#125; private static void concurrency() throws InterruptedException &#123; long start = System.currentTimeMillis(); Thread thread = new Thread(new Runnable() &#123; @Override public void run() &#123; int a = 0; for (long i = 0;i&lt;count;i++)&#123; a +=5; &#125; &#125; &#125;); thread.start(); int b= 0; for(long i = 0;i&lt;count;i++)&#123; b--; &#125; long time = System.currentTimeMillis()-start; thread.join(); System.out.println(\"concurrency:\"+time+\"ms,b = \"+b); &#125; private static void serial()&#123; long start = System.currentTimeMillis(); int a = 0; for (long i = 0;i&lt;count;i++)&#123; a+=5; &#125; int b = 0; for(long i = 0;i&lt;count;i++)&#123; b--; &#125; long time = System.currentTimeMillis()-start; System.out.println(\"serial:\"+time+\"ms,b= \"+b+\" a= \"+a); &#125; 上面的代码是比较串行与并发时的执行效果； 在测试中可以看到数据量在10万以下，并发的执行速度比串行的执行速度慢；在测试中可以看到数据量在100万以上时，并发的执行速度比串行的执行速度快约2倍。上面的结果是因为线程有创建和上下文切换的开销。 如何减少上下文切换减少上下文切换的方法有四种： 无锁并发编程：多线程竞争锁时，会引发上下文切换，所以多线程处理数据时，可以使用例如将数据ID按照Hash算法取模分段，不同的线程处理不同段的数据 CAS算法：Java的Atomic包使用CAS算法来更新数据，而不需加锁 使用最少线程：避免创建不需要的线程 协程：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。 参考资料","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"java并发编程","slug":"java并发编程","permalink":"http://yoursite.com/tags/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}]}]}