{"meta":{"title":"杨生华学习笔记本","subtitle":"","description":"","author":"杨生华","url":"http://yoursite.com","root":"/"},"pages":[{"title":"小杨的简介","date":"2020-02-11T09:43:56.848Z","updated":"2020-02-11T09:43:56.848Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"姓名:杨生华(楊生華)年龄:23 学历:吉林化工学院/本科 个人简介:从Java小白一枚自学两年的编程，学习过各种技术，虽说不能说精通这些技术，但对这些技术还是掌握的。 我是一名文科生,专业学的是日语，2017年八月误打误撞安装了JDK+JRE，并写下了第一行代码 HelloWorld。从此 走上了java开发的不归路。（技术方面还待整理） 个人爱好:空余时间听听轻音乐、跳绳、读小说、收藏书籍、写博客文章，偶尔也会独自去电影院看正在热映的电影。 联系方式: 微信： 电话:13944680832 个人博客： github空间：https://yangshenghua97.github.io/ GitHub：https://github.com/yangshenghua97/"},{"title":"Categories","date":"2020-02-09T08:10:17.612Z","updated":"2020-02-09T08:10:17.612Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2020-02-09T09:12:40.508Z","updated":"2020-02-09T08:10:17.625Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"里氏替换原则","slug":"设计模式/6大设计原则-里氏替换原则","date":"2020-03-08T07:04:15.000Z","updated":"2020-03-08T08:36:07.686Z","comments":true,"path":"2020/03/08/设计模式/6大设计原则-里氏替换原则/","link":"","permalink":"http://yoursite.com/2020/03/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/6%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99-%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99/","excerpt":"","text":"什么是里氏替换原则在《大话设计模式》中： 里氏替换原则（LSP）：子类型必须能够替换掉他们的父类型 一个软件实体如果使用的是一个父类的话，那么一定适用于其子类，而且他察觉不出父类对象和子类对象的区别，那就是说，在软件里面，把父类都替换成它的子类，程序的行为没有变化 只有当子类可以替换掉父类，软件单位的功能不受影响时，父类才能真正被复用，而子类也能够在父类的基础上增加新的行为 比方说，猫是继承动物类的，以动物的身份拥有吃喝跑叫等行为，如果需要扩展狗牛羊也拥有类似的行为，由于都是继承自动物类，所以除了更改实例化的地方，程序其他处无需改变 伪代码: 12345动物 animal = new 猫();animal.吃();animal.喝();animal.跑();animal.叫(); 由于子类型的可替换性才使得使用父类类型的模块在无需修改的情况下就可以扩展。 在《设计模式之禅》中是这样描述的： 如果对每种类型为S的对象o1，都有类型为T的对象o2，使得以T定义的所有程序P在所有的对象o1都代换o2时， 程序P的行为没有发生变化，那么类型S是类型T的子类型。 所有引用基类的地方必须能透明地使用其子类的对象。 参考资料","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式原则","slug":"设计模式原则","permalink":"http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8E%9F%E5%88%99/"}]},{"title":"Linux基础","slug":"Linux/Linux基础","date":"2020-03-07T14:20:39.000Z","updated":"2020-03-07T14:23:47.447Z","comments":true,"path":"2020/03/07/Linux/Linux基础/","link":"","permalink":"http://yoursite.com/2020/03/07/Linux/Linux%E5%9F%BA%E7%A1%80/","excerpt":"","text":"","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"6大设计原则-单一职责原则","slug":"设计模式/6大设计原则-单一职责原则","date":"2020-03-07T12:37:04.000Z","updated":"2020-03-08T07:01:18.055Z","comments":true,"path":"2020/03/07/设计模式/6大设计原则-单一职责原则/","link":"","permalink":"http://yoursite.com/2020/03/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/6%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99-%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99/","excerpt":"","text":"单一职责原则 单一职责(SRP)的定义： 就一个类而言，应该仅有一个引起它变化的原因。 在编程的时候，会不知不觉的给一个类添加各种各样的功能、算法等等，这就意味着这个类维护麻烦，复用不可能，高耦合性，缺乏灵活。 如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭受意想不到破坏。软件设计真正的要做的许多内容，就是发现职责就是并把那些职责相互分离。 其实要去判断是否应该分离出类来，并不难，如果能够想到多于一个的动机去改变一个类，那么这个类就具有多一个职责，那么就应该考虑类的职责分离 案例 许多项目，都会接触到用户，机构，角色管理这类模块，基本上都是使用RBAC模型(Role-Based Access Control)，其实要讲的例子如下面的类图 通过这个类图一眼就能看出接口设计得有问题。 下面我们拆分成两个接口。 现在面对接口编程，所以产生这个UserInfo对象之后，当然可以把它当作IUserBO接口使用，也可以当作IUserBiz接口使用。要获得用户信息，就当是IUserBO的实现类；要是希望维护用户的信息，就把它当作IUserBiz的实现类就可以。 123456789.....IUserInfo userInfo = new UserInfo();//给BO赋值可以认为它是一个单纯的BOIUserBO userBO = (IUserBO)userInfo();userBO.setPassWord(\"abc\");//执行动作，可以认为是一个业务逻辑类IUserBiz userBiz = (IUserBiz)userInfo();userBiz.deleUser();····· 单一职责原则的好处 类的复杂性降低，实现什么职责都有清晰明确的定义 可读性提高，复杂性降低，那就当然可读性提高 可维护性提高，可读性提高，那就当然更容易维护 变更引起的风险降低，变更是必不可少的，如果接口的单一职责做得好，一个接口修改只对相应的实现类有影响，对其他的接口无影响，这对系统的扩展性，维护性都有非常大帮助。 对于接口，我们在设计的时候一定要做到单一，但是对于实现类的需要多方面思考，硬套单一职责原则会引起类的剧增，给维护带来很多的麻烦，而且过分细分类的职责也会人为地增加系统的复杂性。 单一职责适用于接口、类、方法。一个方法尽可能做一件事，每个方法的职责非常清晰明确，开发简单，维护也方便。 参考资料 《设计模式之禅》作者：秦小波 机械工业出版社 《大话设计模式》作者：程杰 清华大学出版社","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式原则","slug":"设计模式原则","permalink":"http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8E%9F%E5%88%99/"}]},{"title":"数据结构与算法概述","slug":"数据结构/数据结构与算法概述","date":"2020-02-20T04:54:01.000Z","updated":"2020-02-20T04:59:17.058Z","comments":true,"path":"2020/02/20/数据结构/数据结构与算法概述/","link":"","permalink":"http://yoursite.com/2020/02/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%A6%82%E8%BF%B0/","excerpt":"","text":"","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"ArrayList的简介与实现","slug":"集合源码简单分析与实现/List/ArrayList的简介与实现","date":"2020-02-18T11:56:08.000Z","updated":"2020-02-19T11:01:36.306Z","comments":true,"path":"2020/02/18/集合源码简单分析与实现/List/ArrayList的简介与实现/","link":"","permalink":"http://yoursite.com/2020/02/18/%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E7%8E%B0/List/ArrayList%E7%9A%84%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"","categories":[{"name":"集合源码简单分析与实现","slug":"集合源码简单分析与实现","permalink":"http://yoursite.com/categories/%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E7%8E%B0/"}],"tags":[{"name":"集合源码简单分析与实现","slug":"集合源码简单分析与实现","permalink":"http://yoursite.com/tags/%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E7%8E%B0/"}]},{"title":"Git快速入门","slug":"git/Git快速入门","date":"2020-02-15T09:56:07.000Z","updated":"2020-02-15T09:33:10.140Z","comments":true,"path":"2020/02/15/git/Git快速入门/","link":"","permalink":"http://yoursite.com/2020/02/15/git/Git%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/","excerpt":"","text":"Git安装(Windowns系统为例) 下载Git软件: 点击链接:https://git-scm.com/ 双击！ 一路Next！ 最后怎么与Github关联将在其他篇章讲述 1 Git命令行git简单易用，只要在终端输入$ Git，Git就会不带任何参数输出它的选项和常用的子命令。 1234567891011121314151617181920212223242526272829303132$ git#输入git后会输出一下选项，如果要得到一个完整的git子命令列表，可以输入 git help --allusage: git [--version] [--help] [-C &lt;path&gt;] [-c &lt;name&gt;=&lt;value&gt;] [--exec-path[=&lt;path&gt;]] [--html-path] [--man-path] [--info-path] [-p | --paginate | -P | --no-pager] [--no-replace-objects] [--bare] [--git-dir=&lt;path&gt;] [--work-tree=&lt;path&gt;] [--namespace=&lt;name&gt;] &lt;command&gt; [&lt;args&gt;]These are common Git commands used in various situations:start a working area (see also: git help tutorial) clone Clone a repository into a new directory init Create an empty Git repository or reinitialize an existing onework on the current change (see also: git help everyday) add Add file contents to the index mv Move or rename a file, a directory, or a symlink reset Reset current HEAD to the specified state rm Remove files from the working tree and from the indexexamine the history and state (see also: git help revisions) bisect Use binary search to find the commit that introduced a bug grep Print lines matching a pattern log Show commit logs show Show various types of objects status Show the working tree statusgrow, mark and tweak your common history branch List, create, or delete branches checkout Switch branches or restore working tree files commit Record changes to the repository diff Show changes between commits, commit and working tree, etc merge Join two or more development histories togethercollaborate (see also: git help workflows) fetch Download objects and refs from another repository pull Fetch from and integrate with another repository or a local branch push Update remote refs along with associated objects ..... 2 Git使用快速入门 2.1创建初始版本库首先在git终端下创建一个空文件夹: 1234567#创建空文件夹 test/$ mkdir -p test/#进入到test文件夹$ cd test/#执行git init命令$ git initInitialized empty Git repository in /root/test/.git/ Git不会关心文件夹里是否为空，执行git init 命令创建了一个隐藏目录，在项目目录的顶层有个名为 .git文件夹，Git把所有修订的信息都放在这唯一的顶层目录里 2.2 将文件添加到版本库中执行 git init 命令时，Git版本库都是空的，为了管理内容，需要明确的把内容放入版本库中。 使用 git add file[^1] 将file添加到版本库中。 例如: 在 test目录中创建一个文件index.html并把该文件添加到版本库中 123$ cd test/$ touch index.html$ git add index.html [^1 ]: 如果目录中已经有很多的文件，使用git add .命令让Git把当前的目录及子目录中的文件都添加到版本库中 运行git status 命令显示中间状态的index.html 12$ git status# 这个命令显示新文件index.html将在下次提交时添加到版本库中 2.3 版本库内文件的删除和重命名 文件删除执行命令 git rm可以删除版本库里不需要的文件 操作如下: 12345# 查看版本库中的文件$ git ls-filesindex.html# 执行git rm index.html即可删除版本库中的index.html文件$ git rm index.html 文件重命名在终端执行git mv srcfile targetfile即可以完成文件的重命名 例如： 12345678# 先查看版本库中的文件$ git ls-filesindex.html# 执行git mv index.html foo.html 将index.html修改为foo.html$ git mv index.html foo.html# 再次查看版本库文件$ git ls-filesfoo.html","categories":[{"name":"git","slug":"git","permalink":"http://yoursite.com/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"Git提交","slug":"git/Git提交","date":"2020-02-15T08:54:50.000Z","updated":"2020-02-15T13:12:57.785Z","comments":true,"path":"2020/02/15/git/Git提交/","link":"","permalink":"http://yoursite.com/2020/02/15/git/Git%E6%8F%90%E4%BA%A4/","excerpt":"","text":"吧啦吧啦乱七八遭的东西在Git中，提交（commit）是用来记录版本库的变更的。当提交时，Git记录索引的快照并把快照放进对象库（简单的介绍）。提交的快照是串联在一起的，每张新的快照指向它的先驱。随着时间的推移，一系列的变更就表示一系列的提交。 Git提供一种机制来确定相对于另一个引用的提交，通常是分支的头。 在某些Git应用场景中，可能见过诸如这样的提交形式 master^ 。 在同一代提交中，插入符号 ^ 是用来选择不同的父提交。给定一个提交C，C^1 是其第一个父提交，C^2 是其第二个父提交，等等，如图: 通过把引用与^ 和 ~ 组合，就可从引用的提交历史图中选出任意提交 提交历史记录 查看旧提交 显示提交历史记录的主要命令是 git log,在参数形式上，git log跟git log HEAD是一样的，输出每一个可从HEAD找到的历史记录中的提交日志信息。变更从HEAD提交开始显示，并从提交图中回溯。如果使用git log 时提供一个提交名，那么这个日志将从该提交开始回溯输出。例如:git log master","categories":[{"name":"git","slug":"git","permalink":"http://yoursite.com/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"关于Git文件管理","slug":"git/关于Git文件管理","date":"2020-02-12T11:25:36.000Z","updated":"2020-02-13T13:17:37.170Z","comments":true,"path":"2020/02/12/git/关于Git文件管理/","link":"","permalink":"http://yoursite.com/2020/02/12/git/%E5%85%B3%E4%BA%8EGit%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/","excerpt":"","text":"git中的文件分类​ Git将所有文件分为3类：已追踪的、被忽略的以及未追踪的 已追踪的 已追踪的文件是指已经在版本库中的文件，或者是已暂存到索引中的文件。如果想将新文件newfile添加到已追踪的文件，执行 git add newfile即可 被忽略的 被忽略的文件必须在版本库中明确声明为不可见或被忽略，即使他可能会在工作目录中出现。一个软件项目通常都会有很多被忽略的文件。普通被忽略的文件包括临时文件、个人笔记、编译器输出文件以及构建过程中自动生成的大多数文件。Git维护一个默认的忽略文件列表，也可以配置版本库来识别其他文件。被忽略的文件会在后面介绍。 未追踪的 未追踪的文件是指那些不在版本库中的文件。 下面举一个栗子: 1234567891011121314151617181920$ git init#查看状态$ git status# On branch master## Initial commit#nothing to commit (create/copy files and use \"git add\" to track)#添加一个文件$ echo \"new Data\" &gt;&gt; data# On branch master## Initial commit## Untracked files:# (use \"git add &lt;file&gt;...\" to include in what will be committed)## datanothing added to commit but untracked files present (use \"git add\" to track) 为了让Git忽略目录中的文件，只需将该文件名添加到一个特殊的文件.gitignore中就可以了。 123456789101112131415161718192021222324252627$ touch main.o$ git status# On branch master## Initial commit## Untracked files:# (use \"git add &lt;file&gt;...\" to include in what will be committed)## data# main.onothing added to commit but untracked files present (use \"git add\" to track)#将 main.o添加到.gitignore中$ echo main.o &gt;&gt; .gitignore$ git status# On branch master## Initial commit## Untracked files:# (use \"git add &lt;file&gt;...\" to include in what will be committed)## .gitignore# datanothing added to commit but untracked files present (use \"git add\" to track) 这样main.o就已经被忽略了，但是git status现在显示一个新的未追踪的文件 .gitignore。 使用 git addgit add 命令将暂存一个文件。就Git文件分类而言，如果一个文件是未追踪的，那么git add就会将文件的状态转化为已追踪的。如果git add作用于一个目录名，那么该目录下的文件以及子目录都会递归暂存起来。 这里还接着上面的栗子: 123456789101112131415161718192021$ git status# On branch master## Initial commit## Untracked files:# (use \"git add &lt;file&gt;...\" to include in what will be committed)## .gitignore# datanothing added to commit but untracked files present (use \"git add\" to track)# 将data、.gitignore两个文件添加至已追踪的分类$ git add data .gitignore$ git status# On branch master# Initial commit# Changes to be committed:# (use \"git rm --cached &lt;file&gt;...\" to unstage)# new file: .gitignore# new file: data 在上面的栗子中使用git add后，暂存和追踪data和.gitignore文件，并准备下次提交是时添加到版本库中。 可以使用git ls-files命令查看隐藏在对象模型下的东西。 123$ git ls-files.gitignoredata 在任何编辑之后，提交变更之前，请执行一次git add命令。 使用 git commit使用 git commit –allgit commit 的 -a或者 --all选项会导致执行提交之前自动暂存所有未暂存的和未追踪的文件变化，包括从工作副本中删除已追踪的文件 下面举个栗子: 12345678910111213$ pwd/tmp/commit-all-example#创建测试版本库$ git initInitialized empty Git repository in /tmp/commit-all-example/.git/$ echo \"Testfile1\" &gt;&gt; ready$ echo \"Testfile2\" &gt;&gt; notyet$ git add ready notyet$ git commit -m \"Setup\"[master (root-commit) 2b00dbf] Setup 2 files changed, 2 insertions(+) create mode 100644 notyet create mode 100644 ready 之后再次编辑ready文件，并用 git add把它添加到版本库中。然后编辑notyet文件保持它是未暂存的。 在一个子目录下添加一个文件，但是不要对它执行git add命令 12$ mkdir subdir$ echo \"Nope\" &gt;&gt; subdir/new 当执行 git commit --all命令，Git会递归遍历整个版本库，暂存所有先前通过git add提交的已知的和修改的文件，然后提交它们，由于subdir/ 一个全新的目录，而且目录下没有任何文件名或路径通过git add和git commit进行操作的， So 即使是 –all选项也不能将其提交。 关于提交日志消息​ 如果不通过命令行直接提供日志消息（例如:git commit -m &quot;提交日志消息&quot;），Git会启动编辑器，并提示你写一个提交日志。 使用 git rm 命令​ git rm命令会在版本库中和目录中同时删除文件。 接着上面的栗子: 这里“意外”的添加了一个文件 1234$ echo \"Random\" &gt; oops#当执行git rm oops时，提示删除失败$ git rm oopsfatal: pathspec 'oops' did not match any files ​ 为什么会这样，可以通过git ls-files命令查看版本库中的文件 123$ git ls-filesnotyetready 现在的版本库中没有oops这个文件，可通过git add oops命令将 oops文件加入到版本库中。 12345$ git add oops$ git ls-filesnotyetoopsready 另外，要将一个文件由已暂存的转化为未暂存的,可以使用git rm --cached命令 比如要删除oops 12$ git rm --cached oopsrm 'oops' git rm --cached会删除索引中的文件并它文件保留在工作目录中，而git rm则会将文件从索引和工作目录中都删除。 如果想要删除一个已经提交的文件，通过简单的git rm filename命令来暂存这一请求 还可以使用 git rm -f来强制删除文件。 如果想保留的文件不小心删除了，可以通过版本控制系统的恢复功能进行恢复 具体的命令如下: 123# 加入不小心删除了oops文件# 可以是下面的命令进行恢复git checkout HEAD -- oops 使用 git mv如果想要给一个文件重命名可以使用git mv srcfile newfile，git mv 命令会将 srcfile文件的文件名称改为newfiles，Git会在索引中删除srcfile文件的路径名，并添加newfile的路径名，至于srcfile文件里的内容，Git仍然会保存在对象库中，然后才会将它与newfile重新关联。git mv 还可以移动一个文件到一个目录中：git mv srcfile dir/ .gitignore 文件在前面简单介绍过.gitignore文件的作用。可以通过.gitignore文件来忽略不相干的文件。Git还支持一种更丰富的机制，一个.gitignore文件下可以包含一个文件名模式列表，指定哪些文件需要忽略。.gitignore 文件的格式如下。 空行会被忽略，而以（#）号开头的行可以用于注释。然而，如果#跟在其他文本后面，它就不代表注释了。 一个简单的字面置文件名匹配任何目录中的同名文件。 目录名由末尾的（/）标记。这能匹配同名的目录和子目录，但不匹配文件或符号链接。 包含shell通配符，如（*）号，这种模式可扩展为shell通配模式。正如标准shell通配符一样，因为不能跨目录匹配，所以一个 * 只能匹配一个文件或目录名。 起始的 ！号会对该行其余部分的模式进行取反。","categories":[{"name":"git","slug":"git","permalink":"http://yoursite.com/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"使用手册","slug":"使用手册","date":"2020-02-09T08:04:23.723Z","updated":"2020-02-10T02:14:57.112Z","comments":true,"path":"2020/02/09/使用手册/","link":"","permalink":"http://yoursite.com/2020/02/09/%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}