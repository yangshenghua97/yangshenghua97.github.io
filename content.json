{"meta":{"title":"楊さんノート","subtitle":"","description":"","author":"杨生华","url":"http://yoursite.com","root":"/"},"pages":[{"title":"小杨的简介","date":"2020-02-11T09:43:56.848Z","updated":"2020-02-11T09:43:56.848Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"姓名:杨生华(楊生華)年龄:23 学历:吉林化工学院/本科 个人简介:从Java小白一枚自学两年的编程，学习过各种技术，虽说不能说精通这些技术，但对这些技术还是掌握的。 我是一名文科生,专业学的是日语，2017年八月误打误撞安装了JDK+JRE，并写下了第一行代码 HelloWorld。从此 走上了java开发的不归路。（技术方面还待整理） 个人爱好:空余时间听听轻音乐、跳绳、读小说、收藏书籍、写博客文章，偶尔也会独自去电影院看正在热映的电影。 联系方式: 微信： 电话:13944680832 个人博客： github空间：https://yangshenghua97.github.io/ GitHub：https://github.com/yangshenghua97/"},{"title":"Categories","date":"2020-02-09T08:10:17.612Z","updated":"2020-02-09T08:10:17.612Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2020-02-09T09:12:40.508Z","updated":"2020-02-09T08:10:17.625Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"MySQL数据库","slug":"数据库/mysql/MySQL数据库","date":"2020-03-18T11:19:50.000Z","updated":"2020-03-18T11:20:52.735Z","comments":true,"path":"2020/03/18/数据库/mysql/MySQL数据库/","link":"","permalink":"http://yoursite.com/2020/03/18/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/","excerpt":"","text":"","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"}]},{"title":"Linux文件权限与目录配置","slug":"Linux/Linux文件权限与目录管理","date":"2020-03-16T09:52:07.000Z","updated":"2020-03-18T13:29:58.177Z","comments":true,"path":"2020/03/16/Linux/Linux文件权限与目录管理/","link":"","permalink":"http://yoursite.com/2020/03/16/Linux/Linux%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E4%B8%8E%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/","excerpt":"","text":"Linux文件权限与文件属性Linux文件属性先来看下面的Linux文件属性信息: 12-rw-r--r--. 1 root root 29 Nov 18 00:00 test.txtdrwxr-xr-x. 4 root root 39 Oct 8 14:39 opt 第一栏代表这个文件的类型与权限 第一个字符代表这个文件是目录、文件或是链接文件等 当为[d]则为目录，例如像上面的文件名【opt】就是一个目录 当为[-]则是文件，例如像上面的文件名【test.txt】就是一个文件 当为[l]则是链接文件 当为[b]则是设备文件里面的可供存储的周边设备 当为[c]则是设备文件里面的串行端口设备 上面图片中后面的三个组表示文件拥有者、文件所属用户组、其他人的文件权限 1234r 可读w 可写x 可执行- 无权限 第一组为文件拥有者可具备的权限。 第二组为加入此用户组的账号的权限 第三组为非本人且没有加入本用户组的其他账号的权限 第二栏表示多少文件名链接到此节点 第三栏表示这个文件或目录的拥有者账号 第四栏表示这个文件的所属用户组 第五栏为这个文件的容量大小，默认单位为Bytes，如果想看更人性化的可以输入ls -alh 第六栏为这个文件创建日期或是最近修该日期 第七栏为文件名，如果文件名之前多一个.,则代表这个文件为隐藏文件。 如何修改文件属性与权限 几个修改用户组、拥有者、各种身份的权限命令 chgrp：修改文件所属用户组 chown：修改文件拥有者 chmod：修改文件的权限，SUID、SGID、SBIT等的特性 修改所属用户组：chgrp修改一个文件的用户组直接使用chgrp命令修改即可，这个命令就是change group的缩写 命令格式： 12chgrp [-R] [系统用户] dirname/filename ... -R：进行递归修改， 现在系统中有yang这个用户，将test.txt文件的用户组修改为yang 12345$ -rw-r--r--. 1 root root 29 Nov 18 00:00 test.txt$ chgrp yang test.txt$ ls -al#已经将test.txt文件的所属用户组修改为yang$ -rw-r--r--. 1 root yang 29 Nov 18 00:00 test.txt 修改文件拥有者：chown要修改文件为指定的用户，系统里必须有这个指定用户账号 命名格式： 123chown [-R] 账号名称 文件或目录chown [-R] 账号名称:用户组名称 文件或目录-R：进行递归修改，如果要连目录下的所有子目录或文件同时更改文件拥有者的话，加上-R选项即可 还是上面的那个test.txt文件，将其的文件拥有者修改为yang 1234567$ -rw-r--r--. 1 root yang 29 Nov 18 00:00 test.txt$ chown yang test.txt$ ls -al$ -rw-r--r--. 1 yang yang 29 Nov 18 00:00 test.txt#将test.txt的拥有者和用户组修改回root$ chown root:root test.txt$ -rw-r--r--. 1 root root 29 Nov 18 00:00 test.txt chown也可以使用【chown user.group file】,在拥有者与用户组间加上【.】也可以修改。 目录与文件权限的意义 权限对文件的重要性权限对于文件来说，意义是这样的： r（read）：可读取此文件的实际内容 w（write）：可以编辑、新增或是修改该文件的内容（但不可以删除该文件哦） x（eXecute）：该文件具有可以被系统执行的权限 在Linux下面，文件是否有执行能力，是根据是否具有【x】这个权限来决定的，和文件名没有绝对的关系 权限对目录的重要性目录的主要内容在记录文件名列表，文件名与目录有强烈的关联。对于目录，r、w、x的意义如下： r：表示具有读取目录结构列表的权限，所有当具有读取一个目录的权限（r）时，表示可以查询该目录下的文件名的数据。 w：这个是对于目录的可写入权限，表示用户具有改动改目录结构列表的权限。也就是下面这些权限： 建立新的文件与目录 删除已经存在的文件与目录 将已存在的文件或目录进行更名 移动该目录内的文件、目录位置 x： 目录的x表示的是当前用户能否进入该目录成工作目录。就是说可以通过cd命令切换到改目录下。如果当前用户在某目录下不具有x的权限，那么就无法切换到改目录下，也就无法在改目录下进行任何操作，即使有该目录的r和w权限也不好使。 注意：要开放目录给任何人浏览时，应该至少也要给予r及x权限 修改文件权限：chmod命名格式语法： 123chmod [-R] xyz 文件或目录 xyz：数字类型的权限属性,为rwx属性值相加的值 -R：进行递归 文件权限修改有两种方式：使用数字或者符号来进行权限修改。 数字类型修改文件权限 Linux文件的基本权限有九个，分别是拥有者(owner)，所属群组（group）、其他人（others）三种身份各有自己的读（r）、写（w）、执行（x）权限。 拿上面介绍的文件权限那样，文件权限字符为：【-rwx rwx rwx】九个权限三个一组。 可以使用数字来代表各个组的权限： r：4 w：2 x：1 三种身份（拥有者(owner)、所属群组(group)、其他人（others））各自的三个权限（r，w，x）数字是需要累加的。例如前面提到的test.txt文件如下： 1-rw-r--r--. 1 root root 29 Nov 18 00:00 test.txt 权限为：【-rw-r–r–】的数字则是：644 123owner = rw = 4+2 = 6group = r = 4others = r = 4 接下来用chmod命令将该文件的是三种身份的权限数字设置为770owner = rwx = 4+2+1 = 7group = rwx = 4+2+1 = 7;others = - - - = 0 123$ chmod 770 test.txt$ ls -al test.txt-rwxrwx--- 1 root root 29 Nov 18 00:00 test.txt 如果要将文件变成可执行的文件，并且不要让其他人修改文件的话，那就需要-rwxr-xr-x这样的权限，此时就要执行 chmod 755 fileName命令。 符号类型修改文件权限 符号类型修改文件权限可以借由(user)u，(group)g，(others)o,来代表三种身份的权限，此外a则代表all全部的身份，读写权限可以写成r、w、x chmod [u、g、o、a] [+（加入）、-（移除）、=（设置）] [r、w、x] 文件或目录 例如要把上面的test.txt设置成【-rwxr-xr-x】时： 12345$ ls -al test.txt-rwxrwx--- 1 root root 0 Mar 18 00:00 test.txt$ chmod u=rwx,go=rx test.txt$ ls -al-rwxr-xr-x 1 root root 0 Mar 18 00:00 test.txt 如果想为每身份加入w权限 123$ chmod a+w test.txt$ ls -al test.txt-rwxrwxrwx 1 root root 0 Mar 18 00:00 test.txt 如果想为每身份移除x权限 123$ chmod a-x test.txt$ ls -al test.txt-rw-rw-rw- 1 root root 0 Mar 18 01:49 test.txtLinux目录树目录树的主要特征： 目录树的起始点为根目录（/，root）； 每个目录不止能使用本地区分的文件系统，也可以使用网络的文件系统； 用NetWork File System(NFS)服务器挂载某特点的目录 每个文件在此目录树中的文件都是独一无二的； 下面是目录树构架示意图（关于目录树更详细的说明，参考《鸟哥的Linux私房菜—基础学习篇（第四版）》第五章5.3节的FHS标准说明） 绝对路径与相对路径根据文件名写法的不同，也可将所谓定义为绝对路径与相对路径。这两种文件名路径写法依据如下： 绝对路径：由根目录（/）开始写起的文件名或目录名称； 相对路径：相对于目前所处在的目录的文件名写法，例如：../dir1、../dir1/opt等 ..代表上一层目录，也可以使用../来代表 .代表当前目录，也可以使用./来代表 参考资料 《鸟哥的Linux私房菜—基础学习篇（第四版）》 鸟哥著 人民邮电出版社","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"TCP/IP协议","slug":"计算机基础/计算机网络/TTCP-IP协议","date":"2020-03-12T18:19:13.000Z","updated":"2020-03-15T14:02:04.814Z","comments":true,"path":"2020/03/13/计算机基础/计算机网络/TTCP-IP协议/","link":"","permalink":"http://yoursite.com/2020/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TTCP-IP%E5%8D%8F%E8%AE%AE/","excerpt":"","text":"TCP/IP的标准制定由于TCP/IP技术的公开性，他不属于任何一个厂商或者是专业协会所有。TCP/IP的标准大部分都由RFC技术报告的形式公开。RCF文件包含了所有TCP/IP的协定标准，以及其最新版本。RFC所涵盖的内容和细节非常广，也可以为新协定的标准和计划，但不能以学术研究论文的方式来编辑。 TCP/IP的特性 它是其它网络服务的基础，几乎所有数据包交换网络都提供了这种服务。TCP/IP是根据信息中所含的地址资料来进行资料的传送，他不能确保每个独立路由的数据包是可靠和依序的送达目的地。在每个连线过程中，线路都不是被”独占”的，而是直接映射到硬件地址上，因此特别有效。 因为数据包交换并不能确保每一个数据包的可靠性，因此我们就需要通讯软件来自动检测和修护传送过程中出现的错误和处理损坏数据包。这种服务就是用来确保电脑程序之间能够连接和传送大量的数据。关键的技术就是数据流进行分割，然后编号传送，然后通过接受的确认来确数据的完整性 在数据包交换技术中，TCP/IP是独立于硬件之上的。TCP/IP有自己的一套数据包规定和定义,能应用在不同的网络之上 只要用TCP/IP连接网络，就会获得一个独一无二的识别位址。数据包在交换过程中，是以位址数据为依据，不管数据包所经历的路由如何，数据都会被送到指定的地址。 TCP/IP 的确认模式是以“端到端”进行的。這样就无需理会数据包交换过程中所参与的其他设备。 TCP/IP协议分层框架 链路程：链路层以字节位单位0和1分别进行分组，定义数据帧，写入源和目标机器的物理地址，数据，校验位来传输数据。 链路层报文结构 网络层：根据IP定义网络地址，区分网段。子网内根据地址解析协议(ARP)进行MAC寻址，子网外进行路由转发数据包，这个数据包即为IP数据包。 传输层：数据包通过网络层发送到目标计算机后，应用程序在传输层定义逻辑端口，确认身份后，将数据包交给应用程序，实现端口到端口间通讯。 应用层：传输层的数据到达应用程序时，以某种统一规定的协议格式解读数据。 IP协议IP是面向无连接、无状态的，没有额外的机制保证发送的包是否有序到达。IP首先规定出IP地址格式，该地址相当于在逻辑意义上进行了网段的划分，给没台机器额外设置了一个唯一的详细地址。IP地址属于网络层，主要的功能字啊WLAN内进行路由寻址，选择最佳路由。 TCP建立连接传输控制协议(TCP)，是一种面向连接、确保数据在端到端间的可靠传输的协议。面向连接是指在发送数据前，需要先建立一条虚拟的链路，然后让数据在这条链路上“流动”传输。每个TCP数据包是封装在IP包中的，每一个IP头的后面紧接的是TCP头。 协议第一行的两个端口号各个占据两个字节，分别代表源机器与目标机器的端口号。这两个端口号与IP报头格式中的源IP地址和目标IP地址所组成的四元组可唯一标识一条TCP连接。由于TCP是面向连接的，所以有服务器和客户端之分。需要服务端先在相应的端口上进行监听，准备好接收客户端发起的连接请求。在类UNIX系统系统上通过netstat命令列出机器上已建立的连接信息，其中包含唯一标识一条连接的四元组，以及各连接的状态等内容。 TCP的FLAG位有6个bit组成，分别代表SYN、ACK、FIN、URG、PSH、RST，需要重点关注的是SYN、ACK、FIN。SYN(Synchronize Sequence Numbers)用作建立连接时的同步信号；ACK(Acknowledgement)用于对收到的数据进行确认，所确认的数据由确认序列号表示；FIN(Finish)表示后面没有数据需要发送，通常意味着所建立的连接需要关闭。 TCP三次握手TCP三次握手是指在建立连接的三个步骤： A机器发出一个数据包并将SYN置1，表示希望建立连接。这个包中的序列号假设是x。 B机器收到A机器发过来的数据包后，通过SYN得知这是一个建立连接的请求，于是发送一个响应包并将SYN和ACK标记都置为1。假设这个包中的序列号是y，而确认序列号的必须是x+1，表示收到了A发过来的SYN。在TCP中，SYN被当作数据中的一个字节。 A接收到B的响应后需进行确认，确认包中将ACK置1，并将确认序列号设置为y+1，表示收到了来自B的SYN。 双方只有确认4类信息，才能建立连接。在第二次握手后，从B机器视角看还有连个NO信息无法确认。在第三次握手后，B机器才能确认自己的发报能力是否正常的。 连接三次握手也是防止出现请求超时导致脏连接。TTL网络报文的生存时间往往都会超过TCP请求时间，如果两次握手就可以创建连接的话，传输数据并释放连接后，第一个超时的连接请求才到达B机器的话，B机器会认为是A创建的连接的请求，然后确认同意创建连接。因为A机器的状态不是SYN_SENT,所以直接丢弃了B的确认数据，以致最后只是B机器单方面创建连接完毕。 TCP断开连接TCP是全双工通信，双方都能作为数据的发送方和接收方，但TCP连接也会有断开的时候。A、B机器连接只要三次握手，而断开则需要四次挥手，例如下图： A机器想要断开连接，则待本方数据发送完毕后，传递FIN信号给B机器。B机器应答ACK，告诉A机器可以断开，但是需要等B机器处理完成数据，再主动给A机器发送FIN信号。这时A机器处于半关闭状态(FIN-WAIT-2)，无法再发送新的数据。B机器做好连接关闭前的准备工作后，发送FIN给A机器，此时B机器也进入半关闭状态(CLOSE_WAIT)。A机器发送针对B机器FIN的ACK后，进入TIME_WAIT状态，经过2MSL后，没有收到B机器传过来的报文，则确定B机器已经收到A机器最后发送的ACK指令，此时TCP连接正式释放。","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"CPU与内存","slug":"计算机基础/计算机构成/CPU与内存","date":"2020-03-11T14:15:02.000Z","updated":"2020-03-12T19:34:04.876Z","comments":true,"path":"2020/03/11/计算机基础/计算机构成/CPU与内存/","link":"","permalink":"http://yoursite.com/2020/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%9E%84%E6%88%90/CPU%E4%B8%8E%E5%86%85%E5%AD%98/","excerpt":"","text":"参考资料","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}]},{"title":"计算机的0与1","slug":"计算机基础/计算机构成/计算机的0与1","date":"2020-03-11T12:53:21.000Z","updated":"2020-03-11T14:14:08.175Z","comments":true,"path":"2020/03/11/计算机基础/计算机构成/计算机的0与1/","link":"","permalink":"http://yoursite.com/2020/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%9E%84%E6%88%90/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%840%E4%B8%8E1/","excerpt":"","text":"在计算机中无论是什么设备，归根结底都是0和1的信号处理，设定基数为2，进位的规则是“逢二进一”，称之为二进制，设想有8条电路，每条电路有高电平和低电平两种状态。根据组合排列，有2^8 即256个种不同的信号。这8条电路，最左侧的一条表示正负，0表示正数，1表示负数，不参与数值表示。 基本编码表示数的基本编码方式有原码、反码、补码； 原码：符号为和数字实际值得结合，正数就是数值本身，符号为0；负数是数值本身，符号位为1，8位的二进制的表示范围是[-127,127] 反码：正数是本身，符号位为0；负数的数值部分是正数表示的基础上对各个位取反，符号位为1。8位二进制数的表示范围是[-127,127] 补码：正数是数组的本身，符号位为0，负数的数值部分是在正数表示基础上对各个位取反加1，符号位为1。8位二进制数的表示范围是[-127,127] 正数/负数 原码 反码 补码 1 0000 0001 0000 0001 0000 0001 -1 1000 0001 1111 1110 1111 1111 2 0000 0010 0000 0010 0000 0010 -2 1000 0010 1111 1101 1111 1110 为了加速计算机对加减乘除运算速度，所有产生了反码和补码。例如在进行减法计算时，1-2=-1在计算机运算中可以这样运算：1+（-2）=-1。如果使用原码计算则结果为：1+（-2）= [0000 0001]原+[1000 0010]原 = [10000011]原 = -3结果是错误的。为了解决这一问题，于是出现了反码，使用反码计算，结果为1-2 = 1+(-2) = [00000001]反+[1111 1101]反=[1111 1110]反 = -1。 计算机存储计量单位在上述的一条线路在计算机中表示1位，即1个bit，8个bit组成一个单位，称为一个字节，即1个Byte，1024个Byte简写为KB，1024个KB简写为MB，1024个MB简写为GB。 位移运算向右移动一位近似表示除以2，十进制转化为二进制数后，向右移时，最右边的1位将被直接抹去。在左移&lt;&lt;和右移&gt;&gt;这两种运算中符号位均参与移动，除了负数右移时高位补1外，其他情况均在空位处补0 左移运算由于符号位参与向左移动，在移动后的结果，最左位可能是1或是0，即正数向左移的结果可能负数也可能是正数，负数向左移的结果也是如此。 对于 &gt;&gt;&gt; 无符号向右移动(不存在&lt;&lt;&lt;位移运算)，当向右移动时，正负数高位均补0，正数不断向右移动的最小值是0，而负数不断向右移动的最小值为1，无需考虑符号位，高位直接补0 参考资料 《码出高效 Java开发手册》","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}]},{"title":"里氏替换原则","slug":"设计模式/设计原则/6大设计原则-里氏替换原则","date":"2020-03-08T07:04:15.000Z","updated":"2020-03-08T08:36:07.686Z","comments":true,"path":"2020/03/08/设计模式/设计原则/6大设计原则-里氏替换原则/","link":"","permalink":"http://yoursite.com/2020/03/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/6%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99-%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99/","excerpt":"","text":"什么是里氏替换原则在《大话设计模式》中： 里氏替换原则（LSP）：子类型必须能够替换掉他们的父类型 一个软件实体如果使用的是一个父类的话，那么一定适用于其子类，而且他察觉不出父类对象和子类对象的区别，那就是说，在软件里面，把父类都替换成它的子类，程序的行为没有变化 只有当子类可以替换掉父类，软件单位的功能不受影响时，父类才能真正被复用，而子类也能够在父类的基础上增加新的行为 比方说，猫是继承动物类的，以动物的身份拥有吃喝跑叫等行为，如果需要扩展狗牛羊也拥有类似的行为，由于都是继承自动物类，所以除了更改实例化的地方，程序其他处无需改变 伪代码: 12345动物 animal = new 猫();animal.吃();animal.喝();animal.跑();animal.叫(); 由于子类型的可替换性才使得使用父类类型的模块在无需修改的情况下就可以扩展。 在《设计模式之禅》中是这样描述的： 如果对每种类型为S的对象o1，都有类型为T的对象o2，使得以T定义的所有程序P在所有的对象o1都代换o2时， 程序P的行为没有发生变化，那么类型S是类型T的子类型。 所有引用基类的地方必须能透明地使用其子类的对象。 参考资料","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式原则","slug":"设计模式原则","permalink":"http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8E%9F%E5%88%99/"}]},{"title":"初识Linux","slug":"Linux/Linux基础","date":"2020-03-07T14:20:39.000Z","updated":"2020-03-16T10:12:17.671Z","comments":true,"path":"2020/03/07/Linux/Linux基础/","link":"","permalink":"http://yoursite.com/2020/03/07/Linux/Linux%E5%9F%BA%E7%A1%80/","excerpt":"","text":"什么是Linux?Linux就是一个操作系统(手动狗头) Linux几个常用的命令 cd dir：跳转到指定文件夹 123456跳转到root目录$ cd ~跳转到之前目录$ cd -跳转到上级目录$ cd .. cd 后面还可以文件夹绝对路径或相对路径跳转到指定目录 例如跳转到 /下的tmp目录 1$ cd /tmp pwd：查看当前所处的路径，输入pwd系统会返回当前所处的目录的绝对路径 ls -al：列出文件夹下的所有文件，包括隐藏文件 1$ ls -al 操作Linux系统几个重要的热键 [Tab]按键[Tab]按键就是在切换大小写按键[Casp Lock]上面的那个按键，它具有命令补全与文件补齐的功能。关键是可以避免打错命令或文件名。 这里总结一下 [Tab]接在一串命令的第一个字段后面，则为【命令补全】 [Tab]接在一串命令的第二个字段后面，则为【文件补全】 [Ctrl+c]按键有时候某些命令或程序在系统上一直“跑个不停”，想让命令或程序“停掉”时，可以用这个按键。输入:[Ctrl+c]按键，可以中断目前程序或命令。 [Ctrl+d]如果想要直接离开命令行模式，可以直接按下[Ctrl+d]就能直接离开（相当于输入exit） [Shift]+{Page Up}、[Shift]+{Page Down}按键使用[Shift]+{Page Up}向前翻页。使用[Shift]+{Page Down}先后翻页 正确的关机方法 正确的关机命令使用 几个与关机或重启相关命令 将数据同步写入硬盘的命令：sync 常用的关机命令：shutdown 重启、关机：reboot、halt、poweroff 数据同步写入磁盘：sync 使用sync命令进行数据的写入操作。在命令行下输入sync，那么在内存中尚未被更新的数据，就会被写入硬盘中。So 在关机或重启系统之前最好多执行几次 常用的关机命令：shutdown 这个是关闭Linux的命令，如果是root管理员可以使用。 1234567891011121314shutdown语法shutdown -[krhc] [时间] [警告信息] 选项与参数 -k：不是真的关机，只是发送警告信息出去。 -r：在将系统的服务停掉之后就重新启动（常用） -h：将系统的服务停掉后，立即关机（常用） -c：取消已经进行的shutdown命令内容 时间：指定系统关机的时间，设置时间的样式如下： shutdown -h 13:00 系统将在今天的13:00分关机 shutdown -h now 系统将立即关机 shutdown -r now 系统会立即重启 shutdown可以完成如下的工作： 可以自由选择关机模式：要是关机或重启均可； 可以设置关机时间：可以设置成现在立即关机，也可以设置某一个特定的时间关机； 可以自定义关机信息：在关机之前，可以将自己设置的信息发送给在线用户； 可以仅发出警告信息：有时有可能要进行一些测试，而不想让其他的用户干扰，或是明白的告诉用户某段时间要注意一下。 重启，关机：reboot、halt，poweroff 这三个命令可以进行重启与关机的操作。一般在关机或重启时，都会执行如下命令： 1sync;sync;sync;reboot 使用管理管理工具systemctl关机 在CentOS 7中可以使用systemctl来进行关机，实际上面介绍的关机与重启命令都是调用systemctl这个命令。 这个命令与关机的语法： 1234567systemctl [命令]命令项目有：haltpoweroffrebootsuspend //进入休眠模式# systemctl reboot #系统重启 参考资料 《鸟哥的Linux私房菜—基础学习篇（第四版）》 鸟哥著 人民邮电出版社","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"linux基础","slug":"linux基础","permalink":"http://yoursite.com/tags/linux%E5%9F%BA%E7%A1%80/"}]},{"title":"6大设计原则-单一职责原则","slug":"设计模式/设计原则/6大设计原则-单一职责原则","date":"2020-03-07T12:37:04.000Z","updated":"2020-03-08T07:01:18.055Z","comments":true,"path":"2020/03/07/设计模式/设计原则/6大设计原则-单一职责原则/","link":"","permalink":"http://yoursite.com/2020/03/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/6%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99-%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99/","excerpt":"","text":"单一职责原则 单一职责(SRP)的定义： 就一个类而言，应该仅有一个引起它变化的原因。 在编程的时候，会不知不觉的给一个类添加各种各样的功能、算法等等，这就意味着这个类维护麻烦，复用不可能，高耦合性，缺乏灵活。 如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭受意想不到破坏。软件设计真正的要做的许多内容，就是发现职责就是并把那些职责相互分离。 其实要去判断是否应该分离出类来，并不难，如果能够想到多于一个的动机去改变一个类，那么这个类就具有多一个职责，那么就应该考虑类的职责分离 案例 许多项目，都会接触到用户，机构，角色管理这类模块，基本上都是使用RBAC模型(Role-Based Access Control)，其实要讲的例子如下面的类图 通过这个类图一眼就能看出接口设计得有问题。 下面我们拆分成两个接口。 现在面对接口编程，所以产生这个UserInfo对象之后，当然可以把它当作IUserBO接口使用，也可以当作IUserBiz接口使用。要获得用户信息，就当是IUserBO的实现类；要是希望维护用户的信息，就把它当作IUserBiz的实现类就可以。 123456789.....IUserInfo userInfo = new UserInfo();//给BO赋值可以认为它是一个单纯的BOIUserBO userBO = (IUserBO)userInfo();userBO.setPassWord(\"abc\");//执行动作，可以认为是一个业务逻辑类IUserBiz userBiz = (IUserBiz)userInfo();userBiz.deleUser();····· 单一职责原则的好处 类的复杂性降低，实现什么职责都有清晰明确的定义 可读性提高，复杂性降低，那就当然可读性提高 可维护性提高，可读性提高，那就当然更容易维护 变更引起的风险降低，变更是必不可少的，如果接口的单一职责做得好，一个接口修改只对相应的实现类有影响，对其他的接口无影响，这对系统的扩展性，维护性都有非常大帮助。 对于接口，我们在设计的时候一定要做到单一，但是对于实现类的需要多方面思考，硬套单一职责原则会引起类的剧增，给维护带来很多的麻烦，而且过分细分类的职责也会人为地增加系统的复杂性。 单一职责适用于接口、类、方法。一个方法尽可能做一件事，每个方法的职责非常清晰明确，开发简单，维护也方便。 参考资料 《设计模式之禅》作者：秦小波 机械工业出版社 《大话设计模式》作者：程杰 清华大学出版社","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式原则","slug":"设计模式原则","permalink":"http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8E%9F%E5%88%99/"}]},{"title":"数据结构与算法概述","slug":"数据结构/数据结构与算法概述","date":"2020-02-20T04:54:01.000Z","updated":"2020-03-16T03:35:35.806Z","comments":true,"path":"2020/02/20/数据结构/数据结构与算法概述/","link":"","permalink":"http://yoursite.com/2020/02/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%A6%82%E8%BF%B0/","excerpt":"","text":"","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"Git快速入门","slug":"git/Git快速入门","date":"2020-02-15T09:56:07.000Z","updated":"2020-03-14T15:34:11.421Z","comments":true,"path":"2020/02/15/git/Git快速入门/","link":"","permalink":"http://yoursite.com/2020/02/15/git/Git%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/","excerpt":"","text":"Git安装(Windowns系统为例) 下载Git软件: 点击链接:https://git-scm.com/ 双击！ 一路Next！ 1 Git命令行git简单易用，只要在终端输入$ Git，Git就会不带任何参数输出它的选项和常用的子命令。 12345678910$ git#输入git后会输出一下选项，如果要得到一个完整的git子命令列表，可以输入 git help --allusage: git [--version] [--help] [-C &lt;path&gt;] [-c &lt;name&gt;=&lt;value&gt;] [--exec-path[=&lt;path&gt;]] [--html-path] [--man-path] [--info-path] [-p | --paginate | -P | --no-pager] [--no-replace-objects] [--bare]····················collaborate (see also: git help workflows) fetch Download objects and refs from another repository pull Fetch from and integrate with another repository or a local branch push Update remote refs along with associated objects ..... 2 Git使用快速入门 2.1创建初始版本库首先在git终端下创建一个空文件夹: 1234567#创建空文件夹 test/$ mkdir -p test/#进入到test文件夹$ cd test/#执行git init命令$ git initInitialized empty Git repository in /root/test/.git/ Git不会关心文件夹里是否为空，执行git init 命令创建了一个隐藏目录，在项目目录的顶层有个名为 .git文件夹，Git把所有修订的信息都放在这唯一的顶层目录里 2.2 将文件添加到版本库中执行 git init 命令时，Git版本库都是空的，为了管理内容，需要明确的把内容放入版本库中。 使用 git add file[^1] 将file添加到版本库中。 例如: 在 test目录中创建一个文件index.html并把该文件添加到版本库中 123$ cd test/$ touch index.html$ git add index.html [^1 ]: 如果目录中已经有很多的文件，使用git add .命令让Git把当前的目录及子目录中的文件都添加到版本库中 运行git status 命令显示中间状态的index.html 12$ git status # 这个命令显示新文件index.html将在下次提交时添加到版本库中 2.3 版本库内文件的删除和重命名 文件删除执行命令 git rm可以删除版本库里不需要的文件 操作如下: 12345 # 查看版本库中的文件 $ git ls-files index.html# 执行git rm index.html即可删除版本库中的index.html文件 $ git rm index.html 文件重命名 在终端执行git mv srcfile targetfile即可以完成文件的重命名 例如： 12345678# 先查看版本库中的文件 $ git ls-filesindex.html # 执行git mv index.html foo.html 将index.html修改为foo.html$ git mv index.html foo.html # 再次查看版本库文件$ git ls-files foo.html","categories":[{"name":"git","slug":"git","permalink":"http://yoursite.com/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"Git提交","slug":"git/Git提交","date":"2020-02-15T08:54:50.000Z","updated":"2020-02-15T13:12:57.785Z","comments":true,"path":"2020/02/15/git/Git提交/","link":"","permalink":"http://yoursite.com/2020/02/15/git/Git%E6%8F%90%E4%BA%A4/","excerpt":"","text":"吧啦吧啦乱七八遭的东西在Git中，提交（commit）是用来记录版本库的变更的。当提交时，Git记录索引的快照并把快照放进对象库（简单的介绍）。提交的快照是串联在一起的，每张新的快照指向它的先驱。随着时间的推移，一系列的变更就表示一系列的提交。 Git提供一种机制来确定相对于另一个引用的提交，通常是分支的头。 在某些Git应用场景中，可能见过诸如这样的提交形式 master^ 。 在同一代提交中，插入符号 ^ 是用来选择不同的父提交。给定一个提交C，C^1 是其第一个父提交，C^2 是其第二个父提交，等等，如图: 通过把引用与^ 和 ~ 组合，就可从引用的提交历史图中选出任意提交 提交历史记录 查看旧提交 显示提交历史记录的主要命令是 git log,在参数形式上，git log跟git log HEAD是一样的，输出每一个可从HEAD找到的历史记录中的提交日志信息。变更从HEAD提交开始显示，并从提交图中回溯。如果使用git log 时提供一个提交名，那么这个日志将从该提交开始回溯输出。例如:git log master","categories":[{"name":"git","slug":"git","permalink":"http://yoursite.com/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"关于Git文件管理","slug":"git/关于Git文件管理","date":"2020-02-12T11:25:36.000Z","updated":"2020-03-14T15:36:34.237Z","comments":true,"path":"2020/02/12/git/关于Git文件管理/","link":"","permalink":"http://yoursite.com/2020/02/12/git/%E5%85%B3%E4%BA%8EGit%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/","excerpt":"","text":"git中的文件分类​ Git将所有文件分为3类：已追踪的、被忽略的以及未追踪的 已追踪的 已追踪的文件是指已经在版本库中的文件，或者是已暂存到索引中的文件。如果想将新文件newfile添加到已追踪的文件，执行 git add newfile即可 被忽略的 被忽略的文件必须在版本库中明确声明为不可见或被忽略，即使他可能会在工作目录中出现。一个软件项目通常都会有很多被忽略的文件。普通被忽略的文件包括临时文件、个人笔记、编译器输出文件以及构建过程中自动生成的大多数文件。Git维护一个默认的忽略文件列表，也可以配置版本库来识别其他文件。被忽略的文件会在后面介绍。 未追踪的 未追踪的文件是指那些不在版本库中的文件。 下面举一个栗子: 1234567891011121314151617181920$ git init#查看状态$ git status# On branch master## Initial commit#nothing to commit (create/copy files and use \"git add\" to track)#添加一个文件$ echo \"new Data\" &gt;&gt; data# On branch master## Initial commit## Untracked files:# (use \"git add &lt;file&gt;...\" to include in what will be committed)## datanothing added to commit but untracked files present (use \"git add\" to track) 为了让Git忽略目录中的文件，只需将该文件名添加到一个特殊的文件.gitignore中就可以了。 123456789101112131415161718192021222324252627$ touch main.o$ git status# On branch master## Initial commit## Untracked files:# (use \"git add &lt;file&gt;...\" to include in what will be committed)## data# main.onothing added to commit but untracked files present (use \"git add\" to track)#将 main.o添加到.gitignore中$ echo main.o &gt;&gt; .gitignore$ git status# On branch master## Initial commit## Untracked files:# (use \"git add &lt;file&gt;...\" to include in what will be committed)## .gitignore# datanothing added to commit but untracked files present (use \"git add\" to track) 这样main.o就已经被忽略了，但是git status现在显示一个新的未追踪的文件 .gitignore。 使用 git addgit add 命令将暂存一个文件。就Git文件分类而言，如果一个文件是未追踪的，那么git add就会将文件的状态转化为已追踪的。如果git add作用于一个目录名，那么该目录下的文件以及子目录都会递归暂存起来。 这里还接着上面的栗子: 123456789101112131415161718192021$ git status# On branch master## Initial commit## Untracked files:# (use \"git add &lt;file&gt;...\" to include in what will be committed)## .gitignore# datanothing added to commit but untracked files present (use \"git add\" to track)# 将data、.gitignore两个文件添加至已追踪的分类$ git add data .gitignore$ git status# On branch master# Initial commit# Changes to be committed:# (use \"git rm --cached &lt;file&gt;...\" to unstage)# new file: .gitignore# new file: data 在上面的栗子中使用git add后，暂存和追踪data和.gitignore文件，并准备下次提交是时添加到版本库中。 可以使用git ls-files命令查看隐藏在对象模型下的东西。 123$ git ls-files.gitignoredata 在任何编辑之后，提交变更之前，请执行一次git add命令。 使用 git commit使用 git commit –allgit commit 的 -a或者 --all选项会导致执行提交之前自动暂存所有未暂存的和未追踪的文件变化，包括从工作副本中删除已追踪的文件 下面举个栗子: 12345678910111213$ pwd/tmp/commit-all-example#创建测试版本库$ git initInitialized empty Git repository in /tmp/commit-all-example/.git/$ echo \"Testfile1\" &gt;&gt; ready$ echo \"Testfile2\" &gt;&gt; notyet$ git add ready notyet$ git commit -m \"Setup\"[master (root-commit) 2b00dbf] Setup 2 files changed, 2 insertions(+) create mode 100644 notyet create mode 100644 ready 之后再次编辑ready文件，并用 git add把它添加到版本库中。然后编辑notyet文件保持它是未暂存的。 在一个子目录下添加一个文件，但是不要对它执行git add命令 12$ mkdir subdir$ echo \"Nope\" &gt;&gt; subdir/new 当执行 git commit --all命令，Git会递归遍历整个版本库，暂存所有先前通过git add提交的已知的和修改的文件，然后提交它们，由于subdir/ 一个全新的目录，而且目录下没有任何文件名或路径通过git add和git commit进行操作的， So 即使是 –all选项也不能将其提交。 关于提交日志消息​ 如果不通过命令行直接提供日志消息（例如:git commit -m &quot;提交日志消息&quot;），Git会启动编辑器，并提示你写一个提交日志。 使用 git rm 命令​ git rm命令会在版本库中和目录中同时删除文件。 接着上面的栗子: 这里“意外”的添加了一个文件 1234$ echo \"Random\" &gt; oops#当执行git rm oops时，提示删除失败$ git rm oopsfatal: pathspec 'oops' did not match any files ​ 为什么会这样，可以通过git ls-files命令查看版本库中的文件 123$ git ls-filesnotyetready 现在的版本库中没有oops这个文件，可通过git add oops命令将 oops文件加入到版本库中。 12345$ git add oops$ git ls-filesnotyetoopsready 另外，要将一个文件由已暂存的转化为未暂存的,可以使用git rm --cached命令 比如要删除oops 12$ git rm --cached oopsrm 'oops' git rm --cached会删除索引中的文件并它文件保留在工作目录中，而git rm则会将文件从索引和工作目录中都删除。 如果想要删除一个已经提交的文件，通过简单的git rm filename命令来暂存这一请求 还可以使用 git rm -f来强制删除文件。 如果想保留的文件不小心删除了，可以通过版本控制系统的恢复功能进行恢复 具体的命令如下: 123# 加入不小心删除了oops文件# 可以是下面的命令进行恢复git checkout HEAD -- oops 使用 git mv如果想要给一个文件重命名可以使用git mv srcfile newfile，git mv 命令会将 srcfile文件的文件名称改为newfiles，Git会在索引中删除srcfile文件的路径名，并添加newfile的路径名，至于srcfile文件里的内容，Git仍然会保存在对象库中，然后才会将它与newfile重新关联。git mv 还可以移动一个文件到一个目录中：git mv srcfile dir/ .gitignore 文件在前面简单介绍过.gitignore文件的作用。可以通过.gitignore文件来忽略不相干的文件。Git还支持一种更丰富的机制，一个.gitignore文件下可以包含一个文件名模式列表，指定哪些文件需要忽略。.gitignore 文件的格式如下。 空行会被忽略，而以（#）号开头的行可以用于注释。然而，如果#跟在其他文本后面，它就不代表注释了。 一个简单的字面置文件名匹配任何目录中的同名文件。 目录名由末尾的（/）标记。这能匹配同名的目录和子目录，但不匹配文件或符号链接。 包含shell通配符，如（*）号，这种模式可扩展为shell通配模式。正如标准shell通配符一样，因为不能跨目录匹配，所以一个 * 只能匹配一个文件或目录名。 起始的 ！号会对该行其余部分的模式进行取反。","categories":[{"name":"git","slug":"git","permalink":"http://yoursite.com/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"使用手册","slug":"其他/使用手册","date":"2020-02-09T08:04:23.723Z","updated":"2020-03-14T13:56:54.019Z","comments":true,"path":"2020/02/09/其他/使用手册/","link":"","permalink":"http://yoursite.com/2020/02/09/%E5%85%B6%E4%BB%96/%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"其他","slug":"其他","permalink":"http://yoursite.com/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"other","slug":"other","permalink":"http://yoursite.com/tags/other/"}]}]}