{"meta":{"title":"楊さんノート","subtitle":"","description":"","author":"杨生华","url":"http://yoursite.com","root":"/"},"pages":[{"title":"Categories","date":"2020-02-09T08:10:17.612Z","updated":"2020-02-09T08:10:17.612Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"小杨的简介","date":"2020-02-11T09:43:56.848Z","updated":"2020-02-11T09:43:56.848Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"姓名:杨生华(楊生華)年龄:23 学历:吉林化工学院/本科 个人简介:从Java小白一枚自学两年的编程，学习过各种技术，虽说不能说精通这些技术，但对这些技术还是掌握的。 我是一名文科生,专业学的是日语，2017年八月误打误撞安装了JDK+JRE，并写下了第一行代码 HelloWorld。从此 走上了java开发的不归路。（技术方面还待整理） 个人爱好:空余时间听听轻音乐、跳绳、读小说、收藏书籍、写博客文章，偶尔也会独自去电影院看正在热映的电影。 联系方式: 微信： 电话:13944680832 个人博客： github空间：https://yangshenghua97.github.io/ GitHub：https://github.com/yangshenghua97/"},{"title":"guestbook","date":"2020-03-31T03:10:00.000Z","updated":"2020-03-31T03:12:08.960Z","comments":true,"path":"guestbook/index.html","permalink":"http://yoursite.com/guestbook/index.html","excerpt":"","text":""},{"title":"Tags","date":"2020-02-09T09:12:40.508Z","updated":"2020-02-09T08:10:17.625Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Hadoop安装、集群部署","slug":"BigData","date":"2020-04-01T15:46:11.000Z","updated":"2020-04-04T14:11:11.856Z","comments":true,"path":"2020/04/01/BigData/","link":"","permalink":"http://yoursite.com/2020/04/01/BigData/","excerpt":"","text":"参考资料","categories":[{"name":"大数据","slug":"大数据","permalink":"http://yoursite.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"}],"tags":[{"name":"大数据","slug":"大数据","permalink":"http://yoursite.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"hadoop","slug":"hadoop","permalink":"http://yoursite.com/tags/hadoop/"}]},{"title":"TCP/IP协议","slug":"计算机基础/计算机网络/TTCP-IP协议","date":"2020-03-12T18:19:13.000Z","updated":"2020-03-15T14:02:04.814Z","comments":true,"path":"2020/03/13/计算机基础/计算机网络/TTCP-IP协议/","link":"","permalink":"http://yoursite.com/2020/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TTCP-IP%E5%8D%8F%E8%AE%AE/","excerpt":"","text":"TCP/IP的标准制定由于TCP/IP技术的公开性，他不属于任何一个厂商或者是专业协会所有。TCP/IP的标准大部分都由RFC技术报告的形式公开。RCF文件包含了所有TCP/IP的协定标准，以及其最新版本。RFC所涵盖的内容和细节非常广，也可以为新协定的标准和计划，但不能以学术研究论文的方式来编辑。 TCP/IP的特性 它是其它网络服务的基础，几乎所有数据包交换网络都提供了这种服务。TCP/IP是根据信息中所含的地址资料来进行资料的传送，他不能确保每个独立路由的数据包是可靠和依序的送达目的地。在每个连线过程中，线路都不是被”独占”的，而是直接映射到硬件地址上，因此特别有效。 因为数据包交换并不能确保每一个数据包的可靠性，因此我们就需要通讯软件来自动检测和修护传送过程中出现的错误和处理损坏数据包。这种服务就是用来确保电脑程序之间能够连接和传送大量的数据。关键的技术就是数据流进行分割，然后编号传送，然后通过接受的确认来确数据的完整性 在数据包交换技术中，TCP/IP是独立于硬件之上的。TCP/IP有自己的一套数据包规定和定义,能应用在不同的网络之上 只要用TCP/IP连接网络，就会获得一个独一无二的识别位址。数据包在交换过程中，是以位址数据为依据，不管数据包所经历的路由如何，数据都会被送到指定的地址。 TCP/IP 的确认模式是以“端到端”进行的。這样就无需理会数据包交换过程中所参与的其他设备。 TCP/IP协议分层框架 链路程：链路层以字节位单位0和1分别进行分组，定义数据帧，写入源和目标机器的物理地址，数据，校验位来传输数据。 链路层报文结构 网络层：根据IP定义网络地址，区分网段。子网内根据地址解析协议(ARP)进行MAC寻址，子网外进行路由转发数据包，这个数据包即为IP数据包。 传输层：数据包通过网络层发送到目标计算机后，应用程序在传输层定义逻辑端口，确认身份后，将数据包交给应用程序，实现端口到端口间通讯。 应用层：传输层的数据到达应用程序时，以某种统一规定的协议格式解读数据。 IP协议IP是面向无连接、无状态的，没有额外的机制保证发送的包是否有序到达。IP首先规定出IP地址格式，该地址相当于在逻辑意义上进行了网段的划分，给没台机器额外设置了一个唯一的详细地址。IP地址属于网络层，主要的功能字啊WLAN内进行路由寻址，选择最佳路由。 TCP建立连接传输控制协议(TCP)，是一种面向连接、确保数据在端到端间的可靠传输的协议。面向连接是指在发送数据前，需要先建立一条虚拟的链路，然后让数据在这条链路上“流动”传输。每个TCP数据包是封装在IP包中的，每一个IP头的后面紧接的是TCP头。 协议第一行的两个端口号各个占据两个字节，分别代表源机器与目标机器的端口号。这两个端口号与IP报头格式中的源IP地址和目标IP地址所组成的四元组可唯一标识一条TCP连接。由于TCP是面向连接的，所以有服务器和客户端之分。需要服务端先在相应的端口上进行监听，准备好接收客户端发起的连接请求。在类UNIX系统系统上通过netstat命令列出机器上已建立的连接信息，其中包含唯一标识一条连接的四元组，以及各连接的状态等内容。 TCP的FLAG位有6个bit组成，分别代表SYN、ACK、FIN、URG、PSH、RST，需要重点关注的是SYN、ACK、FIN。SYN(Synchronize Sequence Numbers)用作建立连接时的同步信号；ACK(Acknowledgement)用于对收到的数据进行确认，所确认的数据由确认序列号表示；FIN(Finish)表示后面没有数据需要发送，通常意味着所建立的连接需要关闭。 TCP三次握手TCP三次握手是指在建立连接的三个步骤： A机器发出一个数据包并将SYN置1，表示希望建立连接。这个包中的序列号假设是x。 B机器收到A机器发过来的数据包后，通过SYN得知这是一个建立连接的请求，于是发送一个响应包并将SYN和ACK标记都置为1。假设这个包中的序列号是y，而确认序列号的必须是x+1，表示收到了A发过来的SYN。在TCP中，SYN被当作数据中的一个字节。 A接收到B的响应后需进行确认，确认包中将ACK置1，并将确认序列号设置为y+1，表示收到了来自B的SYN。 双方只有确认4类信息，才能建立连接。在第二次握手后，从B机器视角看还有连个NO信息无法确认。在第三次握手后，B机器才能确认自己的发报能力是否正常的。 连接三次握手也是防止出现请求超时导致脏连接。TTL网络报文的生存时间往往都会超过TCP请求时间，如果两次握手就可以创建连接的话，传输数据并释放连接后，第一个超时的连接请求才到达B机器的话，B机器会认为是A创建的连接的请求，然后确认同意创建连接。因为A机器的状态不是SYN_SENT,所以直接丢弃了B的确认数据，以致最后只是B机器单方面创建连接完毕。 TCP断开连接TCP是全双工通信，双方都能作为数据的发送方和接收方，但TCP连接也会有断开的时候。A、B机器连接只要三次握手，而断开则需要四次挥手，例如下图： A机器想要断开连接，则待本方数据发送完毕后，传递FIN信号给B机器。B机器应答ACK，告诉A机器可以断开，但是需要等B机器处理完成数据，再主动给A机器发送FIN信号。这时A机器处于半关闭状态(FIN-WAIT-2)，无法再发送新的数据。B机器做好连接关闭前的准备工作后，发送FIN给A机器，此时B机器也进入半关闭状态(CLOSE_WAIT)。A机器发送针对B机器FIN的ACK后，进入TIME_WAIT状态，经过2MSL后，没有收到B机器传过来的报文，则确定B机器已经收到A机器最后发送的ACK指令，此时TCP连接正式释放。","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"CPU与内存","slug":"计算机基础/计算机构成/CPU与内存","date":"2020-03-11T14:15:02.000Z","updated":"2020-03-12T19:34:04.876Z","comments":true,"path":"2020/03/11/计算机基础/计算机构成/CPU与内存/","link":"","permalink":"http://yoursite.com/2020/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%9E%84%E6%88%90/CPU%E4%B8%8E%E5%86%85%E5%AD%98/","excerpt":"","text":"参考资料","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}]},{"title":"计算机的0与1","slug":"计算机基础/计算机构成/计算机的0与1","date":"2020-03-11T12:53:21.000Z","updated":"2020-03-11T14:14:08.175Z","comments":true,"path":"2020/03/11/计算机基础/计算机构成/计算机的0与1/","link":"","permalink":"http://yoursite.com/2020/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%9E%84%E6%88%90/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%840%E4%B8%8E1/","excerpt":"","text":"在计算机中无论是什么设备，归根结底都是0和1的信号处理，设定基数为2，进位的规则是“逢二进一”，称之为二进制，设想有8条电路，每条电路有高电平和低电平两种状态。根据组合排列，有2^8 即256个种不同的信号。这8条电路，最左侧的一条表示正负，0表示正数，1表示负数，不参与数值表示。 基本编码表示数的基本编码方式有原码、反码、补码； 原码：符号为和数字实际值得结合，正数就是数值本身，符号为0；负数是数值本身，符号位为1，8位的二进制的表示范围是[-127,127] 反码：正数是本身，符号位为0；负数的数值部分是正数表示的基础上对各个位取反，符号位为1。8位二进制数的表示范围是[-127,127] 补码：正数是数组的本身，符号位为0，负数的数值部分是在正数表示基础上对各个位取反加1，符号位为1。8位二进制数的表示范围是[-127,127] 正数/负数 原码 反码 补码 1 0000 0001 0000 0001 0000 0001 -1 1000 0001 1111 1110 1111 1111 2 0000 0010 0000 0010 0000 0010 -2 1000 0010 1111 1101 1111 1110 为了加速计算机对加减乘除运算速度，所有产生了反码和补码。例如在进行减法计算时，1-2=-1在计算机运算中可以这样运算：1+（-2）=-1。如果使用原码计算则结果为：1+（-2）= [0000 0001]原+[1000 0010]原 = [10000011]原 = -3结果是错误的。为了解决这一问题，于是出现了反码，使用反码计算，结果为1-2 = 1+(-2) = [00000001]反+[1111 1101]反=[1111 1110]反 = -1。 计算机存储计量单位在上述的一条线路在计算机中表示1位，即1个bit，8个bit组成一个单位，称为一个字节，即1个Byte，1024个Byte简写为KB，1024个KB简写为MB，1024个MB简写为GB。 位移运算向右移动一位近似表示除以2，十进制转化为二进制数后，向右移时，最右边的1位将被直接抹去。在左移&lt;&lt;和右移&gt;&gt;这两种运算中符号位均参与移动，除了负数右移时高位补1外，其他情况均在空位处补0 左移运算由于符号位参与向左移动，在移动后的结果，最左位可能是1或是0，即正数向左移的结果可能负数也可能是正数，负数向左移的结果也是如此。 对于 &gt;&gt;&gt; 无符号向右移动(不存在&lt;&lt;&lt;位移运算)，当向右移动时，正负数高位均补0，正数不断向右移动的最小值是0，而负数不断向右移动的最小值为1，无需考虑符号位，高位直接补0 参考资料 《码出高效 Java开发手册》","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}]},{"title":"里氏替换原则","slug":"设计模式/设计原则/6大设计原则-里氏替换原则","date":"2020-03-08T07:04:15.000Z","updated":"2020-03-08T08:36:07.686Z","comments":true,"path":"2020/03/08/设计模式/设计原则/6大设计原则-里氏替换原则/","link":"","permalink":"http://yoursite.com/2020/03/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/6%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99-%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99/","excerpt":"","text":"什么是里氏替换原则在《大话设计模式》中： 里氏替换原则（LSP）：子类型必须能够替换掉他们的父类型 一个软件实体如果使用的是一个父类的话，那么一定适用于其子类，而且他察觉不出父类对象和子类对象的区别，那就是说，在软件里面，把父类都替换成它的子类，程序的行为没有变化 只有当子类可以替换掉父类，软件单位的功能不受影响时，父类才能真正被复用，而子类也能够在父类的基础上增加新的行为 比方说，猫是继承动物类的，以动物的身份拥有吃喝跑叫等行为，如果需要扩展狗牛羊也拥有类似的行为，由于都是继承自动物类，所以除了更改实例化的地方，程序其他处无需改变 伪代码: 12345动物 animal = new 猫();animal.吃();animal.喝();animal.跑();animal.叫(); 由于子类型的可替换性才使得使用父类类型的模块在无需修改的情况下就可以扩展。 在《设计模式之禅》中是这样描述的： 如果对每种类型为S的对象o1，都有类型为T的对象o2，使得以T定义的所有程序P在所有的对象o1都代换o2时， 程序P的行为没有发生变化，那么类型S是类型T的子类型。 所有引用基类的地方必须能透明地使用其子类的对象。 参考资料","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式原则","slug":"设计模式原则","permalink":"http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8E%9F%E5%88%99/"}]},{"title":"6大设计原则-单一职责原则","slug":"设计模式/设计原则/6大设计原则-单一职责原则","date":"2020-03-07T12:37:04.000Z","updated":"2020-03-08T07:01:18.055Z","comments":true,"path":"2020/03/07/设计模式/设计原则/6大设计原则-单一职责原则/","link":"","permalink":"http://yoursite.com/2020/03/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/6%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99-%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99/","excerpt":"","text":"单一职责原则 单一职责(SRP)的定义： 就一个类而言，应该仅有一个引起它变化的原因。 在编程的时候，会不知不觉的给一个类添加各种各样的功能、算法等等，这就意味着这个类维护麻烦，复用不可能，高耦合性，缺乏灵活。 如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭受意想不到破坏。软件设计真正的要做的许多内容，就是发现职责就是并把那些职责相互分离。 其实要去判断是否应该分离出类来，并不难，如果能够想到多于一个的动机去改变一个类，那么这个类就具有多一个职责，那么就应该考虑类的职责分离 案例 许多项目，都会接触到用户，机构，角色管理这类模块，基本上都是使用RBAC模型(Role-Based Access Control)，其实要讲的例子如下面的类图 通过这个类图一眼就能看出接口设计得有问题。 下面我们拆分成两个接口。 现在面对接口编程，所以产生这个UserInfo对象之后，当然可以把它当作IUserBO接口使用，也可以当作IUserBiz接口使用。要获得用户信息，就当是IUserBO的实现类；要是希望维护用户的信息，就把它当作IUserBiz的实现类就可以。 123456789.....IUserInfo userInfo = new UserInfo();//给BO赋值可以认为它是一个单纯的BOIUserBO userBO = (IUserBO)userInfo();userBO.setPassWord(\"abc\");//执行动作，可以认为是一个业务逻辑类IUserBiz userBiz = (IUserBiz)userInfo();userBiz.deleUser();····· 单一职责原则的好处 类的复杂性降低，实现什么职责都有清晰明确的定义 可读性提高，复杂性降低，那就当然可读性提高 可维护性提高，可读性提高，那就当然更容易维护 变更引起的风险降低，变更是必不可少的，如果接口的单一职责做得好，一个接口修改只对相应的实现类有影响，对其他的接口无影响，这对系统的扩展性，维护性都有非常大帮助。 对于接口，我们在设计的时候一定要做到单一，但是对于实现类的需要多方面思考，硬套单一职责原则会引起类的剧增，给维护带来很多的麻烦，而且过分细分类的职责也会人为地增加系统的复杂性。 单一职责适用于接口、类、方法。一个方法尽可能做一件事，每个方法的职责非常清晰明确，开发简单，维护也方便。 参考资料 《设计模式之禅》作者：秦小波 机械工业出版社 《大话设计模式》作者：程杰 清华大学出版社","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式原则","slug":"设计模式原则","permalink":"http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8E%9F%E5%88%99/"}]},{"title":"数据结构与算法概述","slug":"数据结构/数据结构与算法概述","date":"2020-02-20T04:54:01.000Z","updated":"2020-03-16T03:35:35.806Z","comments":true,"path":"2020/02/20/数据结构/数据结构与算法概述/","link":"","permalink":"http://yoursite.com/2020/02/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%A6%82%E8%BF%B0/","excerpt":"","text":"","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"Git快速入门","slug":"git/Git快速入门","date":"2020-02-15T09:56:07.000Z","updated":"2020-03-27T10:35:41.420Z","comments":true,"path":"2020/02/15/git/Git快速入门/","link":"","permalink":"http://yoursite.com/2020/02/15/git/Git%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/","excerpt":"","text":"Git安装(Windowns系统为例) 下载Git软件: 点击链接:https://git-scm.com/ 双击！ 一路Next！ 1 Git命令行git简单易用，只要在终端输入$ Git，Git就会不带任何参数输出它的选项和常用的子命令。 12345678910$ git#输入git后会输出一下选项，如果要得到一个完整的git子命令列表，可以输入 git help --allusage: git [--version] [--help] [-C &lt;path&gt;] [-c &lt;name&gt;=&lt;value&gt;] [--exec-path[=&lt;path&gt;]] [--html-path] [--man-path] [--info-path] [-p | --paginate | -P | --no-pager] [--no-replace-objects] [--bare]····················collaborate (see also: git help workflows) fetch Download objects and refs from another repository pull Fetch from and integrate with another repository or a local branch push Update remote refs along with associated objects ..... 2 Git使用快速入门 2.1创建初始版本库首先在git终端下创建一个空文件夹: 1234567#创建空文件夹 test/$ mkdir -p test/#进入到test文件夹$ cd test/#执行git init命令$ git initInitialized empty Git repository in /root/test/.git/ Git不会关心文件夹里是否为空，执行git init 命令创建了一个隐藏目录，在项目目录的顶层有个名为 .git文件夹，Git把所有修订的信息都放在这唯一的顶层目录里 2.2 将文件添加到版本库中执行 git init 命令时，Git版本库都是空的，为了管理内容，需要明确的把内容放入版本库中。 使用 git add file[^1] 将file添加到版本库中。 例如: 在 test目录中创建一个文件index.html并把该文件添加到版本库中 123$ cd test/$ touch index.html$ git add index.html [^1 ]: 如果目录中已经有很多的文件，使用git add .命令让Git把当前的目录及子目录中的文件都添加到版本库中 运行git status 命令显示中间状态的index.html 12$ git status # 这个命令显示新文件index.html将在下次提交时添加到版本库中 1 2.3 版本库内文件的删除和重命名 文件删除执行命令 git rm可以删除版本库里不需要的文件 操作如下: 123# 查看版本库中的文件$ git ls-filesindex.html 执行git rm index.html即可删除版本库中的index.html文件$ git rm index.html 12345678910111213141516 - ##### 文件重命名 在终端执行``git mv srcfile targetfile``即可以完成文件的重命名 例如： ```shell # 先查看版本库中的文件 $ git ls-files index.html # 执行git mv index.html foo.html 将index.html修改为foo.html $ git mv index.html foo.html # 再次查看版本库文件 $ git ls-files foo.html ​","categories":[{"name":"版本控制管理","slug":"版本控制管理","permalink":"http://yoursite.com/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%AE%A1%E7%90%86/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"Git提交","slug":"git/Git提交","date":"2020-02-15T08:54:50.000Z","updated":"2020-03-27T10:35:07.010Z","comments":true,"path":"2020/02/15/git/Git提交/","link":"","permalink":"http://yoursite.com/2020/02/15/git/Git%E6%8F%90%E4%BA%A4/","excerpt":"","text":"吧啦吧啦乱七八遭的东西在Git中，提交（commit）是用来记录版本库的变更的。当提交时，Git记录索引的快照并把快照放进对象库（简单的介绍）。提交的快照是串联在一起的，每张新的快照指向它的先驱。随着时间的推移，一系列的变更就表示一系列的提交。 Git提供一种机制来确定相对于另一个引用的提交，通常是分支的头。 在某些Git应用场景中，可能见过诸如这样的提交形式 master^ 。 在同一代提交中，插入符号 ^ 是用来选择不同的父提交。给定一个提交C，C^1 是其第一个父提交，C^2 是其第二个父提交，等等，如图: 通过把引用与^ 和 ~ 组合，就可从引用的提交历史图中选出任意提交 提交历史记录 查看旧提交 显示提交历史记录的主要命令是 git log,在参数形式上，git log跟git log HEAD是一样的，输出每一个可从HEAD找到的历史记录中的提交日志信息。变更从HEAD提交开始显示，并从提交图中回溯。如果使用git log 时提供一个提交名，那么这个日志将从该提交开始回溯输出。例如:git log master","categories":[{"name":"版本控制管理","slug":"版本控制管理","permalink":"http://yoursite.com/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%AE%A1%E7%90%86/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"关于Git文件管理","slug":"git/关于Git文件管理","date":"2020-02-12T11:25:36.000Z","updated":"2020-03-27T10:35:50.019Z","comments":true,"path":"2020/02/12/git/关于Git文件管理/","link":"","permalink":"http://yoursite.com/2020/02/12/git/%E5%85%B3%E4%BA%8EGit%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/","excerpt":"","text":"git中的文件分类​ Git将所有文件分为3类：已追踪的、被忽略的以及未追踪的 已追踪的 已追踪的文件是指已经在版本库中的文件，或者是已暂存到索引中的文件。如果想将新文件newfile添加到已追踪的文件，执行 git add newfile即可 被忽略的 被忽略的文件必须在版本库中明确声明为不可见或被忽略，即使他可能会在工作目录中出现。一个软件项目通常都会有很多被忽略的文件。普通被忽略的文件包括临时文件、个人笔记、编译器输出文件以及构建过程中自动生成的大多数文件。Git维护一个默认的忽略文件列表，也可以配置版本库来识别其他文件。被忽略的文件会在后面介绍。 未追踪的 未追踪的文件是指那些不在版本库中的文件。 下面举一个栗子: 1234567891011121314151617181920$ git init#查看状态$ git status# On branch master## Initial commit#nothing to commit (create/copy files and use \"git add\" to track)#添加一个文件$ echo \"new Data\" &gt;&gt; data# On branch master## Initial commit## Untracked files:# (use \"git add &lt;file&gt;...\" to include in what will be committed)## datanothing added to commit but untracked files present (use \"git add\" to track) 为了让Git忽略目录中的文件，只需将该文件名添加到一个特殊的文件.gitignore中就可以了。 123456789101112131415161718192021222324252627$ touch main.o$ git status# On branch master## Initial commit## Untracked files:# (use \"git add &lt;file&gt;...\" to include in what will be committed)## data# main.onothing added to commit but untracked files present (use \"git add\" to track)#将 main.o添加到.gitignore中$ echo main.o &gt;&gt; .gitignore$ git status# On branch master## Initial commit## Untracked files:# (use \"git add &lt;file&gt;...\" to include in what will be committed)## .gitignore# datanothing added to commit but untracked files present (use \"git add\" to track) 这样main.o就已经被忽略了，但是git status现在显示一个新的未追踪的文件 .gitignore。 使用 git addgit add 命令将暂存一个文件。就Git文件分类而言，如果一个文件是未追踪的，那么git add就会将文件的状态转化为已追踪的。如果git add作用于一个目录名，那么该目录下的文件以及子目录都会递归暂存起来。 这里还接着上面的栗子: 123456789101112131415161718192021$ git status# On branch master## Initial commit## Untracked files:# (use \"git add &lt;file&gt;...\" to include in what will be committed)## .gitignore# datanothing added to commit but untracked files present (use \"git add\" to track)# 将data、.gitignore两个文件添加至已追踪的分类$ git add data .gitignore$ git status# On branch master# Initial commit# Changes to be committed:# (use \"git rm --cached &lt;file&gt;...\" to unstage)# new file: .gitignore# new file: data 在上面的栗子中使用git add后，暂存和追踪data和.gitignore文件，并准备下次提交是时添加到版本库中。 可以使用git ls-files命令查看隐藏在对象模型下的东西。 123$ git ls-files.gitignoredata 在任何编辑之后，提交变更之前，请执行一次git add命令。 使用 git commit使用 git commit –allgit commit 的 -a或者 --all选项会导致执行提交之前自动暂存所有未暂存的和未追踪的文件变化，包括从工作副本中删除已追踪的文件 下面举个栗子: 12345678910111213$ pwd/tmp/commit-all-example#创建测试版本库$ git initInitialized empty Git repository in /tmp/commit-all-example/.git/$ echo \"Testfile1\" &gt;&gt; ready$ echo \"Testfile2\" &gt;&gt; notyet$ git add ready notyet$ git commit -m \"Setup\"[master (root-commit) 2b00dbf] Setup 2 files changed, 2 insertions(+) create mode 100644 notyet create mode 100644 ready 之后再次编辑ready文件，并用 git add把它添加到版本库中。然后编辑notyet文件保持它是未暂存的。 在一个子目录下添加一个文件，但是不要对它执行git add命令 12$ mkdir subdir$ echo \"Nope\" &gt;&gt; subdir/new 当执行 git commit --all命令，Git会递归遍历整个版本库，暂存所有先前通过git add提交的已知的和修改的文件，然后提交它们，由于subdir/ 一个全新的目录，而且目录下没有任何文件名或路径通过git add和git commit进行操作的， So 即使是 –all选项也不能将其提交。 关于提交日志消息​ 如果不通过命令行直接提供日志消息（例如:git commit -m &quot;提交日志消息&quot;），Git会启动编辑器，并提示你写一个提交日志。 使用 git rm 命令​ git rm命令会在版本库中和目录中同时删除文件。 接着上面的栗子: 这里“意外”的添加了一个文件 1234$ echo \"Random\" &gt; oops#当执行git rm oops时，提示删除失败$ git rm oopsfatal: pathspec 'oops' did not match any files ​ 为什么会这样，可以通过git ls-files命令查看版本库中的文件 123$ git ls-filesnotyetready 现在的版本库中没有oops这个文件，可通过git add oops命令将 oops文件加入到版本库中。 12345$ git add oops$ git ls-filesnotyetoopsready 另外，要将一个文件由已暂存的转化为未暂存的,可以使用git rm --cached命令 比如要删除oops 12$ git rm --cached oopsrm 'oops' git rm --cached会删除索引中的文件并它文件保留在工作目录中，而git rm则会将文件从索引和工作目录中都删除。 如果想要删除一个已经提交的文件，通过简单的git rm filename命令来暂存这一请求 还可以使用 git rm -f来强制删除文件。 如果想保留的文件不小心删除了，可以通过版本控制系统的恢复功能进行恢复 具体的命令如下: 123# 加入不小心删除了oops文件# 可以是下面的命令进行恢复git checkout HEAD -- oops 使用 git mv如果想要给一个文件重命名可以使用git mv srcfile newfile，git mv 命令会将 srcfile文件的文件名称改为newfiles，Git会在索引中删除srcfile文件的路径名，并添加newfile的路径名，至于srcfile文件里的内容，Git仍然会保存在对象库中，然后才会将它与newfile重新关联。git mv 还可以移动一个文件到一个目录中：git mv srcfile dir/ .gitignore 文件在前面简单介绍过.gitignore文件的作用。可以通过.gitignore文件来忽略不相干的文件。Git还支持一种更丰富的机制，一个.gitignore文件下可以包含一个文件名模式列表，指定哪些文件需要忽略。.gitignore 文件的格式如下。 空行会被忽略，而以（#）号开头的行可以用于注释。然而，如果#跟在其他文本后面，它就不代表注释了。 一个简单的字面置文件名匹配任何目录中的同名文件。 目录名由末尾的（/）标记。这能匹配同名的目录和子目录，但不匹配文件或符号链接。 包含shell通配符，如（*）号，这种模式可扩展为shell通配模式。正如标准shell通配符一样，因为不能跨目录匹配，所以一个 * 只能匹配一个文件或目录名。 起始的 ！号会对该行其余部分的模式进行取反。","categories":[{"name":"版本控制管理","slug":"版本控制管理","permalink":"http://yoursite.com/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%AE%A1%E7%90%86/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"SQL基础（二）","slug":"数据库/mysql/SQL基础2","date":"2019-04-05T09:57:27.000Z","updated":"2020-04-05T10:17:56.341Z","comments":true,"path":"2019/04/05/数据库/mysql/SQL基础2/","link":"","permalink":"http://yoursite.com/2019/04/05/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/SQL%E5%9F%BA%E7%A1%802/","excerpt":"","text":"过滤数据百分号（%）通配符%表示任何字符出现任意次数。 123SELECT prod_id,prod_nameFROM productsWHERE prod_name LIKE 'jet%'; 上面的SQL检索任意以jet为开头的词，%告诉MYSQL接受jet之后的任意字符，不论它有多少字符。通配符可在搜索模式中任意位置使用，并且可以使用多个通配符 123SELECT prod_id,prod_nameFROM productsWHERE prod_name LIKE '%anvil%'; 下划线（_）通配符下划线通配符只匹配单个字符而不是多个字符。 123SELECT prod_id,prod_nameFROM productsWHERE prod_name LIKE '_ ton anvil' 参考资料 《MySQL必知必会》人民邮电出版社 《MySQL 从入门到精通》清华大学出版社","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"},{"name":"sql","slug":"sql","permalink":"http://yoursite.com/tags/sql/"}]},{"title":"vim基本命令","slug":"vim基本命令","date":"2019-04-04T13:22:53.000Z","updated":"2020-04-05T10:00:38.854Z","comments":true,"path":"2019/04/04/vim基本命令/","link":"","permalink":"http://yoursite.com/2019/04/04/vim%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/","excerpt":"","text":"h或者向左箭头 光标向左移动一个字符 j或者向下箭头 光标向下移动一个字符 k或者向上箭头 光标向上移动一个字符 l或者向右箭头 光标向右移动一个字符 Page Down 屏幕向下移动一页 Page Up 屏幕向上移动一页 n n表示数字，按下数字再按空格键，光标会向右移动这一行的n个字符 功能键[Home] 移动到这一行的最前面字符处 功能键[End] 移动到这一行的最后面字符处 G 移动到这个文件的最后一行 nG 移动到这个文件的第n行 n 光标向下移动n行 /word 向光标之下寻找一个名称为word的字符 :n1,n2s/word1/word2/g 在第n1与n2行之间寻找word1这个字符串，并将该字符串替换为word2 :1,$s/word1/word3/g 在第1与最后一行之间寻找word1这个字符串，并将该字符串替换为word2 :1,$s/word1/word4/gc 在第1与最后一行之间寻找word1这个字符串，并将该字符串替换为word2，且在替换前显示提示字符给用户确认是否需要替换 x与X 在一行中x为向后删除一个字符(相当于[del]),X为向前删除一个字符(相当于退格键) dd 删除(剪切)光标所在的那一整行 ndd 删除(剪切)光标所在的向下n行 yy 复制光标所在的那一行 nyy 复制光标所在的向下n行 p与P p为将已复制的数据在光标下一行粘贴，P则为粘贴在光标的上一行。 u 恢复前一个操作 [ctrl]+r 重做上一个操作 . 重复前一个操作 i、a、o 进入插入模式 r或者R 进入替换模式 [Esc] 退出编辑模式 :w 将编辑的数据写入硬盘中 :q 退出vim :wq 保存后退出","categories":[],"tags":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"Linux进程管理","slug":"Linux/Linux进程管理","date":"2019-03-27T09:09:42.000Z","updated":"2020-03-28T07:09:59.010Z","comments":true,"path":"2019/03/27/Linux/Linux进程管理/","link":"","permalink":"http://yoursite.com/2019/03/27/Linux/Linux%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/","excerpt":"","text":"什么是进程如何产生一个进程？程序一般是放置在物理磁盘中，然后通过用户的执行来触发，触发后会加载内存中成为一个个体，这就是进程，为了让系统可以管理这个进程，进程会给予执行者权限/属性等参数，以及进程所需的脚本或数据，最后在给予一个PID。操作系统通过这个PID来判断该进程是否具有执行权限。过程如下图； 举个常见的例子，我们在操作Linux的时候通过登录系统分给我们一个shell(bash)终端，这个shell终端具有一个PID，这个PID就是由UID/GID而来。当这个进程执行其他作业时，那么由这个进程衍生出来的其他进程在一般状态下，会沿用这个进程的相关权限。 关于程序和进程的总结： 程序：通常为二进制程序，放置在存储媒介中，以物理文件的形式存在 进程：程序被触发后，执行者的权限与属性、程序的代码与所需的数据等都会被加载到内存中，操作系统给予这个内存中的单元一个标识符（PID）所以所进程就是一个正在运行时的程序 程序调用的流程（fork and exec）：Linux的程序调用通常称为fork-and-exec的流程。进程都会借由父进程以复制（fork）的方式产生一个一模一样的子进程，然后被复制出来的子进程再以exec方式执行实际要执行的进程，最终就成为一个子进程。 具体流程就像下面的图片 常驻在内存当中的进程通常都是负责一些系统所提供的功能以服务用户的各项任务，因此这些常驻进程称之为服务 任务管理什么是任务管理任务管理是用在bash环境下的，当登录系统获取 bash shell之后，在单一终端下同时执行多个任务的管理操作，执行任务管理的操作中，每个任务都是目前bash的子进程，彼此之间都是有相关性。 前台与后台 说到终端，这里说一下前台与后台； 可以出现提示字符让你操作的环境称为前台，其他任务就可以放入后台去暂停或运行，放入后台的任务是不可以使用【ctrl+c】来终止的 要执行bash的任务管理必须要注意的限制： 这些任务所触发的进程必须是来自你shell的子进程（只管理自己的bash）； 前台：可以控制与执行命令的这个环境称为前台任务； 后台：可以自动执行任务，无法使用【ctrl+c】终止，可使用bg、fg（这两个命名后面会讲解）调用该任务； 后台中【执行】的进程不能等待或输入； 任务控制的管理 直接将命令扔到后台去执行的&amp; 如果想要同时执行多个任务，利用&amp;可以将某些任务直接丢到后台环境，这样就可以继续操作前台的工作任务 例如需要后台执行一个java程序可以这样做： 12$ java -jar xxxx.jar &amp;[1] 7851 当命令后面加上&amp;代表着该命令丢到后台执行，此时bash会给予这个命令一个任务号码【job number】，就如上面代码的那个【1】。后面的7851则是该命令触发的【PID】。当这个任务执行完毕后bash会返回如下信息，表示[1]这个任务已经执行完毕； 1[1]+ Done java -jar xxxx.jar 将目前的任务丢到后台中暂停：【ctrl-z】 将一个正在执行的任务，扔到后台去暂停，使用【ctrl+c】组合键可以实现，使用【ctrl+c】丢到后台当中的任务都是停止状态 查看目前的后台任务状态：jobs 命令格式：jobs [-lrs] 选项与参数： -l：列出【job number】、【PID】与命令串； -r：仅列出正在后台运行的任务； -s：仅列出正在后台停止的任务； 看一个案例：将vim和vi丢到后台 1234567$ vim &amp;[1] 11439$ vi &amp;[2] 11440$ jobs -l[1]- 11439 Stopped (tty output) vim[2]+ 11440 Stopped (tty output) vi 在上面输出的案例里，有+，-号，+号代表最近被放到后台的任务号码，-号代表最近第二个被放到后台中的任务号码，而第三个以后的任务，就不会有+-号出现 将后台任务拿到前台处理：fg 命令格式：fg %jobnumber 以上面案例基础上将vim和vi放到前台： 1234567$ jobs -l[1]- 11439 Stopped (tty output) vim[2]+ 11440 Stopped (tty output) vi## 将vim放到前台处理$ fg %1vim... 让任务在后台下的状态变成运行中：bg %jobnumber 将还在后台停止的vi在后台运行 12$ bg %1[1]+ vi &amp; 就像上面的输出结果那样，命令串后面有一个【&amp;】符号，代表该任务别被启动到后台了 管理后台当中的任务：kill 如果想要将该任务直接删除或者重新启动，就可以用kill命令，使用这个命名时需要给这个命令一个信号（signal） 命令格式：kill -signal %jobnumber 选项与参数： signal：代表后面的接的任务有什么样的指示，下面列举几个常用的信号 -1：重新读取一次参数的配置文件； -2：表示有键盘输入【ctrl-c】同样的操作； -9：立刻强制删除一个任务； -15：以正常的进程方式终止一项任务； -9这信号通常是在【强制删除一个不正常的任务】是使用的，-15则是以正常步骤结束一项任务，这个信号也是默认值； 脱机运行 通常登录系统，系统会给当前的登录账号一个终端进程，在这个终端下运行的进程，如果终端退出则这些进程也会同时退出，所以Linux才有脱机管理。 如果需要退出系统后让进程继续运行，则需要使用nohup命令 命令格式：nohup [命令与参数] 在终端前台任务 ​ nohup [命令与参数] &amp; 在终端后台任务 nohup命令并不支持bash内置命令,所以命令只能是外部命令。 进程管理查看进程 将某个时间点的进程运行情况截取下来：ps ps aux：查看系统所有的进程 参考资料","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"SQL基础（一）","slug":"数据库/mysql/SQL基础","date":"2019-03-27T05:04:38.000Z","updated":"2020-04-05T10:12:02.303Z","comments":true,"path":"2019/03/27/数据库/mysql/SQL基础/","link":"","permalink":"http://yoursite.com/2019/03/27/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/SQL%E5%9F%BA%E7%A1%80/","excerpt":"","text":"这篇文章主要以MySQL数据库进行讲解 在阅读本文之前假设已经安装MySQL数据库。请先构建好数据源，如果没有安装MYSQL数据库可以通过下面的在线网站构建数据源并练习SQL语句 SQL在线练习网站：http://sqlfiddle.com/ 源数据下载：https://forta.com/wp-content/uploads/books/0672327120/mysql_scripts.zip SQL语言分类SQL语言主要分为三类： DML（Data Manipulation Language）：数据操作语言，常用的增删改查就属于DML，操作的对象是数据表中的对象。 DDL（Data Definition Language）：数据定义语言。建表，建立数据库就属于DDL DCL（Data Control Language）：数据控制语言，提交回滚，数据库安全管理等属于DCL 本文将逐一介绍这三个SQL语言分类的简单讲解。 检索数据SELECT语句123456789101112131415161718#建products表并插入数据CREATE TABLE products( prod_id char(10) NOT NULL, vend_id int NOT NULL , prod_name char(255) NOT NULL , prod_price decimal(8,2) NOT NULL , prod_desc text NULL , PRIMARY KEY(prod_id)) ENGINE=InnoDB;INSERT INTO products(prod_id, vend_id, prod_name, prod_price, prod_desc)VALUES('ANV01', 1001, '.5 ton anvil', 5.99, '.5 ton anvil, black, complete with handy hook');INSERT INTO products(prod_id, vend_id, prod_name, prod_price, prod_desc)VALUES('ANV02', 1001, '1 ton anvil', 9.99, '1 ton anvil, black, complete with handy hook and carrying case');INSERT INTO products(prod_id, vend_id, prod_name, prod_price, prod_desc)VALUES('OL1', 1002, 'Oil can', 8.99, 'Oil can, red');INSERT INTO products(prod_id, vend_id, prod_name, prod_price, prod_desc)VALUES('FU1', 1002, 'Fuses', 3.42, '1 dozen, extra long'); 检索单个列语法：SELECT 列名 FROM 表名 检索prod_name列 12345678SELECT prod_name FROM products;#结果为| prod_name ||--------------|| .5 ton anvil || 1 ton anvil || Fuses || Oil can | 上面的语句利用SELECT语句从products表中检索一个列为prod_name。所需列名在SELECT关键字后面给出，FROM关键字指定要从哪个表检索数据 检索多个列语法：SELECT 列名1,列名2... FROM 表名 要从一个表中检索多个列，使用SELECT语句，后面键入多个列名，列名之间必须以逗号隔开 当心逗号：在选择多个列时，一定要在列名之间加逗号，最后一个列名之后不用加 还是以上面的数据源为例，检索prod_id、prod_name两列 12345678SELECT prod_id,prod_name FROM products;#其结果如下：| prod_id | prod_name ||---------|--------------|| ANV01 | .5 ton anvil || ANV02 | 1 ton anvil || FU1 | Fuses || OL1 | Oil can | 检索所有列语法：SELECT * FROM 表名 检索所有列时，给定一个通配符（*）,则会检索表中的所有列。 1234SELECT * FROM products;prod_id | vend_id | prod_name | prod_price | prod_desc ANV01 | 1001 | .5 ton anvil | 5.99 | .5 ton anvil, black ANV02 | 1001 | 1 ton anvil | 9.99 | 1 ton anvil, black 检索不同的行（DISTINCT）语法：SELECT DISTINCT 列名 FROM 表名 要检索出有不同值的列表，使用DISTINCT关键字，此关键字必须直接放在列名的前面。此关键字指示MySQL只返回不同的值，这里的DISTINCT不能部分使用，它应用于所有列而不仅是前置它的列。 12345SELECT DISTINCT vend_id FROM products;| vend_id ||---------|| 1001 || 1002 | 限制结果（LIMIT）限制返回的行数。可以有两个参数，第一个参数为起始行，从 0 开始；第二个参数为返回的总行数。 语法： 123SELECT 列名1,列名2,... FROM 表名LIMIT starts,count; count：检索取多少行 starts：从第几行开始，注意这里的开始行从0开始 返回前五行： 1SELECT * FROM products LIMIT 5; 1SELECT * FROM products LIMIT 0,5 带一个值的LIMIT总是从第一行开始，给出的数为返回的行数。带两个值的LIMIT可以指定从行号为第一个值的位置开始。 过滤数据使用WHERE子句在SELECT语句中，数据根据WHERE子句中指定的搜索条件进行过滤。WHERE子句在表名后给出。在同时使用ORDER BY和WHERE子句时，应该让ORDER BY位于WHERE之后 WHERE子句操作符语法： 123SELECT 列名1,列名2,... FROM 表名WHERE 条件 MYSQL支持以下所有条件操作符： 操作符 说明 = 等于 &lt;&gt; 不等于 != 不等于 &lt; 小于 &lt;= 小于等于 &gt; 大于 &gt;= 大于等于 BETWEEN 在指定的两个值之间 IS NULL 为NULL值 过滤单个值过滤prod_name=’fuses’的数据 123SELECT prod_name,prod_priceFROM productsWHERE prod_name='fuses'; 过滤价格小于10元的数据 123SELECT prod_name,prod_priceFROM productsWHERE prod_price&lt;10; 过滤价格小于等于10元的数据 123SELECT prod_name,prod_priceFROM productsWHERE prod_price&lt;=10; 过滤不匹配过滤vend_id不是1002的数据 123SELECT prod_name,prod_priceFROM productsWHERE vend_id != 1002; 如果条件值为字符串类型，则需要引用引号，如果条件值为数值类型，则不需要引用引号 过滤范围值(BETWEEN)如果需要检查某个范围的值，可以使用BETWEEN操作符。其语法与其他WHERE子句的操作符不同。BETWEEN需要两个值，过滤范围的开始值和结束值。在范围使用BETWEEN时，必须指定两个值——所需范围的低端值和高端值。这两个值必须用AND关键字分隔。BETWEEN匹配范围中的所有值，包括指定的开始值和结束值。 过滤价格在5元和10元之间的所有产品 123SELECT prod_name,prod_priceFROM productsWHERE prod_price BETWEEN 5 AND 10; 空值过滤(IS NULL)WHERE子句 IS NULL用来检查具有NULL值的列。 123SELECT prod_nameFROM productsWHERE prod_price IS NULL; 组合WHERE子句AND操作符为了通过不止一个列在过滤，可使用AND操作符给WHERE子句附加条件，用来指示检索满足所有给定的条件的行。 案例： 123SELECT prod_id,prod_price,prod_nameFROM productsWHERE vend_id = 1003 AND prod_price &lt;= 10; OR操作符：用于过滤检索匹配任意一条件的行 123SELECT prod_id,prod_price,prod_nameFROM productsWHERE vend_id = 1003 OR prod_price &lt;= 10; IN操作符IN操作符用于指定条件范围，范围中每个条件都可以进行匹配。IN在WHERE中用来指定匹配值的关键字，功能与OR相当 1234SELECT prod_name,prod_priceFROM productsWHERE vend_id IN(1002,1003)ORDER BY prod_name; IN操作符的优点如下： 当需要匹配的值比较多时，IN操作符的语法更清楚且更直观； IN操作符一般比OR操作符执行更快； 在使用IN时，计算的次序更容易管理； IN的一最大优点就是可以包含其他SELECT语句，使得能够更动态地建立WHERE子句； NOT操作符：NOT用在WHERE子句中，用来否定后跟的条件表达式，MYSQL中的NOT，支持NOT对IN，BETWEEN和EXISTS子句取反。 参考资料 《MySQL必知必会》人民邮电出版社 《MySQL 从入门到精通》清华大学出版社","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"},{"name":"sql","slug":"sql","permalink":"http://yoursite.com/tags/sql/"}]},{"title":"Linux账号管理与权限设置","slug":"Linux/Linux账号管理与权限设置","date":"2019-03-21T09:47:17.000Z","updated":"2020-03-21T09:52:13.908Z","comments":true,"path":"2019/03/21/Linux/Linux账号管理与权限设置/","link":"","permalink":"http://yoursite.com/2019/03/21/Linux/Linux%E8%B4%A6%E5%8F%B7%E7%AE%A1%E7%90%86%E4%B8%8E%E6%9D%83%E9%99%90%E8%AE%BE%E7%BD%AE/","excerpt":"","text":"参考资料","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"文件与文件系统压缩","slug":"Linux/文件与文件系统压缩","date":"2019-03-20T06:42:11.000Z","updated":"2020-03-21T09:50:50.125Z","comments":true,"path":"2019/03/20/Linux/文件与文件系统压缩/","link":"","permalink":"http://yoursite.com/2019/03/20/Linux/%E6%96%87%E4%BB%B6%E4%B8%8E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%8E%8B%E7%BC%A9/","excerpt":"","text":"Linux系统常见的压缩命令123456789*.z compress程序压缩的文件；*.zip zip程序压缩的文件；*.gz gzip程序压缩的文件；*.bz2 bzip2程序压缩的文件；*.xz xz程序压缩的文件；*.tar tar程序打包的文件，并没有压缩过；*.tar.gz tar程序打包的文件，并经过gzip的压缩*.tar.bz2 tar程序打包的文件，并经过bzip2的压缩*.tar.xz tar程序打包的文件，并经过xz的压缩 gzip，zcat gzip可以说是应用最广泛的压缩命令。下面介绍这些命令; gzip [-cdtv#] 文件名 选项和参数： -c：将压缩的数据输出到屏幕上，可通过数据流重定向来处理； -d：解压缩的参数 -t：可以用来检验一个压缩文件的一致性，看看文件是否有误 -#：#表示压缩级别，-1最快，但压缩比最差，-9最慢，压缩比最好，默认为-6 xz，xzcat 命令格式 xz [-dtlkc#] 文件名 xcat 文件名.xz 选项与参数: -d：解压缩； -t：测试压缩文件的完整性； -l：列出压缩文件的相关信息； -k：保留原本文件不删除 -c：将数据在屏幕上输出 -#：压缩级别 打包名命名：tar命名格式：tat [-z][-j][-J][cv][-f 待建里的文件名] filename ...：打包与压缩tar [-z][-j][-J][tv][-f 既有的tar文件名]：查看文件名tar [-z][-j][-J][xv][-f 既有的tar文件名] [-C 目录]：解压缩选项与参数：-c：建立打包文件，可搭配-v来查看过程中被打包的文件名；-t：查看打包文件的内容含有哪些文件名，重点看文件名；-x：解包或解压缩，可以搭配-C在特定目录解压；-z：通过gzip的支持进行压缩/解压缩：此时文件名最好为*.tar.gz；-C 目录：若要在特定目录解压缩，可以使用这个选项；-f finame：-f后面要立刻接要被处理的文件名--exclude=FILE：在压缩过程中，不要将FILE打包注意：-c、-t、-x不可同时出现常使用的命令组合：tar -zcvf filename.tar.gz、tar -jcvf filename.tar.bz2：压缩tar -ztvf filename.tar.gz、tar -jtvf filename.tar.bz2：查询tar -zxvf filename.tar.gz -C 目录、tar -jxvf filename.tar.bz2 -C 目录：解压缩 常见的压缩与备份工具dd命令格式：dd if=input_file of=output_file bs=block_size count=number 选项与参数： if：输如设备 of：输出设备 bs：设置的一个block的大小，若未指定则默认是512Bytes（一个扇区大小） count：多少个bs 参考资料","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"Linux的文件与目录管理","slug":"Linux/Linux的文件与目录管理","date":"2019-03-18T13:40:17.000Z","updated":"2020-03-21T06:31:51.518Z","comments":true,"path":"2019/03/18/Linux/Linux的文件与目录管理/","link":"","permalink":"http://yoursite.com/2019/03/18/Linux/Linux%E7%9A%84%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/","excerpt":"","text":"目录相关操作对于目录相关的命名首先要介绍的一个命令是目录切换命令：cd 还有一些比较特殊的目录： .：代表此层目录； ..：代表上一层目录； -：代表前一个工作目录； ~：代表目前使用者身份所在的家目录 ~account：代表account这个使用者的家目录 处理目录的命令： cd（change directory）：切换目录 命令格式：cd [相对路径或绝对路径] 利用相对路径的写法必须确认的目前的路径才能正确地去到想要的目录 下面看几个例子 123456789101112131415##切换到tmp目录$ cd /tmp$ pwd/tmp##回到家目录$ cd ~$ pwd/root##回到上一次的工作目录$ cd -/tmp##当前的工作目录在/tmp，回到上一级目录$ cd ..$ pwd/ pwd（显示目前所在的目录） 命令格式：pwd [-p] ​ 选项与参数：-p：显示出真正的目录，而非使用链接路径 mkdir：建立新目录 命令格式 mkdir [-mp] 目录名称 选项与参数： -m：设置文件的权限。直接设置，不需使用默认权限（umask） -p：递归创建子目录 下面举几个例子： 12345#在当前的工作目录下创建test0目录$ mkdir test0drwxr-xr-x 2 root root 4096 Mar 19 16:58 test0##在当前的工作目录下递归创建test1/test2/test3这样的多层目录$ mkdir -p test1/test2/test3 一般创建目录大都是使用默认权限（umask），mkdir可以在创建目录时可以指定权限，例如： 12$ mkdir -m 711 test2drwx--x--x 2 root root 4096 Mar 19 17:07 test2 rmdir：删除“空”目录命令格式：rmdir [-p] 目录名称被删除的目录里不能存在其他的文件和目录，如果想要一次性删除一个目录以及该目录其下的子目录可以使用rm -rf 目录名称,但这样不是太安全，还是使用rmdir比较安全。 文件与目录管理文件与目录查看：ls命名格式：ls [-adlh] 文件名或目录名称 选项参数： -a：全部的文件，包括隐藏文件（开头为.的文件）一起列出 -d：仅列出目录本身，而不是列出目录内的文件数据 -h：将文件大小以及人类易读的方式（GB，KB，MB）列出 -l：详细信息显示，包括文件的属性与权限等数据 12345678910##列出root目录下的所有文件$ ls -al ~dr-xr-x---. 9 root root 4096 Mar 19 17:07 .dr-xr-xr-x. 18 root root 4096 Mar 14 16:57 ..-rw------- 1 root root 5185 Mar 18 23:42 .bash_history······drwxr-xr-x 2 root root 4096 Mar 19 16:58 test0drwxr-xr-x 3 root root 4096 Mar 19 17:00 test1drwx--x--x 2 root root 4096 Mar 19 17:07 test2-rw-rw-rw- 1 root root 0 Mar 18 01:49 test.txt 12345678910##列出root目录下的所有文件,以人类易读的方式$ ls -alh ~dr-xr-x---. 9 root root 4.0K Mar 19 17:07 .dr-xr-xr-x. 18 root root 4.0K Mar 14 16:57 ..-rw------- 1 root root 5.1K Mar 18 23:42 .bash_history······drwxr-xr-x 2 root root 4.0K Mar 19 16:58 test0drwxr-xr-x 3 root root 4.0K Mar 19 17:00 test1drwx--x--x 2 root root 4.0K Mar 19 17:07 test2-rw-rw-rw- 1 root root 0 Mar 18 01:49 test.txt 复制、删除、移动：cp、rm、mv cp:复制文件或目录 命令格式：cp [-ipr] 源文件（source） 目标文件（dest） 选项与参数： -a：参考下面的-dr选项 -d：若源文件为链接文件属性，则复制链接文件属性而非文件本身 -i：若目标文件已经存在，在覆盖时会先询问操作的进行 -p：连同文件的属性一起复制，不使用默认属性 -r：递归复制，用于目录的复制操作 在默认的条件中，cp的源文件与目标文件的权限是不同的，目标文件的拥有者通常会是命令操作本身。 rm（删除文件或目录） 命令格式：rm [-fir] 文件或目录 选项与参数： -f：强制的意思 -I：交互模式，在删除之前会询问使用是否操作 -r：递归删除 通常这个命令在使用时要十分小心，在删除前要认真确定删除的文件或目录是否正确，避免误删除的情况 1234#删除test1文件夹#连同目录下的所有子目录一并强制删除$ rm -rf test1 #删除文件也是如此 mv（移动文件与目录或重命名） 命令格式：mv [-fiu] source dest 选项与参数： -f：强制执行 -i：若目标文件已经存在，会询问是否覆盖 -u：若目标文件已存在，且source比较新，才会更新 这里举几个例子： 将test.txt文件移动到test0文件夹中 123$ mv test.txt test0$ ls test0test.txt 将test0文件夹重命名为test3 123$ mv test0 test4$ ls .test3 修改文件时间或创建新文件：touch 命令格式：touch [-acdmt] 文件名 选项与参数： ​ -a：仅自定义access time； ​ -c：仅修改文件时间，若该文件不存在则不创建新文件； ​ -d：后面可以接想要自定义的日期而不用目前的日期； ​ -m：修改mtime ​ -t：后面可以接想要自定义的时间而不是使用目前的日期，格式为[YYYYMMDDhhmm] touch命令最常用的情况是： 创建一个空文件 将某个文件日期自定义为目前 举几个例子： 123456#创建一个空文件$ touch test1-rw-r--r-- 1 root root 0 Mar 21 12:03 test1#修改日期为：2020/02/21 00:00$ touch -t 202002210000 test1-rw-r--r-- 1 root root 0 Feb 21 00:00 test1 文件与目录的默认权限与隐藏权限文件默认权限：umaskumask是指定目前用户在创建文件或者目录时的权限默认值。 12345#使用umask查看默认权限$ umask0022 //与一般权限有关的是后面三个数字$ umask -Su=rwx,g=rx,o=rx 默认情况下： 若用户创建文件则默认没有（x）执行权限，也就是只有rw这两个项目,也就是最大为666，默认权限为： -rw-rw-rw- 若用户创建目录则由于x是与是否可以进入目录有关的，因此默认为所有权限均开放，即777 drwxrwxrwx umaks的数字指的是该默认值需要减掉的权限 通过上面umask=0022进行说明。因为umask=0022，user没有被拿掉任何权限，group与others的权限被拿掉了2（也就是w权限）（r、w、x每个权限的数字在《Linux文件权限与目录简介》一篇中介绍过）那么用户： 创建文件时：（-rw-rw-rw-）-（- - - - - w - - w -）==&gt; - rw-r- -r- - ,最后创建文件时的权限：666-022=644 创建目录时：（drwxrwxrwx）-（d - - - - w- - w-）==&gt; drwxr-xr-x最后创建目录时的权限：777-022=755 创建一个文件和一个目录： 1234567891011$ umask0022$ touch test0666-022=644-rw-r--r-- 1 root root 0 Mar 21 12:49 test0 6 4 4#创建目录$ mkdir test.d777-022=755drwxr-xr-x 2 root roo 4096 Mar 21 12:53 test.d 7 5 5 文件隐藏属性 配置文件隐藏属性：chattr [+-=][ASacdistu] 文件或目录名称 常用选项与参数：+：增加某个特殊参数，其他原本存在参数不动；-：减少某个特殊参数，其他原本存在参数不动；=：直接设置参数，且仅有后面接的参数；a：当设置这个a之后，这个文件将只能增加数据，而不能删除也不能修改数据，只有root才能设置这个属性；i：当设置i之后，可以让一个文件不能被删除、改名、设置链接也无法写入或新增数据； 12345$ touch test23$ chattr +i test23$ rm -rf test23#不能删除rm: cannot remove test23：Operation not permitted 显示文件隐藏属性：lsattr [-adR] 文件或目录 选项与参数： -a：将隐藏文件的属性显示出来 -d：如果接的目录，仅列出目录本身的属性而非目录内的文件名 -R：连同子目录的数据也一并列出来 接着上面的例子： 12$ lsattr -aR test23----i--------e-- test23 命令与文件的查找脚本文件查找 查找执行文件：which [-a] command 选项或参数： -a：将所有由PATH目录中可以找到的命令均列出，而不止第一个被找到的命令名称 这个命令是根据【PATH】这个环境变量所规范的路径，去查找执行文件的文件名。 文件查找 由一些特定的目录中查找文件：whereis [-bmsu] 文件或目录 选项与参数： -l：可以列出whereis会去查询的几个主要目录； -b：只找binary（二进制）格式文件； -m：只找在说明文件manual路径下的文件； -s：只找source源文件； -u：查找不在上述三个项目当中的其他特殊文件； locate [-ir] keyword 选项与参数： -i：忽略大小写的差异； -c：不输出文件名，计算找到的文件数量； -l：仅输出几行的意思； -S：输出locate所使用的数据库文件的相关信息，包括该数据库记录文件/目录数量等； -r：后面可接正则表达式的显示方式； find [PATH] [option] [action]没事别用这个命令神慢~ 参考资料 《鸟哥的Linux私房菜—基础学习篇（第四版）》 鸟哥著 人民邮电出版社","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"Linux文件权限与目录简介","slug":"Linux/Linux文件权限与目录简介","date":"2019-03-16T09:52:07.000Z","updated":"2020-03-21T03:49:47.441Z","comments":true,"path":"2019/03/16/Linux/Linux文件权限与目录简介/","link":"","permalink":"http://yoursite.com/2019/03/16/Linux/Linux%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E4%B8%8E%E7%9B%AE%E5%BD%95%E7%AE%80%E4%BB%8B/","excerpt":"","text":"Linux文件权限与文件属性Linux文件属性先来看下面的Linux文件属性信息: 12-rw-r--r--. 1 root root 29 Nov 18 00:00 test.txtdrwxr-xr-x. 4 root root 39 Oct 8 14:39 opt 第一栏代表这个文件的类型与权限 第一个字符代表这个文件是目录、文件或是链接文件等 当为[d]则为目录，例如像上面的文件名【opt】就是一个目录 当为[-]则是文件，例如像上面的文件名【test.txt】就是一个文件 当为[l]则是链接文件 当为[b]则是设备文件里面的可供存储的周边设备 当为[c]则是设备文件里面的串行端口设备 上面图片中后面的三个组表示文件拥有者、文件所属用户组、其他人的文件权限 1234r 可读w 可写x 可执行- 无权限 第一组为文件拥有者可具备的权限。 第二组为加入此用户组的账号的权限 第三组为非本人且没有加入本用户组的其他账号的权限 第二栏表示多少文件名链接到此节点 第三栏表示这个文件或目录的拥有者账号 第四栏表示这个文件的所属用户组 第五栏为这个文件的容量大小，默认单位为Bytes，如果想看更人性化的可以输入ls -alh 第六栏为这个文件创建日期或是最近修该日期 第七栏为文件名，如果文件名之前多一个.,则代表这个文件为隐藏文件。 如何修改文件属性与权限 几个修改用户组、拥有者、各种身份的权限命令 chgrp：修改文件所属用户组 chown：修改文件拥有者 chmod：修改文件的权限，SUID、SGID、SBIT等的特性 修改所属用户组：chgrp修改一个文件的用户组直接使用chgrp命令修改即可，这个命令就是change group的缩写 命令格式： 12chgrp [-R] [系统用户] dirname/filename ... -R：进行递归修改， 现在系统中有yang这个用户，将test.txt文件的用户组修改为yang 12345$ -rw-r--r--. 1 root root 29 Nov 18 00:00 test.txt$ chgrp yang test.txt$ ls -al#已经将test.txt文件的所属用户组修改为yang$ -rw-r--r--. 1 root yang 29 Nov 18 00:00 test.txt 修改文件拥有者：chown要修改文件为指定的用户，系统里必须有这个指定用户账号 命名格式： 123chown [-R] 账号名称 文件或目录chown [-R] 账号名称:用户组名称 文件或目录-R：进行递归修改，如果要连目录下的所有子目录或文件同时更改文件拥有者的话，加上-R选项即可 还是上面的那个test.txt文件，将其的文件拥有者修改为yang 1234567$ -rw-r--r--. 1 root yang 29 Nov 18 00:00 test.txt$ chown yang test.txt$ ls -al$ -rw-r--r--. 1 yang yang 29 Nov 18 00:00 test.txt#将test.txt的拥有者和用户组修改回root$ chown root:root test.txt$ -rw-r--r--. 1 root root 29 Nov 18 00:00 test.txt chown也可以使用【chown user.group file】,在拥有者与用户组间加上【.】也可以修改。 目录与文件权限的意义 权限对文件的重要性权限对于文件来说，意义是这样的： r（read）：可读取此文件的实际内容 w（write）：可以编辑、新增或是修改该文件的内容（但不可以删除该文件哦） x（eXecute）：该文件具有可以被系统执行的权限 在Linux下面，文件是否有执行能力，是根据是否具有【x】这个权限来决定的，和文件名没有绝对的关系 权限对目录的重要性目录的主要内容在记录文件名列表，文件名与目录有强烈的关联。对于目录，r、w、x的意义如下： r：表示具有读取目录结构列表的权限，所有当具有读取一个目录的权限（r）时，表示可以查询该目录下的文件名的数据。 w：这个是对于目录的可写入权限，表示用户具有改动改目录结构列表的权限。也就是下面这些权限： 建立新的文件与目录 删除已经存在的文件与目录 将已存在的文件或目录进行更名 移动该目录内的文件、目录位置 x： 目录的x表示的是当前用户能否进入该目录成工作目录。就是说可以通过cd命令切换到改目录下。如果当前用户在某目录下不具有x的权限，那么就无法切换到改目录下，也就无法在改目录下进行任何操作，即使有该目录的r和w权限也不好使。 注意：要开放目录给任何人浏览时，应该至少也要给予r及x权限 修改文件权限：chmod命名格式语法： 123chmod [-R] xyz 文件或目录 xyz：数字类型的权限属性,为rwx属性值相加的值 -R：进行递归 文件权限修改有两种方式：使用数字或者符号来进行权限修改。 数字类型修改文件权限 Linux文件的基本权限有九个，分别是拥有者(owner)，所属群组（group）、其他人（others）三种身份各有自己的读（r）、写（w）、执行（x）权限。 拿上面介绍的文件权限那样，文件权限字符为：【-rwx rwx rwx】九个权限三个一组。 可以使用数字来代表各个组的权限： r：4 w：2 x：1 三种身份（拥有者(owner)、所属群组(group)、其他人（others））各自的三个权限（r，w，x）数字是需要累加的。例如前面提到的test.txt文件如下： 1-rw-r--r--. 1 root root 29 Nov 18 00:00 test.txt 权限为：【-rw-r–r–】的数字则是：644 123owner = rw = 4+2 = 6group = r = 4others = r = 4 接下来用chmod命令将该文件的是三种身份的权限数字设置为770owner = rwx = 4+2+1 = 7group = rwx = 4+2+1 = 7;others = - - - = 0 123$ chmod 770 test.txt$ ls -al test.txt-rwxrwx--- 1 root root 29 Nov 18 00:00 test.txt 如果要将文件变成可执行的文件，并且不要让其他人修改文件的话，那就需要-rwxr-xr-x这样的权限，此时就要执行 chmod 755 fileName命令。 符号类型修改文件权限 符号类型修改文件权限可以借由(user)u，(group)g，(others)o,来代表三种身份的权限，此外a则代表all全部的身份，读写权限可以写成r、w、x chmod [u、g、o、a] [+（加入）、-（移除）、=（设置）] [r、w、x] 文件或目录 例如要把上面的test.txt设置成【-rwxr-xr-x】时： 12345$ ls -al test.txt-rwxrwx--- 1 root root 0 Mar 18 00:00 test.txt$ chmod u=rwx,go=rx test.txt$ ls -al-rwxr-xr-x 1 root root 0 Mar 18 00:00 test.txt 如果想为每身份加入w权限 123$ chmod a+w test.txt$ ls -al test.txt-rwxrwxrwx 1 root root 0 Mar 18 00:00 test.txt 如果想为每身份移除x权限 123$ chmod a-x test.txt$ ls -al test.txt-rw-rw-rw- 1 root root 0 Mar 18 01:49 test.txtLinux目录树执行文件路径的变量：$PATHPATH这个变量的内容是由一堆目录所组成，每个目录中间用冒号（:）来隔开，每个目录有顺序之分。就像下面的格式 1/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin:/usr/local/python37/bin 目录树的主要特征： 目录树的起始点为根目录（/，root）； 每个目录不止能使用本地区分的文件系统，也可以使用网络的文件系统； 用NetWork File System(NFS)服务器挂载某特点的目录 每个文件在此目录树中的文件都是独一无二的； 下面是目录树构架示意图（关于目录树更详细的说明，参考《鸟哥的Linux私房菜—基础学习篇（第四版）》第五章5.3节的FHS标准说明） 绝对路径与相对路径根据文件名写法的不同，也可将所谓定义为绝对路径与相对路径。这两种文件名路径写法依据如下： 绝对路径：由根目录（/）开始写起的文件名或目录名称； 相对路径：相对于目前所处在的目录的文件名写法，例如：../dir1、../dir1/opt等 ..代表上一层目录，也可以使用../来代表 .代表当前目录，也可以使用./来代表 参考资料 《鸟哥的Linux私房菜—基础学习篇（第四版）》 鸟哥著 人民邮电出版社","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"初识Linux","slug":"Linux/Linux基础","date":"2019-03-15T14:20:39.000Z","updated":"2020-03-18T13:45:01.808Z","comments":true,"path":"2019/03/15/Linux/Linux基础/","link":"","permalink":"http://yoursite.com/2019/03/15/Linux/Linux%E5%9F%BA%E7%A1%80/","excerpt":"","text":"什么是Linux?Linux就是一个操作系统(手动狗头) Linux几个常用的命令 cd dir：跳转到指定文件夹 123456跳转到root目录$ cd ~跳转到之前目录$ cd -跳转到上级目录$ cd .. cd 后面还可以文件夹绝对路径或相对路径跳转到指定目录 例如跳转到 /下的tmp目录 1$ cd /tmp pwd：查看当前所处的路径，输入pwd系统会返回当前所处的目录的绝对路径 ls -al：列出文件夹下的所有文件，包括隐藏文件 1$ ls -al 操作Linux系统几个重要的热键 [Tab]按键[Tab]按键就是在切换大小写按键[Casp Lock]上面的那个按键，它具有命令补全与文件补齐的功能。关键是可以避免打错命令或文件名。 这里总结一下 [Tab]接在一串命令的第一个字段后面，则为【命令补全】 [Tab]接在一串命令的第二个字段后面，则为【文件补全】 [Ctrl+c]按键有时候某些命令或程序在系统上一直“跑个不停”，想让命令或程序“停掉”时，可以用这个按键。输入:[Ctrl+c]按键，可以中断目前程序或命令。 [Ctrl+d]如果想要直接离开命令行模式，可以直接按下[Ctrl+d]就能直接离开（相当于输入exit） [Shift]+{Page Up}、[Shift]+{Page Down}按键使用[Shift]+{Page Up}向前翻页。使用[Shift]+{Page Down}先后翻页 正确的关机方法 正确的关机命令使用 几个与关机或重启相关命令 将数据同步写入硬盘的命令：sync 常用的关机命令：shutdown 重启、关机：reboot、halt、poweroff 数据同步写入磁盘：sync 使用sync命令进行数据的写入操作。在命令行下输入sync，那么在内存中尚未被更新的数据，就会被写入硬盘中。So 在关机或重启系统之前最好多执行几次 常用的关机命令：shutdown 这个是关闭Linux的命令，如果是root管理员可以使用。 1234567891011121314shutdown语法shutdown -[krhc] [时间] [警告信息] 选项与参数 -k：不是真的关机，只是发送警告信息出去。 -r：在将系统的服务停掉之后就重新启动（常用） -h：将系统的服务停掉后，立即关机（常用） -c：取消已经进行的shutdown命令内容 时间：指定系统关机的时间，设置时间的样式如下： shutdown -h 13:00 系统将在今天的13:00分关机 shutdown -h now 系统将立即关机 shutdown -r now 系统会立即重启 shutdown可以完成如下的工作： 可以自由选择关机模式：要是关机或重启均可； 可以设置关机时间：可以设置成现在立即关机，也可以设置某一个特定的时间关机； 可以自定义关机信息：在关机之前，可以将自己设置的信息发送给在线用户； 可以仅发出警告信息：有时有可能要进行一些测试，而不想让其他的用户干扰，或是明白的告诉用户某段时间要注意一下。 重启，关机：reboot、halt，poweroff 这三个命令可以进行重启与关机的操作。一般在关机或重启时，都会执行如下命令： 1sync;sync;sync;reboot 使用管理管理工具systemctl关机 在CentOS 7中可以使用systemctl来进行关机，实际上面介绍的关机与重启命令都是调用systemctl这个命令。 这个命令与关机的语法： 1234567systemctl [命令]命令项目有：haltpoweroffrebootsuspend //进入休眠模式# systemctl reboot #系统重启 参考资料 《鸟哥的Linux私房菜—基础学习篇（第四版）》 鸟哥著 人民邮电出版社","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]}]}