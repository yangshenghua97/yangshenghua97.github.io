{"meta":{"title":"楊さんノート","subtitle":"","description":"","author":"杨生华","url":"http://yoursite.com","root":"/"},"pages":[{"title":"Categories","date":"2020-02-09T08:10:17.612Z","updated":"2020-02-09T08:10:17.612Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"小杨的简介","date":"2020-04-08T13:03:17.937Z","updated":"2020-04-08T13:03:17.937Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"个人信息 杨生华/男/1997 本科/吉林化⼯学院/外国语学院/⽇语系/ 年级：2020年毕业 联系方式：13944680832 微信： 技术博客：楊さんノート Github：yangshenghua97 期望职位：/实习/Java后端开发 期望薪资：税前⽉薪3k-4k 项目和作品个人博客后台管理系统2019.01-2019.02技术运用： 开发环境：Windows/Linux、IntelliJ IDEA、JDK 1.8、MySQL 5.7、Redis、Tomcat 5. x、Git、Maven; 后端框架：Spring、Spring MVC、Myatis; 前端框架：AdminLTE3,JQuery等前端框架； 项目介绍： 基于Spring+Spring MVC + MyBatis框架的整合运用； 利用 Spring AOP对用户登录进行Token身份验证、Spring 事务隔离对SQL进行验证 MySQL 5.7 数据的基本使用、使用Druid数据库连接池对项目执行的SQL进行监控与优化； 单图/多图上传技术； 文件导入导出功能； 利用Redis缓存数据库对用户Token进行缓存 基于阿里云Linux系统进行部署与发布； Nginx + Tomcat的集群搭建； 微人事人力资源管理系统技术运用： 开发环境：Windows/Linux、IntelliJ IDEA、JDK 1.8、MySQL 5.7、Redis、Tomcat 5. x、Git、Maven; 后端框架：Spring Boot、MyBatis； 前端框架：Vue.js+Axios； 项目介绍： 基于Spring Boot、MyBatis、Spring Security的运用； 项目利用Maven对多模块进行整合，后端权限认证采用Spring Security实现； 数据库访问使用MyBatis，同时使用Redis实现认证信息缓存； 项目实现了邮件发送功能，采用Spring-Boot-Email+Spring Thymeleaf配合Java 多线程来对邮件进行发送； 技能清单 Java开发：熟悉Java开发、 对于Java多线程、I/O操作、反射、Java网络编程等都能其进行简单的应用。熟练使用Java集合，并且简单阅读多ArrayList、LinkedList、HashMap的源码。 了解ConcurrentHashMap的使用场景； 熟练操作Linux，掌握Linux常用命令，能够独立编写Linux Shell脚本代码，曾在阿里云服务器上发布过个人博客，熟悉Linux系统管理等； 熟练SQL语句编写、使用虚拟机搭建MySQL集群进行主从复制，事务隔离，索引优化等 了解Redis命令简单使用，使用虚拟机搭建Redis集群进行主从复制 前端框架：了解Vue.js、Node.js构建前端应用框架 版本管理、文档和自动化部署工具：了解Git版本控制系统常用命令的使用 开发框架及单元测试：JUnit对项目的各个模块进行单元测试、Spring、Spring Boot、Spring MVC、MyBatis的简单使用 学校经历2018.04-2018.09担任学生会网络部，主要工作是运营学院微信公众号以及组织学院活动； 2018.06-2018.07参加学校互联网+创新创业大赛获得校级团队二等奖； 工作经历 目前处于待就业实习阶段。2019年8月在吉林市创慧科技有限公司做图片处理工作"},{"title":"guestbook","date":"2020-03-31T03:10:00.000Z","updated":"2020-03-31T03:12:08.960Z","comments":true,"path":"guestbook/index.html","permalink":"http://yoursite.com/guestbook/index.html","excerpt":"","text":""},{"title":"Tags","date":"2020-02-09T09:12:40.508Z","updated":"2020-02-09T08:10:17.625Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Spark大数据快速分析学习笔记（RDD编程）","slug":"Spark大数据快速分析学习笔记（二）","date":"2020-06-27T15:07:07.000Z","updated":"2020-06-28T04:01:46.369Z","comments":true,"path":"2020/06/27/Spark大数据快速分析学习笔记（二）/","link":"","permalink":"http://yoursite.com/2020/06/27/Spark%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BF%AB%E9%80%9F%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/","excerpt":"","text":"RDD编程基础1.何为RDD？RDD的全名叫做弹性分布式数据集，其实就是分布式的元素集合。 RDD支持两种类型的操作：转化操作(Transformation) 和 行为操作(action)。转化操作会由一个RDD生成一个新的RDD。行为操作会对RDD计算出一个结果，并把结果返回到驱动器程序中，或把结果存储到外部的存储系统。 创建RDD创建RDD有两种方式：读取外部数据集、驱动程序中对一个集合进行并行化 创建RDD最简单的方式是把程序中一个已有的集合传递给SparkContext的parallelize()方法，这种方式不怎么常用，常用的方式是读取外部数据集 下面的代码就是从外部数据（HDFS）中创建RDD 1val infile = sc.textFile(\"hdfs://master:9000/datafile\") sc.textFile()是一个将文本文件读入为一个存储字符串的RDD方法 RDD操作 转化操作 行为操作 参考资料 《Spark大数据快速分析》","categories":[{"name":"大数据","slug":"大数据","permalink":"http://yoursite.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"}],"tags":[{"name":"spark","slug":"spark","permalink":"http://yoursite.com/tags/spark/"}]},{"title":"Spark大数据快速分析学习笔记（一）","slug":"Spark大数据快速分析学习笔记","date":"2020-06-26T14:44:53.000Z","updated":"2020-06-27T15:09:23.332Z","comments":true,"path":"2020/06/26/Spark大数据快速分析学习笔记/","link":"","permalink":"http://yoursite.com/2020/06/26/Spark%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BF%AB%E9%80%9F%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"Spark中的Python和Scala的ShellSpark自带交互式shell，能够即时数据分析。这里介绍两中语言的shell的使用； Python 要打开Python版本的Spark Shell可以在终端中输入命令： 1# pyspark Scala 打开Scala版本的shell 1# spark-shell 在打开spark shell时会输出很多的日志信息，可以调整日志的级别来控制输出的信息量。在spark的目录下的conf目录修改log4j.properties文件，在文件中修改如下内容： 1log4j.rootCategory=WARN, console 这样就可以减少大量的日志信息输出 使用Spark 初始化SparkContext 12val conf = new SparkConf().setAppName(\"App\")val sc = new SparkContext(conf=conf) 参考资料 《Spark快速大数据分析》","categories":[{"name":"大数据","slug":"大数据","permalink":"http://yoursite.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"}],"tags":[{"name":"spark","slug":"spark","permalink":"http://yoursite.com/tags/spark/"}]},{"title":"Python数据科学分析笔记","slug":"bigdata/数据分析/Python数据科学分析笔记","date":"2020-06-11T03:37:49.000Z","updated":"2020-06-11T03:37:49.779Z","comments":true,"path":"2020/06/11/bigdata/数据分析/Python数据科学分析笔记/","link":"","permalink":"http://yoursite.com/2020/06/11/bigdata/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E5%88%86%E6%9E%90%E7%AC%94%E8%AE%B0/","excerpt":"","text":"参考资料","categories":[{"name":"bigdata","slug":"bigdata","permalink":"http://yoursite.com/categories/bigdata/"},{"name":"数据分析","slug":"bigdata/数据分析","permalink":"http://yoursite.com/categories/bigdata/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"}],"tags":[]},{"title":"泛读Java集合源码分析","slug":"java/java基础/Java集合源码分析","date":"2020-06-11T03:31:29.000Z","updated":"2020-06-15T07:18:38.873Z","comments":true,"path":"2020/06/11/java/java基础/Java集合源码分析/","link":"","permalink":"http://yoursite.com/2020/06/11/java/java%E5%9F%BA%E7%A1%80/Java%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","excerpt":"","text":"剖析ArrayListArrayList实现的接口123public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123; .... ArrayList实现了List List是一个数组队列，提供了相关的添加、删除、修改、遍历等功能 ArrayList实现了 RandomAccess 接口，为ArrayList提供了随机访问功能，可以通过元素的序号快速获取元素对象。 ArrayList还实现Cloneable 接口，覆盖函数clone()，能够被克隆。实现Serializable意味着ArrayList可以被序列化 从java1.5后java加入了泛型的特性，在使用ArrayList时可以实现泛型化 例如下面的使用方法： 12ArrayList&lt;String&gt; strlist = new ArrayList&lt;String&gt;();ArrayList&lt;Integer&gt; intList = new ArrayList&lt;Integer&gt;(); ArrayList基本原理ArrayList的内部有一个elementData数组，一般会有一些预留的空间，有一个整数size记录实际的元素个数 12transient Object[] elementData;private int size; elementData会随着实际元素个数的增多而重新分配，而size则始终记录实际的元素个数 ArrayList常用方法的实现 add()方法 add方法的主要代码为： 12345public boolean add(E e) &#123; ensureCapacityInternal(size + 1); //插入元素，改变元素个数 elementData[size++] = e; return true; &#125; add()方法首先调用 ensureCapacityInternal(size + 1) 以确保数组容量是够的。 这里以java1.8为例，首先ensureCapacityInternal确保数组容量足够，代码如下： ensureCapacityInternal 123private void ensureCapacityInternal(int minCapacity) &#123; ensureExplicitCapacity(calculateCapacity(elementData,minCapacity));&#125; calculateCapacity 123456private static int calculateCapacity(Object[] elementData, int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; return Math.max(DEFAULT_CAPACITY, minCapacity); &#125; return minCapacity; &#125; calculateCapacity 判断elementData数组是否为空，如果是则将DEFAULT_CAPACITY的容量赋给minCapacity ，在这里DEFAULT_CAPACITY 大小为10； 1private static final int DEFAULT_CAPACITY = 10; 接下来调用ensureExplicitCapacity 1234567private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity); &#125; modCount 表示内部的增加修改次数，如果需要的长度大于当前的数组长度，则调用grow 方法,grow 的主要代码： 123456789private void grow(int minCapacity) &#123; int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); elementData = Arrays.copyOf(elementData, newCapacity); &#125; remove()方法 remove方法源码 1234567891011public E remove(int index) &#123; rangeCheck(index); modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; return oldValue; &#125; get()方法 ArrayList能够支持随机访问，是因为内部的数据结构是数组，数组本身就是支持随机访问。get()方法首先判断输入的index 是否越界，然后将数组的index位置的元素返回即可。 源代码如下： 123456789private void rangeCheck(int index) &#123; if (index &gt;= size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index));&#125;public E get(int index) &#123; rangeCheck(index); return elementData(index);&#125; ArrayList的特点对于Arraylist，由于内部实现采用动态数组实现，所以具有以下几个特点 可以随机访问，按照索引位置进行访问效率很高 除非数组已经排序，否则按照内容查找元素效率比较低下 添加元素的效率一般，重新分配和复制数组的开销平摊 插入删除元素效率低下，因为需要移动元素 ArrayList不是线程安全的，要实现线程安全的方式是使用Collections提供的方法修饰ArrayList 剖析LinkedListLinkedList实现了List接口、Deque、Queue接口。其内部实现是双向链表，每个元素在内存中是单独存放的，元素之间通过前驱链接和后继链接将节点连接起来。节点的代码如下： 1234567891011private static class Node&lt;E&gt; &#123; E item; Node&lt;E&gt; next; Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element;//元素 this.next = next;//前驱节点 this.prev = prev;//后继节点 &#125; &#125; LinkedList内部组成就是如下变量 123transient int size = 0;//链表的长度 transient Node&lt;E&gt; first;//指向头节点 transient Node&lt;E&gt; last;//指向尾节点 LinkedList常用的方法 add()方法 该方法是在链表的end添加元素，其调用了自己的方法linkLast(E e)。俩来看看源码 1234public boolean add()&#123; linkLast(e); return true;&#125; 该方法首先将last的Node引用指向了一个新的Node(l)，然后根据l新建了一个newNode，其中的元素就为要添加的e；而后，我们让last指向newNode，接下来是自身进行维护该链表。 1234567891011void linkLast(E e) &#123; final Node&lt;E&gt; l = last; final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); last = newNode; if (l == null) first = newNode; else l.next = newNode; size++; modCount++; &#125; remove()方法 1234public E remove(int index)&#123; checkElementIndex(index); return unlink(node(index));&#125; 通过node方法找到节点，调用了unlike方法 12345678910111213141516171819202122232425E unlink(Node&lt;E&gt; x) &#123; // assert x != null; final E element = x.item; final Node&lt;E&gt; next = x.next; final Node&lt;E&gt; prev = x.prev; if (prev == null) &#123; first = next; &#125; else &#123; prev.next = next; x.prev = null; &#125; if (next == null) &#123; last = prev; &#125; else &#123; next.prev = prev; x.next = null; &#125; x.item = null; size--; modCount++; return element; &#125; 删除x节点，就是让x的前驱和后继直接链接起来，next是x的后继，prev是x的前驱，分为下面两步： 让x的前驱的后继指向x的后继。如果没有前驱，说明删除的是头节点，则修改头节点指向x的后继。 让x的后继的前驱指向x的前驱。如果x没有后继，说明删除的是尾节点，则修改尾节点指向x的前驱。 LinkedList特点 用法上，LinkedList是一个List，但也实现了Deque接口，可以作为队列、栈。双端队列使用。实现原理上，LinkedList内部是一个双向链表，并维护了长度，头节点、尾节点。 按需分配空间，不需要预先分配很多的空间 不可以随机访问，按照索引位置访问效率太低，必须从头到尾顺着链接找 不管列表是否排序，只要是按照内容查找元素，效率都比较低 在两端添加、删除元素的效率很高 在中间插入、删除元素，要先定位，效率比较低，而修改本身的效率很高 HashMapHashMap实现了Map接口，HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。 内部组成：HashMap内部组成主要有如下实例变量 1234transient Entry&lt;K,V&gt;[]table = (Entry&lt;K,V&gt;[])EMPTY_TABLE;transient int size;int threshold;final float loadFactor;","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"java基础编程","slug":"java基础编程","permalink":"http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/"}]},{"title":"Java集合框架","slug":"java/java基础/Java集合框架","date":"2020-06-09T08:32:12.000Z","updated":"2020-06-11T07:39:18.795Z","comments":true,"path":"2020/06/09/java/java基础/Java集合框架/","link":"","permalink":"http://yoursite.com/2020/06/09/java/java%E5%9F%BA%E7%A1%80/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/","excerpt":"","text":"在编程时有些场景需要用到Java的集合框架，这篇博文将介绍在Java系统里的集合框架。 Java提供了大量持有对象的方式： 数组 Collection保存单一的元素，Map保存相关联的键值对。各种Collection和各种Map都可以在你向其中添加更多元素时自动调整其尺寸。 向数组一样，List也建立数字索引与对象的关联，因此数组和List都是拍好序的容器。List能自动扩充容量。 如果要进行大量的随机访问，就使用ArrayList;如果要经常从表中间插入或删除元素，则使用LinkedList. 各种Queue及栈的行为，优LinkedList提供 Map是一种将对象与对象相关联的设计，HashMap设计用来快速访问；LinkedHashMap保持元素插入时的顺序，但是也通过散列提供快速访问能力。 Set不接受重复元素。HashSet提供最快的查询速度，LinkedHashSet以插入顺序保存元素 CollectionListList有两种基本类型：ArrayList和LinkedList ArrayListArrayList长于随机访问元素，但是在List的中间插入和移除元素时比较慢。下面来列举几个ArrayList的常用API contains()用于确定某个对象是否在列表中。 remove()方法移除一个对象，将这个对象的引用传递给remove()方法 indexOf()方法用来获取某个对象在List中的所处位置的索引编号 subList()方法将从较大的列表中创建出一个片段。 retailAll()方法时List的交集操作 LinkedListLinkedList实现基本的List接口。下面介绍LinkedList中的一些方法 getFirst()方法返回列表的头，如果List为空，则抛出异常 removeFirst()移除并返回列表的头元素，在列表为空时抛出异常 addList()和addLast()相同，将某个元素插入到列表的头部或尾部 removeLast()移除并返回列表的最后一个元素 QueueQueue是先进先出的容器，从容器的一端放入事物，从另一端取出，并且事物放入容器顺序与取出的顺序相同，队列常常被当作一种可靠的将对象从程序的某个区域传输到另一个区域的途径，下面介绍在Queue中的方法： offer()方法将一个元素插入到队尾，或者返回false peek()和element()都将在不移除的情况下返回对头，peek()方法在队列为空时返回null，element()则会抛出异常信息。 poll()和remove()方法将移除并返回对头，当队列为空时poll()返回空，而remove()会抛出异常 Map参考资料 《Java编程思想》","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"java基础编程","slug":"java基础编程","permalink":"http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/"}]},{"title":"Executor框架","slug":"java/并发编程/Executor框架","date":"2020-06-05T06:13:11.000Z","updated":"2020-06-06T10:05:32.139Z","comments":true,"path":"2020/06/05/java/并发编程/Executor框架/","link":"","permalink":"http://yoursite.com/2020/06/05/java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Executor%E6%A1%86%E6%9E%B6/","excerpt":"","text":"Executor框架两级调度 Java线程启动时会创建一个本地操作系统线程，当该Java线程终止时，这个操作系统线程也会被回收。操作系统会调度所有线程并将它们分配给可用CPU。 在上面的调度模型中： 在上层，Java多线程程序通常把应用分解为若干任务，然后使用用户级的调度器将这些任务映射为固定数量的线程；在底层，操作系统内核将这些线程映射到硬件处理器上。 Executor框架结构Executor框架由3大部分组成 任务 包括被执行任务需要的实现接口(Runnable接口或Callable接口)Runnable接口和Callable接口的实现类，可以被ThreadPoolExecutor或者ScheduleThreadPoolExecutor 执行的任务 包括任务执行机制的核心接口Executor以及继承自Executor的ExecutorService接口 Executor是一个接口，时Executor框架的基础，它将任务的提交与任务的执行分离 ThreadPoolExecutor是线程池的核心实现类，用来执行被提交的任务 ScheduleThreadPoolExecutor，可以在给定的延迟后运行命令，或者定期执行命令 异步计算的框架包括接口Future和实现Future接口的FutureTask类，代表异步计算的结果 Executor框架成员Executor框架主要成员：ThreadPoolExecutor、ScheduledThreadPoolExecutor、Future接口、Runnable接口、Callable接口、Executors。 ThreadPoolExecutor ThreadPoolExecutor通常使用工厂类Executors来创建，Executors可以创建3种类型的ThreadPoolExecutor；分别是SingleThreadExecutor、FixedThreadPool、CachedThreadPool。ThreadPoolExecutor是Executor框架最核心的类，是实现线程池的类。主要由下列组件构成 corePool：核心线程池大小 maximumPool：最大线程池的大小 BlockingQueue：用来暂时保存任务的工作队列 下面分别介绍3种类型的ThreadPoolExecutor： SingleThreadExecutor： SingleThreadExecutor适用于需要保证顺序执行各个任务；并且在任意时间点，不会有多个线程是活动的应用场景。 1234567891011121314public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;())); &#125; public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory) &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(), threadFactory)); &#125; 在上面的代码中，SingleThreadExecutor的corePoolSize和maximumPoolSize被设置为1，SingleThreadExecutor使用无界队列LinkedQueueBlockingQueue作为线程池的工作队列（队列的容量为Integer.MAX_VALUE）。SingleThreadExecutor的运行图如下 下面对上图中的过程进行说明： 1.如果当前运行的线程少于corePoolSize（线程池中没有运行的线程），则创建一个线程类执行任务 2.在线程池完成预热之后，将任务加入LinkedBlockingQueue 3.线程执行完1中的任务后，会在一个无限循环中反复从LinkedBlockingQueue获取任务来执行 FixedThreadPool： FixedThreadPool适用于为了满足资源管理的需求，而需要限制当前线程数量的应用场景。适用于负载均衡比较重的服务器 123456789101112public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()); &#125; public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(), threadFactory); &#125; FixedThreadPool的corePoolSize和maximumPoolSize都被设置为创建FixedThreadPool时指定的参数nThread 当线程池中的线程数大于corePoolSize时，keepAliveTime为多余的空闲线程等待新任务的最长时间，超过这个时间后多余的线程将被终止。把keepAliveTime设置为0L，说明多余的空闲线程会被立即终止。 1.如果当前运行的线程数少于corePoolSize，则创建线程来执行任务 2.在线程池完成预热后将任务加入LinkedBlockingQueue 3.线程执行完成1中的任务后，会在循环中反复从LinkedBlockingQueue获取任务来执行 FixedThreadPool使用无界队列LinkedBlockingQueue作为线程池的工作队列（队列的容量为Integer.MAX_VALUE） CachedThreadPool CachedThreadPool是大小无界的线程池，适用于执行很多短期异步任务的小程序或负载较轻的服务器 123456public static ExecutorService newCachedThreadPool(ThreadFactory threadFactory) &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;(), threadFactory); &#125; CachedThreadPool的corePoolSize被设置为0，maximumPoolSize被设置为Integer.MAX_VALUE,即maximumPool是无界，把keepAliveTime设置为60L，CachedThreadPool中的空闲线程等待新任务的最长时间为60秒，空闲线程超过60秒后将会终止 ScheduleThreadPoolExecutor待续","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"java并发编程","slug":"java并发编程","permalink":"http://yoursite.com/tags/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}]},{"title":"MapReduce&HDFS","slug":"bigdata/MapReduce-HDFS","date":"2020-06-05T03:18:43.000Z","updated":"2020-06-06T10:32:39.137Z","comments":true,"path":"2020/06/05/bigdata/MapReduce-HDFS/","link":"","permalink":"http://yoursite.com/2020/06/05/bigdata/MapReduce-HDFS/","excerpt":"","text":"MapReduceMapReduce编程模型 整个MapReduce计算过程分为Map阶段和Reduce阶段，也称为映射和缩减阶段，这两个独立的阶段实际上是两个独立的过程，即Map过程和Reduce过程，在Map中进行数据的读取和数据的预处理，之后将预处理的结果发送给Reduce中进行合并。 MapReduce执行流程 Hadoop计算流程 HDFS","categories":[{"name":"大数据","slug":"大数据","permalink":"http://yoursite.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"}],"tags":[{"name":"hadoop","slug":"hadoop","permalink":"http://yoursite.com/tags/hadoop/"}]},{"title":"队列同步器-AQS","slug":"java/并发编程/AQS同步器","date":"2020-05-16T05:03:22.000Z","updated":"2020-06-04T05:57:00.150Z","comments":true,"path":"2020/05/16/java/并发编程/AQS同步器/","link":"","permalink":"http://yoursite.com/2020/05/16/java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/AQS%E5%90%8C%E6%AD%A5%E5%99%A8/","excerpt":"","text":"什么是队列同步器队列同步器是用来构建锁或者其他同步组件的基础框架，它使用一个int成员变量表示同步状态，通过内置的FIFO队列完成资源获得线程的排队工作。 同步器是实现锁的关键，在锁的实现中聚合同步器，利用同步器实现锁的语义。 锁和同步器两者的关系：锁是面向使用者，定义了使用者与锁交互的接口，隐藏实现细节；而同步器面向的是锁的实现者，简化了锁的实现方式，屏蔽了同步状态管理、线程的排队、等待与唤醒等底层操作。 AQS的主要使用方式是继承，子类通过继承同步器并实现它的抽象方法来管理同步状态，在抽象方法的实现过程中需要对同步状态进行更新，因此就需要使用同步器提供的3个方法来保证状态的改变是安全的。 队列同步器的实现同步队列同步队列依赖内部的同步队列完成同步状态的管理，当前线程获得同步状态失败时，同步器会将当前线程以及等待状态等信息构成一个节点将其加入到同步队列中，同时会阻塞当前线程，当同步状态释放时，会将首节点的线程唤醒，使其再次尝试获取同步状态。同步队列中的节点用来保存获取同步状态失败的线程引用、等待状态以及前驱后继节点。 属性类型与名称 描述 int waitStatus 等待状态 Node prev 前驱节点 Node next 后继节点 Node nextWaiter 等待队列中的后继节点 Thread thread 获取同步状态的线程 上面的waitStatus变量中有这么几个状态， CANCELED SIGNAL CONDITION PROPAGATE INITIAL 同步队列的基本结构如下 同步器提供一个基于CAS的设置尾节点的方法（compareAndSetStatus），通过CAS设置尾节点； 如下图：","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"java并发编程","slug":"java并发编程","permalink":"http://yoursite.com/tags/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}]},{"title":"Java中的线程池","slug":"java/并发编程/Java中的线程池","date":"2020-05-04T06:29:41.000Z","updated":"2020-06-04T12:53:06.297Z","comments":true,"path":"2020/05/04/java/并发编程/Java中的线程池/","link":"","permalink":"http://yoursite.com/2020/05/04/java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0/","excerpt":"","text":"合理使用线程池的好处 降低资源消耗 通过重复利用已创建的线程降低线程创建和的销毁造成的消耗 提高响应速度 当任务到达时，任务可以不需要等到线程创建就能立即执行 提高线程的可管理性 线程是稀缺资源，如果无限制创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优、监控 线程池的实现原理线程池的处理流程 线程池判断核心线程池里的线程是否都在执行任务。如果不是，则创建一个新的工作线程来执行任务。如果核心线程池里的线程都在执行任务，则进入下一个流程 线程池铺垫工作队列是否已满。如果工作队列没有满，则将新提交的任务存储在这个工作队列中。如果工作队列慢了，则进入下一个流程 线程池判断线程池的线程是否都处于工作状态。如果没有，则创建一个新的工作线程來执行任务。如果已满，则交给饱和策略来处理这个任务 流程图图如下： ThreadPoolExector执行execute ThreadPoolExecutor执行execute方法分为4种情况： 1 如果当前线程少于corePoolSize，则创建新线程来执行任务 2 如果运行的线程等于或多于corePoolSize，则将任务加入BlockingQueue 3 如果无法将任务加入BlockingQueue，则创建新的线程来处理任务 4 如果创建新线程将使当前运行的线程超出maximumPoolSize，任务将被拒绝，并调用异常方法 线程池中的线程执行任务分两种情况 在execute()方法中创建一个线程时，会让这个线程执行当前任务 这个线程执行完下图中1的任务后，会反复从BlockingQueue中获取任务来执行 线程池的使用 线程池的创建 通过ThreadPoolExecutor来创建一个线程池 12345new ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) 创建一个线程需要输入几个参数 corePoolSize：线程池的基本大小 maximumPoolSize：线程池最大数量 keepAliveTime：线程活动保持时间 unit：线程活动保持时间单位 workQueue：任务队列 向线程池提交任务 使用两个方法向线程池提交任务 execute()方法： execute()方法用于提交不需要返回值得任务，所以无法判断任务是否被线程池执行成功 submit()方法： submit()方法用于提交需要返回值的任务。线程池会返回一个future类型的对象，通过这个future对象可以判断任务是否执行成功，并且可以通过future的get()方法来获取返回值，get()方法会阻塞当前线程直到任务完成，get(long timeout,TimeUnit unit)方法则会阻塞当前线程一段时间后立即返回，这种情况下有可能任务没有执行完成。 关闭线程池 通过调用线程池的shutdown或shutdownNow方法关闭线程池。 shutdownNow首先将线程池的状态设置成STOP,然后尝试停止所有正在执行或暂停任务的线程，并返回等待执行任务的列表。 shutdown只是将线程池的状态设置成SHUTDOWN状态，然后中断所有没有正在执行的任务的线程。","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"java并发编程","slug":"java并发编程","permalink":"http://yoursite.com/tags/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}]},{"title":"Java并发编程之Synchronized","slug":"java/并发编程/Java并发编程之Synchronized","date":"2020-04-25T08:07:02.000Z","updated":"2020-05-06T01:56:55.758Z","comments":true,"path":"2020/04/25/java/并发编程/Java并发编程之Synchronized/","link":"","permalink":"http://yoursite.com/2020/04/25/java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BSynchronized/","excerpt":"","text":"synchronized的实现原理利用synchronized实现同步的基础： 对于普通同步方法，锁是当前的实例对象 对于静态同步方法，锁是当前类的Class对象 对于同步方法块，锁是Synchronized括号里的配置对象 Synchronized实现原理：JVM基于进入和退出Monitor对象来实现方法同步和代码块同步，代码块同步使用monitorenter和monitorexit指令实现，monitorenter指令是在编译后插入到同步代码块开始位置，而monitorexit是插入到方法结束和异常处，JVM要保证每个monitorenter必须有对应的monitorexit与之匹配。 关键字synchronized可以修饰方法或者以同步块的形式来进行使用，它主要确保多个线程在同一时刻，只能有一个线程处于方法或同步块中，他保证了线程对变量访问的可见性和排他性。对于同步块的实现使用monitorenter和monitorexit指令，而同步方法则是依靠方法修饰符上的ACC_SYNCHRONIZED来完成。其本质上是对一个对象的监视器(monitor)进行获取，而这个过程是排他的，也就是在同一时刻只能有一个线程获得synchronized所保护对象的监视器。任意一个对象都拥有自己的监视器，当这个对象有同步块或者这个对象的同步方法调用时，执行方法的线程必须先获取到该对象的监视器才能进入同步块或者同步方法，而没有获取到监视器的线程将会被阻塞在同步块和同步方法的入口处，进入BLOCKED状态。 参考资料","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"java并发编程","slug":"java并发编程","permalink":"http://yoursite.com/tags/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}]},{"title":"TCP/IP协议","slug":"计算机基础/计算机网络/TTCP-IP协议","date":"2020-03-12T18:19:13.000Z","updated":"2020-03-15T14:02:04.814Z","comments":true,"path":"2020/03/13/计算机基础/计算机网络/TTCP-IP协议/","link":"","permalink":"http://yoursite.com/2020/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TTCP-IP%E5%8D%8F%E8%AE%AE/","excerpt":"","text":"TCP/IP的标准制定由于TCP/IP技术的公开性，他不属于任何一个厂商或者是专业协会所有。TCP/IP的标准大部分都由RFC技术报告的形式公开。RCF文件包含了所有TCP/IP的协定标准，以及其最新版本。RFC所涵盖的内容和细节非常广，也可以为新协定的标准和计划，但不能以学术研究论文的方式来编辑。 TCP/IP的特性 它是其它网络服务的基础，几乎所有数据包交换网络都提供了这种服务。TCP/IP是根据信息中所含的地址资料来进行资料的传送，他不能确保每个独立路由的数据包是可靠和依序的送达目的地。在每个连线过程中，线路都不是被”独占”的，而是直接映射到硬件地址上，因此特别有效。 因为数据包交换并不能确保每一个数据包的可靠性，因此我们就需要通讯软件来自动检测和修护传送过程中出现的错误和处理损坏数据包。这种服务就是用来确保电脑程序之间能够连接和传送大量的数据。关键的技术就是数据流进行分割，然后编号传送，然后通过接受的确认来确数据的完整性 在数据包交换技术中，TCP/IP是独立于硬件之上的。TCP/IP有自己的一套数据包规定和定义,能应用在不同的网络之上 只要用TCP/IP连接网络，就会获得一个独一无二的识别位址。数据包在交换过程中，是以位址数据为依据，不管数据包所经历的路由如何，数据都会被送到指定的地址。 TCP/IP 的确认模式是以“端到端”进行的。這样就无需理会数据包交换过程中所参与的其他设备。 TCP/IP协议分层框架 链路程：链路层以字节位单位0和1分别进行分组，定义数据帧，写入源和目标机器的物理地址，数据，校验位来传输数据。 链路层报文结构 网络层：根据IP定义网络地址，区分网段。子网内根据地址解析协议(ARP)进行MAC寻址，子网外进行路由转发数据包，这个数据包即为IP数据包。 传输层：数据包通过网络层发送到目标计算机后，应用程序在传输层定义逻辑端口，确认身份后，将数据包交给应用程序，实现端口到端口间通讯。 应用层：传输层的数据到达应用程序时，以某种统一规定的协议格式解读数据。 IP协议IP是面向无连接、无状态的，没有额外的机制保证发送的包是否有序到达。IP首先规定出IP地址格式，该地址相当于在逻辑意义上进行了网段的划分，给没台机器额外设置了一个唯一的详细地址。IP地址属于网络层，主要的功能字啊WLAN内进行路由寻址，选择最佳路由。 TCP建立连接传输控制协议(TCP)，是一种面向连接、确保数据在端到端间的可靠传输的协议。面向连接是指在发送数据前，需要先建立一条虚拟的链路，然后让数据在这条链路上“流动”传输。每个TCP数据包是封装在IP包中的，每一个IP头的后面紧接的是TCP头。 协议第一行的两个端口号各个占据两个字节，分别代表源机器与目标机器的端口号。这两个端口号与IP报头格式中的源IP地址和目标IP地址所组成的四元组可唯一标识一条TCP连接。由于TCP是面向连接的，所以有服务器和客户端之分。需要服务端先在相应的端口上进行监听，准备好接收客户端发起的连接请求。在类UNIX系统系统上通过netstat命令列出机器上已建立的连接信息，其中包含唯一标识一条连接的四元组，以及各连接的状态等内容。 TCP的FLAG位有6个bit组成，分别代表SYN、ACK、FIN、URG、PSH、RST，需要重点关注的是SYN、ACK、FIN。SYN(Synchronize Sequence Numbers)用作建立连接时的同步信号；ACK(Acknowledgement)用于对收到的数据进行确认，所确认的数据由确认序列号表示；FIN(Finish)表示后面没有数据需要发送，通常意味着所建立的连接需要关闭。 TCP三次握手TCP三次握手是指在建立连接的三个步骤： A机器发出一个数据包并将SYN置1，表示希望建立连接。这个包中的序列号假设是x。 B机器收到A机器发过来的数据包后，通过SYN得知这是一个建立连接的请求，于是发送一个响应包并将SYN和ACK标记都置为1。假设这个包中的序列号是y，而确认序列号的必须是x+1，表示收到了A发过来的SYN。在TCP中，SYN被当作数据中的一个字节。 A接收到B的响应后需进行确认，确认包中将ACK置1，并将确认序列号设置为y+1，表示收到了来自B的SYN。 双方只有确认4类信息，才能建立连接。在第二次握手后，从B机器视角看还有连个NO信息无法确认。在第三次握手后，B机器才能确认自己的发报能力是否正常的。 连接三次握手也是防止出现请求超时导致脏连接。TTL网络报文的生存时间往往都会超过TCP请求时间，如果两次握手就可以创建连接的话，传输数据并释放连接后，第一个超时的连接请求才到达B机器的话，B机器会认为是A创建的连接的请求，然后确认同意创建连接。因为A机器的状态不是SYN_SENT,所以直接丢弃了B的确认数据，以致最后只是B机器单方面创建连接完毕。 TCP断开连接TCP是全双工通信，双方都能作为数据的发送方和接收方，但TCP连接也会有断开的时候。A、B机器连接只要三次握手，而断开则需要四次挥手，例如下图： A机器想要断开连接，则待本方数据发送完毕后，传递FIN信号给B机器。B机器应答ACK，告诉A机器可以断开，但是需要等B机器处理完成数据，再主动给A机器发送FIN信号。这时A机器处于半关闭状态(FIN-WAIT-2)，无法再发送新的数据。B机器做好连接关闭前的准备工作后，发送FIN给A机器，此时B机器也进入半关闭状态(CLOSE_WAIT)。A机器发送针对B机器FIN的ACK后，进入TIME_WAIT状态，经过2MSL后，没有收到B机器传过来的报文，则确定B机器已经收到A机器最后发送的ACK指令，此时TCP连接正式释放。","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"CPU与内存","slug":"计算机基础/计算机构成/CPU与内存","date":"2020-03-11T14:15:02.000Z","updated":"2020-03-12T19:34:04.876Z","comments":true,"path":"2020/03/11/计算机基础/计算机构成/CPU与内存/","link":"","permalink":"http://yoursite.com/2020/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%9E%84%E6%88%90/CPU%E4%B8%8E%E5%86%85%E5%AD%98/","excerpt":"","text":"参考资料","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}]},{"title":"计算机的0与1","slug":"计算机基础/计算机构成/计算机的0与1","date":"2020-03-11T12:53:21.000Z","updated":"2020-03-11T14:14:08.175Z","comments":true,"path":"2020/03/11/计算机基础/计算机构成/计算机的0与1/","link":"","permalink":"http://yoursite.com/2020/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%9E%84%E6%88%90/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%840%E4%B8%8E1/","excerpt":"","text":"在计算机中无论是什么设备，归根结底都是0和1的信号处理，设定基数为2，进位的规则是“逢二进一”，称之为二进制，设想有8条电路，每条电路有高电平和低电平两种状态。根据组合排列，有2^8 即256个种不同的信号。这8条电路，最左侧的一条表示正负，0表示正数，1表示负数，不参与数值表示。 基本编码表示数的基本编码方式有原码、反码、补码； 原码：符号为和数字实际值得结合，正数就是数值本身，符号为0；负数是数值本身，符号位为1，8位的二进制的表示范围是[-127,127] 反码：正数是本身，符号位为0；负数的数值部分是正数表示的基础上对各个位取反，符号位为1。8位二进制数的表示范围是[-127,127] 补码：正数是数组的本身，符号位为0，负数的数值部分是在正数表示基础上对各个位取反加1，符号位为1。8位二进制数的表示范围是[-127,127] 正数/负数 原码 反码 补码 1 0000 0001 0000 0001 0000 0001 -1 1000 0001 1111 1110 1111 1111 2 0000 0010 0000 0010 0000 0010 -2 1000 0010 1111 1101 1111 1110 为了加速计算机对加减乘除运算速度，所有产生了反码和补码。例如在进行减法计算时，1-2=-1在计算机运算中可以这样运算：1+（-2）=-1。如果使用原码计算则结果为：1+（-2）= [0000 0001]原+[1000 0010]原 = [10000011]原 = -3结果是错误的。为了解决这一问题，于是出现了反码，使用反码计算，结果为1-2 = 1+(-2) = [00000001]反+[1111 1101]反=[1111 1110]反 = -1。 计算机存储计量单位在上述的一条线路在计算机中表示1位，即1个bit，8个bit组成一个单位，称为一个字节，即1个Byte，1024个Byte简写为KB，1024个KB简写为MB，1024个MB简写为GB。 位移运算向右移动一位近似表示除以2，十进制转化为二进制数后，向右移时，最右边的1位将被直接抹去。在左移&lt;&lt;和右移&gt;&gt;这两种运算中符号位均参与移动，除了负数右移时高位补1外，其他情况均在空位处补0 左移运算由于符号位参与向左移动，在移动后的结果，最左位可能是1或是0，即正数向左移的结果可能负数也可能是正数，负数向左移的结果也是如此。 对于 &gt;&gt;&gt; 无符号向右移动(不存在&lt;&lt;&lt;位移运算)，当向右移动时，正负数高位均补0，正数不断向右移动的最小值是0，而负数不断向右移动的最小值为1，无需考虑符号位，高位直接补0 参考资料 《码出高效 Java开发手册》","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}]},{"title":"数据结构基础","slug":"数据结构与算法/数据结构基础","date":"2020-02-20T04:54:01.000Z","updated":"2020-12-05T04:18:14.845Z","comments":true,"path":"2020/02/20/数据结构与算法/数据结构基础/","link":"","permalink":"http://yoursite.com/2020/02/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/","excerpt":"","text":"数据结构数据结构是算法的基石，是数据的组织、管理、存储形式，请使用的目的是为了访问和修改数据。数据结构的组成形式有：线性结构、树、图、其他数据结构（这个后面会缀述） 数组 数组是有限个相同类型的变量所组成的有序集合，数组中的每个变量称为元素。 数组的基本操作 读取元素：读取元素，只需要给出一个数组的下标，就可以读取相应的数组元素。这种根据下标读取的元素的方式称为随机读取。 更新元素：把一个元素的值替换成为一个新值，利用数组下标，把新值赋给该元素。 插入元素：插入数组元素的有三种：尾部插入、中间插入、超范围插入。 中间插入复杂些，因为数组的每个元素都有固定的下标，所以需要把插入位置及以后的元素向后移动，再把插入的元素放到对应的数组位置上。 超范围插入：超范围插入涉及到扩容，可以创建一个新数组，长度是旧数组的2倍，再把旧数组中的元素复制给新数组，就是实现了数组的扩容。 删除元素：数组的删除操作，如果删除的元素位于数组的中间，其后的元素都需要向前（也就是向左移动一位） 数组的优点和缺点数组的优点是拥有高效的随机访问能力。数组的缺点在插入和删除元素方面，由于数组元素连续紧密的存储在内存中，插入和删除元素会导致大量元素移动。数组适合读多写少的应用场景。 链表 链表是一种在物理上非连续、非顺序的数据结构，由若干节点所组成。单向链表的每个节点包含两部分，一部分是存放数据的变量data，一部分是指向下一个节点的指针next。 1234private static class Node&#123; int data; Node next;&#125; 双向链表比单项链表多了指向前置节点的prev指针 链表在内存中的存储方式是随机存储 链表的基本操作 查找节点： 链表查找节点时只能从头节点开始向后逐个查找。 更新节点： 链表的更新过程会像数组那样，直接把旧数据替换成新数据即可 插入节点： 尾部插入：把最后一个节点的next指针指向新插入的节点即可。 头部插入：把新节点的next节点的指针原先的头节点，把新节点变成链表的头节点 中间插入：把新节点的next指针指向插入位置的节点，插入位置前置节点的next指针指向新节点。 删除元素： 尾部删除：把倒数第二个节点的next指针指向空即可 头部删除：把链表的头节点设为原先头节点的next指针即可 中间删除：把要删除的节点的前置节点的next指针，指向要删除元素的下一个节点即可 上代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687public class MyLinkedList&#123; private Node head; private Node last; private int size; public void insert(int data,int index)throws Exception&#123; if(index &lt; 0 || index &gt; size)&#123; throw new IndexOutOfBoundsException(\"Index outfound\"); &#125; Node insertedNode = new Node(data); if(size == 0)&#123; head = insertedNode; last = insertedNode; &#125;else if(index == 0)&#123; insertedNode.next = head; head = insertedNode; &#125;else if(size == index)&#123; last.next = insertedNode; last = insertedNode; &#125;else&#123; Node prevNode = get(index-1); insertedNode.next = prevNode.next; prevNode.next = insertedNode; &#125; size++; &#125; public Node get(int index)throws Exception&#123; if(index &lt; 0 || index &gt;= size)&#123; throw new IndexOutOfBoundsException(\"数组越界\"); &#125; Node temp = head; for(int i = 0;i&lt;index;i++)&#123; temp = temp.next; &#125; return temp; &#125; public void output()&#123; Node temp = head; while(temp != null)&#123; System.out.println(temp.data); temp = temp.next; &#125; System.out.println(\"size：\"+size); &#125; public Node remove(int index)throws Exception&#123; if(index &lt; 0|| index &gt;= size)&#123; throw new IndexOutOfBoundsException(\"下标越界\"); &#125; Node removeNode = null; if(index == 0)&#123; // 删除头结点 removeNode = head; head = head.next; &#125;else if(index == size-1)&#123; // 删除尾节点 Node prevNode = get(index-1); removeNode = prevNode.next; prevNode.next = null; last = prevNode; &#125;else&#123; // 删除中间节点 Node prevNode = get(index-1); Node nextNode = prevNode.next.next; removeNode = prevNode.next; prevNode.next = nextNode; &#125; size--; return removeNode; &#125; private static class Node&#123; int data; Node next; Node(int data)&#123; this.data = data; &#125; &#125; public static void main(String[] args)throws Exception&#123; MyLinkedList myLinkedList = new MyLinkedList(); myLinkedList.insert(3,0); myLinkedList.insert(7,1); myLinkedList.insert(9,2); myLinkedList.insert(5,3); myLinkedList.insert(6,1); myLinkedList.remove(0); myLinkedList.output(); &#125;&#125; 数组和链表的比较： 查找 更新 插入 删除 数组 O(1) O(1) O(n) O(n) 链表 O(n) O(1) O(1) O(1) 对于读操作多写操作少的应用场景数组适合一些，对于需要频繁插入数据删除数据来说，链表合适一些 栈栈是一种线性数据结构，栈中的元素只能先入后出。最早进入的元素存放的位置叫作栈底，最后进入的元素存放的位置叫作栈顶。 栈的基本操作 入栈(push) 入栈操作就是把新元素放入栈中，只允许从栈顶一侧放入元素，新元素的位置将会成为新的栈顶 出栈(pop) 出栈操作是把元素从栈中弹出，只有栈顶元素才能允许出栈，出栈元素的前一个元素将会成为新的栈顶。 代码： 12345678910111213141516171819202122232425262728293031323334353637public class MyStack&#123; private int[] stack; private int size; public MyStack(int capacity)&#123; this.stack = new int[capacity]; this.size = 0; &#125; public void push(int elem)throws Exception&#123; if(size &gt; stack.length)&#123; throw new IndexOutOfBoundsException(\"数组越界\"); &#125; stack[size] = elem; size++; &#125; public int pop()throws Exception&#123; if(size &lt; 0)&#123; throw new IndexOutOfBoundsException(\"栈为空\"); &#125; size--; return stack[size]; &#125; public void output()throws Exception&#123; System.out.print(\"栈顶：\"); for(int i = size-1;i&gt;=0;i--)&#123; System.out.println(pop()); &#125; System.out.println(\"栈底：\"); &#125; public static void main(String[] args)throws Exception&#123; MyStack stack = new MyStack(5); stack.push(5); stack.push(6); stack.push(52); System.out.println(stack.pop()); // stack.output(); &#125;&#125; 队列队列是一种线性数据结构，队列中的元素只能先入后出，对列的出口端叫作队头(front)，队列的入口端叫作队尾(rear)。 队列的基本操作 入队（enqueue） 入队操作（enqueue）就是把新元素放入队列中，只允许在队尾的位置放入元素，新元素的下一个位置将会成为新的对尾。 出队（dequeue） 出队操作就是把元素移出队列，只允许在队头一侧移出元素，出队元素的后一个元素将会成为队头。 循环队列：在数组不做扩容的前提下，可以利用已出队元素留下的空间，让队尾指针重新指回数组的首位。一直到(队尾下标+1)%数组长度 = 队头下标，表示此队列已经满，队尾指针指向的位置永远空出1位，所以队列最大容量比数组长度小1。 12345678910111213141516171819202122232425262728293031323334353637383940414243public class MyQueue&#123; private int[] array; // 队头 private int front; // 队尾 private int rear; public MyQueue(int capacity)&#123; this.array = new int[capacity]; &#125; /** 入队操作 */ public void enqueue(int elem)throws Exception&#123; if((rear+1)%array.length == front)&#123; throw new Exception(\"队列已满\"); &#125; array[rear] = elem; rear = (rear+1)%array.length; &#125; /** */ public int dequeue()throws Exception&#123; if(rear==front)&#123; throw new Exception(\"队列已空\"); &#125; int dequeueElem = array[front]; front = (front+1)%array.length; return dequeueElem; &#125; public void output()&#123; for(int i = front;i!=rear;i=(i+1)%array.length)&#123; System.out.println(array[i]); &#125; &#125; public static void main(String[] args)throws Exception&#123; MyQueue queue = new MyQueue(5); queue.enqueue(5); queue.enqueue(4); queue.enqueue(6); queue.enqueue(5); queue.output(); &#125;&#125; 栈和队列的应用栈的输出顺序和输入顺序相反，所以栈通常用于对“历史”的回溯，也就是逆流而上追溯“历史”。例如实现递归的逻辑，就可以用栈来代替，因为栈可以回溯方法的调用链。 队列的输出顺序和输入顺序相同，所以队列通常用于对“历史”的回放，也就是按照“历史”顺序，把“历史”重演一遍。例如在多线程中，争夺公平锁的等待队列，就是按照访问顺序来决定线程在队列中的次序的。 散列表散列表也叫哈希表(hash table)，散列表在本质上也是一个数组。这种数据结构提供了键值对的映射关系。只要给出Key，就可以查找出它所匹配的Value，时间复杂度接近O(1)。 哈希函数在不同的编程语言中，哈希函数的实现也不一样，这里以Java为例，在Java及大多数面向对象编程语言中，每个对象都有自己的hashcode，hashcode是区分不同对象的重要标识，无论对象的自身类型是什么，它们的hashcode都是一个整型变量。最简单的转化方式是按照数组长度进行取模运算。 index = HashCode(Key)%Array.length 通过哈希函数，可以把字符串或其他类型的Key转化为数组的下标index。 散列表的读写操作 写操作（put） 写操作就是在散列表中插入新的键值对，通过哈希函数，把Key转化为数组下标，如果数组下标没有对应的元素，就把这个Entry填充到数组下标的相应位置。由于数组的长度有限，当插入的Entry越来越多时，不同的Key通过哈希函数获得的下标也有可能相同，所以这就造成了哈希冲突。哈希冲突是无法避免的。解决哈希冲突的方法有两中；一种是开放寻址法，一种是链表法。在Java中开放寻址法用于ThreadLocal。HashMap使用的是链表法解决哈希冲突问题。HashMap数组的每个元素不仅是一个Entry对象，还是一个链表的头节点，每个Entry对象通过next指针指向它的下一个Entry节点。当新来的Entry映射到与之冲突的数组位置时，只需要插入到对应的链表中即可。 读操作（get） 读操作就是通过给定的Key，在散列表中查找对应的Value。通过哈希函数，把Key转化为数组的下标。找到数组下标对应的元素，如果找到了这个元素就返回对应数组的值；如果找不到就顺着这个数组的元素的链表往下找，是否能够找到与之对匹配的节点。 扩容（resize） 当经过多次元素插入，散列表达到一定的饱和时，key映射的位置发生冲突的几率会增加。大量的元素拥挤在相同的数组下标位置下，会形成很长的链表。对于后续的插入操作和查询操作的性能都有很大的影响，这时就需要扩容了。 散列表的扩容操作 扩容，创建一个新的Entry空数组，长度为元素的两倍。 重新hash，遍历原Entry数组，把所有的Entry重新Hash到新数组中，因为长度扩容后，Hash的规则也随之变化。 用Java中的散列表实现类HashMap为例，影响扩容的因素有两个： Capacity：散列表的当前长度 LoadFactor：散列表的负载因子，默认值为0.75f 衡量HashMap需要扩容的条件如下： HashMap.size &gt;= Capacity*LoadFactor 树树（tree）是n（n&gt;=0）个节点的有限集。当n=0时，称为空树。在任意一个非空树中，有下面两个特点。 有且仅有一个特定的称为根的节点。 当n&gt;1时，其余的节点可分为m（m&gt;0）个互不相交的有限集，每个集合本身又是一个树，并称为根的子树。 二叉树二叉树是树的一种特殊形式。这种树结构的每个节点最多有2个子节点，也可能只有1个，或者没有孩子节点。二叉树的两个孩子节点，一个称为左孩子节点(left child)，一个称为右孩子节点（right child）,这两个孩子节点的顺序是固定的，不能够颠倒。 二叉树还有两种特殊的形式，一个叫作满二叉树，一个叫完全二叉树。 满二叉树是一个二叉树的所有非叶子节点都存在左右节点，并且所有叶子节点都在同一层级上，那么这个树就是满二叉树。也就是说满二叉树的每个分支都是满的。 完全二叉树对一个有n个节点的二叉树，按层级顺序编号，则所有节点的编号为从1到n。如果这个树所有节点和同样深度的满二叉树的编号为从1到n的节点位置相同，则这个二叉树为完全二叉树。 二叉树的物理存储结构 链式存储结构 链式存储结构的二叉树每个节点包含3部分：存储数据的data变量、指向左孩子的left指针、指向右孩子的right指针。 数组 使用数组存储，会按照层级顺序把二叉树的节点放到数组中对应的位置上。如果某个节点的左孩子或右孩子，则数组的相应位置也空出来。这样就可以更方便地在数组中定位二叉树的孩子节点和父节点。 假设一个父节点的下标是parent，那么它的左孩子的节点下标就是：leftchild=2*parent+1；右孩子节点下标就是：rightchild=2*parent+2。","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"Git快速入门","slug":"git/Git快速入门","date":"2020-02-15T09:56:07.000Z","updated":"2020-03-27T10:35:41.420Z","comments":true,"path":"2020/02/15/git/Git快速入门/","link":"","permalink":"http://yoursite.com/2020/02/15/git/Git%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/","excerpt":"","text":"Git安装(Windowns系统为例) 下载Git软件: 点击链接:https://git-scm.com/ 双击！ 一路Next！ 1 Git命令行git简单易用，只要在终端输入$ Git，Git就会不带任何参数输出它的选项和常用的子命令。 12345678910$ git#输入git后会输出一下选项，如果要得到一个完整的git子命令列表，可以输入 git help --allusage: git [--version] [--help] [-C &lt;path&gt;] [-c &lt;name&gt;=&lt;value&gt;] [--exec-path[=&lt;path&gt;]] [--html-path] [--man-path] [--info-path] [-p | --paginate | -P | --no-pager] [--no-replace-objects] [--bare]····················collaborate (see also: git help workflows) fetch Download objects and refs from another repository pull Fetch from and integrate with another repository or a local branch push Update remote refs along with associated objects ..... 2 Git使用快速入门 2.1创建初始版本库首先在git终端下创建一个空文件夹: 1234567#创建空文件夹 test/$ mkdir -p test/#进入到test文件夹$ cd test/#执行git init命令$ git initInitialized empty Git repository in /root/test/.git/ Git不会关心文件夹里是否为空，执行git init 命令创建了一个隐藏目录，在项目目录的顶层有个名为 .git文件夹，Git把所有修订的信息都放在这唯一的顶层目录里 2.2 将文件添加到版本库中执行 git init 命令时，Git版本库都是空的，为了管理内容，需要明确的把内容放入版本库中。 使用 git add file[^1] 将file添加到版本库中。 例如: 在 test目录中创建一个文件index.html并把该文件添加到版本库中 123$ cd test/$ touch index.html$ git add index.html [^1 ]: 如果目录中已经有很多的文件，使用git add .命令让Git把当前的目录及子目录中的文件都添加到版本库中 运行git status 命令显示中间状态的index.html 12$ git status # 这个命令显示新文件index.html将在下次提交时添加到版本库中 1 2.3 版本库内文件的删除和重命名 文件删除执行命令 git rm可以删除版本库里不需要的文件 操作如下: 123# 查看版本库中的文件$ git ls-filesindex.html 执行git rm index.html即可删除版本库中的index.html文件$ git rm index.html 12345678910111213141516 - ##### 文件重命名 在终端执行``git mv srcfile targetfile``即可以完成文件的重命名 例如： ```shell # 先查看版本库中的文件 $ git ls-files index.html # 执行git mv index.html foo.html 将index.html修改为foo.html $ git mv index.html foo.html # 再次查看版本库文件 $ git ls-files foo.html ​","categories":[{"name":"版本控制管理","slug":"版本控制管理","permalink":"http://yoursite.com/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%AE%A1%E7%90%86/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"Git提交","slug":"git/Git提交","date":"2020-02-15T08:54:50.000Z","updated":"2020-03-27T10:35:07.010Z","comments":true,"path":"2020/02/15/git/Git提交/","link":"","permalink":"http://yoursite.com/2020/02/15/git/Git%E6%8F%90%E4%BA%A4/","excerpt":"","text":"吧啦吧啦乱七八遭的东西在Git中，提交（commit）是用来记录版本库的变更的。当提交时，Git记录索引的快照并把快照放进对象库（简单的介绍）。提交的快照是串联在一起的，每张新的快照指向它的先驱。随着时间的推移，一系列的变更就表示一系列的提交。 Git提供一种机制来确定相对于另一个引用的提交，通常是分支的头。 在某些Git应用场景中，可能见过诸如这样的提交形式 master^ 。 在同一代提交中，插入符号 ^ 是用来选择不同的父提交。给定一个提交C，C^1 是其第一个父提交，C^2 是其第二个父提交，等等，如图: 通过把引用与^ 和 ~ 组合，就可从引用的提交历史图中选出任意提交 提交历史记录 查看旧提交 显示提交历史记录的主要命令是 git log,在参数形式上，git log跟git log HEAD是一样的，输出每一个可从HEAD找到的历史记录中的提交日志信息。变更从HEAD提交开始显示，并从提交图中回溯。如果使用git log 时提供一个提交名，那么这个日志将从该提交开始回溯输出。例如:git log master","categories":[{"name":"版本控制管理","slug":"版本控制管理","permalink":"http://yoursite.com/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%AE%A1%E7%90%86/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"关于Git文件管理","slug":"git/关于Git文件管理","date":"2020-02-12T11:25:36.000Z","updated":"2020-03-27T10:35:50.019Z","comments":true,"path":"2020/02/12/git/关于Git文件管理/","link":"","permalink":"http://yoursite.com/2020/02/12/git/%E5%85%B3%E4%BA%8EGit%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/","excerpt":"","text":"git中的文件分类​ Git将所有文件分为3类：已追踪的、被忽略的以及未追踪的 已追踪的 已追踪的文件是指已经在版本库中的文件，或者是已暂存到索引中的文件。如果想将新文件newfile添加到已追踪的文件，执行 git add newfile即可 被忽略的 被忽略的文件必须在版本库中明确声明为不可见或被忽略，即使他可能会在工作目录中出现。一个软件项目通常都会有很多被忽略的文件。普通被忽略的文件包括临时文件、个人笔记、编译器输出文件以及构建过程中自动生成的大多数文件。Git维护一个默认的忽略文件列表，也可以配置版本库来识别其他文件。被忽略的文件会在后面介绍。 未追踪的 未追踪的文件是指那些不在版本库中的文件。 下面举一个栗子: 1234567891011121314151617181920$ git init#查看状态$ git status# On branch master## Initial commit#nothing to commit (create/copy files and use \"git add\" to track)#添加一个文件$ echo \"new Data\" &gt;&gt; data# On branch master## Initial commit## Untracked files:# (use \"git add &lt;file&gt;...\" to include in what will be committed)## datanothing added to commit but untracked files present (use \"git add\" to track) 为了让Git忽略目录中的文件，只需将该文件名添加到一个特殊的文件.gitignore中就可以了。 123456789101112131415161718192021222324252627$ touch main.o$ git status# On branch master## Initial commit## Untracked files:# (use \"git add &lt;file&gt;...\" to include in what will be committed)## data# main.onothing added to commit but untracked files present (use \"git add\" to track)#将 main.o添加到.gitignore中$ echo main.o &gt;&gt; .gitignore$ git status# On branch master## Initial commit## Untracked files:# (use \"git add &lt;file&gt;...\" to include in what will be committed)## .gitignore# datanothing added to commit but untracked files present (use \"git add\" to track) 这样main.o就已经被忽略了，但是git status现在显示一个新的未追踪的文件 .gitignore。 使用 git addgit add 命令将暂存一个文件。就Git文件分类而言，如果一个文件是未追踪的，那么git add就会将文件的状态转化为已追踪的。如果git add作用于一个目录名，那么该目录下的文件以及子目录都会递归暂存起来。 这里还接着上面的栗子: 123456789101112131415161718192021$ git status# On branch master## Initial commit## Untracked files:# (use \"git add &lt;file&gt;...\" to include in what will be committed)## .gitignore# datanothing added to commit but untracked files present (use \"git add\" to track)# 将data、.gitignore两个文件添加至已追踪的分类$ git add data .gitignore$ git status# On branch master# Initial commit# Changes to be committed:# (use \"git rm --cached &lt;file&gt;...\" to unstage)# new file: .gitignore# new file: data 在上面的栗子中使用git add后，暂存和追踪data和.gitignore文件，并准备下次提交是时添加到版本库中。 可以使用git ls-files命令查看隐藏在对象模型下的东西。 123$ git ls-files.gitignoredata 在任何编辑之后，提交变更之前，请执行一次git add命令。 使用 git commit使用 git commit –allgit commit 的 -a或者 --all选项会导致执行提交之前自动暂存所有未暂存的和未追踪的文件变化，包括从工作副本中删除已追踪的文件 下面举个栗子: 12345678910111213$ pwd/tmp/commit-all-example#创建测试版本库$ git initInitialized empty Git repository in /tmp/commit-all-example/.git/$ echo \"Testfile1\" &gt;&gt; ready$ echo \"Testfile2\" &gt;&gt; notyet$ git add ready notyet$ git commit -m \"Setup\"[master (root-commit) 2b00dbf] Setup 2 files changed, 2 insertions(+) create mode 100644 notyet create mode 100644 ready 之后再次编辑ready文件，并用 git add把它添加到版本库中。然后编辑notyet文件保持它是未暂存的。 在一个子目录下添加一个文件，但是不要对它执行git add命令 12$ mkdir subdir$ echo \"Nope\" &gt;&gt; subdir/new 当执行 git commit --all命令，Git会递归遍历整个版本库，暂存所有先前通过git add提交的已知的和修改的文件，然后提交它们，由于subdir/ 一个全新的目录，而且目录下没有任何文件名或路径通过git add和git commit进行操作的， So 即使是 –all选项也不能将其提交。 关于提交日志消息​ 如果不通过命令行直接提供日志消息（例如:git commit -m &quot;提交日志消息&quot;），Git会启动编辑器，并提示你写一个提交日志。 使用 git rm 命令​ git rm命令会在版本库中和目录中同时删除文件。 接着上面的栗子: 这里“意外”的添加了一个文件 1234$ echo \"Random\" &gt; oops#当执行git rm oops时，提示删除失败$ git rm oopsfatal: pathspec 'oops' did not match any files ​ 为什么会这样，可以通过git ls-files命令查看版本库中的文件 123$ git ls-filesnotyetready 现在的版本库中没有oops这个文件，可通过git add oops命令将 oops文件加入到版本库中。 12345$ git add oops$ git ls-filesnotyetoopsready 另外，要将一个文件由已暂存的转化为未暂存的,可以使用git rm --cached命令 比如要删除oops 12$ git rm --cached oopsrm 'oops' git rm --cached会删除索引中的文件并它文件保留在工作目录中，而git rm则会将文件从索引和工作目录中都删除。 如果想要删除一个已经提交的文件，通过简单的git rm filename命令来暂存这一请求 还可以使用 git rm -f来强制删除文件。 如果想保留的文件不小心删除了，可以通过版本控制系统的恢复功能进行恢复 具体的命令如下: 123# 加入不小心删除了oops文件# 可以是下面的命令进行恢复git checkout HEAD -- oops 使用 git mv如果想要给一个文件重命名可以使用git mv srcfile newfile，git mv 命令会将 srcfile文件的文件名称改为newfiles，Git会在索引中删除srcfile文件的路径名，并添加newfile的路径名，至于srcfile文件里的内容，Git仍然会保存在对象库中，然后才会将它与newfile重新关联。git mv 还可以移动一个文件到一个目录中：git mv srcfile dir/ .gitignore 文件在前面简单介绍过.gitignore文件的作用。可以通过.gitignore文件来忽略不相干的文件。Git还支持一种更丰富的机制，一个.gitignore文件下可以包含一个文件名模式列表，指定哪些文件需要忽略。.gitignore 文件的格式如下。 空行会被忽略，而以（#）号开头的行可以用于注释。然而，如果#跟在其他文本后面，它就不代表注释了。 一个简单的字面置文件名匹配任何目录中的同名文件。 目录名由末尾的（/）标记。这能匹配同名的目录和子目录，但不匹配文件或符号链接。 包含shell通配符，如（*）号，这种模式可扩展为shell通配模式。正如标准shell通配符一样，因为不能跨目录匹配，所以一个 * 只能匹配一个文件或目录名。 起始的 ！号会对该行其余部分的模式进行取反。","categories":[{"name":"版本控制管理","slug":"版本控制管理","permalink":"http://yoursite.com/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%AE%A1%E7%90%86/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"Java枚举类型","slug":"java/java基础/Java枚举类型","date":"2019-06-07T13:12:02.000Z","updated":"2020-06-08T13:54:08.832Z","comments":true,"path":"2019/06/07/java/java基础/Java枚举类型/","link":"","permalink":"http://yoursite.com/2019/06/07/java/java%E5%9F%BA%E7%A1%80/Java%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"Enum关键字enum关键字，在需要群组并使用枚举类型集合时，可以很方便的处理。由于枚举类型的实例是常量，因此命名时大都使用大写。在创建enum时，编译器会自动添加一些有用的特性，,比如会创建toString()方法，便于显示某个enum实例的名字。编译器还会创建ordinal()方法，用来表示某个特定enum常量的声明顺序。static values()方法产生常量值构成的数组,还会生成一个相关的类，这个类继承自java.lang.Enum 下面看代码实例： 1234567public static void main(String[] args) &#123; //values()方法用于产生常量值构成的数组 for(Spiciness s:Spiciness.values()) &#123; //ordinal()方法，用来表示某个特定**enum常量**的声明顺序 System.out.println(s+\" ,\"+s.ordinal()); &#125; &#125; 12345678910111213public enum Spiciness &#123;//声明enum常量时通常使用大写字母 NOT, MILD, MEDIUM, HOT&#125;public class SimpleEnumeUse &#123; public static void main(String[] args) &#123; Spiciness howhot = Spiciness.MILD; System.out.println(howhot); &#125;&#125; enum还有一个实用的特性，可以在switch语句块中使用 1234567891011121314151617181920212223242526272829import static EnumType.demo1.Spiciness.*;public class Burrito &#123; Spiciness deg; public Burrito(Spiciness s)&#123; this.deg = s; &#125; public void describe()&#123; System.out.println(\"This Burrito\"); switch (deg) &#123; case NOT: System.out.println(\"not\"); break; case MILD: System.out.println(\"this MILD\"); break; case MEDIUM: System.out.println(\"a little hot\"); break; case HOT: System.out.println(\"this is HOT\"); break; &#125; &#125; public static void main(String[] args) &#123; Burrito plain = new Burrito(HOT); plain.describe(); &#125;&#125; 由于switch是要在有限的可能值集合中进行选择，因此与enum能很好的进行组合。 将静态导入应用于enum使用static import能够将enum实例的标识符带入当前的命名空间，所以无需再用enum类型来修饰enum实例 12345678910111213public enum Spiciness &#123; NOT, MILD, MEDIUM, HOT&#125;//static import导入Spicinessimport static EnumType.demo1.Spiciness.*;public class ImportEnum &#123; public static void main(String[] args) &#123; System.out.println(HOT); &#125;&#125; 向enum中添加新方法如果希望每个枚举能够返回对自身的描述，而不是使用toString实现，这只能返回枚举实例的名字。为此，需要提供一个构造器，专门负责处理这个额外的信息，然后添加一个方法，返回这个描述信息。 123456789101112131415161718192021public enum EnumFunction &#123; NAME(\"我是杨阿阳\"), AGE(\"23\"); private String decript; EnumFunction(String decript)&#123; this.decript = decript; &#125; public String getDecript() &#123; return decript; &#125; public static void main(String[] args) &#123; for(EnumFunction e:EnumFunction.values()) &#123; System.out.println(e+\": \"+e.getDecript()); &#125; System.out.println(EnumFunction.AGE.getDecript()); &#125;&#125;//outinfo~NAME: 我是杨阿阳AGE: 2323 在定义enum方法时，必须在enum实例序列的最后添加一个分号。同时必须先定义enum实例。如果在定义enum实例前定义任何方法或属性，那么编译时就会报错。在定义enum时将enum的构造器修饰为private 常量相关的方法在enum中可以声明常量方法，从而为每个enum实例赋予各自不同的行为。如果要实现常量相关的方法，需要为enum定义一个或多个abstract方法，然后为每个enum实例实现该抽象方法。 1234567891011121314151617public enum ConstantSpecificMethod &#123; DATA_TIME&#123; String getinfo() &#123; return \"getinfo1\"; &#125; &#125;, ClassPath&#123; String getinfo() &#123; return \"getinfo2\"; &#125; &#125;; abstract String getinfo(); public static void main(String[] args) &#123; ConstantSpecificMethod s = ConstantSpecificMethod.ClassPath; System.out.println(s.getinfo()); &#125;&#125; 通过相应的enum实例，可以调用其上的方法，上面的代码也称为表驱动的代码，这跟设计模式里的命令模式有些相似","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"java基础编程","slug":"java基础编程","permalink":"http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/"}]},{"title":"Java并发基础Java中的锁","slug":"java/并发编程/Java并发基础Java中的锁","date":"2019-04-30T10:40:11.000Z","updated":"2020-06-04T06:03:26.423Z","comments":true,"path":"2019/04/30/java/并发编程/Java并发基础Java中的锁/","link":"","permalink":"http://yoursite.com/2019/04/30/java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80Java%E4%B8%AD%E7%9A%84%E9%94%81/","excerpt":"","text":"锁是用来控制多个线程访问共享资源的方式，一个锁能够防止多个线程同时访问共享资源。 Lock在Lock接口出现之前，Java通过synchronized关键字实现锁功能，JDK 1.5之后，在并发包中新增了Lock接口来实现锁功能，有与synchronized关键字类似功能，只是在使用时需要显示的获取锁和释放锁，拥有了锁释放和获取的可操作性、可中断性等synchronized关键字不具备的特性。在使用synchronized关键字会隐式的获取锁和释放锁，但锁的获取和释放固化，即先获取后释放。Lock接口的实现基本上是通过聚合一个同步器（AQS）的子类来完成线程访问控制。 Lock接口的使用方式： 123456Lock lock = new ReentrantLock();lock.lock();try&#123;&#125;finally&#123; lock.unlock()&#125; 上面的代码示例中要注意：获取锁的过程不要写在try中，因为在获取锁时发生异常，异常抛出的同时，也会导致锁无故释放。 比较synchronized和ReentrantLock 锁的实现 synchronized是JVM实现的，而ReentrantLock是JDK实现 性能新版Java对synchronized进行了很多的优化，synchronized与ReentrantLock大致相同。 等待可中断 当持有锁的线程长期不释放锁，正在等待的线程可以选择放弃等待，改为处理其他事情。ReentrantLock可以中断，而synchronized不可以中断 公平锁 公平锁是指多个线程在等待同一锁时，必须按照申请的时间顺序来依次获得锁。synchronized中的锁是非公平的，ReentrantLock默认也是非公平，但也是可以公平的 锁绑定多个条件 一个ReentrantLock可以同时绑定多个Condition对象 如何选择呢？优先使用synchronized，除非需要使用ReentrantLock的高级功能，因为synchronized是JVM实现的一种锁机制，JVM原生的支持，而ReentrantLock不是所有的JDK都支持，synchronized不用担心没有锁而造成死锁问题，JVM会确保锁的释放。 重入锁重入锁ReentrantLock，支持重进入的锁，表示该锁功能支持一个线程对资源的重复加锁。 实现重进入重进入是指任意线程在获取锁之后能够再次获取该锁而不会被锁所阻塞，这个特性需要解决两个问题： 线程再次获取锁：所需要去识别获取锁的线程是否为当前占据锁的线程，如果是则再次成功获取。 锁的最终释放：线程重复n次获取锁，随后第n次释放该锁后，其他线程能够获取到该锁。锁的最终释放要求锁对于获取进行计数自增，计数表示当前锁被重复获取的次数，而锁被释放时，计数自减当计数等于0时表示已经释放成功。 重入锁是通过组合自定义同步器来实现锁的获取和释放。获取同步状态的代码如下： 123456789101112131415161718final boolean nonfairTryAcquire(int acquires) &#123; final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) &#123; if (compareAndSetState(0, acquires)) &#123; setExclusiveOwnerThread(current); return true; &#125; &#125; else if (current == getExclusiveOwnerThread()) &#123; int nextc = c + acquires; if (nextc &lt; 0) // overflow throw new Error(\"Maximum lock count exceeded\"); setState(nextc); return true; &#125; return false; &#125; 通过判断当前线程是否为获取锁的线程来决定获取操作是否成功，如果是获取锁的线程再次请求，则将同步状态值进行增加并返回true，表示获取同步状态成功。 读写锁读写锁维护一对锁，一个读锁和一个写锁，通过分离读锁和写锁使得并发性相比一般的排他锁有了更大的提升，读写锁的性能都会比排它锁好，因为大多数场景读操作对于写操作，在这样的情况下读写锁能够提供排它锁更好的并发性和吞吐量， 读写锁的实现 读写状态的设计 读写锁同样依赖自定义同步器来实现同步功能，而读写状态就是其同步器的同步状态。读写锁的自定义同步器需要在同步同步状态上维护多个读线程和一个写线程的状态，状态的设计成为读写锁实现的关键。 如果在一个整型变量上维护多种状态，就一定需要“按位切割使用”这个变量，读写锁将变量切分成两个部分，高16为表示读，低16位表示写 写锁的获取与释放 写锁是一个支持重进入的排它锁，如果当前线程已经获取了写锁，则增加写状态。如果当前线程在获取写锁时，读锁已经被获取或者该线程不是已经获取写锁的线程，则当前线程进入等待状态。写锁的释放与ReentrantLock的释放过程基本相似，每次释放均减少写状态，当写状态为0时表示写锁已经被释放，从而等待读写线程能够继续访问读写锁，同时前次的写线程的修改对后续读写线程可见。 读锁的获取与释放 读锁是一个支持重进入的共享锁，能够被多个线程同时获取，在没有其他的写线程访问时，读锁总会被成功的获取，而所做的只是增加读状态，如果当前线程已经获取了读锁，则增加读状。如果当前线程在获取读锁时，写锁已被其他线程获取，则进入等待状态。 锁降级 锁降级指的是写锁降级为读锁。如果当前线程拥有写锁，然后将其释放，最后在获取读锁，这种分段完成的过程不能称为锁降级。锁降级是指把持住写锁，再获取到读锁，随后释放写锁的过程。锁降级中读锁释放主要是为了保证数据的可见性。 队列同步器队列同步器AbstractQueuedSynchronizer，是用来构建锁或者其他同步组件的基本框架，使用一个int成员变量表示同步状态，通过内置FIFO队列来完成资源的获取线程的排队工作。 同步器是实现锁的关键，在锁的实现中聚合同步器，利用同步器实现锁的语义。二者的关系是：锁是面向使用者，定义了使用者与锁交互的接口，隐藏了实现细节；同步器则面向锁的实现者，简化了锁的实现方式，屏蔽了同步状态管理、线程的排队、等待与唤醒等底层操作。同步器的主要使用方式是继承，子类通过继承同步器并实现它的抽象方法来管理同步器状态。 队列同步器的实现分析同步队列同步器依赖内部的同步队列来完成同步状态的管理，当前线程获取同步状态失败时，同步器会将当前线程以及等待状态的信息够造成一个节点将其加入到同步队列，同时会阻塞当前线程，当同步状态释放时，会把首节点中的线程唤醒，使其再次尝试获取同步器状态。 节点是构成同步队列的基础，同步器拥有首节点和尾节点，没有成功获取同步状态的线程会成为节点加入到该队列的尾部。","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"java并发编程","slug":"java并发编程","permalink":"http://yoursite.com/tags/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}]},{"title":"Java并发基础","slug":"java/并发编程/Java并发基础Java","date":"2019-04-30T10:39:37.000Z","updated":"2020-05-06T09:01:30.973Z","comments":true,"path":"2019/04/30/java/并发编程/Java并发基础Java/","link":"","permalink":"http://yoursite.com/2019/04/30/java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80Java/","excerpt":"","text":"参考资料","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"java并发编程","slug":"java并发编程","permalink":"http://yoursite.com/tags/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}]},{"title":"Java并发容器和框架","slug":"java/并发编程/Java并发容器和框架","date":"2019-04-25T08:07:02.000Z","updated":"2020-05-09T08:53:21.771Z","comments":true,"path":"2019/04/25/java/并发编程/Java并发容器和框架/","link":"","permalink":"http://yoursite.com/2019/04/25/java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E5%92%8C%E6%A1%86%E6%9E%B6/","excerpt":"","text":"ConcurrentHashMap ​ 在多线程环境中，使用HashMap可能会导致程序死循环，使用线程安全的HashTable效率低效，所以便有了 ConcurrentHashMap。 ConcurrentHashMap利用锁的分断技术可有效提升并发访问率，在容器里有多把锁，每一把锁用于锁容器其中一部分数据，当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效提升并发访问效率。容器中有多把锁，每把锁用于锁容器其中的一部分数据，那么当多线程访问容器里不同的数据段时，线程之间就不会存在锁竞争，从而提高并发访问效率。 ConcurrentHashMap的结构ConcurrentHashMap由Segment数组结构和HashEntry数组结构组成。Segment是一种可重入锁；HashEntry用于存储键值对数据，一个ConcurrentHashMap包含一个Segment数组。Segment数组的结构和HashMap类似，是一种数组和链表结构，一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素，每个Segment守护一个HashEntry数组里的元素，当对HashEntry数组的数据进行修改时，必须先获得与它对应的Segment锁。 ConcurrentHashMap初始化初始化Segment数组segments数组的长度ssize是通过ConcurrencyLevel计算得出，为了可以通过按位与的散列算法定位Segments数组的索引，必须保证segments数组的长度是2的N次方，所以必须计算出一个大于或等于concurrencyLevel的最小的2的N次方值来作为segments数组的长度。下面是segments数组的源代码 123456789101112if(concurrencyLevel &gt; MAX_SEGMENTS)&#123; concurrencyLevel = MAX_SEGMENTS; int sshift = 0; int ssize = 1; while(ssize &lt; concurrencyLevel)&#123; ++sshift; ssize &lt;&lt;= 1; &#125; segmentShift = 32 - sshift; segmentMask = ssize -1; this.segments = Segment.newArray(ssize);&#125; concurrencyLevel的最大值是65535，Segments数组的长度最大为65536对应的二进制数组 初始化segmentShift和segmentMask这两个全局变量需要定位segments的散列算法里使用，sshift等于ssize从1向左移位的次数，在默认情况下concurrencyLevel等于161需要向左移位移动4次，所以sshift等于4segmentShift用于定位参与散列运算的位数，segmentShift等于32减sshift，所以等于28。 定位SegmentConcurrentHashMap使用分段锁Segment保护不同的数据，在插入和获取元素的时候，必须通过散列算法定位到Segment，然后在进行再散列，减少散列冲突，使元素能够均匀地分布在不同的Segment上，提高容器的存取效率。 散列算法如下： 1234final Segment&lt;K,V&gt; segmentFor(int hash)&#123; //segmentShift默认为28，SegmentMask为15 return segments[(hash&gt;&gt;&gt;segmentShift)&amp;segmentMask];&#125; 初始化每个segment输入参数initialCapacity是ConcurrentHashMap的初始化容量，loadfactor是每个segment的负载因子，在构造方法中需要通过这两个参数来初始化数组中的每个segment。 1234567891011121314if(initialCapacity &gt;MAXIMUM_CAPACITY)&#123; initialCapacity = MAXIMUM_CAPACITY; int c = initialCapacity/ssize; if(c * ssize &lt; initialCapacity)&#123; ++c; &#125; int cap = 1; while(cap &lt; c)&#123; cap &lt;&lt;= 1; &#125; for(int i = 0;i&lt;this.segments.length;i++)&#123; this.segments[i] = new Segment&lt;K,V&gt;(cap,loadFactor); &#125;&#125; ConcurrentHashMap的操作 get操作get操作先经过一次再散列，然后使用这个散列值通过散列运算定位到Segment，在通过散列算法定位到元素。 1234public V get(Object key)&#123; int hash = hash(key.hashCode()); return segmentFor(hash).get(key,hash);&#125; get操作之所以高效是因为整个get过程不需要加锁，除非读到的值是空才会加锁重读。get方法里面将要使用的共享变量都定义为volatile,定义成volatile的变量，能够在线程之间保持可见性，能够被多线程同时读，并且保证不会读到过期的值，在get操作里只需要读不需要写共享变量count和value，所以不需要加锁。不会读到过期的值，是因为根据Java内存模型Happen-before原则，对volatile字段的写入优先于读操作，即使两个线程同时修改和获取volatile变量，get操作也能够拿到最新的值。 put操作由于put操作需要对共享变量进行写入操作，为了线程安全，在操作共享变量是必须加锁。插入操作需经历两步：（1）判断是否需要对Segment数组里的HashEntry数组进行扩容；（2）定位添加元素的为位置，然后将其放在HashEntry数组中。根据上面的两个步骤这里又抛出两个问题：是否需要扩容、如何扩容。 是否需要扩容：在插入元素前会先判断Segment里的HashEntry数组是否超过容量，如果超过阈值，则对数组进行扩容（Segment的扩容判断比HashMap更恰当，因为HashMap是在插入元素后判断元素是否已经达到容量，如果达到了就进行扩容）， 如果扩容：在扩容的时候，为了高效ConcurrentHashMap不会对整个容器进行扩容，而只是对某个Segment数组进行扩容 size操作在统计size的时候会把所有Segment的put、remove、clean方法全部加锁，这种做法会变得非常低效，ConcurrentHashMap先尝试通过两次不加锁Segment的方式来统计各个Segment大小，通过过程中容器的count发生了变化，则再采用加锁的方式来统计所有Segment的大小，那么ConcurrentHashMap如何判断容器是否发生变化？使用modCount变量，在put、remove、clean方法里操作元素前都会将变量modCount进行加一操作，那么在统计size前后比较modCount是否发生变化，从而知道容器大小是否发生变化。 ConcurrentLinkedQueueConcurrentLinkedQueue是个基于链表节点的无界线程安全队列，采用先进先出的规则对节点进行排序，当添加一个元素时，会添加到队列的尾部；当获取一个元素时会返回队列的头元素。采用CAS算法实现。 ConcurrentLinkedQueue的入队列入队列过程入队列就是将入队节点添加到队列的尾部，在单线程下入队列比较简单，但在多线程同时进行入对的时候就复杂了许多，这个过程可能会有其他线程入队的情况，如果有个线程正在入队，那么这个线程就必须获取尾节点，然后设置尾结点的下一个节点为入队节点，要是这时有另一个线程插队，那么队列的尾节点就会发生变化，当前线程停止入队操作。这里就需要用到CAS算法 出队列过程出队列就是从队列里返回一个节点元素，并清空该节点对元素的引用。首先获取头节点的元素，然后判断头节点元素是否为空，如果为空，表示另外一个线程已经进行了一次出队操作将该节点的元素取走，如果不为空，则使用CAS的方式将头节点的引用设置为null，如果CAS成功，则直接返回头节点的元素，如果不为空表示另外一个线程已经进行了一次出队操作更新过了head头节点，导致元素发生变化，需要重新获取头节点。 Java中的阻塞队列什么是阻塞队列：阻塞队列是个支持阻塞的插入方法和阻塞的移除方法的队列； 支持阻塞的插入方法：当队列满时，队列会阻塞插入元素的线程直到队列不满。 支持阻塞的移除方法：当队列空时，获取元素的线程会等待队列变为非空 阻塞队列的实现原理 使用通知模式实现：通知模式就是当生产者往满的队列里添加元素时会阻塞生产者，当消费者消费了一个队列中的元素后，会通知生产者当前队列可用。","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"java并发编程","slug":"java并发编程","permalink":"http://yoursite.com/tags/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}]},{"title":"SQL基础（二）","slug":"数据库/mysql/SQL基础2","date":"2019-04-05T09:57:27.000Z","updated":"2020-04-09T13:52:30.812Z","comments":true,"path":"2019/04/05/数据库/mysql/SQL基础2/","link":"","permalink":"http://yoursite.com/2019/04/05/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/SQL%E5%9F%BA%E7%A1%802/","excerpt":"","text":"过滤数据百分号（%）通配符%表示任何字符出现任意次数。 123SELECT prod_id,prod_nameFROM productsWHERE prod_name LIKE 'jet%'; 上面的SQL检索任意以jet为开头的词，%告诉MYSQL接受jet之后的任意字符，不论它有多少字符。通配符可在搜索模式中任意位置使用，并且可以使用多个通配符 123SELECT prod_id,prod_nameFROM productsWHERE prod_name LIKE '%anvil%'; 下划线（_）通配符下划线通配符只匹配单个字符而不是多个字符。 123SELECT prod_id,prod_nameFROM productsWHERE prod_name LIKE '_ ton anvil' 使用通配符的技巧 不要过度使用通配符，如果其他操作符能达到相同的效果，应该使用其他操作符； 在确实需要使用通配符时，除非绝对有必要，否则不要把通配符放在搜索模式的开始处。如果把通配符置于开始处，搜索起来很慢； 仔细注意通配符的位置，如果犯错位置。可能不会得到想要的数据； 正则表达式MySQL中使用REGEXP关键字指定正则表达式的字符匹配。 正则表达式常用的字符匹配列表 选项 说明 ^ 匹配文本的开始字符 $ 匹配文本的结束字符 . 匹配任何单一字符 * 匹配零个或多个在在它前面的字符 + 匹配前面的字符1次或多次 字符串 匹配包含指定的字符串的文本 [字符集合] 匹配字符集合中的任何一个字符 [^] 匹配不在括号中的任何字符 字符串{n,} 匹配前面的字符串至少n次 字符串{n,m} 匹配前面的字符串至少n次，至多m次。 | 进行OR匹配 正则表达式经典例子： 基本字符匹配 1234SELECT prod_nameFROM productsWHERE prod_name REGEXP '1000'ORDER BY prod_name; 1234SELECT prod_nameFROM productsWHERE prod_name REGEXP '.000'ORDER BY prod_name; 进行OR匹配 1234SELECT prod_nameFROM productsWHERE prod_name REGEXP '1000|2000'ORDER BY prod_name; 范围匹配 1234SELECT prod_nameFROM productsWHERE prod_name REGEXP '[1-5] Ton'ORDER BY prod_name; 匹配特殊字符 1234SELECT vend_nameFROM vendorsWHERE vend_name REGEXP '\\\\.'ORDER BY prod_name; MYSQL函数文本处理函数 函数 说明 Left() 返回字符串左边的字符 Length() 返回字符串的长度 Locate() 找出字符串的一个子串 Lower() 将字符串转换为小写 LTrim() 去掉字符串左边的空格 Right() 去掉字符串右边的字符 RTrim() 去掉字符串右边的空格 Upper() 将字符串转换为大写 经典例子 将字符串转换为大写 123SELECT vend_name,Upper(vend_name)FROM vendorsORDER BY vend_name; 日期时间处理函数 函数 说明 AddDate() 增加一个日期（天，周等） AddTime() 增加一个时间（时，分等） CurDate() 获取当前日期 CurTime() 获取当前时间 Date() 返回日期时间的日期部分 DateDiff() 计算两个日期之差 Time() 返回一个日期时间的时间部分 Now() 返回当前日期和时间 聚集函数 函数 说明 AVG() 计算某一列的平均值 COUNT() 获取某一列的行数 MAX() 获取某一列的最大值 MIN() 获取某一列的最小值 SUM() 获取某一列值之和 数据分组创建分组分组是在SELECT语句的GROUP BY子句中建立的。 举个例子： 123SELECT vend_id,COUNT(*) as num_prodsFROM productsGROUP BY vend_id; 使用GROUP BY子句的一些规定 GROUP BY子句可以包含任意数目的列。使得能够对分组进行嵌套，为数据分组提供更细致的控制。 如果GROUP BY子句中嵌套了分组，数据将在最后规定的分组上进行汇总。 GROUP BY子句中列出每个列都必须是检索列或是有效的表达式。如果在SELECT中使用表达式，则必须在GROUP BY子句中指定相同的表达式。不能使用别名。 除聚集函数语句外，SELECT语句中每个列都必须在GROUP BY子句中给出。 如果分组列中具有NULL值，则NULL将作为一个分组返回。如果列中有多行NULL值，他们将分为一组。 GROUP BY子句必须出现在WHERE子句之后，ORDER BY子句之前。 过滤分组：HAVING使用HAVING对分组进行过滤，基于分组聚集值进行分组。 举几个例子 1234SELECT vend_id,COUNT(*) as num_prodsFROM productsGROUP BY vend_idHAVING COUNT(*)&gt;2; 1234SELECT order_num,SUM(quantity*item_price) as ordertotalFROM orderitemsGROUP BY order_numHAVING SUM(quantity*item_price) &gt;=50; SELECT子句顺序以下语句由上至下的顺序 SELECT：要返回的列或表达式 FROM：从中检索数据的表 WHERE：行级过滤 GROUP BY：分组说明 HAVING：组级过滤 ORDER BY：输出排序顺序 LIMIT：遥检索的行数 子查询子查询就是嵌套在其他查询中的查询。 利用子查询过滤1234567SELECT cust_idFROM ordersWHERE order_num IN(SELECT order_numFROM orderitemsWHERE prod_id = 'TNT2'); 上面的SELECT语句中子查询总是从内向外处理，上面的SQL语句实际上执行了两个SELECT操作。 在WHERE子句中使用子查询能够编写出功能很强并且很灵活的SQL语句。对于能嵌套的子查询的数目没有限制，但在实际应用中对于性能的要求，不能嵌套太多的子查询。 用作计算字段使用子查询123456SELECT cust_name,cust_state,(SELECT COUNT(*)FROM ordersWHERE orders.cust_id = customers.cust_id) as ordersFROM customersORDER BY cust_name; 联结表创建联结联结的创建非常简单，规定要联结的所有表以及他们如何关联即可。 1234SELECT vend_name,prod_name,prod_priceFROM vendors as vend,products as prdWHERE vend.vend_id = prd.vend_idORDER BY vend_name,prod_name; 内部联结基于两个表之间的相等测试，称为内部联结。 123SELECT vend_name,prod_name,prod_priceFROM vendors as vend,INNER JOIN products as prodON vend.vend_id = prod.vend_id; 两个表之间的关系是FROM子句的组成部分，以INNER JOIN指定，在使用这种语法时，联结条件用特定的ON子句而不是WHERE子句给出。传递给ON的实际条件与传递给WHERE的相同。 自联结12345SELECT p1.prod_id,p1.prod_nameFROM products as p1,products as p2WHERE p1.vend_id = p2.vend_idANDp2.prod_id = 'DTNTR'; 自联结通常作为外部语句用来替代从相同表中检索数据时使用的子查询语句。 外部联结看下面的例子： 12345SELECT customers.cust_id,orders.order_numFROM customers LEFT OUTER JOIN ordersON customers.cust_id = orders.cust_id; 在使用OUTER JOIN语法时，必须使用RIGHT或LEFT关键字指定包含其所有行的表（RIGHT指出的是OUTER JOIN右边的表，而LEFT指出的是OUTER JOIN左边的表） 使用联结和联结条件 注意所使用的联结类型，一般使用内部联结，但使用外部联结也是有效的； 保证使用正确的联结条件，否则将返回不正确的数据； 应该总是提供联结条件，否则会得笛卡儿积； 在一个联结中可以包含多个表，甚至对于每个联结可以采用不同的联结类型。虽然这样做合法的，一般也很有用，但应该在一起测试他们之前，分别测试每个联结，这将是故障排除更为简单； 组合查询组合查询将结果作为单个查询结果集返回。这些组合查询通常称为复合查询。 下面的情况，需要使用组合查询 在单个查询浙江哦你从不同的表中返回类型类似结构的数据； 对单个表执行多个查询，按单个查询返回数据； 创建组合查询 — 使用UNIONUNION的使用很简单，写出每个SELECT语句，在各条语句之间放上关键字 举个例子： 第一条select语句 123SELECT vend_id,prod_id,prod_priceFROM productsWHERE prod_price &lt;= 5; 第二条select语句 123SELECT vend_id,prod_id,prod_priceFROM productsWHERE vend_id IN(1001,1002); 复合两个语句 1234567SELECT vend_id,prod_id,prod_priceFROM productsWHERE prod_price &lt;= 5;UNIONSELECT vend_id,prod_id,prod_priceFROM productsWHERE vend_id IN(1001,1002); UNION规则 UNION必须有两条或者两条以上SELECT语句组成，语句之间用关键字UNION分隔； UNION中的每个查询必须包含相同的列，表达式或聚集函数（不过各个列不需要以相同的次序列出）； 列数据类型必须兼容：类型不必完全相同，但必须是DBSM可以隐式转换的类型； 参考资料 《MySQL必知必会》人民邮电出版社 《MySQL 从入门到精通》清华大学出版社","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"},{"name":"sql","slug":"sql","permalink":"http://yoursite.com/tags/sql/"}]},{"title":"vim基本命令","slug":"其他/vim基本命令","date":"2019-04-04T13:22:53.000Z","updated":"2020-04-05T10:00:38.854Z","comments":true,"path":"2019/04/04/其他/vim基本命令/","link":"","permalink":"http://yoursite.com/2019/04/04/%E5%85%B6%E4%BB%96/vim%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/","excerpt":"","text":"h或者向左箭头 光标向左移动一个字符 j或者向下箭头 光标向下移动一个字符 k或者向上箭头 光标向上移动一个字符 l或者向右箭头 光标向右移动一个字符 Page Down 屏幕向下移动一页 Page Up 屏幕向上移动一页 n n表示数字，按下数字再按空格键，光标会向右移动这一行的n个字符 功能键[Home] 移动到这一行的最前面字符处 功能键[End] 移动到这一行的最后面字符处 G 移动到这个文件的最后一行 nG 移动到这个文件的第n行 n 光标向下移动n行 /word 向光标之下寻找一个名称为word的字符 :n1,n2s/word1/word2/g 在第n1与n2行之间寻找word1这个字符串，并将该字符串替换为word2 :1,$s/word1/word3/g 在第1与最后一行之间寻找word1这个字符串，并将该字符串替换为word2 :1,$s/word1/word4/gc 在第1与最后一行之间寻找word1这个字符串，并将该字符串替换为word2，且在替换前显示提示字符给用户确认是否需要替换 x与X 在一行中x为向后删除一个字符(相当于[del]),X为向前删除一个字符(相当于退格键) dd 删除(剪切)光标所在的那一整行 ndd 删除(剪切)光标所在的向下n行 yy 复制光标所在的那一行 nyy 复制光标所在的向下n行 p与P p为将已复制的数据在光标下一行粘贴，P则为粘贴在光标的上一行。 u 恢复前一个操作 [ctrl]+r 重做上一个操作 . 重复前一个操作 i、a、o 进入插入模式 r或者R 进入替换模式 [Esc] 退出编辑模式 :w 将编辑的数据写入硬盘中 :q 退出vim :wq 保存后退出","categories":[{"name":"其他","slug":"其他","permalink":"http://yoursite.com/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"Linux进程管理","slug":"Linux/Linux进程管理","date":"2019-03-27T09:09:42.000Z","updated":"2020-03-28T07:09:59.010Z","comments":true,"path":"2019/03/27/Linux/Linux进程管理/","link":"","permalink":"http://yoursite.com/2019/03/27/Linux/Linux%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/","excerpt":"","text":"什么是进程如何产生一个进程？程序一般是放置在物理磁盘中，然后通过用户的执行来触发，触发后会加载内存中成为一个个体，这就是进程，为了让系统可以管理这个进程，进程会给予执行者权限/属性等参数，以及进程所需的脚本或数据，最后在给予一个PID。操作系统通过这个PID来判断该进程是否具有执行权限。过程如下图； 举个常见的例子，我们在操作Linux的时候通过登录系统分给我们一个shell(bash)终端，这个shell终端具有一个PID，这个PID就是由UID/GID而来。当这个进程执行其他作业时，那么由这个进程衍生出来的其他进程在一般状态下，会沿用这个进程的相关权限。 关于程序和进程的总结： 程序：通常为二进制程序，放置在存储媒介中，以物理文件的形式存在 进程：程序被触发后，执行者的权限与属性、程序的代码与所需的数据等都会被加载到内存中，操作系统给予这个内存中的单元一个标识符（PID）所以所进程就是一个正在运行时的程序 程序调用的流程（fork and exec）：Linux的程序调用通常称为fork-and-exec的流程。进程都会借由父进程以复制（fork）的方式产生一个一模一样的子进程，然后被复制出来的子进程再以exec方式执行实际要执行的进程，最终就成为一个子进程。 具体流程就像下面的图片 常驻在内存当中的进程通常都是负责一些系统所提供的功能以服务用户的各项任务，因此这些常驻进程称之为服务 任务管理什么是任务管理任务管理是用在bash环境下的，当登录系统获取 bash shell之后，在单一终端下同时执行多个任务的管理操作，执行任务管理的操作中，每个任务都是目前bash的子进程，彼此之间都是有相关性。 前台与后台 说到终端，这里说一下前台与后台； 可以出现提示字符让你操作的环境称为前台，其他任务就可以放入后台去暂停或运行，放入后台的任务是不可以使用【ctrl+c】来终止的 要执行bash的任务管理必须要注意的限制： 这些任务所触发的进程必须是来自你shell的子进程（只管理自己的bash）； 前台：可以控制与执行命令的这个环境称为前台任务； 后台：可以自动执行任务，无法使用【ctrl+c】终止，可使用bg、fg（这两个命名后面会讲解）调用该任务； 后台中【执行】的进程不能等待或输入； 任务控制的管理 直接将命令扔到后台去执行的&amp; 如果想要同时执行多个任务，利用&amp;可以将某些任务直接丢到后台环境，这样就可以继续操作前台的工作任务 例如需要后台执行一个java程序可以这样做： 12$ java -jar xxxx.jar &amp;[1] 7851 当命令后面加上&amp;代表着该命令丢到后台执行，此时bash会给予这个命令一个任务号码【job number】，就如上面代码的那个【1】。后面的7851则是该命令触发的【PID】。当这个任务执行完毕后bash会返回如下信息，表示[1]这个任务已经执行完毕； 1[1]+ Done java -jar xxxx.jar 将目前的任务丢到后台中暂停：【ctrl-z】 将一个正在执行的任务，扔到后台去暂停，使用【ctrl+c】组合键可以实现，使用【ctrl+c】丢到后台当中的任务都是停止状态 查看目前的后台任务状态：jobs 命令格式：jobs [-lrs] 选项与参数： -l：列出【job number】、【PID】与命令串； -r：仅列出正在后台运行的任务； -s：仅列出正在后台停止的任务； 看一个案例：将vim和vi丢到后台 1234567$ vim &amp;[1] 11439$ vi &amp;[2] 11440$ jobs -l[1]- 11439 Stopped (tty output) vim[2]+ 11440 Stopped (tty output) vi 在上面输出的案例里，有+，-号，+号代表最近被放到后台的任务号码，-号代表最近第二个被放到后台中的任务号码，而第三个以后的任务，就不会有+-号出现 将后台任务拿到前台处理：fg 命令格式：fg %jobnumber 以上面案例基础上将vim和vi放到前台： 1234567$ jobs -l[1]- 11439 Stopped (tty output) vim[2]+ 11440 Stopped (tty output) vi## 将vim放到前台处理$ fg %1vim... 让任务在后台下的状态变成运行中：bg %jobnumber 将还在后台停止的vi在后台运行 12$ bg %1[1]+ vi &amp; 就像上面的输出结果那样，命令串后面有一个【&amp;】符号，代表该任务别被启动到后台了 管理后台当中的任务：kill 如果想要将该任务直接删除或者重新启动，就可以用kill命令，使用这个命名时需要给这个命令一个信号（signal） 命令格式：kill -signal %jobnumber 选项与参数： signal：代表后面的接的任务有什么样的指示，下面列举几个常用的信号 -1：重新读取一次参数的配置文件； -2：表示有键盘输入【ctrl-c】同样的操作； -9：立刻强制删除一个任务； -15：以正常的进程方式终止一项任务； -9这信号通常是在【强制删除一个不正常的任务】是使用的，-15则是以正常步骤结束一项任务，这个信号也是默认值； 脱机运行 通常登录系统，系统会给当前的登录账号一个终端进程，在这个终端下运行的进程，如果终端退出则这些进程也会同时退出，所以Linux才有脱机管理。 如果需要退出系统后让进程继续运行，则需要使用nohup命令 命令格式：nohup [命令与参数] 在终端前台任务 ​ nohup [命令与参数] &amp; 在终端后台任务 nohup命令并不支持bash内置命令,所以命令只能是外部命令。 进程管理查看进程 将某个时间点的进程运行情况截取下来：ps ps aux：查看系统所有的进程 参考资料","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"SQL基础（一）","slug":"数据库/mysql/SQL基础","date":"2019-03-27T05:04:38.000Z","updated":"2020-05-11T08:49:10.687Z","comments":true,"path":"2019/03/27/数据库/mysql/SQL基础/","link":"","permalink":"http://yoursite.com/2019/03/27/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/SQL%E5%9F%BA%E7%A1%80/","excerpt":"","text":"这篇文章主要以MySQL数据库进行讲解 在阅读本文之前假设已经安装MySQL数据库。请先构建好数据源，如果没有安装MYSQL数据库可以通过下面的在线网站构建数据源并练习SQL语句 SQL在线练习网站：http://sqlfiddle.com/ 源数据下载：https://forta.com/wp-content/uploads/books/0672327120/mysql_scripts.zip SQL语言分类SQL语言主要分为三类： DML（Data Manipulation Language）：数据操作语言，常用的增删改查就属于DML，操作的对象是数据表中的对象。 DDL（Data Definition Language）：数据定义语言。建表，建立数据库就属于DDL DCL（Data Control Language）：数据控制语言，提交回滚，数据库安全管理等属于DCL 本文将逐一介绍这三个SQL语言分类的简单讲解。 检索数据SELECT语句123456789101112131415161718#建products表并插入数据CREATE TABLE products( prod_id char(10) NOT NULL, vend_id int NOT NULL , prod_name char(255) NOT NULL , prod_price decimal(8,2) NOT NULL , prod_desc text NULL , PRIMARY KEY(prod_id)) ENGINE=InnoDB;INSERT INTO products(prod_id, vend_id, prod_name, prod_price, prod_desc)VALUES('ANV01', 1001, '.5 ton anvil', 5.99, '.5 ton anvil, black, complete with handy hook');INSERT INTO products(prod_id, vend_id, prod_name, prod_price, prod_desc)VALUES('ANV02', 1001, '1 ton anvil', 9.99, '1 ton anvil, black, complete with handy hook and carrying case');INSERT INTO products(prod_id, vend_id, prod_name, prod_price, prod_desc)VALUES('OL1', 1002, 'Oil can', 8.99, 'Oil can, red');INSERT INTO products(prod_id, vend_id, prod_name, prod_price, prod_desc)VALUES('FU1', 1002, 'Fuses', 3.42, '1 dozen, extra long'); 检索单个列语法：SELECT 列名 FROM 表名 检索prod_name列 12345678SELECT prod_name FROM products;#结果为| prod_name ||--------------|| .5 ton anvil || 1 ton anvil || Fuses || Oil can | 上面的语句利用SELECT语句从products表中检索一个列为prod_name。所需列名在SELECT关键字后面给出，FROM关键字指定要从哪个表检索数据 检索多个列语法：SELECT 列名1,列名2... FROM 表名 要从一个表中检索多个列，使用SELECT语句，后面键入多个列名，列名之间必须以逗号隔开 当心逗号：在选择多个列时，一定要在列名之间加逗号，最后一个列名之后不用加 还是以上面的数据源为例，检索prod_id、prod_name两列 12345678SELECT prod_id,prod_name FROM products;#其结果如下：| prod_id | prod_name ||---------|--------------|| ANV01 | .5 ton anvil || ANV02 | 1 ton anvil || FU1 | Fuses || OL1 | Oil can | 检索所有列语法：SELECT * FROM 表名 检索所有列时，给定一个通配符（*）,则会检索表中的所有列。 1234SELECT * FROM products;prod_id | vend_id | prod_name | prod_price | prod_desc ANV01 | 1001 | .5 ton anvil | 5.99 | .5 ton anvil, black ANV02 | 1001 | 1 ton anvil | 9.99 | 1 ton anvil, black 检索不同的行（DISTINCT）语法：SELECT DISTINCT 列名 FROM 表名 要检索出有不同值的列表，使用DISTINCT关键字，此关键字必须直接放在列名的前面。此关键字指示MySQL只返回不同的值，这里的DISTINCT不能部分使用，它应用于所有列而不仅是前置它的列。 12345SELECT DISTINCT vend_id FROM products;| vend_id ||---------|| 1001 || 1002 | 限制结果（LIMIT）限制返回的行数。可以有两个参数，第一个参数为起始行，从 0 开始；第二个参数为返回的总行数。 语法： 123SELECT 列名1,列名2,... FROM 表名LIMIT starts,count; count：检索取多少行 starts：从第几行开始，注意这里的开始行从0开始 返回前五行： 1SELECT * FROM products LIMIT 5; 1SELECT * FROM products LIMIT 0,5 带一个值的LIMIT总是从第一行开始，给出的数为返回的行数。带两个值的LIMIT可以指定从行号为第一个值的位置开始。 过滤数据使用WHERE子句在SELECT语句中，数据根据WHERE子句中指定的搜索条件进行过滤。WHERE子句在表名后给出。在同时使用ORDER BY和WHERE子句时，应该让ORDER BY位于WHERE之后 WHERE子句操作符语法： 123SELECT 列名1,列名2,... FROM 表名WHERE 条件 MYSQL支持以下所有条件操作符： 操作符 说明 = 等于 &lt;&gt; 不等于 != 不等于 &lt; 小于 &lt;= 小于等于 &gt; 大于 &gt;= 大于等于 BETWEEN 在指定的两个值之间 IS NULL 为NULL值 过滤单个值过滤prod_name=’fuses’的数据 123SELECT prod_name,prod_priceFROM productsWHERE prod_name='fuses'; 过滤价格小于10元的数据 123SELECT prod_name,prod_priceFROM productsWHERE prod_price&lt;10; 过滤价格小于等于10元的数据 123SELECT prod_name,prod_priceFROM productsWHERE prod_price&lt;=10; 过滤不匹配过滤vend_id不是1002的数据 123SELECT prod_name,prod_priceFROM productsWHERE vend_id != 1002; 如果条件值为字符串类型，则需要引用引号，如果条件值为数值类型，则不需要引用引号 过滤范围值(BETWEEN)如果需要检查某个范围的值，可以使用BETWEEN操作符。其语法与其他WHERE子句的操作符不同。BETWEEN需要两个值，过滤范围的开始值和结束值。在范围使用BETWEEN时，必须指定两个值——所需范围的低端值和高端值。这两个值必须用AND关键字分隔。BETWEEN匹配范围中的所有值，包括指定的开始值和结束值。 过滤价格在5元和10元之间的所有产品 123SELECT prod_name,prod_priceFROM productsWHERE prod_price BETWEEN 5 AND 10; 空值过滤(IS NULL)WHERE子句 IS NULL用来检查具有NULL值的列。 123SELECT prod_nameFROM productsWHERE prod_price IS NULL; 组合WHERE子句AND操作符为了通过不止一个列在过滤，可使用AND操作符给WHERE子句附加条件，用来指示检索满足所有给定的条件的行。 案例： 123SELECT prod_id,prod_price,prod_nameFROM productsWHERE vend_id = 1003 AND prod_price &lt;= 10; OR操作符：用于过滤检索匹配任意一条件的行 123SELECT prod_id,prod_price,prod_nameFROM productsWHERE vend_id = 1003 OR prod_price &lt;= 10; IN操作符IN操作符用于指定条件范围，范围中每个条件都可以进行匹配。IN在WHERE中用来指定匹配值的关键字，功能与OR相当 1234SELECT prod_name,prod_priceFROM productsWHERE vend_id IN(1002,1003)ORDER BY prod_name; IN操作符的优点如下： 当需要匹配的值比较多时，IN操作符的语法更清楚且更直观； IN操作符一般比OR操作符执行更快； 在使用IN时，计算的次序更容易管理； IN的一最大优点就是可以包含其他SELECT语句，使得能够更动态地建立WHERE子句； NOT操作符：NOT用在WHERE子句中，用来否定后跟的条件表达式，MYSQL中的NOT，支持NOT对IN，BETWEEN和EXISTS子句取反。 参考资料 《MySQL必知必会》人民邮电出版社 《MySQL 从入门到精通》清华大学出版社","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"},{"name":"sql","slug":"sql","permalink":"http://yoursite.com/tags/sql/"}]},{"title":"Linux账号管理与权限设置","slug":"Linux/Linux账号管理与权限设置","date":"2019-03-21T09:47:17.000Z","updated":"2020-03-21T09:52:13.908Z","comments":true,"path":"2019/03/21/Linux/Linux账号管理与权限设置/","link":"","permalink":"http://yoursite.com/2019/03/21/Linux/Linux%E8%B4%A6%E5%8F%B7%E7%AE%A1%E7%90%86%E4%B8%8E%E6%9D%83%E9%99%90%E8%AE%BE%E7%BD%AE/","excerpt":"","text":"参考资料","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"文件与文件系统压缩","slug":"Linux/文件与文件系统压缩","date":"2019-03-20T06:42:11.000Z","updated":"2020-03-21T09:50:50.125Z","comments":true,"path":"2019/03/20/Linux/文件与文件系统压缩/","link":"","permalink":"http://yoursite.com/2019/03/20/Linux/%E6%96%87%E4%BB%B6%E4%B8%8E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%8E%8B%E7%BC%A9/","excerpt":"","text":"Linux系统常见的压缩命令123456789*.z compress程序压缩的文件；*.zip zip程序压缩的文件；*.gz gzip程序压缩的文件；*.bz2 bzip2程序压缩的文件；*.xz xz程序压缩的文件；*.tar tar程序打包的文件，并没有压缩过；*.tar.gz tar程序打包的文件，并经过gzip的压缩*.tar.bz2 tar程序打包的文件，并经过bzip2的压缩*.tar.xz tar程序打包的文件，并经过xz的压缩 gzip，zcat gzip可以说是应用最广泛的压缩命令。下面介绍这些命令; gzip [-cdtv#] 文件名 选项和参数： -c：将压缩的数据输出到屏幕上，可通过数据流重定向来处理； -d：解压缩的参数 -t：可以用来检验一个压缩文件的一致性，看看文件是否有误 -#：#表示压缩级别，-1最快，但压缩比最差，-9最慢，压缩比最好，默认为-6 xz，xzcat 命令格式 xz [-dtlkc#] 文件名 xcat 文件名.xz 选项与参数: -d：解压缩； -t：测试压缩文件的完整性； -l：列出压缩文件的相关信息； -k：保留原本文件不删除 -c：将数据在屏幕上输出 -#：压缩级别 打包名命名：tar命名格式：tat [-z][-j][-J][cv][-f 待建里的文件名] filename ...：打包与压缩tar [-z][-j][-J][tv][-f 既有的tar文件名]：查看文件名tar [-z][-j][-J][xv][-f 既有的tar文件名] [-C 目录]：解压缩选项与参数：-c：建立打包文件，可搭配-v来查看过程中被打包的文件名；-t：查看打包文件的内容含有哪些文件名，重点看文件名；-x：解包或解压缩，可以搭配-C在特定目录解压；-z：通过gzip的支持进行压缩/解压缩：此时文件名最好为*.tar.gz；-C 目录：若要在特定目录解压缩，可以使用这个选项；-f finame：-f后面要立刻接要被处理的文件名--exclude=FILE：在压缩过程中，不要将FILE打包注意：-c、-t、-x不可同时出现常使用的命令组合：tar -zcvf filename.tar.gz、tar -jcvf filename.tar.bz2：压缩tar -ztvf filename.tar.gz、tar -jtvf filename.tar.bz2：查询tar -zxvf filename.tar.gz -C 目录、tar -jxvf filename.tar.bz2 -C 目录：解压缩 常见的压缩与备份工具dd命令格式：dd if=input_file of=output_file bs=block_size count=number 选项与参数： if：输如设备 of：输出设备 bs：设置的一个block的大小，若未指定则默认是512Bytes（一个扇区大小） count：多少个bs 参考资料","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"Linux的文件与目录管理","slug":"Linux/Linux的文件与目录管理","date":"2019-03-18T13:40:17.000Z","updated":"2020-03-21T06:31:51.518Z","comments":true,"path":"2019/03/18/Linux/Linux的文件与目录管理/","link":"","permalink":"http://yoursite.com/2019/03/18/Linux/Linux%E7%9A%84%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/","excerpt":"","text":"目录相关操作对于目录相关的命名首先要介绍的一个命令是目录切换命令：cd 还有一些比较特殊的目录： .：代表此层目录； ..：代表上一层目录； -：代表前一个工作目录； ~：代表目前使用者身份所在的家目录 ~account：代表account这个使用者的家目录 处理目录的命令： cd（change directory）：切换目录 命令格式：cd [相对路径或绝对路径] 利用相对路径的写法必须确认的目前的路径才能正确地去到想要的目录 下面看几个例子 123456789101112131415##切换到tmp目录$ cd /tmp$ pwd/tmp##回到家目录$ cd ~$ pwd/root##回到上一次的工作目录$ cd -/tmp##当前的工作目录在/tmp，回到上一级目录$ cd ..$ pwd/ pwd（显示目前所在的目录） 命令格式：pwd [-p] ​ 选项与参数：-p：显示出真正的目录，而非使用链接路径 mkdir：建立新目录 命令格式 mkdir [-mp] 目录名称 选项与参数： -m：设置文件的权限。直接设置，不需使用默认权限（umask） -p：递归创建子目录 下面举几个例子： 12345#在当前的工作目录下创建test0目录$ mkdir test0drwxr-xr-x 2 root root 4096 Mar 19 16:58 test0##在当前的工作目录下递归创建test1/test2/test3这样的多层目录$ mkdir -p test1/test2/test3 一般创建目录大都是使用默认权限（umask），mkdir可以在创建目录时可以指定权限，例如： 12$ mkdir -m 711 test2drwx--x--x 2 root root 4096 Mar 19 17:07 test2 rmdir：删除“空”目录命令格式：rmdir [-p] 目录名称被删除的目录里不能存在其他的文件和目录，如果想要一次性删除一个目录以及该目录其下的子目录可以使用rm -rf 目录名称,但这样不是太安全，还是使用rmdir比较安全。 文件与目录管理文件与目录查看：ls命名格式：ls [-adlh] 文件名或目录名称 选项参数： -a：全部的文件，包括隐藏文件（开头为.的文件）一起列出 -d：仅列出目录本身，而不是列出目录内的文件数据 -h：将文件大小以及人类易读的方式（GB，KB，MB）列出 -l：详细信息显示，包括文件的属性与权限等数据 12345678910##列出root目录下的所有文件$ ls -al ~dr-xr-x---. 9 root root 4096 Mar 19 17:07 .dr-xr-xr-x. 18 root root 4096 Mar 14 16:57 ..-rw------- 1 root root 5185 Mar 18 23:42 .bash_history······drwxr-xr-x 2 root root 4096 Mar 19 16:58 test0drwxr-xr-x 3 root root 4096 Mar 19 17:00 test1drwx--x--x 2 root root 4096 Mar 19 17:07 test2-rw-rw-rw- 1 root root 0 Mar 18 01:49 test.txt 12345678910##列出root目录下的所有文件,以人类易读的方式$ ls -alh ~dr-xr-x---. 9 root root 4.0K Mar 19 17:07 .dr-xr-xr-x. 18 root root 4.0K Mar 14 16:57 ..-rw------- 1 root root 5.1K Mar 18 23:42 .bash_history······drwxr-xr-x 2 root root 4.0K Mar 19 16:58 test0drwxr-xr-x 3 root root 4.0K Mar 19 17:00 test1drwx--x--x 2 root root 4.0K Mar 19 17:07 test2-rw-rw-rw- 1 root root 0 Mar 18 01:49 test.txt 复制、删除、移动：cp、rm、mv cp:复制文件或目录 命令格式：cp [-ipr] 源文件（source） 目标文件（dest） 选项与参数： -a：参考下面的-dr选项 -d：若源文件为链接文件属性，则复制链接文件属性而非文件本身 -i：若目标文件已经存在，在覆盖时会先询问操作的进行 -p：连同文件的属性一起复制，不使用默认属性 -r：递归复制，用于目录的复制操作 在默认的条件中，cp的源文件与目标文件的权限是不同的，目标文件的拥有者通常会是命令操作本身。 rm（删除文件或目录） 命令格式：rm [-fir] 文件或目录 选项与参数： -f：强制的意思 -I：交互模式，在删除之前会询问使用是否操作 -r：递归删除 通常这个命令在使用时要十分小心，在删除前要认真确定删除的文件或目录是否正确，避免误删除的情况 1234#删除test1文件夹#连同目录下的所有子目录一并强制删除$ rm -rf test1 #删除文件也是如此 mv（移动文件与目录或重命名） 命令格式：mv [-fiu] source dest 选项与参数： -f：强制执行 -i：若目标文件已经存在，会询问是否覆盖 -u：若目标文件已存在，且source比较新，才会更新 这里举几个例子： 将test.txt文件移动到test0文件夹中 123$ mv test.txt test0$ ls test0test.txt 将test0文件夹重命名为test3 123$ mv test0 test4$ ls .test3 修改文件时间或创建新文件：touch 命令格式：touch [-acdmt] 文件名 选项与参数： ​ -a：仅自定义access time； ​ -c：仅修改文件时间，若该文件不存在则不创建新文件； ​ -d：后面可以接想要自定义的日期而不用目前的日期； ​ -m：修改mtime ​ -t：后面可以接想要自定义的时间而不是使用目前的日期，格式为[YYYYMMDDhhmm] touch命令最常用的情况是： 创建一个空文件 将某个文件日期自定义为目前 举几个例子： 123456#创建一个空文件$ touch test1-rw-r--r-- 1 root root 0 Mar 21 12:03 test1#修改日期为：2020/02/21 00:00$ touch -t 202002210000 test1-rw-r--r-- 1 root root 0 Feb 21 00:00 test1 文件与目录的默认权限与隐藏权限文件默认权限：umaskumask是指定目前用户在创建文件或者目录时的权限默认值。 12345#使用umask查看默认权限$ umask0022 //与一般权限有关的是后面三个数字$ umask -Su=rwx,g=rx,o=rx 默认情况下： 若用户创建文件则默认没有（x）执行权限，也就是只有rw这两个项目,也就是最大为666，默认权限为： -rw-rw-rw- 若用户创建目录则由于x是与是否可以进入目录有关的，因此默认为所有权限均开放，即777 drwxrwxrwx umaks的数字指的是该默认值需要减掉的权限 通过上面umask=0022进行说明。因为umask=0022，user没有被拿掉任何权限，group与others的权限被拿掉了2（也就是w权限）（r、w、x每个权限的数字在《Linux文件权限与目录简介》一篇中介绍过）那么用户： 创建文件时：（-rw-rw-rw-）-（- - - - - w - - w -）==&gt; - rw-r- -r- - ,最后创建文件时的权限：666-022=644 创建目录时：（drwxrwxrwx）-（d - - - - w- - w-）==&gt; drwxr-xr-x最后创建目录时的权限：777-022=755 创建一个文件和一个目录： 1234567891011$ umask0022$ touch test0666-022=644-rw-r--r-- 1 root root 0 Mar 21 12:49 test0 6 4 4#创建目录$ mkdir test.d777-022=755drwxr-xr-x 2 root roo 4096 Mar 21 12:53 test.d 7 5 5 文件隐藏属性 配置文件隐藏属性：chattr [+-=][ASacdistu] 文件或目录名称 常用选项与参数：+：增加某个特殊参数，其他原本存在参数不动；-：减少某个特殊参数，其他原本存在参数不动；=：直接设置参数，且仅有后面接的参数；a：当设置这个a之后，这个文件将只能增加数据，而不能删除也不能修改数据，只有root才能设置这个属性；i：当设置i之后，可以让一个文件不能被删除、改名、设置链接也无法写入或新增数据； 12345$ touch test23$ chattr +i test23$ rm -rf test23#不能删除rm: cannot remove test23：Operation not permitted 显示文件隐藏属性：lsattr [-adR] 文件或目录 选项与参数： -a：将隐藏文件的属性显示出来 -d：如果接的目录，仅列出目录本身的属性而非目录内的文件名 -R：连同子目录的数据也一并列出来 接着上面的例子： 12$ lsattr -aR test23----i--------e-- test23 命令与文件的查找脚本文件查找 查找执行文件：which [-a] command 选项或参数： -a：将所有由PATH目录中可以找到的命令均列出，而不止第一个被找到的命令名称 这个命令是根据【PATH】这个环境变量所规范的路径，去查找执行文件的文件名。 文件查找 由一些特定的目录中查找文件：whereis [-bmsu] 文件或目录 选项与参数： -l：可以列出whereis会去查询的几个主要目录； -b：只找binary（二进制）格式文件； -m：只找在说明文件manual路径下的文件； -s：只找source源文件； -u：查找不在上述三个项目当中的其他特殊文件； locate [-ir] keyword 选项与参数： -i：忽略大小写的差异； -c：不输出文件名，计算找到的文件数量； -l：仅输出几行的意思； -S：输出locate所使用的数据库文件的相关信息，包括该数据库记录文件/目录数量等； -r：后面可接正则表达式的显示方式； find [PATH] [option] [action]没事别用这个命令神慢~ 参考资料 《鸟哥的Linux私房菜—基础学习篇（第四版）》 鸟哥著 人民邮电出版社","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"Linux文件权限与目录简介","slug":"Linux/Linux文件权限与目录简介","date":"2019-03-16T09:52:07.000Z","updated":"2020-03-21T03:49:47.441Z","comments":true,"path":"2019/03/16/Linux/Linux文件权限与目录简介/","link":"","permalink":"http://yoursite.com/2019/03/16/Linux/Linux%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E4%B8%8E%E7%9B%AE%E5%BD%95%E7%AE%80%E4%BB%8B/","excerpt":"","text":"Linux文件权限与文件属性Linux文件属性先来看下面的Linux文件属性信息: 12-rw-r--r--. 1 root root 29 Nov 18 00:00 test.txtdrwxr-xr-x. 4 root root 39 Oct 8 14:39 opt 第一栏代表这个文件的类型与权限 第一个字符代表这个文件是目录、文件或是链接文件等 当为[d]则为目录，例如像上面的文件名【opt】就是一个目录 当为[-]则是文件，例如像上面的文件名【test.txt】就是一个文件 当为[l]则是链接文件 当为[b]则是设备文件里面的可供存储的周边设备 当为[c]则是设备文件里面的串行端口设备 上面图片中后面的三个组表示文件拥有者、文件所属用户组、其他人的文件权限 1234r 可读w 可写x 可执行- 无权限 第一组为文件拥有者可具备的权限。 第二组为加入此用户组的账号的权限 第三组为非本人且没有加入本用户组的其他账号的权限 第二栏表示多少文件名链接到此节点 第三栏表示这个文件或目录的拥有者账号 第四栏表示这个文件的所属用户组 第五栏为这个文件的容量大小，默认单位为Bytes，如果想看更人性化的可以输入ls -alh 第六栏为这个文件创建日期或是最近修该日期 第七栏为文件名，如果文件名之前多一个.,则代表这个文件为隐藏文件。 如何修改文件属性与权限 几个修改用户组、拥有者、各种身份的权限命令 chgrp：修改文件所属用户组 chown：修改文件拥有者 chmod：修改文件的权限，SUID、SGID、SBIT等的特性 修改所属用户组：chgrp修改一个文件的用户组直接使用chgrp命令修改即可，这个命令就是change group的缩写 命令格式： 12chgrp [-R] [系统用户] dirname/filename ... -R：进行递归修改， 现在系统中有yang这个用户，将test.txt文件的用户组修改为yang 12345$ -rw-r--r--. 1 root root 29 Nov 18 00:00 test.txt$ chgrp yang test.txt$ ls -al#已经将test.txt文件的所属用户组修改为yang$ -rw-r--r--. 1 root yang 29 Nov 18 00:00 test.txt 修改文件拥有者：chown要修改文件为指定的用户，系统里必须有这个指定用户账号 命名格式： 123chown [-R] 账号名称 文件或目录chown [-R] 账号名称:用户组名称 文件或目录-R：进行递归修改，如果要连目录下的所有子目录或文件同时更改文件拥有者的话，加上-R选项即可 还是上面的那个test.txt文件，将其的文件拥有者修改为yang 1234567$ -rw-r--r--. 1 root yang 29 Nov 18 00:00 test.txt$ chown yang test.txt$ ls -al$ -rw-r--r--. 1 yang yang 29 Nov 18 00:00 test.txt#将test.txt的拥有者和用户组修改回root$ chown root:root test.txt$ -rw-r--r--. 1 root root 29 Nov 18 00:00 test.txt chown也可以使用【chown user.group file】,在拥有者与用户组间加上【.】也可以修改。 目录与文件权限的意义 权限对文件的重要性权限对于文件来说，意义是这样的： r（read）：可读取此文件的实际内容 w（write）：可以编辑、新增或是修改该文件的内容（但不可以删除该文件哦） x（eXecute）：该文件具有可以被系统执行的权限 在Linux下面，文件是否有执行能力，是根据是否具有【x】这个权限来决定的，和文件名没有绝对的关系 权限对目录的重要性目录的主要内容在记录文件名列表，文件名与目录有强烈的关联。对于目录，r、w、x的意义如下： r：表示具有读取目录结构列表的权限，所有当具有读取一个目录的权限（r）时，表示可以查询该目录下的文件名的数据。 w：这个是对于目录的可写入权限，表示用户具有改动改目录结构列表的权限。也就是下面这些权限： 建立新的文件与目录 删除已经存在的文件与目录 将已存在的文件或目录进行更名 移动该目录内的文件、目录位置 x： 目录的x表示的是当前用户能否进入该目录成工作目录。就是说可以通过cd命令切换到改目录下。如果当前用户在某目录下不具有x的权限，那么就无法切换到改目录下，也就无法在改目录下进行任何操作，即使有该目录的r和w权限也不好使。 注意：要开放目录给任何人浏览时，应该至少也要给予r及x权限 修改文件权限：chmod命名格式语法： 123chmod [-R] xyz 文件或目录 xyz：数字类型的权限属性,为rwx属性值相加的值 -R：进行递归 文件权限修改有两种方式：使用数字或者符号来进行权限修改。 数字类型修改文件权限 Linux文件的基本权限有九个，分别是拥有者(owner)，所属群组（group）、其他人（others）三种身份各有自己的读（r）、写（w）、执行（x）权限。 拿上面介绍的文件权限那样，文件权限字符为：【-rwx rwx rwx】九个权限三个一组。 可以使用数字来代表各个组的权限： r：4 w：2 x：1 三种身份（拥有者(owner)、所属群组(group)、其他人（others））各自的三个权限（r，w，x）数字是需要累加的。例如前面提到的test.txt文件如下： 1-rw-r--r--. 1 root root 29 Nov 18 00:00 test.txt 权限为：【-rw-r–r–】的数字则是：644 123owner = rw = 4+2 = 6group = r = 4others = r = 4 接下来用chmod命令将该文件的是三种身份的权限数字设置为770owner = rwx = 4+2+1 = 7group = rwx = 4+2+1 = 7;others = - - - = 0 123$ chmod 770 test.txt$ ls -al test.txt-rwxrwx--- 1 root root 29 Nov 18 00:00 test.txt 如果要将文件变成可执行的文件，并且不要让其他人修改文件的话，那就需要-rwxr-xr-x这样的权限，此时就要执行 chmod 755 fileName命令。 符号类型修改文件权限 符号类型修改文件权限可以借由(user)u，(group)g，(others)o,来代表三种身份的权限，此外a则代表all全部的身份，读写权限可以写成r、w、x chmod [u、g、o、a] [+（加入）、-（移除）、=（设置）] [r、w、x] 文件或目录 例如要把上面的test.txt设置成【-rwxr-xr-x】时： 12345$ ls -al test.txt-rwxrwx--- 1 root root 0 Mar 18 00:00 test.txt$ chmod u=rwx,go=rx test.txt$ ls -al-rwxr-xr-x 1 root root 0 Mar 18 00:00 test.txt 如果想为每身份加入w权限 123$ chmod a+w test.txt$ ls -al test.txt-rwxrwxrwx 1 root root 0 Mar 18 00:00 test.txt 如果想为每身份移除x权限 123$ chmod a-x test.txt$ ls -al test.txt-rw-rw-rw- 1 root root 0 Mar 18 01:49 test.txtLinux目录树执行文件路径的变量：$PATHPATH这个变量的内容是由一堆目录所组成，每个目录中间用冒号（:）来隔开，每个目录有顺序之分。就像下面的格式 1/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin:/usr/local/python37/bin 目录树的主要特征： 目录树的起始点为根目录（/，root）； 每个目录不止能使用本地区分的文件系统，也可以使用网络的文件系统； 用NetWork File System(NFS)服务器挂载某特点的目录 每个文件在此目录树中的文件都是独一无二的； 下面是目录树构架示意图（关于目录树更详细的说明，参考《鸟哥的Linux私房菜—基础学习篇（第四版）》第五章5.3节的FHS标准说明） 绝对路径与相对路径根据文件名写法的不同，也可将所谓定义为绝对路径与相对路径。这两种文件名路径写法依据如下： 绝对路径：由根目录（/）开始写起的文件名或目录名称； 相对路径：相对于目前所处在的目录的文件名写法，例如：../dir1、../dir1/opt等 ..代表上一层目录，也可以使用../来代表 .代表当前目录，也可以使用./来代表 参考资料 《鸟哥的Linux私房菜—基础学习篇（第四版）》 鸟哥著 人民邮电出版社","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"初识Linux","slug":"Linux/Linux基础","date":"2019-03-15T14:20:39.000Z","updated":"2020-05-06T06:30:21.139Z","comments":true,"path":"2019/03/15/Linux/Linux基础/","link":"","permalink":"http://yoursite.com/2019/03/15/Linux/Linux%E5%9F%BA%E7%A1%80/","excerpt":"","text":"什么是Linux?Linux就是一个操作系统(手动狗头) Linux几个常用的命令 cd dir：跳转到指定文件夹 123456跳转到root目录$ cd ~跳转到之前目录$ cd -跳转到上级目录$ cd .. cd 后面还可以文件夹绝对路径或相对路径跳转到指定目录 例如跳转到 /下的tmp目录 1$ cd /tmp pwd：查看当前所处的路径，输入pwd系统会返回当前所处的目录的绝对路径 ls -al：列出文件夹下的所有文件，包括隐藏文件 1$ ls -al 操作Linux系统几个重要的热键 [Tab]按键[Tab]按键就是在切换大小写按键[Casp Lock]上面的那个按键，它具有命令补全与文件补齐的功能。关键是可以避免打错命令或文件名。 这里总结一下 [Tab]接在一串命令的第一个字段后面，则为【命令补全】 [Tab]接在一串命令的第二个字段后面，则为【文件补全】 [Ctrl+c]按键有时候某些命令或程序在系统上一直“跑个不停”，想让命令或程序“停掉”时，可以用这个按键。输入:[Ctrl+c]按键，可以中断目前程序或命令。 [Ctrl+d]如果想要直接离开命令行模式，可以直接按下[Ctrl+d]就能直接离开（相当于输入exit） [Shift]+{Page Up}、[Shift]+{Page Down}按键使用[Shift]+{Page Up}向前翻页。使用[Shift]+{Page Down}先后翻页 正确的关机方法 正确的关机命令使用 几个与关机或重启相关命令 将数据同步写入硬盘的命令：sync 常用的关机命令：shutdown 重启、关机：reboot、halt、poweroff 数据同步写入磁盘：sync 使用sync命令进行数据的写入操作。在命令行下输入sync，那么在内存中尚未被更新的数据，就会被写入硬盘中。So 在关机或重启系统之前最好多执行几次 常用的关机命令：shutdown 这个是关闭Linux的命令，如果是root管理员可以使用。 1234567891011121314shutdown语法shutdown -[krhc] [时间] [警告信息] 选项与参数 -k：不是真的关机，只是发送警告信息出去。 -r：在将系统的服务停掉之后就重新启动（常用） -h：将系统的服务停掉后，立即关机（常用） -c：取消已经进行的shutdown命令内容 时间：指定系统关机的时间，设置时间的样式如下： shutdown -h 13:00 系统将在今天的13:00分关机 shutdown -h now 系统将立即关机 shutdown -r now 系统会立即重启 shutdown可以完成如下的工作： 可以自由选择关机模式：要是关机或重启均可； 可以设置关机时间：可以设置成现在立即关机，也可以设置某一个特定的时间关机； 可以自定义关机信息：在关机之前，可以将自己设置的信息发送给在线用户； 可以仅发出警告信息：有时有可能要进行一些测试，而不想让其他的用户干扰，或是明白的告诉用户某段时间要注意一下。 重启，关机：reboot、halt，poweroff 这三个命令可以进行重启与关机的操作。一般在关机或重启时，都会执行如下命令： 1sync;sync;sync;reboot 使用管理管理工具systemctl关机 在CentOS 7中可以使用systemctl来进行关机，实际上面介绍的关机与重启命令都是调用systemctl这个命令。 这个命令与关机的语法： 1234567systemctl [命令]命令项目有：haltpoweroffrebootsuspend //进入休眠模式# systemctl reboot #系统重启 参考资料 《鸟哥的Linux私房菜—基础学习篇（第四版）》 鸟哥著 人民邮电出版社","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"Java并发基础volatile关键字","slug":"java/并发编程/volitile关键字","date":"2018-07-22T11:16:24.000Z","updated":"2020-05-06T01:42:50.060Z","comments":true,"path":"2018/07/22/java/并发编程/volitile关键字/","link":"","permalink":"http://yoursite.com/2018/07/22/java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/volitile%E5%85%B3%E9%94%AE%E5%AD%97/","excerpt":"","text":"并发编程的三个重要特性 原子性 原子性指在一次的操作或多次的操作中，要么所有操作全部执行且不会受到任何因素的干扰而中断，要么所有操作全部不执行 可见性 当一个线程对共享变量进行修改，另外的线程可以立刻看到修改后的新值。 有序性 有序性是指程序代码在被执行过程中的先后顺序。Java编译器以及运行期的优化，导致代码的执行顺序未必就是在编写代码时的顺序。 关于volatile下面有必要说一下内存与CPU相关的知识 CPU Cache模型CPU的处理速度和内存访问速度之间差距很大，通过直连内存的方式会导致CPU资源受到限制，为了降低CPU整体的吞吐量，可在CPU和内存之间增加缓存的设计，目前缓存的数量可增加到3级，最靠近CPU的缓存称为L1，依次是L2，L3和主内存。CPU缓存模型如下： Cache的出现为了解决CPU直接访问内存效率低下的问题，CPU将运算所需的数据从主内存复制一份到CPU Cache中，CPU在计算时就可以直接对CPU Cache中的数据进行读取和写入，运算结束后，再将CPU Cache中的最新数据刷新回主内存中。 CPU缓存一致性问题缓存的出现极大提高CPU的吞吐能力，但也引入了缓存不一致的问题，为了解决缓存不一致性的问题，通常主流的解决方法有两种： 通过总线加锁的方式 通过缓存一致性协议 缓存一致性协议的大致思想：当CPU在操作Cache中的数据时，如果发现该变量是一个共享变量，在其他CPU Cache中存在一个副本，当进行如下操作时： 读取操作：不做任何处理，只将Cache中的数据读取到寄存器中 写入操作：发出信号通知其他CPU将该变量的Cache line置为无效状态，其他CPU进行该变量读取时，必须在主存中再次获取。 关于volatile关键字为了确保共享变量能够准确和一致性的更新，线程应该确保通过排他锁单独获取这个变量。Java提供了volatile关键字，如果一个字段被声明为volatile，多线程内存模型确保所有线程看到这个变量的值是一致的。 JMM内存模型java内存模型决定了一个线程对共享变量的写入何时对其他线程可见，java内存模型定义了线程和内存之间的抽象关系 共享变量存储于主内存中，每个线程都可以访问。 每个线程都有私有的工作内存或称为本地内存。 工作内存只存储该线程对共享变量的副本 线程不能直接操作主内存，只有先操作工作内存后才能写入主内存。 工作内存和Java内存模型一样也是一个抽象的概念，其实并不存在，它涵盖了缓存、寄存器、编译器优化以及硬件等。 在前面所说的并发编程的三大特性，JMM如何保证这三大特性 JMM与原子性 先介绍几种简单的赋值操作 (1) x = 1 (2) y = x (3) y++ (4) z = z+1 在上面的四类赋值操作中，只有第一种赋值操作具有原子性，其余均不具备原子性。可以得出以下结论 多个原子性的操作在一起就不再是原子性操作 简单的读取与赋值是原子性，将一个变量赋值给另外一个变量的操作就不具备原子性 JMM只保证基本读取和赋值的原子性操作，其余的均不能保证，如果要使某些代码段具备原子性，需要使用关键字synchronized，或JUC中的lock。如果想要使得int等类型自增操作具备原子性封装类型atomic.* 最后volatile关键字不具备保证原子性的语义 在Java中可以通过锁和循环CAS的方式来实现原子操作 使用循环CAS实现原子性操作 JVM中的CAS操作利用处理器提供的指令CMPCHG实现，自旋CAS实现的基本思路是循环进行CAS操作直到成功为止。 CAS实现原子类操作的三大问题 ABA问题 因为CAS需要在操作值的时候，检查值有没有变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查的时候会发现它的值没有发生变化，但是实际发生了变化，ABA问题的解决思路就是使用版本号。在变量前面追加版本号，每次变量更新的时候把版本号加1，JDK中通过使用原子类AtomicStampedReference解决ABA问题 循环时间长开销大 自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。如果JVM能支持处理器提供的pause指令，那么效率在一定程度上提升 只能保证一个共享变量的原子操作 把多个共享变量合并成一个共享变量来操作。 123i = 2j = a合并 =&gt; ij = 2a 然后CAS来操作ij，JDK提供了AtomicReference类来保证引用对象之间的原子性，就可以把多个变量放入一个对象里来进行CAS操作 使用锁机制实现原子性操作 锁机制保证了只有获得锁的线程才能够操作锁定内存的区域。JVM内部实现了很多锁机制，有偏向锁、轻量锁、互斥锁。JVM实现锁的方式都用了循环CAS，即当一个线程进入同步块的时候使用CAS的方式来获取锁，当它退出同步块的时候使用循环CAS释放锁。 JMM与可见性 Java通过三种方式来保证可见性 使用关键字volatile，当一个变量被volatile关键字修饰时，对于共享资源的读操作会直接在主内存中进行（也可能会缓存到工作内存中，当其他线程对该共享资源进行修改，则会导致当前线程在工作内存中的共享资源失效，必须要在主内存中再次获取），对于共享资源的写操作当然是先要修改工作内存，但是修改结束后会立刻将其刷新进主内存中。 通过synchronized关键字能够保证可见性，synchronized关键字能够保证同一时刻只有一个线程获得锁，然后执行同步方法，并且还会确保在锁释放之前，会将对变量的修改刷新到主内存中。 通过JUC提供的显式锁Lock也能保证可见性，Lock的lock方法能够保证在同一时刻只有一个线程获得锁然后执行同步方法，并且会确保在锁释放（Lock的unlock方法）之前会将对变量的修改刷新到主内存中。 volatile关键字具有保证可见性的语义 JMM与有序性 在JMM中允许编译器和处理器对指令进行重排序，在当线程下并不会引起什么问题。在多线程下，重排序会影响到程序的正确运行。 Java提供了三种保证有序性的方式 使用volatile关键字来保证有序性。 使用synchronized关键字来保证有序性。 使用显式锁Lock来保证有序性 在JMM中具备一些自带的有序性规则，不需要任何同步手段就能够保证有序性，这规则称之为Happens-before原则。 重排序是什么 重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段。 三种类型的重排序 编译器优化重排序 编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序 指令级并行的重排序 现代处理器采用指令级并行技术来将多条指令重叠执行，如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。 内存系统的重排序 由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作来起来可能是在乱序执行 Happens-Before规则 程序次序规则：在一个线程内，代码按照编写时的次序执行，编写在后面的操作发生于编写在前面的操作之后。虚拟机还是可能会对程序代码的指令进行重排序，只要确保在一个线程内最终的结果和代码顺序执行的结果一致即可。 锁定规则：一个unlock操作要先行发生于对同一个锁的lock操作 volatile变量规则：对一个变量的写操作要早于对这个变量的读操 传递规则：如果操作A先于操作B，B操作先于C操作，则A操作一定先于C操作，说明Happens-Before 线程启动规则：Thread对象的start()方法先行发生于线程的任何动作，只有start后的线程才能真正运行，否则Thread只是一个对象。 线程中断规则：对线程执行interrupt()方法，肯定要优先于捕获到中断信号。 线程的终结规则：线程中断所有的操作都要先行发生于线程的终止检测，线程的任务执行，逻辑单元执行肯定要发生于线程死亡之前。 对象的终结规则：一个对象初始化的完成先行发生于finalize()方法之前。 volatile关键字具有保证顺序性的语义 volatile写读的内存语义 volatile写的内存语义 当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存 volatile读的内存语义 当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量 volatile写读的内存语义总结： 线程A写一个volatile变量，实质上是线程A向接下来将要读这个volatile变量的某个线程发出消息 线程B读一个volatile变量，实质上是线程B接收了之前某个线程发出的（在写这个volatile变量之前对共享变量所做修改的）消息 线程A写一个volatile变量，随后线程B读这个volatile变量，过程实质上是线程A通过主内存向线程B发送消息 volatile关键字语义被volatile修饰的实例变量或类变量具备两层语义： 保证不同线程之间对共享变量操作时的可见性，也就是说当一个线程修改volatile修饰变量，另外一个线程立即可看到新的值。 禁止对指令进行重排序操作。 volatile的原理和实现机制volatile关键字可以保证可见性以及顺序性，是如何做到的？ 观察OpenJDK源码就知道，被volatile修饰的变量存在于一个”lock;”前缀 Lock前缀指令在多核处理器下会引发两件事 将当前处理器缓存行的数据写回到系统内存 写回内存操作会使在其他CPU里缓存了该内存地址的数据无效 “lock;”前缀实际上相当于一个内存屏障，该屏障会为指令提供几个保障： 确保指令重排序时不会将后面的代码排到内存屏障之前 确保指令重排序时不会将其前面的代码排到内存屏障之后 确保在执行到内存屏障修饰的指令时前面的代码全部执行完成 强制在线程工作内存中值的修改刷新至主内存中 如果是写操作，则会导致其他线程工作内存中的缓存数据失效 volatile和synchronized的区别 使用上的区别 volatile关键字只能用于修饰实例变量和类变量，不能用于修饰方法以及方法参数和局部变量，常量等 synchronized关键字不能用于对变量的修饰，只能用于修饰方法或语句块 volatile修饰的变量可以为null，synchronized关键字同步语句块的monitor对象不能为null 对原子的保证 volatile无法保证原子性 由于synchronized是一种排他机制，因此被synchronized关键字修饰的同步代码块是无法被中途打断，因此其能够保证代码的原子性 对可见性的保证 俩者均可以保证共享资源在多线程间的可见性，但是实现机制完全不同 synchronized借助JVM指令monitorentry和monitorexit对通过排他的方式使得同步代码块串行化，在monitorexit时所有共享资源都将会被刷新到主内存中。 volatile使用机器指令“lock;”的方式迫使其他线程工作内存中的数据失效，必须到主内存中进行再次加载。 对有序性的保证 volatile关键字禁止JVM编译器以及处理器对其进行重排序，所以它能够保证有序性 虽然synchronized关键字所修改的同步方法也可以保证顺序性，但是这种顺序性是以程序的串行化执行换来的，在synchronized关键字所修改的代码块中代码指令也会发生指令重排序的情况 其他 volatile不会使线程陷入阻塞 synchronized关键字会使线程进入阻塞状态","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"java并发编程","slug":"java并发编程","permalink":"http://yoursite.com/tags/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}]},{"title":"Java并发编程","slug":"java/并发编程/Java并发基础1","date":"2018-04-06T10:39:51.000Z","updated":"2020-05-11T07:20:26.025Z","comments":true,"path":"2018/04/06/java/并发编程/Java并发基础1/","link":"","permalink":"http://yoursite.com/2018/04/06/java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%801/","excerpt":"","text":"线程生命周期 NEW – 新建 RUNABLE – 可运行 RUNING – 运行 BLOCKED – 阻塞 TERMINATED – 死亡 上面所列的是线程的生命周期 何为上下文切换 CPU通过时间片分配算法来循环执行任务，当前任务执行一个任务时间片后会切换到下一个任务，但是在切换之前将保存上一个任务的状态，以便下次切换回这个任务时，可以在再加载这个任务的状态，所以任务从保存再到加载的过程就是一次上下文切换。上下文切换也会影响多线程的执行速度 下面看一段代码： 1234567891011121314151617181920212223242526272829303132333435363738394041public class ConcurrencyTest &#123; private static final long count = 10000000000L; public static void main(String[] args) throws InterruptedException &#123; concurrency(); serial(); &#125; private static void concurrency() throws InterruptedException &#123; long start = System.currentTimeMillis(); Thread thread = new Thread(new Runnable() &#123; @Override public void run() &#123; int a = 0; for (long i = 0;i&lt;count;i++)&#123; a +=5; &#125; &#125; &#125;); thread.start(); int b= 0; for(long i = 0;i&lt;count;i++)&#123; b--; &#125; long time = System.currentTimeMillis()-start; thread.join(); System.out.println(\"concurrency:\"+time+\"ms,b = \"+b); &#125; private static void serial()&#123; long start = System.currentTimeMillis(); int a = 0; for (long i = 0;i&lt;count;i++)&#123; a+=5; &#125; int b = 0; for(long i = 0;i&lt;count;i++)&#123; b--; &#125; long time = System.currentTimeMillis()-start; System.out.println(\"serial:\"+time+\"ms,b= \"+b+\" a= \"+a); &#125; 上面的代码是比较串行与并发时的执行效果； 在测试中可以看到数据量在10万以下，并发的执行速度比串行的执行速度慢；在测试中可以看到数据量在100万以上时，并发的执行速度比串行的执行速度快约2倍。上面的结果是因为线程有创建和上下文切换的开销。 如何减少上下文切换减少上下文切换的方法有四种： 无锁并发编程：多线程竞争锁时，会引发上下文切换，所以多线程处理数据时，可以使用例如将数据ID按照Hash算法取模分段，不同的线程处理不同段的数据 CAS算法：Java的Atomic包使用CAS算法来更新数据，而不需加锁 使用最少线程：避免创建不需要的线程 协程：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。 参考资料","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"java并发编程","slug":"java并发编程","permalink":"http://yoursite.com/tags/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}]}]}