{"meta":{"title":"楊さんノート","subtitle":"","description":"","author":"杨生华","url":"http://yoursite.com","root":"/"},"pages":[{"title":"Categories","date":"2020-02-09T08:10:17.612Z","updated":"2020-02-09T08:10:17.612Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"小杨的简介","date":"2020-04-08T13:03:17.937Z","updated":"2020-04-08T13:03:17.937Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"个人信息 杨生华/男/1997 本科/吉林化⼯学院/外国语学院/⽇语系/ 年级：2020年毕业 联系方式：13944680832 微信： 技术博客：楊さんノート Github：yangshenghua97 期望职位：/实习/Java后端开发 期望薪资：税前⽉薪3k-4k 项目和作品个人博客后台管理系统2019.01-2019.02技术运用： 开发环境：Windows/Linux、IntelliJ IDEA、JDK 1.8、MySQL 5.7、Redis、Tomcat 5. x、Git、Maven; 后端框架：Spring、Spring MVC、Myatis; 前端框架：AdminLTE3,JQuery等前端框架； 项目介绍： 基于Spring+Spring MVC + MyBatis框架的整合运用； 利用 Spring AOP对用户登录进行Token身份验证、Spring 事务隔离对SQL进行验证 MySQL 5.7 数据的基本使用、使用Druid数据库连接池对项目执行的SQL进行监控与优化； 单图/多图上传技术； 文件导入导出功能； 利用Redis缓存数据库对用户Token进行缓存 基于阿里云Linux系统进行部署与发布； Nginx + Tomcat的集群搭建； 微人事人力资源管理系统技术运用： 开发环境：Windows/Linux、IntelliJ IDEA、JDK 1.8、MySQL 5.7、Redis、Tomcat 5. x、Git、Maven; 后端框架：Spring Boot、MyBatis； 前端框架：Vue.js+Axios； 项目介绍： 基于Spring Boot、MyBatis、Spring Security的运用； 项目利用Maven对多模块进行整合，后端权限认证采用Spring Security实现； 数据库访问使用MyBatis，同时使用Redis实现认证信息缓存； 项目实现了邮件发送功能，采用Spring-Boot-Email+Spring Thymeleaf配合Java 多线程来对邮件进行发送； 技能清单 Java开发：熟悉Java开发、 对于Java多线程、I/O操作、反射、Java网络编程等都能其进行简单的应用。熟练使用Java集合，并且简单阅读多ArrayList、LinkedList、HashMap的源码。 了解ConcurrentHashMap的使用场景； 熟练操作Linux，掌握Linux常用命令，能够独立编写Linux Shell脚本代码，曾在阿里云服务器上发布过个人博客，熟悉Linux系统管理等； 熟练SQL语句编写、使用虚拟机搭建MySQL集群进行主从复制，事务隔离，索引优化等 了解Redis命令简单使用，使用虚拟机搭建Redis集群进行主从复制 前端框架：了解Vue.js、Node.js构建前端应用框架 版本管理、文档和自动化部署工具：了解Git版本控制系统常用命令的使用 开发框架及单元测试：JUnit对项目的各个模块进行单元测试、Spring、Spring Boot、Spring MVC、MyBatis的简单使用 学校经历2018.04-2018.09担任学生会网络部，主要工作是运营学院微信公众号以及组织学院活动； 2018.06-2018.07参加学校互联网+创新创业大赛获得校级团队二等奖； 工作经历 目前处于待就业实习阶段。2019年8月在吉林市创慧科技有限公司做图片处理工作"},{"title":"guestbook","date":"2020-03-31T03:10:00.000Z","updated":"2020-03-31T03:12:08.960Z","comments":true,"path":"guestbook/index.html","permalink":"http://yoursite.com/guestbook/index.html","excerpt":"","text":""},{"title":"Tags","date":"2020-02-09T09:12:40.508Z","updated":"2020-02-09T08:10:17.625Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"大数据各组件安装","slug":"大数据各组件安装","date":"2020-04-30T10:44:31.000Z","updated":"2020-04-30T11:05:54.716Z","comments":true,"path":"2020/04/30/大数据各组件安装/","link":"","permalink":"http://yoursite.com/2020/04/30/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%90%84%E7%BB%84%E4%BB%B6%E5%AE%89%E8%A3%85/","excerpt":"","text":"参考资料","categories":[{"name":"大数据","slug":"大数据","permalink":"http://yoursite.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"}],"tags":[{"name":"大数据","slug":"大数据","permalink":"http://yoursite.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"hadoop","slug":"hadoop","permalink":"http://yoursite.com/tags/hadoop/"},{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"},{"name":"hive","slug":"hive","permalink":"http://yoursite.com/tags/hive/"},{"name":"spark","slug":"spark","permalink":"http://yoursite.com/tags/spark/"},{"name":"zookeeper","slug":"zookeeper","permalink":"http://yoursite.com/tags/zookeeper/"},{"name":"hbase","slug":"hbase","permalink":"http://yoursite.com/tags/hbase/"},{"name":"flink","slug":"flink","permalink":"http://yoursite.com/tags/flink/"},{"name":"kafka","slug":"kafka","permalink":"http://yoursite.com/tags/kafka/"},{"name":"flume","slug":"flume","permalink":"http://yoursite.com/tags/flume/"}]},{"title":"Java并发编程之Synchronized","slug":"java/并发编程/Java并发编程之Synchronized","date":"2020-04-25T08:07:02.000Z","updated":"2020-05-06T01:56:55.758Z","comments":true,"path":"2020/04/25/java/并发编程/Java并发编程之Synchronized/","link":"","permalink":"http://yoursite.com/2020/04/25/java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BSynchronized/","excerpt":"","text":"synchronized的实现原理利用synchronized实现同步的基础： 对于普通同步方法，锁是当前的实例对象 对于静态同步方法，锁是当前类的Class对象 对于同步方法块，锁是Synchronized括号里的配置对象 Synchronized实现原理：JVM基于进入和退出Monitor对象来实现方法同步和代码块同步，代码块同步使用monitorenter和monitorexit指令实现，monitorenter指令是在编译后插入到同步代码块开始位置，而monitorexit是插入到方法结束和异常处，JVM要保证每个monitorenter必须有对应的monitorexit与之匹配。 关键字synchronized可以修饰方法或者以同步块的形式来进行使用，它主要确保多个线程在同一时刻，只能有一个线程处于方法或同步块中，他保证了线程对变量访问的可见性和排他性。对于同步块的实现使用monitorenter和monitorexit指令，而同步方法则是依靠方法修饰符上的ACC_SYNCHRONIZED来完成。其本质上是对一个对象的监视器(monitor)进行获取，而这个过程是排他的，也就是在同一时刻只能有一个线程获得synchronized所保护对象的监视器。任意一个对象都拥有自己的监视器，当这个对象有同步块或者这个对象的同步方法调用时，执行方法的线程必须先获取到该对象的监视器才能进入同步块或者同步方法，而没有获取到监视器的线程将会被阻塞在同步块和同步方法的入口处，进入BLOCKED状态。 参考资料","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"java并发编程","slug":"java并发编程","permalink":"http://yoursite.com/tags/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}]},{"title":"Hadoop基础知识","slug":"BigData","date":"2020-04-01T15:46:11.000Z","updated":"2020-04-23T05:12:10.698Z","comments":true,"path":"2020/04/01/BigData/","link":"","permalink":"http://yoursite.com/2020/04/01/BigData/","excerpt":"","text":"MapReduce MapReduce是海量数据的分布式计算框架，这一框架解决了：数据分布式存储，作业调度，容错，机器间通信等复杂问题 关于MapReduce的两个重要进程 JobTracker：主进程，负责接收客户作业提交 TaskTracker：由JobTracker指派任务 MapReduce执行流程文件要存储在HDFS上，每个文件切换成多个一定大小的文件块，存储在多个节点上 MapReduce的核心思想：分而治之 分解 求解 合并 Hadoop 2.0 参考资料","categories":[{"name":"大数据","slug":"大数据","permalink":"http://yoursite.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"}],"tags":[{"name":"大数据","slug":"大数据","permalink":"http://yoursite.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"hadoop","slug":"hadoop","permalink":"http://yoursite.com/tags/hadoop/"}]},{"title":"TCP/IP协议","slug":"计算机基础/计算机网络/TTCP-IP协议","date":"2020-03-12T18:19:13.000Z","updated":"2020-03-15T14:02:04.814Z","comments":true,"path":"2020/03/13/计算机基础/计算机网络/TTCP-IP协议/","link":"","permalink":"http://yoursite.com/2020/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TTCP-IP%E5%8D%8F%E8%AE%AE/","excerpt":"","text":"TCP/IP的标准制定由于TCP/IP技术的公开性，他不属于任何一个厂商或者是专业协会所有。TCP/IP的标准大部分都由RFC技术报告的形式公开。RCF文件包含了所有TCP/IP的协定标准，以及其最新版本。RFC所涵盖的内容和细节非常广，也可以为新协定的标准和计划，但不能以学术研究论文的方式来编辑。 TCP/IP的特性 它是其它网络服务的基础，几乎所有数据包交换网络都提供了这种服务。TCP/IP是根据信息中所含的地址资料来进行资料的传送，他不能确保每个独立路由的数据包是可靠和依序的送达目的地。在每个连线过程中，线路都不是被”独占”的，而是直接映射到硬件地址上，因此特别有效。 因为数据包交换并不能确保每一个数据包的可靠性，因此我们就需要通讯软件来自动检测和修护传送过程中出现的错误和处理损坏数据包。这种服务就是用来确保电脑程序之间能够连接和传送大量的数据。关键的技术就是数据流进行分割，然后编号传送，然后通过接受的确认来确数据的完整性 在数据包交换技术中，TCP/IP是独立于硬件之上的。TCP/IP有自己的一套数据包规定和定义,能应用在不同的网络之上 只要用TCP/IP连接网络，就会获得一个独一无二的识别位址。数据包在交换过程中，是以位址数据为依据，不管数据包所经历的路由如何，数据都会被送到指定的地址。 TCP/IP 的确认模式是以“端到端”进行的。這样就无需理会数据包交换过程中所参与的其他设备。 TCP/IP协议分层框架 链路程：链路层以字节位单位0和1分别进行分组，定义数据帧，写入源和目标机器的物理地址，数据，校验位来传输数据。 链路层报文结构 网络层：根据IP定义网络地址，区分网段。子网内根据地址解析协议(ARP)进行MAC寻址，子网外进行路由转发数据包，这个数据包即为IP数据包。 传输层：数据包通过网络层发送到目标计算机后，应用程序在传输层定义逻辑端口，确认身份后，将数据包交给应用程序，实现端口到端口间通讯。 应用层：传输层的数据到达应用程序时，以某种统一规定的协议格式解读数据。 IP协议IP是面向无连接、无状态的，没有额外的机制保证发送的包是否有序到达。IP首先规定出IP地址格式，该地址相当于在逻辑意义上进行了网段的划分，给没台机器额外设置了一个唯一的详细地址。IP地址属于网络层，主要的功能字啊WLAN内进行路由寻址，选择最佳路由。 TCP建立连接传输控制协议(TCP)，是一种面向连接、确保数据在端到端间的可靠传输的协议。面向连接是指在发送数据前，需要先建立一条虚拟的链路，然后让数据在这条链路上“流动”传输。每个TCP数据包是封装在IP包中的，每一个IP头的后面紧接的是TCP头。 协议第一行的两个端口号各个占据两个字节，分别代表源机器与目标机器的端口号。这两个端口号与IP报头格式中的源IP地址和目标IP地址所组成的四元组可唯一标识一条TCP连接。由于TCP是面向连接的，所以有服务器和客户端之分。需要服务端先在相应的端口上进行监听，准备好接收客户端发起的连接请求。在类UNIX系统系统上通过netstat命令列出机器上已建立的连接信息，其中包含唯一标识一条连接的四元组，以及各连接的状态等内容。 TCP的FLAG位有6个bit组成，分别代表SYN、ACK、FIN、URG、PSH、RST，需要重点关注的是SYN、ACK、FIN。SYN(Synchronize Sequence Numbers)用作建立连接时的同步信号；ACK(Acknowledgement)用于对收到的数据进行确认，所确认的数据由确认序列号表示；FIN(Finish)表示后面没有数据需要发送，通常意味着所建立的连接需要关闭。 TCP三次握手TCP三次握手是指在建立连接的三个步骤： A机器发出一个数据包并将SYN置1，表示希望建立连接。这个包中的序列号假设是x。 B机器收到A机器发过来的数据包后，通过SYN得知这是一个建立连接的请求，于是发送一个响应包并将SYN和ACK标记都置为1。假设这个包中的序列号是y，而确认序列号的必须是x+1，表示收到了A发过来的SYN。在TCP中，SYN被当作数据中的一个字节。 A接收到B的响应后需进行确认，确认包中将ACK置1，并将确认序列号设置为y+1，表示收到了来自B的SYN。 双方只有确认4类信息，才能建立连接。在第二次握手后，从B机器视角看还有连个NO信息无法确认。在第三次握手后，B机器才能确认自己的发报能力是否正常的。 连接三次握手也是防止出现请求超时导致脏连接。TTL网络报文的生存时间往往都会超过TCP请求时间，如果两次握手就可以创建连接的话，传输数据并释放连接后，第一个超时的连接请求才到达B机器的话，B机器会认为是A创建的连接的请求，然后确认同意创建连接。因为A机器的状态不是SYN_SENT,所以直接丢弃了B的确认数据，以致最后只是B机器单方面创建连接完毕。 TCP断开连接TCP是全双工通信，双方都能作为数据的发送方和接收方，但TCP连接也会有断开的时候。A、B机器连接只要三次握手，而断开则需要四次挥手，例如下图： A机器想要断开连接，则待本方数据发送完毕后，传递FIN信号给B机器。B机器应答ACK，告诉A机器可以断开，但是需要等B机器处理完成数据，再主动给A机器发送FIN信号。这时A机器处于半关闭状态(FIN-WAIT-2)，无法再发送新的数据。B机器做好连接关闭前的准备工作后，发送FIN给A机器，此时B机器也进入半关闭状态(CLOSE_WAIT)。A机器发送针对B机器FIN的ACK后，进入TIME_WAIT状态，经过2MSL后，没有收到B机器传过来的报文，则确定B机器已经收到A机器最后发送的ACK指令，此时TCP连接正式释放。","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"CPU与内存","slug":"计算机基础/计算机构成/CPU与内存","date":"2020-03-11T14:15:02.000Z","updated":"2020-03-12T19:34:04.876Z","comments":true,"path":"2020/03/11/计算机基础/计算机构成/CPU与内存/","link":"","permalink":"http://yoursite.com/2020/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%9E%84%E6%88%90/CPU%E4%B8%8E%E5%86%85%E5%AD%98/","excerpt":"","text":"参考资料","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}]},{"title":"计算机的0与1","slug":"计算机基础/计算机构成/计算机的0与1","date":"2020-03-11T12:53:21.000Z","updated":"2020-03-11T14:14:08.175Z","comments":true,"path":"2020/03/11/计算机基础/计算机构成/计算机的0与1/","link":"","permalink":"http://yoursite.com/2020/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%9E%84%E6%88%90/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%840%E4%B8%8E1/","excerpt":"","text":"在计算机中无论是什么设备，归根结底都是0和1的信号处理，设定基数为2，进位的规则是“逢二进一”，称之为二进制，设想有8条电路，每条电路有高电平和低电平两种状态。根据组合排列，有2^8 即256个种不同的信号。这8条电路，最左侧的一条表示正负，0表示正数，1表示负数，不参与数值表示。 基本编码表示数的基本编码方式有原码、反码、补码； 原码：符号为和数字实际值得结合，正数就是数值本身，符号为0；负数是数值本身，符号位为1，8位的二进制的表示范围是[-127,127] 反码：正数是本身，符号位为0；负数的数值部分是正数表示的基础上对各个位取反，符号位为1。8位二进制数的表示范围是[-127,127] 补码：正数是数组的本身，符号位为0，负数的数值部分是在正数表示基础上对各个位取反加1，符号位为1。8位二进制数的表示范围是[-127,127] 正数/负数 原码 反码 补码 1 0000 0001 0000 0001 0000 0001 -1 1000 0001 1111 1110 1111 1111 2 0000 0010 0000 0010 0000 0010 -2 1000 0010 1111 1101 1111 1110 为了加速计算机对加减乘除运算速度，所有产生了反码和补码。例如在进行减法计算时，1-2=-1在计算机运算中可以这样运算：1+（-2）=-1。如果使用原码计算则结果为：1+（-2）= [0000 0001]原+[1000 0010]原 = [10000011]原 = -3结果是错误的。为了解决这一问题，于是出现了反码，使用反码计算，结果为1-2 = 1+(-2) = [00000001]反+[1111 1101]反=[1111 1110]反 = -1。 计算机存储计量单位在上述的一条线路在计算机中表示1位，即1个bit，8个bit组成一个单位，称为一个字节，即1个Byte，1024个Byte简写为KB，1024个KB简写为MB，1024个MB简写为GB。 位移运算向右移动一位近似表示除以2，十进制转化为二进制数后，向右移时，最右边的1位将被直接抹去。在左移&lt;&lt;和右移&gt;&gt;这两种运算中符号位均参与移动，除了负数右移时高位补1外，其他情况均在空位处补0 左移运算由于符号位参与向左移动，在移动后的结果，最左位可能是1或是0，即正数向左移的结果可能负数也可能是正数，负数向左移的结果也是如此。 对于 &gt;&gt;&gt; 无符号向右移动(不存在&lt;&lt;&lt;位移运算)，当向右移动时，正负数高位均补0，正数不断向右移动的最小值是0，而负数不断向右移动的最小值为1，无需考虑符号位，高位直接补0 参考资料 《码出高效 Java开发手册》","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}]},{"title":"数据结构与算法概述","slug":"数据结构/数据结构与算法概述","date":"2020-02-20T04:54:01.000Z","updated":"2020-03-16T03:35:35.806Z","comments":true,"path":"2020/02/20/数据结构/数据结构与算法概述/","link":"","permalink":"http://yoursite.com/2020/02/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%A6%82%E8%BF%B0/","excerpt":"","text":"","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"Git快速入门","slug":"git/Git快速入门","date":"2020-02-15T09:56:07.000Z","updated":"2020-03-27T10:35:41.420Z","comments":true,"path":"2020/02/15/git/Git快速入门/","link":"","permalink":"http://yoursite.com/2020/02/15/git/Git%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/","excerpt":"","text":"Git安装(Windowns系统为例) 下载Git软件: 点击链接:https://git-scm.com/ 双击！ 一路Next！ 1 Git命令行git简单易用，只要在终端输入$ Git，Git就会不带任何参数输出它的选项和常用的子命令。 12345678910$ git#输入git后会输出一下选项，如果要得到一个完整的git子命令列表，可以输入 git help --allusage: git [--version] [--help] [-C &lt;path&gt;] [-c &lt;name&gt;=&lt;value&gt;] [--exec-path[=&lt;path&gt;]] [--html-path] [--man-path] [--info-path] [-p | --paginate | -P | --no-pager] [--no-replace-objects] [--bare]····················collaborate (see also: git help workflows) fetch Download objects and refs from another repository pull Fetch from and integrate with another repository or a local branch push Update remote refs along with associated objects ..... 2 Git使用快速入门 2.1创建初始版本库首先在git终端下创建一个空文件夹: 1234567#创建空文件夹 test/$ mkdir -p test/#进入到test文件夹$ cd test/#执行git init命令$ git initInitialized empty Git repository in /root/test/.git/ Git不会关心文件夹里是否为空，执行git init 命令创建了一个隐藏目录，在项目目录的顶层有个名为 .git文件夹，Git把所有修订的信息都放在这唯一的顶层目录里 2.2 将文件添加到版本库中执行 git init 命令时，Git版本库都是空的，为了管理内容，需要明确的把内容放入版本库中。 使用 git add file[^1] 将file添加到版本库中。 例如: 在 test目录中创建一个文件index.html并把该文件添加到版本库中 123$ cd test/$ touch index.html$ git add index.html [^1 ]: 如果目录中已经有很多的文件，使用git add .命令让Git把当前的目录及子目录中的文件都添加到版本库中 运行git status 命令显示中间状态的index.html 12$ git status # 这个命令显示新文件index.html将在下次提交时添加到版本库中 1 2.3 版本库内文件的删除和重命名 文件删除执行命令 git rm可以删除版本库里不需要的文件 操作如下: 123# 查看版本库中的文件$ git ls-filesindex.html 执行git rm index.html即可删除版本库中的index.html文件$ git rm index.html 12345678910111213141516 - ##### 文件重命名 在终端执行``git mv srcfile targetfile``即可以完成文件的重命名 例如： ```shell # 先查看版本库中的文件 $ git ls-files index.html # 执行git mv index.html foo.html 将index.html修改为foo.html $ git mv index.html foo.html # 再次查看版本库文件 $ git ls-files foo.html ​","categories":[{"name":"版本控制管理","slug":"版本控制管理","permalink":"http://yoursite.com/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%AE%A1%E7%90%86/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"Git提交","slug":"git/Git提交","date":"2020-02-15T08:54:50.000Z","updated":"2020-03-27T10:35:07.010Z","comments":true,"path":"2020/02/15/git/Git提交/","link":"","permalink":"http://yoursite.com/2020/02/15/git/Git%E6%8F%90%E4%BA%A4/","excerpt":"","text":"吧啦吧啦乱七八遭的东西在Git中，提交（commit）是用来记录版本库的变更的。当提交时，Git记录索引的快照并把快照放进对象库（简单的介绍）。提交的快照是串联在一起的，每张新的快照指向它的先驱。随着时间的推移，一系列的变更就表示一系列的提交。 Git提供一种机制来确定相对于另一个引用的提交，通常是分支的头。 在某些Git应用场景中，可能见过诸如这样的提交形式 master^ 。 在同一代提交中，插入符号 ^ 是用来选择不同的父提交。给定一个提交C，C^1 是其第一个父提交，C^2 是其第二个父提交，等等，如图: 通过把引用与^ 和 ~ 组合，就可从引用的提交历史图中选出任意提交 提交历史记录 查看旧提交 显示提交历史记录的主要命令是 git log,在参数形式上，git log跟git log HEAD是一样的，输出每一个可从HEAD找到的历史记录中的提交日志信息。变更从HEAD提交开始显示，并从提交图中回溯。如果使用git log 时提供一个提交名，那么这个日志将从该提交开始回溯输出。例如:git log master","categories":[{"name":"版本控制管理","slug":"版本控制管理","permalink":"http://yoursite.com/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%AE%A1%E7%90%86/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"关于Git文件管理","slug":"git/关于Git文件管理","date":"2020-02-12T11:25:36.000Z","updated":"2020-03-27T10:35:50.019Z","comments":true,"path":"2020/02/12/git/关于Git文件管理/","link":"","permalink":"http://yoursite.com/2020/02/12/git/%E5%85%B3%E4%BA%8EGit%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/","excerpt":"","text":"git中的文件分类​ Git将所有文件分为3类：已追踪的、被忽略的以及未追踪的 已追踪的 已追踪的文件是指已经在版本库中的文件，或者是已暂存到索引中的文件。如果想将新文件newfile添加到已追踪的文件，执行 git add newfile即可 被忽略的 被忽略的文件必须在版本库中明确声明为不可见或被忽略，即使他可能会在工作目录中出现。一个软件项目通常都会有很多被忽略的文件。普通被忽略的文件包括临时文件、个人笔记、编译器输出文件以及构建过程中自动生成的大多数文件。Git维护一个默认的忽略文件列表，也可以配置版本库来识别其他文件。被忽略的文件会在后面介绍。 未追踪的 未追踪的文件是指那些不在版本库中的文件。 下面举一个栗子: 1234567891011121314151617181920$ git init#查看状态$ git status# On branch master## Initial commit#nothing to commit (create/copy files and use \"git add\" to track)#添加一个文件$ echo \"new Data\" &gt;&gt; data# On branch master## Initial commit## Untracked files:# (use \"git add &lt;file&gt;...\" to include in what will be committed)## datanothing added to commit but untracked files present (use \"git add\" to track) 为了让Git忽略目录中的文件，只需将该文件名添加到一个特殊的文件.gitignore中就可以了。 123456789101112131415161718192021222324252627$ touch main.o$ git status# On branch master## Initial commit## Untracked files:# (use \"git add &lt;file&gt;...\" to include in what will be committed)## data# main.onothing added to commit but untracked files present (use \"git add\" to track)#将 main.o添加到.gitignore中$ echo main.o &gt;&gt; .gitignore$ git status# On branch master## Initial commit## Untracked files:# (use \"git add &lt;file&gt;...\" to include in what will be committed)## .gitignore# datanothing added to commit but untracked files present (use \"git add\" to track) 这样main.o就已经被忽略了，但是git status现在显示一个新的未追踪的文件 .gitignore。 使用 git addgit add 命令将暂存一个文件。就Git文件分类而言，如果一个文件是未追踪的，那么git add就会将文件的状态转化为已追踪的。如果git add作用于一个目录名，那么该目录下的文件以及子目录都会递归暂存起来。 这里还接着上面的栗子: 123456789101112131415161718192021$ git status# On branch master## Initial commit## Untracked files:# (use \"git add &lt;file&gt;...\" to include in what will be committed)## .gitignore# datanothing added to commit but untracked files present (use \"git add\" to track)# 将data、.gitignore两个文件添加至已追踪的分类$ git add data .gitignore$ git status# On branch master# Initial commit# Changes to be committed:# (use \"git rm --cached &lt;file&gt;...\" to unstage)# new file: .gitignore# new file: data 在上面的栗子中使用git add后，暂存和追踪data和.gitignore文件，并准备下次提交是时添加到版本库中。 可以使用git ls-files命令查看隐藏在对象模型下的东西。 123$ git ls-files.gitignoredata 在任何编辑之后，提交变更之前，请执行一次git add命令。 使用 git commit使用 git commit –allgit commit 的 -a或者 --all选项会导致执行提交之前自动暂存所有未暂存的和未追踪的文件变化，包括从工作副本中删除已追踪的文件 下面举个栗子: 12345678910111213$ pwd/tmp/commit-all-example#创建测试版本库$ git initInitialized empty Git repository in /tmp/commit-all-example/.git/$ echo \"Testfile1\" &gt;&gt; ready$ echo \"Testfile2\" &gt;&gt; notyet$ git add ready notyet$ git commit -m \"Setup\"[master (root-commit) 2b00dbf] Setup 2 files changed, 2 insertions(+) create mode 100644 notyet create mode 100644 ready 之后再次编辑ready文件，并用 git add把它添加到版本库中。然后编辑notyet文件保持它是未暂存的。 在一个子目录下添加一个文件，但是不要对它执行git add命令 12$ mkdir subdir$ echo \"Nope\" &gt;&gt; subdir/new 当执行 git commit --all命令，Git会递归遍历整个版本库，暂存所有先前通过git add提交的已知的和修改的文件，然后提交它们，由于subdir/ 一个全新的目录，而且目录下没有任何文件名或路径通过git add和git commit进行操作的， So 即使是 –all选项也不能将其提交。 关于提交日志消息​ 如果不通过命令行直接提供日志消息（例如:git commit -m &quot;提交日志消息&quot;），Git会启动编辑器，并提示你写一个提交日志。 使用 git rm 命令​ git rm命令会在版本库中和目录中同时删除文件。 接着上面的栗子: 这里“意外”的添加了一个文件 1234$ echo \"Random\" &gt; oops#当执行git rm oops时，提示删除失败$ git rm oopsfatal: pathspec 'oops' did not match any files ​ 为什么会这样，可以通过git ls-files命令查看版本库中的文件 123$ git ls-filesnotyetready 现在的版本库中没有oops这个文件，可通过git add oops命令将 oops文件加入到版本库中。 12345$ git add oops$ git ls-filesnotyetoopsready 另外，要将一个文件由已暂存的转化为未暂存的,可以使用git rm --cached命令 比如要删除oops 12$ git rm --cached oopsrm 'oops' git rm --cached会删除索引中的文件并它文件保留在工作目录中，而git rm则会将文件从索引和工作目录中都删除。 如果想要删除一个已经提交的文件，通过简单的git rm filename命令来暂存这一请求 还可以使用 git rm -f来强制删除文件。 如果想保留的文件不小心删除了，可以通过版本控制系统的恢复功能进行恢复 具体的命令如下: 123# 加入不小心删除了oops文件# 可以是下面的命令进行恢复git checkout HEAD -- oops 使用 git mv如果想要给一个文件重命名可以使用git mv srcfile newfile，git mv 命令会将 srcfile文件的文件名称改为newfiles，Git会在索引中删除srcfile文件的路径名，并添加newfile的路径名，至于srcfile文件里的内容，Git仍然会保存在对象库中，然后才会将它与newfile重新关联。git mv 还可以移动一个文件到一个目录中：git mv srcfile dir/ .gitignore 文件在前面简单介绍过.gitignore文件的作用。可以通过.gitignore文件来忽略不相干的文件。Git还支持一种更丰富的机制，一个.gitignore文件下可以包含一个文件名模式列表，指定哪些文件需要忽略。.gitignore 文件的格式如下。 空行会被忽略，而以（#）号开头的行可以用于注释。然而，如果#跟在其他文本后面，它就不代表注释了。 一个简单的字面置文件名匹配任何目录中的同名文件。 目录名由末尾的（/）标记。这能匹配同名的目录和子目录，但不匹配文件或符号链接。 包含shell通配符，如（*）号，这种模式可扩展为shell通配模式。正如标准shell通配符一样，因为不能跨目录匹配，所以一个 * 只能匹配一个文件或目录名。 起始的 ！号会对该行其余部分的模式进行取反。","categories":[{"name":"版本控制管理","slug":"版本控制管理","permalink":"http://yoursite.com/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%AE%A1%E7%90%86/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"Java并发基础Java中的锁","slug":"java/并发编程/Java并发基础Java中的锁","date":"2019-04-30T10:40:11.000Z","updated":"2020-05-06T04:49:24.445Z","comments":true,"path":"2019/04/30/java/并发编程/Java并发基础Java中的锁/","link":"","permalink":"http://yoursite.com/2019/04/30/java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80Java%E4%B8%AD%E7%9A%84%E9%94%81/","excerpt":"","text":"锁是用来控制多个线程访问共享资源的方式，一个锁能够防止多个线程同时访问共享资源。 Lock在Lock接口出现之前，Java通过synchronized关键字实现锁功能，JDK 1.5之后，在并发包中新增了Lock接口来实现锁功能，有与synchronized关键字类似功能，只是在使用时需要显示的获取锁和释放锁，拥有了锁释放和获取的可操作性、可中断性等synchronized关键字不具备的特性。在使用synchronized关键字会隐式的获取锁和释放锁，但锁的获取和释放固化，即先获取后释放。Lock接口的实现基本上是通过聚合一个同步器（AQS）的子类来完成线程访问控制。 Lock接口的使用方式： 123456Lock lock = new ReentrantLock();lock.lock();try&#123;&#125;finally&#123; lock.unlock()&#125; 上面的代码示例中要注意：获取锁的过程不要写在try中，因为在获取锁时发生异常，异常抛出的同时，也会导致锁无故释放。 重入锁重入锁ReentrantLock，支持重进入的锁，表示该锁功能支持一个线程对资源的重复加锁。 实现重进入重进入是指任意线程在获取锁之后能够再次获取该锁而不会被锁所阻塞，这个特性需要解决两个问题： 线程再次获取锁：所需要去识别获取锁的线程是否为当前占据锁的线程，如果是则再次成功获取。 锁的最终释放：线程重复n次获取锁，随后第n次释放该锁后，其他线程能够获取到该锁。锁的最终释放要求锁对于获取进行计数自增，计数表示当前锁被重复获取的次数，而锁被释放时，计数自减当计数等于0时表示已经释放成功。 重入锁是通过组合自定义同步器来实现锁的获取和释放。获取同步状态的代码如下： 123456789101112131415161718final boolean nonfairTryAcquire(int acquires) &#123; final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) &#123; if (compareAndSetState(0, acquires)) &#123; setExclusiveOwnerThread(current); return true; &#125; &#125; else if (current == getExclusiveOwnerThread()) &#123; int nextc = c + acquires; if (nextc &lt; 0) // overflow throw new Error(\"Maximum lock count exceeded\"); setState(nextc); return true; &#125; return false; &#125; 通过判断当前线程是否为获取锁的线程来决定获取操作是否成功，如果是获取锁的线程再次请求，则将同步状态值进行增加并返回true，表示获取同步状态成功。 读写锁读写锁维护一对锁，一个读锁和一个写锁，通过分离读锁和写锁使得并发性相比一般的排他锁有了更大的提升，读写锁的性能都会比排它锁好，因为大多数场景读操作对于写操作，在这样的情况下读写锁能够提供排它锁更好的并发性和吞吐量， 读写锁的实现 读写状态的设计 读写锁同样依赖自定义同步器来实现同步功能，而读写状态就是其同步器的同步状态。读写锁的自定义同步器需要在同步同步状态上维护多个读线程和一个写线程的状态，状态的设计成为读写锁实现的关键。 如果在一个整型变量上维护多种状态，就一定需要“按位切割使用”这个变量，读写锁将变量切分成两个部分，高16为表示读，低16位表示写 队列同步器队列同步器AbstractQueuedSynchronizer，是用来构建锁或者其他同步组件的基本框架，使用一个int成员变量表示同步状态，通过内置FIFO队列来完成资源的获取线程的排队工作。 同步器是实现锁的关键，在锁的实现中聚合同步器，利用同步器实现锁的语义。二者的关系是：锁是面向使用者，定义了使用者与锁交互的接口，隐藏了实现细节；同步器则面向锁的实现者，简化了锁的实现方式，屏蔽了同步状态管理、线程的排队、等待与唤醒等底层操作。同步器的主要使用方式是继承，子类通过继承同步器并实现它的抽象方法来管理同步器状态。 队列同步器的实现分析同步队列同步器依赖内部的同步队列来完成同步状态的管理，当前线程获取同步状态失败时，同步器会将当前线程以及等待状态的信息够造成一个节点将其加入到同步队列，同时会阻塞当前线程，当同步状态释放时，会把首节点中的线程唤醒，使其再次尝试获取同步器状态。 节点是构成同步队列的基础，同步器拥有首节点和尾节点，没有成功获取同步状态的线程会成为节点加入到该队列的尾部。 参考资料","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"java并发编程","slug":"java并发编程","permalink":"http://yoursite.com/tags/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}]},{"title":"Java并发基础","slug":"java/并发编程/Java并发基础Java","date":"2019-04-30T10:39:37.000Z","updated":"2020-04-30T10:42:24.059Z","comments":true,"path":"2019/04/30/java/并发编程/Java并发基础Java/","link":"","permalink":"http://yoursite.com/2019/04/30/java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80Java/","excerpt":"","text":"参考资料","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"java并发编程","slug":"java并发编程","permalink":"http://yoursite.com/tags/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}]},{"title":"SQL基础（二）","slug":"数据库/mysql/SQL基础2","date":"2019-04-05T09:57:27.000Z","updated":"2020-04-09T13:52:30.812Z","comments":true,"path":"2019/04/05/数据库/mysql/SQL基础2/","link":"","permalink":"http://yoursite.com/2019/04/05/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/SQL%E5%9F%BA%E7%A1%802/","excerpt":"","text":"过滤数据百分号（%）通配符%表示任何字符出现任意次数。 123SELECT prod_id,prod_nameFROM productsWHERE prod_name LIKE 'jet%'; 上面的SQL检索任意以jet为开头的词，%告诉MYSQL接受jet之后的任意字符，不论它有多少字符。通配符可在搜索模式中任意位置使用，并且可以使用多个通配符 123SELECT prod_id,prod_nameFROM productsWHERE prod_name LIKE '%anvil%'; 下划线（_）通配符下划线通配符只匹配单个字符而不是多个字符。 123SELECT prod_id,prod_nameFROM productsWHERE prod_name LIKE '_ ton anvil' 使用通配符的技巧 不要过度使用通配符，如果其他操作符能达到相同的效果，应该使用其他操作符； 在确实需要使用通配符时，除非绝对有必要，否则不要把通配符放在搜索模式的开始处。如果把通配符置于开始处，搜索起来很慢； 仔细注意通配符的位置，如果犯错位置。可能不会得到想要的数据； 正则表达式MySQL中使用REGEXP关键字指定正则表达式的字符匹配。 正则表达式常用的字符匹配列表 选项 说明 ^ 匹配文本的开始字符 $ 匹配文本的结束字符 . 匹配任何单一字符 * 匹配零个或多个在在它前面的字符 + 匹配前面的字符1次或多次 字符串 匹配包含指定的字符串的文本 [字符集合] 匹配字符集合中的任何一个字符 [^] 匹配不在括号中的任何字符 字符串{n,} 匹配前面的字符串至少n次 字符串{n,m} 匹配前面的字符串至少n次，至多m次。 | 进行OR匹配 正则表达式经典例子： 基本字符匹配 1234SELECT prod_nameFROM productsWHERE prod_name REGEXP '1000'ORDER BY prod_name; 1234SELECT prod_nameFROM productsWHERE prod_name REGEXP '.000'ORDER BY prod_name; 进行OR匹配 1234SELECT prod_nameFROM productsWHERE prod_name REGEXP '1000|2000'ORDER BY prod_name; 范围匹配 1234SELECT prod_nameFROM productsWHERE prod_name REGEXP '[1-5] Ton'ORDER BY prod_name; 匹配特殊字符 1234SELECT vend_nameFROM vendorsWHERE vend_name REGEXP '\\\\.'ORDER BY prod_name; MYSQL函数文本处理函数 函数 说明 Left() 返回字符串左边的字符 Length() 返回字符串的长度 Locate() 找出字符串的一个子串 Lower() 将字符串转换为小写 LTrim() 去掉字符串左边的空格 Right() 去掉字符串右边的字符 RTrim() 去掉字符串右边的空格 Upper() 将字符串转换为大写 经典例子 将字符串转换为大写 123SELECT vend_name,Upper(vend_name)FROM vendorsORDER BY vend_name; 日期时间处理函数 函数 说明 AddDate() 增加一个日期（天，周等） AddTime() 增加一个时间（时，分等） CurDate() 获取当前日期 CurTime() 获取当前时间 Date() 返回日期时间的日期部分 DateDiff() 计算两个日期之差 Time() 返回一个日期时间的时间部分 Now() 返回当前日期和时间 聚集函数 函数 说明 AVG() 计算某一列的平均值 COUNT() 获取某一列的行数 MAX() 获取某一列的最大值 MIN() 获取某一列的最小值 SUM() 获取某一列值之和 数据分组创建分组分组是在SELECT语句的GROUP BY子句中建立的。 举个例子： 123SELECT vend_id,COUNT(*) as num_prodsFROM productsGROUP BY vend_id; 使用GROUP BY子句的一些规定 GROUP BY子句可以包含任意数目的列。使得能够对分组进行嵌套，为数据分组提供更细致的控制。 如果GROUP BY子句中嵌套了分组，数据将在最后规定的分组上进行汇总。 GROUP BY子句中列出每个列都必须是检索列或是有效的表达式。如果在SELECT中使用表达式，则必须在GROUP BY子句中指定相同的表达式。不能使用别名。 除聚集函数语句外，SELECT语句中每个列都必须在GROUP BY子句中给出。 如果分组列中具有NULL值，则NULL将作为一个分组返回。如果列中有多行NULL值，他们将分为一组。 GROUP BY子句必须出现在WHERE子句之后，ORDER BY子句之前。 过滤分组：HAVING使用HAVING对分组进行过滤，基于分组聚集值进行分组。 举几个例子 1234SELECT vend_id,COUNT(*) as num_prodsFROM productsGROUP BY vend_idHAVING COUNT(*)&gt;2; 1234SELECT order_num,SUM(quantity*item_price) as ordertotalFROM orderitemsGROUP BY order_numHAVING SUM(quantity*item_price) &gt;=50; SELECT子句顺序以下语句由上至下的顺序 SELECT：要返回的列或表达式 FROM：从中检索数据的表 WHERE：行级过滤 GROUP BY：分组说明 HAVING：组级过滤 ORDER BY：输出排序顺序 LIMIT：遥检索的行数 子查询子查询就是嵌套在其他查询中的查询。 利用子查询过滤1234567SELECT cust_idFROM ordersWHERE order_num IN(SELECT order_numFROM orderitemsWHERE prod_id = 'TNT2'); 上面的SELECT语句中子查询总是从内向外处理，上面的SQL语句实际上执行了两个SELECT操作。 在WHERE子句中使用子查询能够编写出功能很强并且很灵活的SQL语句。对于能嵌套的子查询的数目没有限制，但在实际应用中对于性能的要求，不能嵌套太多的子查询。 用作计算字段使用子查询123456SELECT cust_name,cust_state,(SELECT COUNT(*)FROM ordersWHERE orders.cust_id = customers.cust_id) as ordersFROM customersORDER BY cust_name; 联结表创建联结联结的创建非常简单，规定要联结的所有表以及他们如何关联即可。 1234SELECT vend_name,prod_name,prod_priceFROM vendors as vend,products as prdWHERE vend.vend_id = prd.vend_idORDER BY vend_name,prod_name; 内部联结基于两个表之间的相等测试，称为内部联结。 123SELECT vend_name,prod_name,prod_priceFROM vendors as vend,INNER JOIN products as prodON vend.vend_id = prod.vend_id; 两个表之间的关系是FROM子句的组成部分，以INNER JOIN指定，在使用这种语法时，联结条件用特定的ON子句而不是WHERE子句给出。传递给ON的实际条件与传递给WHERE的相同。 自联结12345SELECT p1.prod_id,p1.prod_nameFROM products as p1,products as p2WHERE p1.vend_id = p2.vend_idANDp2.prod_id = 'DTNTR'; 自联结通常作为外部语句用来替代从相同表中检索数据时使用的子查询语句。 外部联结看下面的例子： 12345SELECT customers.cust_id,orders.order_numFROM customers LEFT OUTER JOIN ordersON customers.cust_id = orders.cust_id; 在使用OUTER JOIN语法时，必须使用RIGHT或LEFT关键字指定包含其所有行的表（RIGHT指出的是OUTER JOIN右边的表，而LEFT指出的是OUTER JOIN左边的表） 使用联结和联结条件 注意所使用的联结类型，一般使用内部联结，但使用外部联结也是有效的； 保证使用正确的联结条件，否则将返回不正确的数据； 应该总是提供联结条件，否则会得笛卡儿积； 在一个联结中可以包含多个表，甚至对于每个联结可以采用不同的联结类型。虽然这样做合法的，一般也很有用，但应该在一起测试他们之前，分别测试每个联结，这将是故障排除更为简单； 组合查询组合查询将结果作为单个查询结果集返回。这些组合查询通常称为复合查询。 下面的情况，需要使用组合查询 在单个查询浙江哦你从不同的表中返回类型类似结构的数据； 对单个表执行多个查询，按单个查询返回数据； 创建组合查询 — 使用UNIONUNION的使用很简单，写出每个SELECT语句，在各条语句之间放上关键字 举个例子： 第一条select语句 123SELECT vend_id,prod_id,prod_priceFROM productsWHERE prod_price &lt;= 5; 第二条select语句 123SELECT vend_id,prod_id,prod_priceFROM productsWHERE vend_id IN(1001,1002); 复合两个语句 1234567SELECT vend_id,prod_id,prod_priceFROM productsWHERE prod_price &lt;= 5;UNIONSELECT vend_id,prod_id,prod_priceFROM productsWHERE vend_id IN(1001,1002); UNION规则 UNION必须有两条或者两条以上SELECT语句组成，语句之间用关键字UNION分隔； UNION中的每个查询必须包含相同的列，表达式或聚集函数（不过各个列不需要以相同的次序列出）； 列数据类型必须兼容：类型不必完全相同，但必须是DBSM可以隐式转换的类型； 参考资料 《MySQL必知必会》人民邮电出版社 《MySQL 从入门到精通》清华大学出版社","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"},{"name":"sql","slug":"sql","permalink":"http://yoursite.com/tags/sql/"}]},{"title":"vim基本命令","slug":"其他/vim基本命令","date":"2019-04-04T13:22:53.000Z","updated":"2020-04-05T10:00:38.854Z","comments":true,"path":"2019/04/04/其他/vim基本命令/","link":"","permalink":"http://yoursite.com/2019/04/04/%E5%85%B6%E4%BB%96/vim%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/","excerpt":"","text":"h或者向左箭头 光标向左移动一个字符 j或者向下箭头 光标向下移动一个字符 k或者向上箭头 光标向上移动一个字符 l或者向右箭头 光标向右移动一个字符 Page Down 屏幕向下移动一页 Page Up 屏幕向上移动一页 n n表示数字，按下数字再按空格键，光标会向右移动这一行的n个字符 功能键[Home] 移动到这一行的最前面字符处 功能键[End] 移动到这一行的最后面字符处 G 移动到这个文件的最后一行 nG 移动到这个文件的第n行 n 光标向下移动n行 /word 向光标之下寻找一个名称为word的字符 :n1,n2s/word1/word2/g 在第n1与n2行之间寻找word1这个字符串，并将该字符串替换为word2 :1,$s/word1/word3/g 在第1与最后一行之间寻找word1这个字符串，并将该字符串替换为word2 :1,$s/word1/word4/gc 在第1与最后一行之间寻找word1这个字符串，并将该字符串替换为word2，且在替换前显示提示字符给用户确认是否需要替换 x与X 在一行中x为向后删除一个字符(相当于[del]),X为向前删除一个字符(相当于退格键) dd 删除(剪切)光标所在的那一整行 ndd 删除(剪切)光标所在的向下n行 yy 复制光标所在的那一行 nyy 复制光标所在的向下n行 p与P p为将已复制的数据在光标下一行粘贴，P则为粘贴在光标的上一行。 u 恢复前一个操作 [ctrl]+r 重做上一个操作 . 重复前一个操作 i、a、o 进入插入模式 r或者R 进入替换模式 [Esc] 退出编辑模式 :w 将编辑的数据写入硬盘中 :q 退出vim :wq 保存后退出","categories":[{"name":"其他","slug":"其他","permalink":"http://yoursite.com/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"Linux进程管理","slug":"Linux/Linux进程管理","date":"2019-03-27T09:09:42.000Z","updated":"2020-03-28T07:09:59.010Z","comments":true,"path":"2019/03/27/Linux/Linux进程管理/","link":"","permalink":"http://yoursite.com/2019/03/27/Linux/Linux%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/","excerpt":"","text":"什么是进程如何产生一个进程？程序一般是放置在物理磁盘中，然后通过用户的执行来触发，触发后会加载内存中成为一个个体，这就是进程，为了让系统可以管理这个进程，进程会给予执行者权限/属性等参数，以及进程所需的脚本或数据，最后在给予一个PID。操作系统通过这个PID来判断该进程是否具有执行权限。过程如下图； 举个常见的例子，我们在操作Linux的时候通过登录系统分给我们一个shell(bash)终端，这个shell终端具有一个PID，这个PID就是由UID/GID而来。当这个进程执行其他作业时，那么由这个进程衍生出来的其他进程在一般状态下，会沿用这个进程的相关权限。 关于程序和进程的总结： 程序：通常为二进制程序，放置在存储媒介中，以物理文件的形式存在 进程：程序被触发后，执行者的权限与属性、程序的代码与所需的数据等都会被加载到内存中，操作系统给予这个内存中的单元一个标识符（PID）所以所进程就是一个正在运行时的程序 程序调用的流程（fork and exec）：Linux的程序调用通常称为fork-and-exec的流程。进程都会借由父进程以复制（fork）的方式产生一个一模一样的子进程，然后被复制出来的子进程再以exec方式执行实际要执行的进程，最终就成为一个子进程。 具体流程就像下面的图片 常驻在内存当中的进程通常都是负责一些系统所提供的功能以服务用户的各项任务，因此这些常驻进程称之为服务 任务管理什么是任务管理任务管理是用在bash环境下的，当登录系统获取 bash shell之后，在单一终端下同时执行多个任务的管理操作，执行任务管理的操作中，每个任务都是目前bash的子进程，彼此之间都是有相关性。 前台与后台 说到终端，这里说一下前台与后台； 可以出现提示字符让你操作的环境称为前台，其他任务就可以放入后台去暂停或运行，放入后台的任务是不可以使用【ctrl+c】来终止的 要执行bash的任务管理必须要注意的限制： 这些任务所触发的进程必须是来自你shell的子进程（只管理自己的bash）； 前台：可以控制与执行命令的这个环境称为前台任务； 后台：可以自动执行任务，无法使用【ctrl+c】终止，可使用bg、fg（这两个命名后面会讲解）调用该任务； 后台中【执行】的进程不能等待或输入； 任务控制的管理 直接将命令扔到后台去执行的&amp; 如果想要同时执行多个任务，利用&amp;可以将某些任务直接丢到后台环境，这样就可以继续操作前台的工作任务 例如需要后台执行一个java程序可以这样做： 12$ java -jar xxxx.jar &amp;[1] 7851 当命令后面加上&amp;代表着该命令丢到后台执行，此时bash会给予这个命令一个任务号码【job number】，就如上面代码的那个【1】。后面的7851则是该命令触发的【PID】。当这个任务执行完毕后bash会返回如下信息，表示[1]这个任务已经执行完毕； 1[1]+ Done java -jar xxxx.jar 将目前的任务丢到后台中暂停：【ctrl-z】 将一个正在执行的任务，扔到后台去暂停，使用【ctrl+c】组合键可以实现，使用【ctrl+c】丢到后台当中的任务都是停止状态 查看目前的后台任务状态：jobs 命令格式：jobs [-lrs] 选项与参数： -l：列出【job number】、【PID】与命令串； -r：仅列出正在后台运行的任务； -s：仅列出正在后台停止的任务； 看一个案例：将vim和vi丢到后台 1234567$ vim &amp;[1] 11439$ vi &amp;[2] 11440$ jobs -l[1]- 11439 Stopped (tty output) vim[2]+ 11440 Stopped (tty output) vi 在上面输出的案例里，有+，-号，+号代表最近被放到后台的任务号码，-号代表最近第二个被放到后台中的任务号码，而第三个以后的任务，就不会有+-号出现 将后台任务拿到前台处理：fg 命令格式：fg %jobnumber 以上面案例基础上将vim和vi放到前台： 1234567$ jobs -l[1]- 11439 Stopped (tty output) vim[2]+ 11440 Stopped (tty output) vi## 将vim放到前台处理$ fg %1vim... 让任务在后台下的状态变成运行中：bg %jobnumber 将还在后台停止的vi在后台运行 12$ bg %1[1]+ vi &amp; 就像上面的输出结果那样，命令串后面有一个【&amp;】符号，代表该任务别被启动到后台了 管理后台当中的任务：kill 如果想要将该任务直接删除或者重新启动，就可以用kill命令，使用这个命名时需要给这个命令一个信号（signal） 命令格式：kill -signal %jobnumber 选项与参数： signal：代表后面的接的任务有什么样的指示，下面列举几个常用的信号 -1：重新读取一次参数的配置文件； -2：表示有键盘输入【ctrl-c】同样的操作； -9：立刻强制删除一个任务； -15：以正常的进程方式终止一项任务； -9这信号通常是在【强制删除一个不正常的任务】是使用的，-15则是以正常步骤结束一项任务，这个信号也是默认值； 脱机运行 通常登录系统，系统会给当前的登录账号一个终端进程，在这个终端下运行的进程，如果终端退出则这些进程也会同时退出，所以Linux才有脱机管理。 如果需要退出系统后让进程继续运行，则需要使用nohup命令 命令格式：nohup [命令与参数] 在终端前台任务 ​ nohup [命令与参数] &amp; 在终端后台任务 nohup命令并不支持bash内置命令,所以命令只能是外部命令。 进程管理查看进程 将某个时间点的进程运行情况截取下来：ps ps aux：查看系统所有的进程 参考资料","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"SQL基础（一）","slug":"数据库/mysql/SQL基础","date":"2019-03-27T05:04:38.000Z","updated":"2020-04-05T10:12:02.303Z","comments":true,"path":"2019/03/27/数据库/mysql/SQL基础/","link":"","permalink":"http://yoursite.com/2019/03/27/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/SQL%E5%9F%BA%E7%A1%80/","excerpt":"","text":"这篇文章主要以MySQL数据库进行讲解 在阅读本文之前假设已经安装MySQL数据库。请先构建好数据源，如果没有安装MYSQL数据库可以通过下面的在线网站构建数据源并练习SQL语句 SQL在线练习网站：http://sqlfiddle.com/ 源数据下载：https://forta.com/wp-content/uploads/books/0672327120/mysql_scripts.zip SQL语言分类SQL语言主要分为三类： DML（Data Manipulation Language）：数据操作语言，常用的增删改查就属于DML，操作的对象是数据表中的对象。 DDL（Data Definition Language）：数据定义语言。建表，建立数据库就属于DDL DCL（Data Control Language）：数据控制语言，提交回滚，数据库安全管理等属于DCL 本文将逐一介绍这三个SQL语言分类的简单讲解。 检索数据SELECT语句123456789101112131415161718#建products表并插入数据CREATE TABLE products( prod_id char(10) NOT NULL, vend_id int NOT NULL , prod_name char(255) NOT NULL , prod_price decimal(8,2) NOT NULL , prod_desc text NULL , PRIMARY KEY(prod_id)) ENGINE=InnoDB;INSERT INTO products(prod_id, vend_id, prod_name, prod_price, prod_desc)VALUES('ANV01', 1001, '.5 ton anvil', 5.99, '.5 ton anvil, black, complete with handy hook');INSERT INTO products(prod_id, vend_id, prod_name, prod_price, prod_desc)VALUES('ANV02', 1001, '1 ton anvil', 9.99, '1 ton anvil, black, complete with handy hook and carrying case');INSERT INTO products(prod_id, vend_id, prod_name, prod_price, prod_desc)VALUES('OL1', 1002, 'Oil can', 8.99, 'Oil can, red');INSERT INTO products(prod_id, vend_id, prod_name, prod_price, prod_desc)VALUES('FU1', 1002, 'Fuses', 3.42, '1 dozen, extra long'); 检索单个列语法：SELECT 列名 FROM 表名 检索prod_name列 12345678SELECT prod_name FROM products;#结果为| prod_name ||--------------|| .5 ton anvil || 1 ton anvil || Fuses || Oil can | 上面的语句利用SELECT语句从products表中检索一个列为prod_name。所需列名在SELECT关键字后面给出，FROM关键字指定要从哪个表检索数据 检索多个列语法：SELECT 列名1,列名2... FROM 表名 要从一个表中检索多个列，使用SELECT语句，后面键入多个列名，列名之间必须以逗号隔开 当心逗号：在选择多个列时，一定要在列名之间加逗号，最后一个列名之后不用加 还是以上面的数据源为例，检索prod_id、prod_name两列 12345678SELECT prod_id,prod_name FROM products;#其结果如下：| prod_id | prod_name ||---------|--------------|| ANV01 | .5 ton anvil || ANV02 | 1 ton anvil || FU1 | Fuses || OL1 | Oil can | 检索所有列语法：SELECT * FROM 表名 检索所有列时，给定一个通配符（*）,则会检索表中的所有列。 1234SELECT * FROM products;prod_id | vend_id | prod_name | prod_price | prod_desc ANV01 | 1001 | .5 ton anvil | 5.99 | .5 ton anvil, black ANV02 | 1001 | 1 ton anvil | 9.99 | 1 ton anvil, black 检索不同的行（DISTINCT）语法：SELECT DISTINCT 列名 FROM 表名 要检索出有不同值的列表，使用DISTINCT关键字，此关键字必须直接放在列名的前面。此关键字指示MySQL只返回不同的值，这里的DISTINCT不能部分使用，它应用于所有列而不仅是前置它的列。 12345SELECT DISTINCT vend_id FROM products;| vend_id ||---------|| 1001 || 1002 | 限制结果（LIMIT）限制返回的行数。可以有两个参数，第一个参数为起始行，从 0 开始；第二个参数为返回的总行数。 语法： 123SELECT 列名1,列名2,... FROM 表名LIMIT starts,count; count：检索取多少行 starts：从第几行开始，注意这里的开始行从0开始 返回前五行： 1SELECT * FROM products LIMIT 5; 1SELECT * FROM products LIMIT 0,5 带一个值的LIMIT总是从第一行开始，给出的数为返回的行数。带两个值的LIMIT可以指定从行号为第一个值的位置开始。 过滤数据使用WHERE子句在SELECT语句中，数据根据WHERE子句中指定的搜索条件进行过滤。WHERE子句在表名后给出。在同时使用ORDER BY和WHERE子句时，应该让ORDER BY位于WHERE之后 WHERE子句操作符语法： 123SELECT 列名1,列名2,... FROM 表名WHERE 条件 MYSQL支持以下所有条件操作符： 操作符 说明 = 等于 &lt;&gt; 不等于 != 不等于 &lt; 小于 &lt;= 小于等于 &gt; 大于 &gt;= 大于等于 BETWEEN 在指定的两个值之间 IS NULL 为NULL值 过滤单个值过滤prod_name=’fuses’的数据 123SELECT prod_name,prod_priceFROM productsWHERE prod_name='fuses'; 过滤价格小于10元的数据 123SELECT prod_name,prod_priceFROM productsWHERE prod_price&lt;10; 过滤价格小于等于10元的数据 123SELECT prod_name,prod_priceFROM productsWHERE prod_price&lt;=10; 过滤不匹配过滤vend_id不是1002的数据 123SELECT prod_name,prod_priceFROM productsWHERE vend_id != 1002; 如果条件值为字符串类型，则需要引用引号，如果条件值为数值类型，则不需要引用引号 过滤范围值(BETWEEN)如果需要检查某个范围的值，可以使用BETWEEN操作符。其语法与其他WHERE子句的操作符不同。BETWEEN需要两个值，过滤范围的开始值和结束值。在范围使用BETWEEN时，必须指定两个值——所需范围的低端值和高端值。这两个值必须用AND关键字分隔。BETWEEN匹配范围中的所有值，包括指定的开始值和结束值。 过滤价格在5元和10元之间的所有产品 123SELECT prod_name,prod_priceFROM productsWHERE prod_price BETWEEN 5 AND 10; 空值过滤(IS NULL)WHERE子句 IS NULL用来检查具有NULL值的列。 123SELECT prod_nameFROM productsWHERE prod_price IS NULL; 组合WHERE子句AND操作符为了通过不止一个列在过滤，可使用AND操作符给WHERE子句附加条件，用来指示检索满足所有给定的条件的行。 案例： 123SELECT prod_id,prod_price,prod_nameFROM productsWHERE vend_id = 1003 AND prod_price &lt;= 10; OR操作符：用于过滤检索匹配任意一条件的行 123SELECT prod_id,prod_price,prod_nameFROM productsWHERE vend_id = 1003 OR prod_price &lt;= 10; IN操作符IN操作符用于指定条件范围，范围中每个条件都可以进行匹配。IN在WHERE中用来指定匹配值的关键字，功能与OR相当 1234SELECT prod_name,prod_priceFROM productsWHERE vend_id IN(1002,1003)ORDER BY prod_name; IN操作符的优点如下： 当需要匹配的值比较多时，IN操作符的语法更清楚且更直观； IN操作符一般比OR操作符执行更快； 在使用IN时，计算的次序更容易管理； IN的一最大优点就是可以包含其他SELECT语句，使得能够更动态地建立WHERE子句； NOT操作符：NOT用在WHERE子句中，用来否定后跟的条件表达式，MYSQL中的NOT，支持NOT对IN，BETWEEN和EXISTS子句取反。 参考资料 《MySQL必知必会》人民邮电出版社 《MySQL 从入门到精通》清华大学出版社","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"},{"name":"sql","slug":"sql","permalink":"http://yoursite.com/tags/sql/"}]},{"title":"Linux账号管理与权限设置","slug":"Linux/Linux账号管理与权限设置","date":"2019-03-21T09:47:17.000Z","updated":"2020-03-21T09:52:13.908Z","comments":true,"path":"2019/03/21/Linux/Linux账号管理与权限设置/","link":"","permalink":"http://yoursite.com/2019/03/21/Linux/Linux%E8%B4%A6%E5%8F%B7%E7%AE%A1%E7%90%86%E4%B8%8E%E6%9D%83%E9%99%90%E8%AE%BE%E7%BD%AE/","excerpt":"","text":"参考资料","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"文件与文件系统压缩","slug":"Linux/文件与文件系统压缩","date":"2019-03-20T06:42:11.000Z","updated":"2020-03-21T09:50:50.125Z","comments":true,"path":"2019/03/20/Linux/文件与文件系统压缩/","link":"","permalink":"http://yoursite.com/2019/03/20/Linux/%E6%96%87%E4%BB%B6%E4%B8%8E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%8E%8B%E7%BC%A9/","excerpt":"","text":"Linux系统常见的压缩命令123456789*.z compress程序压缩的文件；*.zip zip程序压缩的文件；*.gz gzip程序压缩的文件；*.bz2 bzip2程序压缩的文件；*.xz xz程序压缩的文件；*.tar tar程序打包的文件，并没有压缩过；*.tar.gz tar程序打包的文件，并经过gzip的压缩*.tar.bz2 tar程序打包的文件，并经过bzip2的压缩*.tar.xz tar程序打包的文件，并经过xz的压缩 gzip，zcat gzip可以说是应用最广泛的压缩命令。下面介绍这些命令; gzip [-cdtv#] 文件名 选项和参数： -c：将压缩的数据输出到屏幕上，可通过数据流重定向来处理； -d：解压缩的参数 -t：可以用来检验一个压缩文件的一致性，看看文件是否有误 -#：#表示压缩级别，-1最快，但压缩比最差，-9最慢，压缩比最好，默认为-6 xz，xzcat 命令格式 xz [-dtlkc#] 文件名 xcat 文件名.xz 选项与参数: -d：解压缩； -t：测试压缩文件的完整性； -l：列出压缩文件的相关信息； -k：保留原本文件不删除 -c：将数据在屏幕上输出 -#：压缩级别 打包名命名：tar命名格式：tat [-z][-j][-J][cv][-f 待建里的文件名] filename ...：打包与压缩tar [-z][-j][-J][tv][-f 既有的tar文件名]：查看文件名tar [-z][-j][-J][xv][-f 既有的tar文件名] [-C 目录]：解压缩选项与参数：-c：建立打包文件，可搭配-v来查看过程中被打包的文件名；-t：查看打包文件的内容含有哪些文件名，重点看文件名；-x：解包或解压缩，可以搭配-C在特定目录解压；-z：通过gzip的支持进行压缩/解压缩：此时文件名最好为*.tar.gz；-C 目录：若要在特定目录解压缩，可以使用这个选项；-f finame：-f后面要立刻接要被处理的文件名--exclude=FILE：在压缩过程中，不要将FILE打包注意：-c、-t、-x不可同时出现常使用的命令组合：tar -zcvf filename.tar.gz、tar -jcvf filename.tar.bz2：压缩tar -ztvf filename.tar.gz、tar -jtvf filename.tar.bz2：查询tar -zxvf filename.tar.gz -C 目录、tar -jxvf filename.tar.bz2 -C 目录：解压缩 常见的压缩与备份工具dd命令格式：dd if=input_file of=output_file bs=block_size count=number 选项与参数： if：输如设备 of：输出设备 bs：设置的一个block的大小，若未指定则默认是512Bytes（一个扇区大小） count：多少个bs 参考资料","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"Linux的文件与目录管理","slug":"Linux/Linux的文件与目录管理","date":"2019-03-18T13:40:17.000Z","updated":"2020-03-21T06:31:51.518Z","comments":true,"path":"2019/03/18/Linux/Linux的文件与目录管理/","link":"","permalink":"http://yoursite.com/2019/03/18/Linux/Linux%E7%9A%84%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/","excerpt":"","text":"目录相关操作对于目录相关的命名首先要介绍的一个命令是目录切换命令：cd 还有一些比较特殊的目录： .：代表此层目录； ..：代表上一层目录； -：代表前一个工作目录； ~：代表目前使用者身份所在的家目录 ~account：代表account这个使用者的家目录 处理目录的命令： cd（change directory）：切换目录 命令格式：cd [相对路径或绝对路径] 利用相对路径的写法必须确认的目前的路径才能正确地去到想要的目录 下面看几个例子 123456789101112131415##切换到tmp目录$ cd /tmp$ pwd/tmp##回到家目录$ cd ~$ pwd/root##回到上一次的工作目录$ cd -/tmp##当前的工作目录在/tmp，回到上一级目录$ cd ..$ pwd/ pwd（显示目前所在的目录） 命令格式：pwd [-p] ​ 选项与参数：-p：显示出真正的目录，而非使用链接路径 mkdir：建立新目录 命令格式 mkdir [-mp] 目录名称 选项与参数： -m：设置文件的权限。直接设置，不需使用默认权限（umask） -p：递归创建子目录 下面举几个例子： 12345#在当前的工作目录下创建test0目录$ mkdir test0drwxr-xr-x 2 root root 4096 Mar 19 16:58 test0##在当前的工作目录下递归创建test1/test2/test3这样的多层目录$ mkdir -p test1/test2/test3 一般创建目录大都是使用默认权限（umask），mkdir可以在创建目录时可以指定权限，例如： 12$ mkdir -m 711 test2drwx--x--x 2 root root 4096 Mar 19 17:07 test2 rmdir：删除“空”目录命令格式：rmdir [-p] 目录名称被删除的目录里不能存在其他的文件和目录，如果想要一次性删除一个目录以及该目录其下的子目录可以使用rm -rf 目录名称,但这样不是太安全，还是使用rmdir比较安全。 文件与目录管理文件与目录查看：ls命名格式：ls [-adlh] 文件名或目录名称 选项参数： -a：全部的文件，包括隐藏文件（开头为.的文件）一起列出 -d：仅列出目录本身，而不是列出目录内的文件数据 -h：将文件大小以及人类易读的方式（GB，KB，MB）列出 -l：详细信息显示，包括文件的属性与权限等数据 12345678910##列出root目录下的所有文件$ ls -al ~dr-xr-x---. 9 root root 4096 Mar 19 17:07 .dr-xr-xr-x. 18 root root 4096 Mar 14 16:57 ..-rw------- 1 root root 5185 Mar 18 23:42 .bash_history······drwxr-xr-x 2 root root 4096 Mar 19 16:58 test0drwxr-xr-x 3 root root 4096 Mar 19 17:00 test1drwx--x--x 2 root root 4096 Mar 19 17:07 test2-rw-rw-rw- 1 root root 0 Mar 18 01:49 test.txt 12345678910##列出root目录下的所有文件,以人类易读的方式$ ls -alh ~dr-xr-x---. 9 root root 4.0K Mar 19 17:07 .dr-xr-xr-x. 18 root root 4.0K Mar 14 16:57 ..-rw------- 1 root root 5.1K Mar 18 23:42 .bash_history······drwxr-xr-x 2 root root 4.0K Mar 19 16:58 test0drwxr-xr-x 3 root root 4.0K Mar 19 17:00 test1drwx--x--x 2 root root 4.0K Mar 19 17:07 test2-rw-rw-rw- 1 root root 0 Mar 18 01:49 test.txt 复制、删除、移动：cp、rm、mv cp:复制文件或目录 命令格式：cp [-ipr] 源文件（source） 目标文件（dest） 选项与参数： -a：参考下面的-dr选项 -d：若源文件为链接文件属性，则复制链接文件属性而非文件本身 -i：若目标文件已经存在，在覆盖时会先询问操作的进行 -p：连同文件的属性一起复制，不使用默认属性 -r：递归复制，用于目录的复制操作 在默认的条件中，cp的源文件与目标文件的权限是不同的，目标文件的拥有者通常会是命令操作本身。 rm（删除文件或目录） 命令格式：rm [-fir] 文件或目录 选项与参数： -f：强制的意思 -I：交互模式，在删除之前会询问使用是否操作 -r：递归删除 通常这个命令在使用时要十分小心，在删除前要认真确定删除的文件或目录是否正确，避免误删除的情况 1234#删除test1文件夹#连同目录下的所有子目录一并强制删除$ rm -rf test1 #删除文件也是如此 mv（移动文件与目录或重命名） 命令格式：mv [-fiu] source dest 选项与参数： -f：强制执行 -i：若目标文件已经存在，会询问是否覆盖 -u：若目标文件已存在，且source比较新，才会更新 这里举几个例子： 将test.txt文件移动到test0文件夹中 123$ mv test.txt test0$ ls test0test.txt 将test0文件夹重命名为test3 123$ mv test0 test4$ ls .test3 修改文件时间或创建新文件：touch 命令格式：touch [-acdmt] 文件名 选项与参数： ​ -a：仅自定义access time； ​ -c：仅修改文件时间，若该文件不存在则不创建新文件； ​ -d：后面可以接想要自定义的日期而不用目前的日期； ​ -m：修改mtime ​ -t：后面可以接想要自定义的时间而不是使用目前的日期，格式为[YYYYMMDDhhmm] touch命令最常用的情况是： 创建一个空文件 将某个文件日期自定义为目前 举几个例子： 123456#创建一个空文件$ touch test1-rw-r--r-- 1 root root 0 Mar 21 12:03 test1#修改日期为：2020/02/21 00:00$ touch -t 202002210000 test1-rw-r--r-- 1 root root 0 Feb 21 00:00 test1 文件与目录的默认权限与隐藏权限文件默认权限：umaskumask是指定目前用户在创建文件或者目录时的权限默认值。 12345#使用umask查看默认权限$ umask0022 //与一般权限有关的是后面三个数字$ umask -Su=rwx,g=rx,o=rx 默认情况下： 若用户创建文件则默认没有（x）执行权限，也就是只有rw这两个项目,也就是最大为666，默认权限为： -rw-rw-rw- 若用户创建目录则由于x是与是否可以进入目录有关的，因此默认为所有权限均开放，即777 drwxrwxrwx umaks的数字指的是该默认值需要减掉的权限 通过上面umask=0022进行说明。因为umask=0022，user没有被拿掉任何权限，group与others的权限被拿掉了2（也就是w权限）（r、w、x每个权限的数字在《Linux文件权限与目录简介》一篇中介绍过）那么用户： 创建文件时：（-rw-rw-rw-）-（- - - - - w - - w -）==&gt; - rw-r- -r- - ,最后创建文件时的权限：666-022=644 创建目录时：（drwxrwxrwx）-（d - - - - w- - w-）==&gt; drwxr-xr-x最后创建目录时的权限：777-022=755 创建一个文件和一个目录： 1234567891011$ umask0022$ touch test0666-022=644-rw-r--r-- 1 root root 0 Mar 21 12:49 test0 6 4 4#创建目录$ mkdir test.d777-022=755drwxr-xr-x 2 root roo 4096 Mar 21 12:53 test.d 7 5 5 文件隐藏属性 配置文件隐藏属性：chattr [+-=][ASacdistu] 文件或目录名称 常用选项与参数：+：增加某个特殊参数，其他原本存在参数不动；-：减少某个特殊参数，其他原本存在参数不动；=：直接设置参数，且仅有后面接的参数；a：当设置这个a之后，这个文件将只能增加数据，而不能删除也不能修改数据，只有root才能设置这个属性；i：当设置i之后，可以让一个文件不能被删除、改名、设置链接也无法写入或新增数据； 12345$ touch test23$ chattr +i test23$ rm -rf test23#不能删除rm: cannot remove test23：Operation not permitted 显示文件隐藏属性：lsattr [-adR] 文件或目录 选项与参数： -a：将隐藏文件的属性显示出来 -d：如果接的目录，仅列出目录本身的属性而非目录内的文件名 -R：连同子目录的数据也一并列出来 接着上面的例子： 12$ lsattr -aR test23----i--------e-- test23 命令与文件的查找脚本文件查找 查找执行文件：which [-a] command 选项或参数： -a：将所有由PATH目录中可以找到的命令均列出，而不止第一个被找到的命令名称 这个命令是根据【PATH】这个环境变量所规范的路径，去查找执行文件的文件名。 文件查找 由一些特定的目录中查找文件：whereis [-bmsu] 文件或目录 选项与参数： -l：可以列出whereis会去查询的几个主要目录； -b：只找binary（二进制）格式文件； -m：只找在说明文件manual路径下的文件； -s：只找source源文件； -u：查找不在上述三个项目当中的其他特殊文件； locate [-ir] keyword 选项与参数： -i：忽略大小写的差异； -c：不输出文件名，计算找到的文件数量； -l：仅输出几行的意思； -S：输出locate所使用的数据库文件的相关信息，包括该数据库记录文件/目录数量等； -r：后面可接正则表达式的显示方式； find [PATH] [option] [action]没事别用这个命令神慢~ 参考资料 《鸟哥的Linux私房菜—基础学习篇（第四版）》 鸟哥著 人民邮电出版社","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"Linux文件权限与目录简介","slug":"Linux/Linux文件权限与目录简介","date":"2019-03-16T09:52:07.000Z","updated":"2020-03-21T03:49:47.441Z","comments":true,"path":"2019/03/16/Linux/Linux文件权限与目录简介/","link":"","permalink":"http://yoursite.com/2019/03/16/Linux/Linux%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E4%B8%8E%E7%9B%AE%E5%BD%95%E7%AE%80%E4%BB%8B/","excerpt":"","text":"Linux文件权限与文件属性Linux文件属性先来看下面的Linux文件属性信息: 12-rw-r--r--. 1 root root 29 Nov 18 00:00 test.txtdrwxr-xr-x. 4 root root 39 Oct 8 14:39 opt 第一栏代表这个文件的类型与权限 第一个字符代表这个文件是目录、文件或是链接文件等 当为[d]则为目录，例如像上面的文件名【opt】就是一个目录 当为[-]则是文件，例如像上面的文件名【test.txt】就是一个文件 当为[l]则是链接文件 当为[b]则是设备文件里面的可供存储的周边设备 当为[c]则是设备文件里面的串行端口设备 上面图片中后面的三个组表示文件拥有者、文件所属用户组、其他人的文件权限 1234r 可读w 可写x 可执行- 无权限 第一组为文件拥有者可具备的权限。 第二组为加入此用户组的账号的权限 第三组为非本人且没有加入本用户组的其他账号的权限 第二栏表示多少文件名链接到此节点 第三栏表示这个文件或目录的拥有者账号 第四栏表示这个文件的所属用户组 第五栏为这个文件的容量大小，默认单位为Bytes，如果想看更人性化的可以输入ls -alh 第六栏为这个文件创建日期或是最近修该日期 第七栏为文件名，如果文件名之前多一个.,则代表这个文件为隐藏文件。 如何修改文件属性与权限 几个修改用户组、拥有者、各种身份的权限命令 chgrp：修改文件所属用户组 chown：修改文件拥有者 chmod：修改文件的权限，SUID、SGID、SBIT等的特性 修改所属用户组：chgrp修改一个文件的用户组直接使用chgrp命令修改即可，这个命令就是change group的缩写 命令格式： 12chgrp [-R] [系统用户] dirname/filename ... -R：进行递归修改， 现在系统中有yang这个用户，将test.txt文件的用户组修改为yang 12345$ -rw-r--r--. 1 root root 29 Nov 18 00:00 test.txt$ chgrp yang test.txt$ ls -al#已经将test.txt文件的所属用户组修改为yang$ -rw-r--r--. 1 root yang 29 Nov 18 00:00 test.txt 修改文件拥有者：chown要修改文件为指定的用户，系统里必须有这个指定用户账号 命名格式： 123chown [-R] 账号名称 文件或目录chown [-R] 账号名称:用户组名称 文件或目录-R：进行递归修改，如果要连目录下的所有子目录或文件同时更改文件拥有者的话，加上-R选项即可 还是上面的那个test.txt文件，将其的文件拥有者修改为yang 1234567$ -rw-r--r--. 1 root yang 29 Nov 18 00:00 test.txt$ chown yang test.txt$ ls -al$ -rw-r--r--. 1 yang yang 29 Nov 18 00:00 test.txt#将test.txt的拥有者和用户组修改回root$ chown root:root test.txt$ -rw-r--r--. 1 root root 29 Nov 18 00:00 test.txt chown也可以使用【chown user.group file】,在拥有者与用户组间加上【.】也可以修改。 目录与文件权限的意义 权限对文件的重要性权限对于文件来说，意义是这样的： r（read）：可读取此文件的实际内容 w（write）：可以编辑、新增或是修改该文件的内容（但不可以删除该文件哦） x（eXecute）：该文件具有可以被系统执行的权限 在Linux下面，文件是否有执行能力，是根据是否具有【x】这个权限来决定的，和文件名没有绝对的关系 权限对目录的重要性目录的主要内容在记录文件名列表，文件名与目录有强烈的关联。对于目录，r、w、x的意义如下： r：表示具有读取目录结构列表的权限，所有当具有读取一个目录的权限（r）时，表示可以查询该目录下的文件名的数据。 w：这个是对于目录的可写入权限，表示用户具有改动改目录结构列表的权限。也就是下面这些权限： 建立新的文件与目录 删除已经存在的文件与目录 将已存在的文件或目录进行更名 移动该目录内的文件、目录位置 x： 目录的x表示的是当前用户能否进入该目录成工作目录。就是说可以通过cd命令切换到改目录下。如果当前用户在某目录下不具有x的权限，那么就无法切换到改目录下，也就无法在改目录下进行任何操作，即使有该目录的r和w权限也不好使。 注意：要开放目录给任何人浏览时，应该至少也要给予r及x权限 修改文件权限：chmod命名格式语法： 123chmod [-R] xyz 文件或目录 xyz：数字类型的权限属性,为rwx属性值相加的值 -R：进行递归 文件权限修改有两种方式：使用数字或者符号来进行权限修改。 数字类型修改文件权限 Linux文件的基本权限有九个，分别是拥有者(owner)，所属群组（group）、其他人（others）三种身份各有自己的读（r）、写（w）、执行（x）权限。 拿上面介绍的文件权限那样，文件权限字符为：【-rwx rwx rwx】九个权限三个一组。 可以使用数字来代表各个组的权限： r：4 w：2 x：1 三种身份（拥有者(owner)、所属群组(group)、其他人（others））各自的三个权限（r，w，x）数字是需要累加的。例如前面提到的test.txt文件如下： 1-rw-r--r--. 1 root root 29 Nov 18 00:00 test.txt 权限为：【-rw-r–r–】的数字则是：644 123owner = rw = 4+2 = 6group = r = 4others = r = 4 接下来用chmod命令将该文件的是三种身份的权限数字设置为770owner = rwx = 4+2+1 = 7group = rwx = 4+2+1 = 7;others = - - - = 0 123$ chmod 770 test.txt$ ls -al test.txt-rwxrwx--- 1 root root 29 Nov 18 00:00 test.txt 如果要将文件变成可执行的文件，并且不要让其他人修改文件的话，那就需要-rwxr-xr-x这样的权限，此时就要执行 chmod 755 fileName命令。 符号类型修改文件权限 符号类型修改文件权限可以借由(user)u，(group)g，(others)o,来代表三种身份的权限，此外a则代表all全部的身份，读写权限可以写成r、w、x chmod [u、g、o、a] [+（加入）、-（移除）、=（设置）] [r、w、x] 文件或目录 例如要把上面的test.txt设置成【-rwxr-xr-x】时： 12345$ ls -al test.txt-rwxrwx--- 1 root root 0 Mar 18 00:00 test.txt$ chmod u=rwx,go=rx test.txt$ ls -al-rwxr-xr-x 1 root root 0 Mar 18 00:00 test.txt 如果想为每身份加入w权限 123$ chmod a+w test.txt$ ls -al test.txt-rwxrwxrwx 1 root root 0 Mar 18 00:00 test.txt 如果想为每身份移除x权限 123$ chmod a-x test.txt$ ls -al test.txt-rw-rw-rw- 1 root root 0 Mar 18 01:49 test.txtLinux目录树执行文件路径的变量：$PATHPATH这个变量的内容是由一堆目录所组成，每个目录中间用冒号（:）来隔开，每个目录有顺序之分。就像下面的格式 1/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin:/usr/local/python37/bin 目录树的主要特征： 目录树的起始点为根目录（/，root）； 每个目录不止能使用本地区分的文件系统，也可以使用网络的文件系统； 用NetWork File System(NFS)服务器挂载某特点的目录 每个文件在此目录树中的文件都是独一无二的； 下面是目录树构架示意图（关于目录树更详细的说明，参考《鸟哥的Linux私房菜—基础学习篇（第四版）》第五章5.3节的FHS标准说明） 绝对路径与相对路径根据文件名写法的不同，也可将所谓定义为绝对路径与相对路径。这两种文件名路径写法依据如下： 绝对路径：由根目录（/）开始写起的文件名或目录名称； 相对路径：相对于目前所处在的目录的文件名写法，例如：../dir1、../dir1/opt等 ..代表上一层目录，也可以使用../来代表 .代表当前目录，也可以使用./来代表 参考资料 《鸟哥的Linux私房菜—基础学习篇（第四版）》 鸟哥著 人民邮电出版社","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"初识Linux","slug":"Linux/Linux基础","date":"2019-03-15T14:20:39.000Z","updated":"2020-03-18T13:45:01.808Z","comments":true,"path":"2019/03/15/Linux/Linux基础/","link":"","permalink":"http://yoursite.com/2019/03/15/Linux/Linux%E5%9F%BA%E7%A1%80/","excerpt":"","text":"什么是Linux?Linux就是一个操作系统(手动狗头) Linux几个常用的命令 cd dir：跳转到指定文件夹 123456跳转到root目录$ cd ~跳转到之前目录$ cd -跳转到上级目录$ cd .. cd 后面还可以文件夹绝对路径或相对路径跳转到指定目录 例如跳转到 /下的tmp目录 1$ cd /tmp pwd：查看当前所处的路径，输入pwd系统会返回当前所处的目录的绝对路径 ls -al：列出文件夹下的所有文件，包括隐藏文件 1$ ls -al 操作Linux系统几个重要的热键 [Tab]按键[Tab]按键就是在切换大小写按键[Casp Lock]上面的那个按键，它具有命令补全与文件补齐的功能。关键是可以避免打错命令或文件名。 这里总结一下 [Tab]接在一串命令的第一个字段后面，则为【命令补全】 [Tab]接在一串命令的第二个字段后面，则为【文件补全】 [Ctrl+c]按键有时候某些命令或程序在系统上一直“跑个不停”，想让命令或程序“停掉”时，可以用这个按键。输入:[Ctrl+c]按键，可以中断目前程序或命令。 [Ctrl+d]如果想要直接离开命令行模式，可以直接按下[Ctrl+d]就能直接离开（相当于输入exit） [Shift]+{Page Up}、[Shift]+{Page Down}按键使用[Shift]+{Page Up}向前翻页。使用[Shift]+{Page Down}先后翻页 正确的关机方法 正确的关机命令使用 几个与关机或重启相关命令 将数据同步写入硬盘的命令：sync 常用的关机命令：shutdown 重启、关机：reboot、halt、poweroff 数据同步写入磁盘：sync 使用sync命令进行数据的写入操作。在命令行下输入sync，那么在内存中尚未被更新的数据，就会被写入硬盘中。So 在关机或重启系统之前最好多执行几次 常用的关机命令：shutdown 这个是关闭Linux的命令，如果是root管理员可以使用。 1234567891011121314shutdown语法shutdown -[krhc] [时间] [警告信息] 选项与参数 -k：不是真的关机，只是发送警告信息出去。 -r：在将系统的服务停掉之后就重新启动（常用） -h：将系统的服务停掉后，立即关机（常用） -c：取消已经进行的shutdown命令内容 时间：指定系统关机的时间，设置时间的样式如下： shutdown -h 13:00 系统将在今天的13:00分关机 shutdown -h now 系统将立即关机 shutdown -r now 系统会立即重启 shutdown可以完成如下的工作： 可以自由选择关机模式：要是关机或重启均可； 可以设置关机时间：可以设置成现在立即关机，也可以设置某一个特定的时间关机； 可以自定义关机信息：在关机之前，可以将自己设置的信息发送给在线用户； 可以仅发出警告信息：有时有可能要进行一些测试，而不想让其他的用户干扰，或是明白的告诉用户某段时间要注意一下。 重启，关机：reboot、halt，poweroff 这三个命令可以进行重启与关机的操作。一般在关机或重启时，都会执行如下命令： 1sync;sync;sync;reboot 使用管理管理工具systemctl关机 在CentOS 7中可以使用systemctl来进行关机，实际上面介绍的关机与重启命令都是调用systemctl这个命令。 这个命令与关机的语法： 1234567systemctl [命令]命令项目有：haltpoweroffrebootsuspend //进入休眠模式# systemctl reboot #系统重启 参考资料 《鸟哥的Linux私房菜—基础学习篇（第四版）》 鸟哥著 人民邮电出版社","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"Java并发基础volatile关键字","slug":"java/并发编程/volitile关键字","date":"2018-07-22T11:16:24.000Z","updated":"2020-05-06T01:42:50.060Z","comments":true,"path":"2018/07/22/java/并发编程/volitile关键字/","link":"","permalink":"http://yoursite.com/2018/07/22/java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/volitile%E5%85%B3%E9%94%AE%E5%AD%97/","excerpt":"","text":"并发编程的三个重要特性 原子性 原子性指在一次的操作或多次的操作中，要么所有操作全部执行且不会受到任何因素的干扰而中断，要么所有操作全部不执行 可见性 当一个线程对共享变量进行修改，另外的线程可以立刻看到修改后的新值。 有序性 有序性是指程序代码在被执行过程中的先后顺序。Java编译器以及运行期的优化，导致代码的执行顺序未必就是在编写代码时的顺序。 关于volatile下面有必要说一下内存与CPU相关的知识 CPU Cache模型CPU的处理速度和内存访问速度之间差距很大，通过直连内存的方式会导致CPU资源受到限制，为了降低CPU整体的吞吐量，可在CPU和内存之间增加缓存的设计，目前缓存的数量可增加到3级，最靠近CPU的缓存称为L1，依次是L2，L3和主内存。CPU缓存模型如下： Cache的出现为了解决CPU直接访问内存效率低下的问题，CPU将运算所需的数据从主内存复制一份到CPU Cache中，CPU在计算时就可以直接对CPU Cache中的数据进行读取和写入，运算结束后，再将CPU Cache中的最新数据刷新回主内存中。 CPU缓存一致性问题缓存的出现极大提高CPU的吞吐能力，但也引入了缓存不一致的问题，为了解决缓存不一致性的问题，通常主流的解决方法有两种： 通过总线加锁的方式 通过缓存一致性协议 缓存一致性协议的大致思想：当CPU在操作Cache中的数据时，如果发现该变量是一个共享变量，在其他CPU Cache中存在一个副本，当进行如下操作时： 读取操作：不做任何处理，只将Cache中的数据读取到寄存器中 写入操作：发出信号通知其他CPU将该变量的Cache line置为无效状态，其他CPU进行该变量读取时，必须在主存中再次获取。 关于volatile关键字为了确保共享变量能够准确和一致性的更新，线程应该确保通过排他锁单独获取这个变量。Java提供了volatile关键字，如果一个字段被声明为volatile，多线程内存模型确保所有线程看到这个变量的值是一致的。 JMM内存模型java内存模型决定了一个线程对共享变量的写入何时对其他线程可见，java内存模型定义了线程和内存之间的抽象关系 共享变量存储于主内存中，每个线程都可以访问。 每个线程都有私有的工作内存或称为本地内存。 工作内存只存储该线程对共享变量的副本 线程不能直接操作主内存，只有先操作工作内存后才能写入主内存。 工作内存和Java内存模型一样也是一个抽象的概念，其实并不存在，它涵盖了缓存、寄存器、编译器优化以及硬件等。 在前面所说的并发编程的三大特性，JMM如何保证这三大特性 JMM与原子性 先介绍几种简单的赋值操作 (1) x = 1 (2) y = x (3) y++ (4) z = z+1 在上面的四类赋值操作中，只有第一种赋值操作具有原子性，其余均不具备原子性。可以得出以下结论 多个原子性的操作在一起就不再是原子性操作 简单的读取与赋值是原子性，将一个变量赋值给另外一个变量的操作就不具备原子性 JMM只保证基本读取和赋值的原子性操作，其余的均不能保证，如果要使某些代码段具备原子性，需要使用关键字synchronized，或JUC中的lock。如果想要使得int等类型自增操作具备原子性封装类型atomic.* 最后volatile关键字不具备保证原子性的语义 在Java中可以通过锁和循环CAS的方式来实现原子操作 使用循环CAS实现原子性操作 JVM中的CAS操作利用处理器提供的指令CMPCHG实现，自旋CAS实现的基本思路是循环进行CAS操作直到成功为止。 CAS实现原子类操作的三大问题 ABA问题 因为CAS需要在操作值的时候，检查值有没有变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查的时候会发现它的值没有发生变化，但是实际发生了变化，ABA问题的解决思路就是使用版本号。在变量前面追加版本号，每次变量更新的时候把版本号加1，JDK中通过使用原子类AtomicStampedReference解决ABA问题 循环时间长开销大 自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。如果JVM能支持处理器提供的pause指令，那么效率在一定程度上提升 只能保证一个共享变量的原子操作 把多个共享变量合并成一个共享变量来操作。 123i = 2j = a合并 =&gt; ij = 2a 然后CAS来操作ij，JDK提供了AtomicReference类来保证引用对象之间的原子性，就可以把多个变量放入一个对象里来进行CAS操作 使用锁机制实现原子性操作 锁机制保证了只有获得锁的线程才能够操作锁定内存的区域。JVM内部实现了很多锁机制，有偏向锁、轻量锁、互斥锁。JVM实现锁的方式都用了循环CAS，即当一个线程进入同步块的时候使用CAS的方式来获取锁，当它退出同步块的时候使用循环CAS释放锁。 JMM与可见性 Java通过三种方式来保证可见性 使用关键字volatile，当一个变量被volatile关键字修饰时，对于共享资源的读操作会直接在主内存中进行（也可能会缓存到工作内存中，当其他线程对该共享资源进行修改，则会导致当前线程在工作内存中的共享资源失效，必须要在主内存中再次获取），对于共享资源的写操作当然是先要修改工作内存，但是修改结束后会立刻将其刷新进主内存中。 通过synchronized关键字能够保证可见性，synchronized关键字能够保证同一时刻只有一个线程获得锁，然后执行同步方法，并且还会确保在锁释放之前，会将对变量的修改刷新到主内存中。 通过JUC提供的显式锁Lock也能保证可见性，Lock的lock方法能够保证在同一时刻只有一个线程获得锁然后执行同步方法，并且会确保在锁释放（Lock的unlock方法）之前会将对变量的修改刷新到主内存中。 volatile关键字具有保证可见性的语义 JMM与有序性 在JMM中允许编译器和处理器对指令进行重排序，在当线程下并不会引起什么问题。在多线程下，重排序会影响到程序的正确运行。 Java提供了三种保证有序性的方式 使用volatile关键字来保证有序性。 使用synchronized关键字来保证有序性。 使用显式锁Lock来保证有序性 在JMM中具备一些自带的有序性规则，不需要任何同步手段就能够保证有序性，这规则称之为Happens-before原则。 重排序是什么 重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段。 三种类型的重排序 编译器优化重排序 编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序 指令级并行的重排序 现代处理器采用指令级并行技术来将多条指令重叠执行，如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。 内存系统的重排序 由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作来起来可能是在乱序执行 Happens-Before规则 程序次序规则：在一个线程内，代码按照编写时的次序执行，编写在后面的操作发生于编写在前面的操作之后。虚拟机还是可能会对程序代码的指令进行重排序，只要确保在一个线程内最终的结果和代码顺序执行的结果一致即可。 锁定规则：一个unlock操作要先行发生于对同一个锁的lock操作 volatile变量规则：对一个变量的写操作要早于对这个变量的读操 传递规则：如果操作A先于操作B，B操作先于C操作，则A操作一定先于C操作，说明Happens-Before 线程启动规则：Thread对象的start()方法先行发生于线程的任何动作，只有start后的线程才能真正运行，否则Thread只是一个对象。 线程中断规则：对线程执行interrupt()方法，肯定要优先于捕获到中断信号。 线程的终结规则：线程中断所有的操作都要先行发生于线程的终止检测，线程的任务执行，逻辑单元执行肯定要发生于线程死亡之前。 对象的终结规则：一个对象初始化的完成先行发生于finalize()方法之前。 volatile关键字具有保证顺序性的语义 volatile写读的内存语义 volatile写的内存语义 当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存 volatile读的内存语义 当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量 volatile写读的内存语义总结： 线程A写一个volatile变量，实质上是线程A向接下来将要读这个volatile变量的某个线程发出消息 线程B读一个volatile变量，实质上是线程B接收了之前某个线程发出的（在写这个volatile变量之前对共享变量所做修改的）消息 线程A写一个volatile变量，随后线程B读这个volatile变量，过程实质上是线程A通过主内存向线程B发送消息 volatile关键字语义被volatile修饰的实例变量或类变量具备两层语义： 保证不同线程之间对共享变量操作时的可见性，也就是说当一个线程修改volatile修饰变量，另外一个线程立即可看到新的值。 禁止对指令进行重排序操作。 volatile的原理和实现机制volatile关键字可以保证可见性以及顺序性，是如何做到的？ 观察OpenJDK源码就知道，被volatile修饰的变量存在于一个”lock;”前缀 Lock前缀指令在多核处理器下会引发两件事 将当前处理器缓存行的数据写回到系统内存 写回内存操作会使在其他CPU里缓存了该内存地址的数据无效 “lock;”前缀实际上相当于一个内存屏障，该屏障会为指令提供几个保障： 确保指令重排序时不会将后面的代码排到内存屏障之前 确保指令重排序时不会将其前面的代码排到内存屏障之后 确保在执行到内存屏障修饰的指令时前面的代码全部执行完成 强制在线程工作内存中值的修改刷新至主内存中 如果是写操作，则会导致其他线程工作内存中的缓存数据失效 volatile和synchronized的区别 使用上的区别 volatile关键字只能用于修饰实例变量和类变量，不能用于修饰方法以及方法参数和局部变量，常量等 synchronized关键字不能用于对变量的修饰，只能用于修饰方法或语句块 volatile修饰的变量可以为null，synchronized关键字同步语句块的monitor对象不能为null 对原子的保证 volatile无法保证原子性 由于synchronized是一种排他机制，因此被synchronized关键字修饰的同步代码块是无法被中途打断，因此其能够保证代码的原子性 对可见性的保证 俩者均可以保证共享资源在多线程间的可见性，但是实现机制完全不同 synchronized借助JVM指令monitorentry和monitorexit对通过排他的方式使得同步代码块串行化，在monitorexit时所有共享资源都将会被刷新到主内存中。 volatile使用机器指令“lock;”的方式迫使其他线程工作内存中的数据失效，必须到主内存中进行再次加载。 对有序性的保证 volatile关键字禁止JVM编译器以及处理器对其进行重排序，所以它能够保证有序性 虽然synchronized关键字所修改的同步方法也可以保证顺序性，但是这种顺序性是以程序的串行化执行换来的，在synchronized关键字所修改的代码块中代码指令也会发生指令重排序的情况 其他 volatile不会使线程陷入阻塞 synchronized关键字会使线程进入阻塞状态","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"java并发编程","slug":"java并发编程","permalink":"http://yoursite.com/tags/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}]},{"title":"Java并发之上下文切换","slug":"java/并发编程/Java并发基础1","date":"2018-04-06T10:39:51.000Z","updated":"2020-04-23T08:00:56.206Z","comments":true,"path":"2018/04/06/java/并发编程/Java并发基础1/","link":"","permalink":"http://yoursite.com/2018/04/06/java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%801/","excerpt":"","text":"何为上下文切换 CPU通过时间片分配算法来循环执行任务，当前任务执行一个任务时间片后会切换到下一个任务，但是在切换之前将保存上一个任务的状态，以便下次切换回这个任务时，可以在再加载这个任务的状态，所以任务从保存再到加载的过程就是一次上下文切换。上下文切换也会影响多线程的执行速度 下面看一段代码： 1234567891011121314151617181920212223242526272829303132333435363738394041public class ConcurrencyTest &#123; private static final long count = 10000000000L; public static void main(String[] args) throws InterruptedException &#123; concurrency(); serial(); &#125; private static void concurrency() throws InterruptedException &#123; long start = System.currentTimeMillis(); Thread thread = new Thread(new Runnable() &#123; @Override public void run() &#123; int a = 0; for (long i = 0;i&lt;count;i++)&#123; a +=5; &#125; &#125; &#125;); thread.start(); int b= 0; for(long i = 0;i&lt;count;i++)&#123; b--; &#125; long time = System.currentTimeMillis()-start; thread.join(); System.out.println(\"concurrency:\"+time+\"ms,b = \"+b); &#125; private static void serial()&#123; long start = System.currentTimeMillis(); int a = 0; for (long i = 0;i&lt;count;i++)&#123; a+=5; &#125; int b = 0; for(long i = 0;i&lt;count;i++)&#123; b--; &#125; long time = System.currentTimeMillis()-start; System.out.println(\"serial:\"+time+\"ms,b= \"+b+\" a= \"+a); &#125; 上面的代码是比较串行与并发时的执行效果； 在测试中可以看到数据量在10万以下，并发的执行速度比串行的执行速度慢；在测试中可以看到数据量在100万以上时，并发的执行速度比串行的执行速度快约2倍。上面的结果是因为线程有创建和上下文切换的开销。 如何减少上下文切换减少上下文切换的方法有四种： 无锁并发编程：多线程竞争锁时，会引发上下文切换，所以多线程处理数据时，可以使用例如将数据ID按照Hash算法取模分段，不同的线程处理不同段的数据 CAS算法：Java的Atomic包使用CAS算法来更新数据，而不需加锁 使用最少线程：避免创建不需要的线程 协程：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。 参考资料","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"java并发编程","slug":"java并发编程","permalink":"http://yoursite.com/tags/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}]}]}